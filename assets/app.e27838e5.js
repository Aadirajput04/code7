var uz = Object.defineProperty,
    dz = Object.defineProperties;
var fz = Object.getOwnPropertyDescriptors;
var qp = Object.getOwnPropertySymbols;
var CI = Object.prototype.hasOwnProperty,
    AI = Object.prototype.propertyIsEnumerable;
var xI = (e, t, n) => t in e ? uz(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    x = (e, t) => {
        for (var n in t || (t = {})) CI.call(t, n) && xI(e, n, t[n]);
        if (qp)
            for (var n of qp(t)) AI.call(t, n) && xI(e, n, t[n]);
        return e
    },
    G = (e, t) => dz(e, fz(t));
var Gr = (e, t) => {
    var n = {};
    for (var r in e) CI.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && qp)
        for (var r of qp(e)) t.indexOf(r) < 0 && AI.call(e, r) && (n[r] = e[r]);
    return n
};
(function() {
    try {
        var e = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {},
            t = new Error().stack;
        t && (e._sentryDebugIds = e._sentryDebugIds || {}, e._sentryDebugIds[t] = "3d05b3bd-65da-417a-268f-4b6ab13dffc0", e._sentryDebugIdIdentifier = "sentry-dbid-3d05b3bd-65da-417a-268f-4b6ab13dffc0")
    } catch {}
})();
const hz = function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
    new MutationObserver(s => {
        for (const i of s)
            if (i.type === "childList")
                for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function n(s) {
        const i = {};
        return s.integrity && (i.integrity = s.integrity), s.referrerpolicy && (i.referrerPolicy = s.referrerpolicy), s.crossorigin === "use-credentials" ? i.credentials = "include" : s.crossorigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i
    }

    function r(s) {
        if (s.ep) return;
        s.ep = !0;
        const i = n(s);
        fetch(s.href, i)
    }
};
hz();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tP = {
    NODE_CLIENT: !1,
    NODE_ADMIN: !1,
    SDK_VERSION: "${JSCORE_VERSION}"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const X = function(e, t) {
        if (!e) throw Hu(t)
    },
    Hu = function(e) {
        return new Error("Firebase Database (" + tP.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + e)
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nP = function(e) {
        const t = [];
        let n = 0;
        for (let r = 0; r < e.length; r++) {
            let s = e.charCodeAt(r);
            s < 128 ? t[n++] = s : s < 2048 ? (t[n++] = s >> 6 | 192, t[n++] = s & 63 | 128) : (s & 64512) === 55296 && r + 1 < e.length && (e.charCodeAt(r + 1) & 64512) === 56320 ? (s = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++r) & 1023), t[n++] = s >> 18 | 240, t[n++] = s >> 12 & 63 | 128, t[n++] = s >> 6 & 63 | 128, t[n++] = s & 63 | 128) : (t[n++] = s >> 12 | 224, t[n++] = s >> 6 & 63 | 128, t[n++] = s & 63 | 128)
        }
        return t
    },
    pz = function(e) {
        const t = [];
        let n = 0,
            r = 0;
        for (; n < e.length;) {
            const s = e[n++];
            if (s < 128) t[r++] = String.fromCharCode(s);
            else if (s > 191 && s < 224) {
                const i = e[n++];
                t[r++] = String.fromCharCode((s & 31) << 6 | i & 63)
            } else if (s > 239 && s < 365) {
                const i = e[n++],
                    o = e[n++],
                    a = e[n++],
                    l = ((s & 7) << 18 | (i & 63) << 12 | (o & 63) << 6 | a & 63) - 65536;
                t[r++] = String.fromCharCode(55296 + (l >> 10)), t[r++] = String.fromCharCode(56320 + (l & 1023))
            } else {
                const i = e[n++],
                    o = e[n++];
                t[r++] = String.fromCharCode((s & 15) << 12 | (i & 63) << 6 | o & 63)
            }
        }
        return t.join("")
    },
    Fy = {
        byteToCharMap_: null,
        charToByteMap_: null,
        byteToCharMapWebSafe_: null,
        charToByteMapWebSafe_: null,
        ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        get ENCODED_VALS() {
            return this.ENCODED_VALS_BASE + "+/="
        },
        get ENCODED_VALS_WEBSAFE() {
            return this.ENCODED_VALS_BASE + "-_."
        },
        HAS_NATIVE_SUPPORT: typeof atob == "function",
        encodeByteArray(e, t) {
            if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter");
            this.init_();
            const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
                r = [];
            for (let s = 0; s < e.length; s += 3) {
                const i = e[s],
                    o = s + 1 < e.length,
                    a = o ? e[s + 1] : 0,
                    l = s + 2 < e.length,
                    c = l ? e[s + 2] : 0,
                    u = i >> 2,
                    d = (i & 3) << 4 | a >> 4;
                let f = (a & 15) << 2 | c >> 6,
                    h = c & 63;
                l || (h = 64, o || (f = 64)), r.push(n[u], n[d], n[f], n[h])
            }
            return r.join("")
        },
        encodeString(e, t) {
            return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(nP(e), t)
        },
        decodeString(e, t) {
            return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : pz(this.decodeStringToByteArray(e, t))
        },
        decodeStringToByteArray(e, t) {
            this.init_();
            const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_,
                r = [];
            for (let s = 0; s < e.length;) {
                const i = n[e.charAt(s++)],
                    a = s < e.length ? n[e.charAt(s)] : 0;
                ++s;
                const c = s < e.length ? n[e.charAt(s)] : 64;
                ++s;
                const d = s < e.length ? n[e.charAt(s)] : 64;
                if (++s, i == null || a == null || c == null || d == null) throw new mz;
                const f = i << 2 | a >> 4;
                if (r.push(f), c !== 64) {
                    const h = a << 4 & 240 | c >> 2;
                    if (r.push(h), d !== 64) {
                        const p = c << 6 & 192 | d;
                        r.push(p)
                    }
                }
            }
            return r
        },
        init_() {
            if (!this.byteToCharMap_) {
                this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
                for (let e = 0; e < this.ENCODED_VALS.length; e++) this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e)
            }
        }
    };
class mz extends Error {
    constructor() {
        super(...arguments), this.name = "DecodeBase64StringError"
    }
}
const rP = function(e) {
        const t = nP(e);
        return Fy.encodeByteArray(t, !0)
    },
    Mg = function(e) {
        return rP(e).replace(/\./g, "")
    },
    Lg = function(e) {
        try {
            return Fy.decodeString(e, !0)
        } catch (t) {
            console.error("base64Decode failed: ", t)
        }
        return null
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function gz(e) {
    return sP(void 0, e)
}

function sP(e, t) {
    if (!(t instanceof Object)) return t;
    switch (t.constructor) {
        case Date:
            const n = t;
            return new Date(n.getTime());
        case Object:
            e === void 0 && (e = {});
            break;
        case Array:
            e = [];
            break;
        default:
            return t
    }
    for (const n in t) !t.hasOwnProperty(n) || !_z(n) || (e[n] = sP(e[n], t[n]));
    return e
}

function _z(e) {
    return e !== "__proto__"
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function iP() {
    if (typeof self != "undefined") return self;
    if (typeof window != "undefined") return window;
    if (typeof global != "undefined") return global;
    throw new Error("Unable to locate global object.")
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yz = () => iP().__FIREBASE_DEFAULTS__,
    vz = () => {
        if (typeof process == "undefined" || typeof process.env == "undefined") return;
        const e = {}.__FIREBASE_DEFAULTS__;
        if (e) return JSON.parse(e)
    },
    bz = () => {
        if (typeof document == "undefined") return;
        let e;
        try {
            e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
        } catch {
            return
        }
        const t = e && Lg(e[1]);
        return t && JSON.parse(t)
    },
    cS = () => {
        try {
            return yz() || vz() || bz()
        } catch (e) {
            console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
            return
        }
    },
    oP = e => {
        var t, n;
        return (n = (t = cS()) === null || t === void 0 ? void 0 : t.emulatorHosts) === null || n === void 0 ? void 0 : n[e]
    },
    uS = e => {
        const t = oP(e);
        if (!t) return;
        const n = t.lastIndexOf(":");
        if (n <= 0 || n + 1 === t.length) throw new Error(`Invalid host ${t} with no separate hostname and port!`);
        const r = parseInt(t.substring(n + 1), 10);
        return t[0] === "[" ? [t.substring(1, n - 1), r] : [t.substring(0, n), r]
    },
    wz = () => {
        var e;
        return (e = cS()) === null || e === void 0 ? void 0 : e.config
    },
    aP = e => {
        var t;
        return (t = cS()) === null || t === void 0 ? void 0 : t[`_${e}`]
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Mo {
    constructor() {
        this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise((t, n) => {
            this.resolve = t, this.reject = n
        })
    }
    wrapCallback(t) {
        return (n, r) => {
            n ? this.reject(n) : this.resolve(r), typeof t == "function" && (this.promise.catch(() => {}), t.length === 1 ? t(n) : t(n, r))
        }
    }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function lP(e, t) {
    if (e.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
    const n = {
            alg: "none",
            type: "JWT"
        },
        r = t || "demo-project",
        s = e.iat || 0,
        i = e.sub || e.user_id;
    if (!i) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
    const o = Object.assign({
            iss: `https://securetoken.google.com/${r}`,
            aud: r,
            iat: s,
            exp: s + 3600,
            auth_time: s,
            sub: i,
            user_id: i,
            firebase: {
                sign_in_provider: "custom",
                identities: {}
            }
        }, e),
        a = "";
    return [Mg(JSON.stringify(n)), Mg(JSON.stringify(o)), a].join(".")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Yn() {
    return typeof navigator != "undefined" && typeof navigator.userAgent == "string" ? navigator.userAgent : ""
}

function dS() {
    return typeof window != "undefined" && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Yn())
}

function cP() {
    const e = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
    return typeof e == "object" && e.id !== void 0
}

function uP() {
    return typeof navigator == "object" && navigator.product === "ReactNative"
}

function Ez() {
    const e = Yn();
    return e.indexOf("MSIE ") >= 0 || e.indexOf("Trident/") >= 0
}

function dP() {
    return tP.NODE_ADMIN === !0
}

function Uy() {
    try {
        return typeof indexedDB == "object"
    } catch {
        return !1
    }
}

function fP() {
    return new Promise((e, t) => {
        try {
            let n = !0;
            const r = "validate-browser-context-for-indexeddb-analytics-module",
                s = self.indexedDB.open(r);
            s.onsuccess = () => {
                s.result.close(), n || self.indexedDB.deleteDatabase(r), e(!0)
            }, s.onupgradeneeded = () => {
                n = !1
            }, s.onerror = () => {
                var i;
                t(((i = s.error) === null || i === void 0 ? void 0 : i.message) || "")
            }
        } catch (n) {
            t(n)
        }
    })
}

function Sz() {
    return !(typeof navigator == "undefined" || !navigator.cookieEnabled)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Tz = "FirebaseError";
class zr extends Error {
    constructor(t, n, r) {
        super(n), this.code = t, this.customData = r, this.name = Tz, Object.setPrototypeOf(this, zr.prototype), Error.captureStackTrace && Error.captureStackTrace(this, sa.prototype.create)
    }
}
class sa {
    constructor(t, n, r) {
        this.service = t, this.serviceName = n, this.errors = r
    }
    create(t, ...n) {
        const r = n[0] || {},
            s = `${this.service}/${t}`,
            i = this.errors[t],
            o = i ? $z(i, r) : "Error",
            a = `${this.serviceName}: ${o} (${s}).`;
        return new zr(s, a, r)
    }
}

function $z(e, t) {
    return e.replace(kz, (n, r) => {
        const s = t[r];
        return s != null ? String(s) : `<${r}?>`
    })
}
const kz = /\{\$([^}]+)}/g;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Mf(e) {
    return JSON.parse(e)
}

function rn(e) {
    return JSON.stringify(e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hP = function(e) {
        let t = {},
            n = {},
            r = {},
            s = "";
        try {
            const i = e.split(".");
            t = Mf(Lg(i[0]) || ""), n = Mf(Lg(i[1]) || ""), s = i[2], r = n.d || {}, delete n.d
        } catch {}
        return {
            header: t,
            claims: n,
            data: r,
            signature: s
        }
    },
    Iz = function(e) {
        const t = hP(e),
            n = t.claims;
        return !!n && typeof n == "object" && n.hasOwnProperty("iat")
    },
    xz = function(e) {
        const t = hP(e).claims;
        return typeof t == "object" && t.admin === !0
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Pi(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}

function Jc(e, t) {
    if (Object.prototype.hasOwnProperty.call(e, t)) return e[t]
}

function Ew(e) {
    for (const t in e)
        if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
    return !0
}

function Fg(e, t, n) {
    const r = {};
    for (const s in e) Object.prototype.hasOwnProperty.call(e, s) && (r[s] = t.call(n, e[s], s, e));
    return r
}

function Lf(e, t) {
    if (e === t) return !0;
    const n = Object.keys(e),
        r = Object.keys(t);
    for (const s of n) {
        if (!r.includes(s)) return !1;
        const i = e[s],
            o = t[s];
        if (RI(i) && RI(o)) {
            if (!Lf(i, o)) return !1
        } else if (i !== o) return !1
    }
    for (const s of r)
        if (!n.includes(s)) return !1;
    return !0
}

function RI(e) {
    return e !== null && typeof e == "object"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ju(e) {
    const t = [];
    for (const [n, r] of Object.entries(e)) Array.isArray(r) ? r.forEach(s => {
        t.push(encodeURIComponent(n) + "=" + encodeURIComponent(s))
    }) : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(r));
    return t.length ? "&" + t.join("&") : ""
}

function Cd(e) {
    const t = {};
    return e.replace(/^\?/, "").split("&").forEach(r => {
        if (r) {
            const [s, i] = r.split("=");
            t[decodeURIComponent(s)] = decodeURIComponent(i)
        }
    }), t
}

function Ad(e) {
    const t = e.indexOf("?");
    if (!t) return "";
    const n = e.indexOf("#", t);
    return e.substring(t, n > 0 ? n : void 0)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Cz {
    constructor() {
        this.chain_ = [], this.buf_ = [], this.W_ = [], this.pad_ = [], this.inbuf_ = 0, this.total_ = 0, this.blockSize = 512 / 8, this.pad_[0] = 128;
        for (let t = 1; t < this.blockSize; ++t) this.pad_[t] = 0;
        this.reset()
    }
    reset() {
        this.chain_[0] = 1732584193, this.chain_[1] = 4023233417, this.chain_[2] = 2562383102, this.chain_[3] = 271733878, this.chain_[4] = 3285377520, this.inbuf_ = 0, this.total_ = 0
    }
    compress_(t, n) {
        n || (n = 0);
        const r = this.W_;
        if (typeof t == "string")
            for (let d = 0; d < 16; d++) r[d] = t.charCodeAt(n) << 24 | t.charCodeAt(n + 1) << 16 | t.charCodeAt(n + 2) << 8 | t.charCodeAt(n + 3), n += 4;
        else
            for (let d = 0; d < 16; d++) r[d] = t[n] << 24 | t[n + 1] << 16 | t[n + 2] << 8 | t[n + 3], n += 4;
        for (let d = 16; d < 80; d++) {
            const f = r[d - 3] ^ r[d - 8] ^ r[d - 14] ^ r[d - 16];
            r[d] = (f << 1 | f >>> 31) & 4294967295
        }
        let s = this.chain_[0],
            i = this.chain_[1],
            o = this.chain_[2],
            a = this.chain_[3],
            l = this.chain_[4],
            c, u;
        for (let d = 0; d < 80; d++) {
            d < 40 ? d < 20 ? (c = a ^ i & (o ^ a), u = 1518500249) : (c = i ^ o ^ a, u = 1859775393) : d < 60 ? (c = i & o | a & (i | o), u = 2400959708) : (c = i ^ o ^ a, u = 3395469782);
            const f = (s << 5 | s >>> 27) + c + l + u + r[d] & 4294967295;
            l = a, a = o, o = (i << 30 | i >>> 2) & 4294967295, i = s, s = f
        }
        this.chain_[0] = this.chain_[0] + s & 4294967295, this.chain_[1] = this.chain_[1] + i & 4294967295, this.chain_[2] = this.chain_[2] + o & 4294967295, this.chain_[3] = this.chain_[3] + a & 4294967295, this.chain_[4] = this.chain_[4] + l & 4294967295
    }
    update(t, n) {
        if (t == null) return;
        n === void 0 && (n = t.length);
        const r = n - this.blockSize;
        let s = 0;
        const i = this.buf_;
        let o = this.inbuf_;
        for (; s < n;) {
            if (o === 0)
                for (; s <= r;) this.compress_(t, s), s += this.blockSize;
            if (typeof t == "string") {
                for (; s < n;)
                    if (i[o] = t.charCodeAt(s), ++o, ++s, o === this.blockSize) {
                        this.compress_(i), o = 0;
                        break
                    }
            } else
                for (; s < n;)
                    if (i[o] = t[s], ++o, ++s, o === this.blockSize) {
                        this.compress_(i), o = 0;
                        break
                    }
        }
        this.inbuf_ = o, this.total_ += n
    }
    digest() {
        const t = [];
        let n = this.total_ * 8;
        this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        for (let s = this.blockSize - 1; s >= 56; s--) this.buf_[s] = n & 255, n /= 256;
        this.compress_(this.buf_);
        let r = 0;
        for (let s = 0; s < 5; s++)
            for (let i = 24; i >= 0; i -= 8) t[r] = this.chain_[s] >> i & 255, ++r;
        return t
    }
}

function Az(e, t) {
    const n = new Rz(e, t);
    return n.subscribe.bind(n)
}
class Rz {
    constructor(t, n) {
        this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = n, this.task.then(() => {
            t(this)
        }).catch(r => {
            this.error(r)
        })
    }
    next(t) {
        this.forEachObserver(n => {
            n.next(t)
        })
    }
    error(t) {
        this.forEachObserver(n => {
            n.error(t)
        }), this.close(t)
    }
    complete() {
        this.forEachObserver(t => {
            t.complete()
        }), this.close()
    }
    subscribe(t, n, r) {
        let s;
        if (t === void 0 && n === void 0 && r === void 0) throw new Error("Missing Observer.");
        Oz(t, ["next", "error", "complete"]) ? s = t : s = {
            next: t,
            error: n,
            complete: r
        }, s.next === void 0 && (s.next = Ub), s.error === void 0 && (s.error = Ub), s.complete === void 0 && (s.complete = Ub);
        const i = this.unsubscribeOne.bind(this, this.observers.length);
        return this.finalized && this.task.then(() => {
            try {
                this.finalError ? s.error(this.finalError) : s.complete()
            } catch {}
        }), this.observers.push(s), i
    }
    unsubscribeOne(t) {
        this.observers === void 0 || this.observers[t] === void 0 || (delete this.observers[t], this.observerCount -= 1, this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this))
    }
    forEachObserver(t) {
        if (!this.finalized)
            for (let n = 0; n < this.observers.length; n++) this.sendOne(n, t)
    }
    sendOne(t, n) {
        this.task.then(() => {
            if (this.observers !== void 0 && this.observers[t] !== void 0) try {
                n(this.observers[t])
            } catch (r) {
                typeof console != "undefined" && console.error && console.error(r)
            }
        })
    }
    close(t) {
        this.finalized || (this.finalized = !0, t !== void 0 && (this.finalError = t), this.task.then(() => {
            this.observers = void 0, this.onNoObservers = void 0
        }))
    }
}

function Oz(e, t) {
    if (typeof e != "object" || e === null) return !1;
    for (const n of t)
        if (n in e && typeof e[n] == "function") return !0;
    return !1
}

function Ub() {}

function fS(e, t) {
    return `${e} failed: ${t} argument `
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Dz = function(e) {
        const t = [];
        let n = 0;
        for (let r = 0; r < e.length; r++) {
            let s = e.charCodeAt(r);
            if (s >= 55296 && s <= 56319) {
                const i = s - 55296;
                r++, X(r < e.length, "Surrogate pair missing trail surrogate.");
                const o = e.charCodeAt(r) - 56320;
                s = 65536 + (i << 10) + o
            }
            s < 128 ? t[n++] = s : s < 2048 ? (t[n++] = s >> 6 | 192, t[n++] = s & 63 | 128) : s < 65536 ? (t[n++] = s >> 12 | 224, t[n++] = s >> 6 & 63 | 128, t[n++] = s & 63 | 128) : (t[n++] = s >> 18 | 240, t[n++] = s >> 12 & 63 | 128, t[n++] = s >> 6 & 63 | 128, t[n++] = s & 63 | 128)
        }
        return t
    },
    By = function(e) {
        let t = 0;
        for (let n = 0; n < e.length; n++) {
            const r = e.charCodeAt(n);
            r < 128 ? t++ : r < 2048 ? t += 2 : r >= 55296 && r <= 56319 ? (t += 4, n++) : t += 3
        }
        return t
    };
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Nz = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, e => {
        const t = Math.random() * 16 | 0;
        return (e === "x" ? t : t & 3 | 8).toString(16)
    })
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Pz = 1e3,
    Mz = 2,
    Lz = 4 * 60 * 60 * 1e3,
    Fz = .5;

function Sw(e, t = Pz, n = Mz) {
    const r = t * Math.pow(n, e),
        s = Math.round(Fz * r * (Math.random() - .5) * 2);
    return Math.min(Lz, r + s)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function st(e) {
    return e && e._delegate ? e._delegate : e
}
class Kn {
    constructor(t, n, r) {
        this.name = t, this.instanceFactory = n, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null
    }
    setInstantiationMode(t) {
        return this.instantiationMode = t, this
    }
    setMultipleInstances(t) {
        return this.multipleInstances = t, this
    }
    setServiceProps(t) {
        return this.serviceProps = t, this
    }
    setInstanceCreatedCallback(t) {
        return this.onInstanceCreated = t, this
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wa = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Uz {
    constructor(t, n) {
        this.name = t, this.container = n, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map
    }
    get(t) {
        const n = this.normalizeInstanceIdentifier(t);
        if (!this.instancesDeferred.has(n)) {
            const r = new Mo;
            if (this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize()) try {
                const s = this.getOrInitializeService({
                    instanceIdentifier: n
                });
                s && r.resolve(s)
            } catch {}
        }
        return this.instancesDeferred.get(n).promise
    }
    getImmediate(t) {
        var n;
        const r = this.normalizeInstanceIdentifier(t == null ? void 0 : t.identifier),
            s = (n = t == null ? void 0 : t.optional) !== null && n !== void 0 ? n : !1;
        if (this.isInitialized(r) || this.shouldAutoInitialize()) try {
            return this.getOrInitializeService({
                instanceIdentifier: r
            })
        } catch (i) {
            if (s) return null;
            throw i
        } else {
            if (s) return null;
            throw Error(`Service ${this.name} is not available`)
        }
    }
    getComponent() {
        return this.component
    }
    setComponent(t) {
        if (t.name !== this.name) throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`);
        if (this.component) throw Error(`Component for ${this.name} has already been provided`);
        if (this.component = t, !!this.shouldAutoInitialize()) {
            if (Vz(t)) try {
                this.getOrInitializeService({
                    instanceIdentifier: wa
                })
            } catch {}
            for (const [n, r] of this.instancesDeferred.entries()) {
                const s = this.normalizeInstanceIdentifier(n);
                try {
                    const i = this.getOrInitializeService({
                        instanceIdentifier: s
                    });
                    r.resolve(i)
                } catch {}
            }
        }
    }
    clearInstance(t = wa) {
        this.instancesDeferred.delete(t), this.instancesOptions.delete(t), this.instances.delete(t)
    }
    async delete() {
        const t = Array.from(this.instances.values());
        await Promise.all([...t.filter(n => "INTERNAL" in n).map(n => n.INTERNAL.delete()), ...t.filter(n => "_delete" in n).map(n => n._delete())])
    }
    isComponentSet() {
        return this.component != null
    }
    isInitialized(t = wa) {
        return this.instances.has(t)
    }
    getOptions(t = wa) {
        return this.instancesOptions.get(t) || {}
    }
    initialize(t = {}) {
        const {
            options: n = {}
        } = t, r = this.normalizeInstanceIdentifier(t.instanceIdentifier);
        if (this.isInitialized(r)) throw Error(`${this.name}(${r}) has already been initialized`);
        if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
        const s = this.getOrInitializeService({
            instanceIdentifier: r,
            options: n
        });
        for (const [i, o] of this.instancesDeferred.entries()) {
            const a = this.normalizeInstanceIdentifier(i);
            r === a && o.resolve(s)
        }
        return s
    }
    onInit(t, n) {
        var r;
        const s = this.normalizeInstanceIdentifier(n),
            i = (r = this.onInitCallbacks.get(s)) !== null && r !== void 0 ? r : new Set;
        i.add(t), this.onInitCallbacks.set(s, i);
        const o = this.instances.get(s);
        return o && t(o, s), () => {
            i.delete(t)
        }
    }
    invokeOnInitCallbacks(t, n) {
        const r = this.onInitCallbacks.get(n);
        if (!!r)
            for (const s of r) try {
                s(t, n)
            } catch {}
    }
    getOrInitializeService({
        instanceIdentifier: t,
        options: n = {}
    }) {
        let r = this.instances.get(t);
        if (!r && this.component && (r = this.component.instanceFactory(this.container, {
                instanceIdentifier: Bz(t),
                options: n
            }), this.instances.set(t, r), this.instancesOptions.set(t, n), this.invokeOnInitCallbacks(r, t), this.component.onInstanceCreated)) try {
            this.component.onInstanceCreated(this.container, t, r)
        } catch {}
        return r || null
    }
    normalizeInstanceIdentifier(t = wa) {
        return this.component ? this.component.multipleInstances ? t : wa : t
    }
    shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT"
    }
}

function Bz(e) {
    return e === wa ? void 0 : e
}

function Vz(e) {
    return e.instantiationMode === "EAGER"
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Hz {
    constructor(t) {
        this.name = t, this.providers = new Map
    }
    addComponent(t) {
        const n = this.getProvider(t.name);
        if (n.isComponentSet()) throw new Error(`Component ${t.name} has already been registered with ${this.name}`);
        n.setComponent(t)
    }
    addOrOverwriteComponent(t) {
        this.getProvider(t.name).isComponentSet() && this.providers.delete(t.name), this.addComponent(t)
    }
    getProvider(t) {
        if (this.providers.has(t)) return this.providers.get(t);
        const n = new Uz(t, this);
        return this.providers.set(t, n), n
    }
    getProviders() {
        return Array.from(this.providers.values())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Xe;
(function(e) {
    e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT"
})(Xe || (Xe = {}));
const jz = {
        debug: Xe.DEBUG,
        verbose: Xe.VERBOSE,
        info: Xe.INFO,
        warn: Xe.WARN,
        error: Xe.ERROR,
        silent: Xe.SILENT
    },
    zz = Xe.INFO,
    Wz = {
        [Xe.DEBUG]: "log",
        [Xe.VERBOSE]: "log",
        [Xe.INFO]: "info",
        [Xe.WARN]: "warn",
        [Xe.ERROR]: "error"
    },
    Gz = (e, t, ...n) => {
        if (t < e.logLevel) return;
        const r = new Date().toISOString(),
            s = Wz[t];
        if (s) console[s](`[${r}]  ${e.name}:`, ...n);
        else throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`)
    };
class zu {
    constructor(t) {
        this.name = t, this._logLevel = zz, this._logHandler = Gz, this._userLogHandler = null
    }
    get logLevel() {
        return this._logLevel
    }
    set logLevel(t) {
        if (!(t in Xe)) throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);
        this._logLevel = t
    }
    setLogLevel(t) {
        this._logLevel = typeof t == "string" ? jz[t] : t
    }
    get logHandler() {
        return this._logHandler
    }
    set logHandler(t) {
        if (typeof t != "function") throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = t
    }
    get userLogHandler() {
        return this._userLogHandler
    }
    set userLogHandler(t) {
        this._userLogHandler = t
    }
    debug(...t) {
        this._userLogHandler && this._userLogHandler(this, Xe.DEBUG, ...t), this._logHandler(this, Xe.DEBUG, ...t)
    }
    log(...t) {
        this._userLogHandler && this._userLogHandler(this, Xe.VERBOSE, ...t), this._logHandler(this, Xe.VERBOSE, ...t)
    }
    info(...t) {
        this._userLogHandler && this._userLogHandler(this, Xe.INFO, ...t), this._logHandler(this, Xe.INFO, ...t)
    }
    warn(...t) {
        this._userLogHandler && this._userLogHandler(this, Xe.WARN, ...t), this._logHandler(this, Xe.WARN, ...t)
    }
    error(...t) {
        this._userLogHandler && this._userLogHandler(this, Xe.ERROR, ...t), this._logHandler(this, Xe.ERROR, ...t)
    }
}
const qz = (e, t) => t.some(n => e instanceof n);
let OI, DI;

function Yz() {
    return OI || (OI = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}

function Kz() {
    return DI || (DI = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}
const pP = new WeakMap,
    Tw = new WeakMap,
    mP = new WeakMap,
    Bb = new WeakMap,
    hS = new WeakMap;

function Xz(e) {
    const t = new Promise((n, r) => {
        const s = () => {
                e.removeEventListener("success", i), e.removeEventListener("error", o)
            },
            i = () => {
                n($o(e.result)), s()
            },
            o = () => {
                r(e.error), s()
            };
        e.addEventListener("success", i), e.addEventListener("error", o)
    });
    return t.then(n => {
        n instanceof IDBCursor && pP.set(n, e)
    }).catch(() => {}), hS.set(t, e), t
}

function Qz(e) {
    if (Tw.has(e)) return;
    const t = new Promise((n, r) => {
        const s = () => {
                e.removeEventListener("complete", i), e.removeEventListener("error", o), e.removeEventListener("abort", o)
            },
            i = () => {
                n(), s()
            },
            o = () => {
                r(e.error || new DOMException("AbortError", "AbortError")), s()
            };
        e.addEventListener("complete", i), e.addEventListener("error", o), e.addEventListener("abort", o)
    });
    Tw.set(e, t)
}
let $w = {
    get(e, t, n) {
        if (e instanceof IDBTransaction) {
            if (t === "done") return Tw.get(e);
            if (t === "objectStoreNames") return e.objectStoreNames || mP.get(e);
            if (t === "store") return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
        }
        return $o(e[t])
    },
    set(e, t, n) {
        return e[t] = n, !0
    },
    has(e, t) {
        return e instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in e
    }
};

function Jz(e) {
    $w = e($w)
}

function Zz(e) {
    return e === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(t, ...n) {
        const r = e.call(Vb(this), t, ...n);
        return mP.set(r, t.sort ? t.sort() : [t]), $o(r)
    } : Kz().includes(e) ? function(...t) {
        return e.apply(Vb(this), t), $o(pP.get(this))
    } : function(...t) {
        return $o(e.apply(Vb(this), t))
    }
}

function e6(e) {
    return typeof e == "function" ? Zz(e) : (e instanceof IDBTransaction && Qz(e), qz(e, Yz()) ? new Proxy(e, $w) : e)
}

function $o(e) {
    if (e instanceof IDBRequest) return Xz(e);
    if (Bb.has(e)) return Bb.get(e);
    const t = e6(e);
    return t !== e && (Bb.set(e, t), hS.set(t, e)), t
}
const Vb = e => hS.get(e);

function gP(e, t, {
    blocked: n,
    upgrade: r,
    blocking: s,
    terminated: i
} = {}) {
    const o = indexedDB.open(e, t),
        a = $o(o);
    return r && o.addEventListener("upgradeneeded", l => {
        r($o(o.result), l.oldVersion, l.newVersion, $o(o.transaction))
    }), n && o.addEventListener("blocked", () => n()), a.then(l => {
        i && l.addEventListener("close", () => i()), s && l.addEventListener("versionchange", () => s())
    }).catch(() => {}), a
}
const t6 = ["get", "getKey", "getAll", "getAllKeys", "count"],
    n6 = ["put", "add", "delete", "clear"],
    Hb = new Map;

function NI(e, t) {
    if (!(e instanceof IDBDatabase && !(t in e) && typeof t == "string")) return;
    if (Hb.get(t)) return Hb.get(t);
    const n = t.replace(/FromIndex$/, ""),
        r = t !== n,
        s = n6.includes(n);
    if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(s || t6.includes(n))) return;
    const i = async function(o, ...a) {
        const l = this.transaction(o, s ? "readwrite" : "readonly");
        let c = l.store;
        return r && (c = c.index(a.shift())), (await Promise.all([c[n](...a), s && l.done]))[0]
    };
    return Hb.set(t, i), i
}
Jz(e => G(x({}, e), {
    get: (t, n, r) => NI(t, n) || e.get(t, n, r),
    has: (t, n) => !!NI(t, n) || e.has(t, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class r6 {
    constructor(t) {
        this.container = t
    }
    getPlatformInfoString() {
        return this.container.getProviders().map(n => {
            if (s6(n)) {
                const r = n.getImmediate();
                return `${r.library}/${r.version}`
            } else return null
        }).filter(n => n).join(" ")
    }
}

function s6(e) {
    const t = e.getComponent();
    return (t == null ? void 0 : t.type) === "VERSION"
}
const kw = "@firebase/app",
    PI = "0.9.8";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Za = new zu("@firebase/app"),
    i6 = "@firebase/app-compat",
    o6 = "@firebase/analytics-compat",
    a6 = "@firebase/analytics",
    l6 = "@firebase/app-check-compat",
    c6 = "@firebase/app-check",
    u6 = "@firebase/auth",
    d6 = "@firebase/auth-compat",
    f6 = "@firebase/database",
    h6 = "@firebase/database-compat",
    p6 = "@firebase/functions",
    m6 = "@firebase/functions-compat",
    g6 = "@firebase/installations",
    _6 = "@firebase/installations-compat",
    y6 = "@firebase/messaging",
    v6 = "@firebase/messaging-compat",
    b6 = "@firebase/performance",
    w6 = "@firebase/performance-compat",
    E6 = "@firebase/remote-config",
    S6 = "@firebase/remote-config-compat",
    T6 = "@firebase/storage",
    $6 = "@firebase/storage-compat",
    k6 = "@firebase/firestore",
    I6 = "@firebase/firestore-compat",
    x6 = "firebase",
    C6 = "9.20.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Iw = "[DEFAULT]",
    A6 = {
        [kw]: "fire-core",
        [i6]: "fire-core-compat",
        [a6]: "fire-analytics",
        [o6]: "fire-analytics-compat",
        [c6]: "fire-app-check",
        [l6]: "fire-app-check-compat",
        [u6]: "fire-auth",
        [d6]: "fire-auth-compat",
        [f6]: "fire-rtdb",
        [h6]: "fire-rtdb-compat",
        [p6]: "fire-fn",
        [m6]: "fire-fn-compat",
        [g6]: "fire-iid",
        [_6]: "fire-iid-compat",
        [y6]: "fire-fcm",
        [v6]: "fire-fcm-compat",
        [b6]: "fire-perf",
        [w6]: "fire-perf-compat",
        [E6]: "fire-rc",
        [S6]: "fire-rc-compat",
        [T6]: "fire-gcs",
        [$6]: "fire-gcs-compat",
        [k6]: "fire-fst",
        [I6]: "fire-fst-compat",
        "fire-js": "fire-js",
        [x6]: "fire-js-all"
    };
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ff = new Map,
    xw = new Map;

function R6(e, t) {
    try {
        e.container.addComponent(t)
    } catch (n) {
        Za.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, n)
    }
}

function dr(e) {
    const t = e.name;
    if (xw.has(t)) return Za.debug(`There were multiple attempts to register component ${t}.`), !1;
    xw.set(t, e);
    for (const n of Ff.values()) R6(n, e);
    return !0
}

function vs(e, t) {
    const n = e.container.getProvider("heartbeat").getImmediate({
        optional: !0
    });
    return n && n.triggerHeartbeat(), e.container.getProvider(t)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const O6 = {
        ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
        ["bad-app-name"]: "Illegal App name: '{$appName}",
        ["duplicate-app"]: "Firebase App named '{$appName}' already exists with different options or config",
        ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
        ["no-options"]: "Need to provide options, when not being deployed to hosting via source.",
        ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
        ["invalid-log-argument"]: "First argument to `onLog` must be null or a function.",
        ["idb-open"]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
        ["idb-get"]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
        ["idb-set"]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
        ["idb-delete"]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
    },
    ko = new sa("app", "Firebase", O6);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class D6 {
    constructor(t, n, r) {
        this._isDeleted = !1, this._options = Object.assign({}, t), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new Kn("app", () => this, "PUBLIC"))
    }
    get automaticDataCollectionEnabled() {
        return this.checkDestroyed(), this._automaticDataCollectionEnabled
    }
    set automaticDataCollectionEnabled(t) {
        this.checkDestroyed(), this._automaticDataCollectionEnabled = t
    }
    get name() {
        return this.checkDestroyed(), this._name
    }
    get options() {
        return this.checkDestroyed(), this._options
    }
    get config() {
        return this.checkDestroyed(), this._config
    }
    get container() {
        return this._container
    }
    get isDeleted() {
        return this._isDeleted
    }
    set isDeleted(t) {
        this._isDeleted = t
    }
    checkDestroyed() {
        if (this.isDeleted) throw ko.create("app-deleted", {
            appName: this._name
        })
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ia = C6;

function _P(e, t = {}) {
    let n = e;
    typeof t != "object" && (t = {
        name: t
    });
    const r = Object.assign({
            name: Iw,
            automaticDataCollectionEnabled: !1
        }, t),
        s = r.name;
    if (typeof s != "string" || !s) throw ko.create("bad-app-name", {
        appName: String(s)
    });
    if (n || (n = wz()), !n) throw ko.create("no-options");
    const i = Ff.get(s);
    if (i) {
        if (Lf(n, i.options) && Lf(r, i.config)) return i;
        throw ko.create("duplicate-app", {
            appName: s
        })
    }
    const o = new Hz(s);
    for (const l of xw.values()) o.addComponent(l);
    const a = new D6(n, r, o);
    return Ff.set(s, a), a
}

function Il(e = Iw) {
    const t = Ff.get(e);
    if (!t && e === Iw) return _P();
    if (!t) throw ko.create("no-app", {
        appName: e
    });
    return t
}

function N6() {
    return Array.from(Ff.values())
}

function cn(e, t, n) {
    var r;
    let s = (r = A6[e]) !== null && r !== void 0 ? r : e;
    n && (s += `-${n}`);
    const i = s.match(/\s|\//),
        o = t.match(/\s|\//);
    if (i || o) {
        const a = [`Unable to register library "${s}" with version "${t}":`];
        i && a.push(`library name "${s}" contains illegal characters (whitespace or "/")`), i && o && a.push("and"), o && a.push(`version name "${t}" contains illegal characters (whitespace or "/")`), Za.warn(a.join(" "));
        return
    }
    dr(new Kn(`${s}-version`, () => ({
        library: s,
        version: t
    }), "VERSION"))
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const P6 = "firebase-heartbeat-database",
    M6 = 1,
    Uf = "firebase-heartbeat-store";
let jb = null;

function yP() {
    return jb || (jb = gP(P6, M6, {
        upgrade: (e, t) => {
            switch (t) {
                case 0:
                    e.createObjectStore(Uf)
            }
        }
    }).catch(e => {
        throw ko.create("idb-open", {
            originalErrorMessage: e.message
        })
    })), jb
}
async function L6(e) {
    try {
        return (await yP()).transaction(Uf).objectStore(Uf).get(vP(e))
    } catch (t) {
        if (t instanceof zr) Za.warn(t.message);
        else {
            const n = ko.create("idb-get", {
                originalErrorMessage: t == null ? void 0 : t.message
            });
            Za.warn(n.message)
        }
    }
}
async function MI(e, t) {
    try {
        const r = (await yP()).transaction(Uf, "readwrite");
        return await r.objectStore(Uf).put(t, vP(e)), r.done
    } catch (n) {
        if (n instanceof zr) Za.warn(n.message);
        else {
            const r = ko.create("idb-set", {
                originalErrorMessage: n == null ? void 0 : n.message
            });
            Za.warn(r.message)
        }
    }
}

function vP(e) {
    return `${e.name}!${e.options.appId}`
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const F6 = 1024,
    U6 = 30 * 24 * 60 * 60 * 1e3;
class B6 {
    constructor(t) {
        this.container = t, this._heartbeatsCache = null;
        const n = this.container.getProvider("app").getImmediate();
        this._storage = new H6(n), this._heartbeatsCachePromise = this._storage.read().then(r => (this._heartbeatsCache = r, r))
    }
    async triggerHeartbeat() {
        const n = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),
            r = LI();
        if (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise), !(this._heartbeatsCache.lastSentHeartbeatDate === r || this._heartbeatsCache.heartbeats.some(s => s.date === r))) return this._heartbeatsCache.heartbeats.push({
            date: r,
            agent: n
        }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(s => {
            const i = new Date(s.date).valueOf();
            return Date.now() - i <= U6
        }), this._storage.overwrite(this._heartbeatsCache)
    }
    async getHeartbeatsHeader() {
        if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) return "";
        const t = LI(),
            {
                heartbeatsToSend: n,
                unsentEntries: r
            } = V6(this._heartbeatsCache.heartbeats),
            s = Mg(JSON.stringify({
                version: 2,
                heartbeats: n
            }));
        return this._heartbeatsCache.lastSentHeartbeatDate = t, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s
    }
}

function LI() {
    return new Date().toISOString().substring(0, 10)
}

function V6(e, t = F6) {
    const n = [];
    let r = e.slice();
    for (const s of e) {
        const i = n.find(o => o.agent === s.agent);
        if (i) {
            if (i.dates.push(s.date), FI(n) > t) {
                i.dates.pop();
                break
            }
        } else if (n.push({
                agent: s.agent,
                dates: [s.date]
            }), FI(n) > t) {
            n.pop();
            break
        }
        r = r.slice(1)
    }
    return {
        heartbeatsToSend: n,
        unsentEntries: r
    }
}
class H6 {
    constructor(t) {
        this.app = t, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
    }
    async runIndexedDBEnvironmentCheck() {
        return Uy() ? fP().then(() => !0).catch(() => !1) : !1
    }
    async read() {
        return await this._canUseIndexedDBPromise ? await L6(this.app) || {
            heartbeats: []
        } : {
            heartbeats: []
        }
    }
    async overwrite(t) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const s = await this.read();
            return MI(this.app, {
                lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : s.lastSentHeartbeatDate,
                heartbeats: t.heartbeats
            })
        } else return
    }
    async add(t) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const s = await this.read();
            return MI(this.app, {
                lastSentHeartbeatDate: (n = t.lastSentHeartbeatDate) !== null && n !== void 0 ? n : s.lastSentHeartbeatDate,
                heartbeats: [...s.heartbeats, ...t.heartbeats]
            })
        } else return
    }
}

function FI(e) {
    return Mg(JSON.stringify({
        version: 2,
        heartbeats: e
    })).length
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function j6(e) {
    dr(new Kn("platform-logger", t => new r6(t), "PRIVATE")), dr(new Kn("heartbeat", t => new B6(t), "PRIVATE")), cn(kw, PI, e), cn(kw, PI, "esm2017"), cn("fire-js", "")
}
j6("");
var z6 = "firebase",
    W6 = "9.20.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
cn(z6, W6, "app");
const UI = "@firebase/database",
    BI = "0.14.4";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let bP = "";

function G6(e) {
    bP = e
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class q6 {
    constructor(t) {
        this.domStorage_ = t, this.prefix_ = "firebase:"
    }
    set(t, n) {
        n == null ? this.domStorage_.removeItem(this.prefixedName_(t)) : this.domStorage_.setItem(this.prefixedName_(t), rn(n))
    }
    get(t) {
        const n = this.domStorage_.getItem(this.prefixedName_(t));
        return n == null ? null : Mf(n)
    }
    remove(t) {
        this.domStorage_.removeItem(this.prefixedName_(t))
    }
    prefixedName_(t) {
        return this.prefix_ + t
    }
    toString() {
        return this.domStorage_.toString()
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Y6 {
    constructor() {
        this.cache_ = {}, this.isInMemoryStorage = !0
    }
    set(t, n) {
        n == null ? delete this.cache_[t] : this.cache_[t] = n
    }
    get(t) {
        return Pi(this.cache_, t) ? this.cache_[t] : null
    }
    remove(t) {
        delete this.cache_[t]
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wP = function(e) {
        try {
            if (typeof window != "undefined" && typeof window[e] != "undefined") {
                const t = window[e];
                return t.setItem("firebase:sentinel", "cache"), t.removeItem("firebase:sentinel"), new q6(t)
            }
        } catch {}
        return new Y6
    },
    Ca = wP("localStorage"),
    Cw = wP("sessionStorage");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Sc = new zu("@firebase/database"),
    K6 = function() {
        let e = 1;
        return function() {
            return e++
        }
    }(),
    EP = function(e) {
        const t = Dz(e),
            n = new Cz;
        n.update(t);
        const r = n.digest();
        return Fy.encodeByteArray(r)
    },
    Kh = function(...e) {
        let t = "";
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            Array.isArray(r) || r && typeof r == "object" && typeof r.length == "number" ? t += Kh.apply(null, r) : typeof r == "object" ? t += rn(r) : t += r, t += " "
        }
        return t
    };
let Ba = null,
    VI = !0;
const X6 = function(e, t) {
        X(!t || e === !0 || e === !1, "Can't turn on custom loggers persistently."), e === !0 ? (Sc.logLevel = Xe.VERBOSE, Ba = Sc.log.bind(Sc), t && Cw.set("logging_enabled", !0)) : typeof e == "function" ? Ba = e : (Ba = null, Cw.remove("logging_enabled"))
    },
    Un = function(...e) {
        if (VI === !0 && (VI = !1, Ba === null && Cw.get("logging_enabled") === !0 && X6(!0)), Ba) {
            const t = Kh.apply(null, e);
            Ba(t)
        }
    },
    Xh = function(e) {
        return function(...t) {
            Un(e, ...t)
        }
    },
    Aw = function(...e) {
        const t = "FIREBASE INTERNAL ERROR: " + Kh(...e);
        Sc.error(t)
    },
    vi = function(...e) {
        const t = `FIREBASE FATAL ERROR: ${Kh(...e)}`;
        throw Sc.error(t), new Error(t)
    },
    Sr = function(...e) {
        const t = "FIREBASE WARNING: " + Kh(...e);
        Sc.warn(t)
    },
    Q6 = function() {
        typeof window != "undefined" && window.location && window.location.protocol && window.location.protocol.indexOf("https:") !== -1 && Sr("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().")
    },
    SP = function(e) {
        return typeof e == "number" && (e !== e || e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY)
    },
    J6 = function(e) {
        if (document.readyState === "complete") e();
        else {
            let t = !1;
            const n = function() {
                if (!document.body) {
                    setTimeout(n, Math.floor(10));
                    return
                }
                t || (t = !0, e())
            };
            document.addEventListener ? (document.addEventListener("DOMContentLoaded", n, !1), window.addEventListener("load", n, !1)) : document.attachEvent && (document.attachEvent("onreadystatechange", () => {
                document.readyState === "complete" && n()
            }), window.attachEvent("onload", n))
        }
    },
    Zc = "[MIN_NAME]",
    el = "[MAX_NAME]",
    Wu = function(e, t) {
        if (e === t) return 0;
        if (e === Zc || t === el) return -1;
        if (t === Zc || e === el) return 1; {
            const n = HI(e),
                r = HI(t);
            return n !== null ? r !== null ? n - r === 0 ? e.length - t.length : n - r : -1 : r !== null ? 1 : e < t ? -1 : 1
        }
    },
    Z6 = function(e, t) {
        return e === t ? 0 : e < t ? -1 : 1
    },
    ld = function(e, t) {
        if (t && e in t) return t[e];
        throw new Error("Missing required key (" + e + ") in object: " + rn(t))
    },
    pS = function(e) {
        if (typeof e != "object" || e === null) return rn(e);
        const t = [];
        for (const r in e) t.push(r);
        t.sort();
        let n = "{";
        for (let r = 0; r < t.length; r++) r !== 0 && (n += ","), n += rn(t[r]), n += ":", n += pS(e[t[r]]);
        return n += "}", n
    },
    TP = function(e, t) {
        const n = e.length;
        if (n <= t) return [e];
        const r = [];
        for (let s = 0; s < n; s += t) s + t > n ? r.push(e.substring(s, n)) : r.push(e.substring(s, s + t));
        return r
    };

function kr(e, t) {
    for (const n in e) e.hasOwnProperty(n) && t(n, e[n])
}
const $P = function(e) {
        X(!SP(e), "Invalid JSON number");
        const t = 11,
            n = 52,
            r = (1 << t - 1) - 1;
        let s, i, o, a, l;
        e === 0 ? (i = 0, o = 0, s = 1 / e === -1 / 0 ? 1 : 0) : (s = e < 0, e = Math.abs(e), e >= Math.pow(2, 1 - r) ? (a = Math.min(Math.floor(Math.log(e) / Math.LN2), r), i = a + r, o = Math.round(e * Math.pow(2, n - a) - Math.pow(2, n))) : (i = 0, o = Math.round(e / Math.pow(2, 1 - r - n))));
        const c = [];
        for (l = n; l; l -= 1) c.push(o % 2 ? 1 : 0), o = Math.floor(o / 2);
        for (l = t; l; l -= 1) c.push(i % 2 ? 1 : 0), i = Math.floor(i / 2);
        c.push(s ? 1 : 0), c.reverse();
        const u = c.join("");
        let d = "";
        for (l = 0; l < 64; l += 8) {
            let f = parseInt(u.substr(l, 8), 2).toString(16);
            f.length === 1 && (f = "0" + f), d = d + f
        }
        return d.toLowerCase()
    },
    e4 = function() {
        return !!(typeof window == "object" && window.chrome && window.chrome.extension && !/^chrome/.test(window.location.href))
    },
    t4 = function() {
        return typeof Windows == "object" && typeof Windows.UI == "object"
    };

function n4(e, t) {
    let n = "Unknown Error";
    e === "too_big" ? n = "The data requested exceeds the maximum size that can be accessed with a single request." : e === "permission_denied" ? n = "Client doesn't have permission to access the desired data." : e === "unavailable" && (n = "The service is unavailable");
    const r = new Error(e + " at " + t._path.toString() + ": " + n);
    return r.code = e.toUpperCase(), r
}
const r4 = new RegExp("^-?(0*)\\d{1,10}$"),
    s4 = -2147483648,
    i4 = 2147483647,
    HI = function(e) {
        if (r4.test(e)) {
            const t = Number(e);
            if (t >= s4 && t <= i4) return t
        }
        return null
    },
    Gu = function(e) {
        try {
            e()
        } catch (t) {
            setTimeout(() => {
                const n = t.stack || "";
                throw Sr("Exception was thrown by user callback.", n), t
            }, Math.floor(0))
        }
    },
    o4 = function() {
        return (typeof window == "object" && window.navigator && window.navigator.userAgent || "").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0
    },
    Gd = function(e, t) {
        const n = setTimeout(e, t);
        return typeof n == "number" && typeof Deno != "undefined" && Deno.unrefTimer ? Deno.unrefTimer(n) : typeof n == "object" && n.unref && n.unref(), n
    };
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class a4 {
    constructor(t, n) {
        this.appName_ = t, this.appCheckProvider = n, this.appCheck = n == null ? void 0 : n.getImmediate({
            optional: !0
        }), this.appCheck || n == null || n.get().then(r => this.appCheck = r)
    }
    getToken(t) {
        return this.appCheck ? this.appCheck.getToken(t) : new Promise((n, r) => {
            setTimeout(() => {
                this.appCheck ? this.getToken(t).then(n, r) : n(null)
            }, 0)
        })
    }
    addTokenChangeListener(t) {
        var n;
        (n = this.appCheckProvider) === null || n === void 0 || n.get().then(r => r.addTokenListener(t))
    }
    notifyForInvalidToken() {
        Sr(`Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class l4 {
    constructor(t, n, r) {
        this.appName_ = t, this.firebaseOptions_ = n, this.authProvider_ = r, this.auth_ = null, this.auth_ = r.getImmediate({
            optional: !0
        }), this.auth_ || r.onInit(s => this.auth_ = s)
    }
    getToken(t) {
        return this.auth_ ? this.auth_.getToken(t).catch(n => n && n.code === "auth/token-not-initialized" ? (Un("Got auth/token-not-initialized error.  Treating as null token."), null) : Promise.reject(n)) : new Promise((n, r) => {
            setTimeout(() => {
                this.auth_ ? this.getToken(t).then(n, r) : n(null)
            }, 0)
        })
    }
    addTokenChangeListener(t) {
        this.auth_ ? this.auth_.addAuthTokenListener(t) : this.authProvider_.get().then(n => n.addAuthTokenListener(t))
    }
    removeTokenChangeListener(t) {
        this.authProvider_.get().then(n => n.removeAuthTokenListener(t))
    }
    notifyForInvalidToken() {
        let t = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
        "credential" in this.firebaseOptions_ ? t += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : "serviceAccount" in this.firebaseOptions_ ? t += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : t += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.', Sr(t)
    }
}
class Tc {
    constructor(t) {
        this.accessToken = t
    }
    getToken(t) {
        return Promise.resolve({
            accessToken: this.accessToken
        })
    }
    addTokenChangeListener(t) {
        t(this.accessToken)
    }
    removeTokenChangeListener(t) {}
    notifyForInvalidToken() {}
}
Tc.OWNER = "owner";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mS = "5",
    kP = "v",
    IP = "s",
    xP = "r",
    CP = "f",
    AP = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/,
    RP = "ls",
    OP = "p",
    Rw = "ac",
    DP = "websocket",
    NP = "long_polling";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PP {
    constructor(t, n, r, s, i = !1, o = "", a = !1, l = !1) {
        this.secure = n, this.namespace = r, this.webSocketOnly = s, this.nodeAdmin = i, this.persistenceKey = o, this.includeNamespaceInQueryParams = a, this.isUsingEmulator = l, this._host = t.toLowerCase(), this._domain = this._host.substr(this._host.indexOf(".") + 1), this.internalHost = Ca.get("host:" + t) || this._host
    }
    isCacheableHost() {
        return this.internalHost.substr(0, 2) === "s-"
    }
    isCustomHost() {
        return this._domain !== "firebaseio.com" && this._domain !== "firebaseio-demo.com"
    }
    get host() {
        return this._host
    }
    set host(t) {
        t !== this.internalHost && (this.internalHost = t, this.isCacheableHost() && Ca.set("host:" + this._host, this.internalHost))
    }
    toString() {
        let t = this.toURLString();
        return this.persistenceKey && (t += "<" + this.persistenceKey + ">"), t
    }
    toURLString() {
        const t = this.secure ? "https://" : "http://",
            n = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : "";
        return `${t}${this.host}/${n}`
    }
}

function c4(e) {
    return e.host !== e.internalHost || e.isCustomHost() || e.includeNamespaceInQueryParams
}

function MP(e, t, n) {
    X(typeof t == "string", "typeof type must == string"), X(typeof n == "object", "typeof params must == object");
    let r;
    if (t === DP) r = (e.secure ? "wss://" : "ws://") + e.internalHost + "/.ws?";
    else if (t === NP) r = (e.secure ? "https://" : "http://") + e.internalHost + "/.lp?";
    else throw new Error("Unknown connection type: " + t);
    c4(e) && (n.ns = e.namespace);
    const s = [];
    return kr(n, (i, o) => {
        s.push(i + "=" + o)
    }), r + s.join("&")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class u4 {
    constructor() {
        this.counters_ = {}
    }
    incrementCounter(t, n = 1) {
        Pi(this.counters_, t) || (this.counters_[t] = 0), this.counters_[t] += n
    }
    get() {
        return gz(this.counters_)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zb = {},
    Wb = {};

function gS(e) {
    const t = e.toString();
    return zb[t] || (zb[t] = new u4), zb[t]
}

function d4(e, t) {
    const n = e.toString();
    return Wb[n] || (Wb[n] = t()), Wb[n]
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class f4 {
    constructor(t) {
        this.onMessage_ = t, this.pendingResponses = [], this.currentResponseNum = 0, this.closeAfterResponse = -1, this.onClose = null
    }
    closeAfter(t, n) {
        this.closeAfterResponse = t, this.onClose = n, this.closeAfterResponse < this.currentResponseNum && (this.onClose(), this.onClose = null)
    }
    handleResponse(t, n) {
        for (this.pendingResponses[t] = n; this.pendingResponses[this.currentResponseNum];) {
            const r = this.pendingResponses[this.currentResponseNum];
            delete this.pendingResponses[this.currentResponseNum];
            for (let s = 0; s < r.length; ++s) r[s] && Gu(() => {
                this.onMessage_(r[s])
            });
            if (this.currentResponseNum === this.closeAfterResponse) {
                this.onClose && (this.onClose(), this.onClose = null);
                break
            }
            this.currentResponseNum++
        }
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const jI = "start",
    h4 = "close",
    p4 = "pLPCommand",
    m4 = "pRTLPCB",
    LP = "id",
    FP = "pw",
    UP = "ser",
    g4 = "cb",
    _4 = "seg",
    y4 = "ts",
    v4 = "d",
    b4 = "dframe",
    BP = 1870,
    VP = 30,
    w4 = BP - VP,
    E4 = 25e3,
    S4 = 3e4;
class gc {
    constructor(t, n, r, s, i, o, a) {
        this.connId = t, this.repoInfo = n, this.applicationId = r, this.appCheckToken = s, this.authToken = i, this.transportSessionId = o, this.lastSessionId = a, this.bytesSent = 0, this.bytesReceived = 0, this.everConnected_ = !1, this.log_ = Xh(t), this.stats_ = gS(n), this.urlFn = l => (this.appCheckToken && (l[Rw] = this.appCheckToken), MP(n, NP, l))
    }
    open(t, n) {
        this.curSegmentNum = 0, this.onDisconnect_ = n, this.myPacketOrderer = new f4(t), this.isClosed_ = !1, this.connectTimeoutTimer_ = setTimeout(() => {
            this.log_("Timed out trying to connect."), this.onClosed_(), this.connectTimeoutTimer_ = null
        }, Math.floor(S4)), J6(() => {
            if (this.isClosed_) return;
            this.scriptTagHolder = new _S((...i) => {
                const [o, a, l, c, u] = i;
                if (this.incrementIncomingBytes_(i), !!this.scriptTagHolder)
                    if (this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null), this.everConnected_ = !0, o === jI) this.id = a, this.password = l;
                    else if (o === h4) a ? (this.scriptTagHolder.sendNewPolls = !1, this.myPacketOrderer.closeAfter(a, () => {
                    this.onClosed_()
                })) : this.onClosed_();
                else throw new Error("Unrecognized command received: " + o)
            }, (...i) => {
                const [o, a] = i;
                this.incrementIncomingBytes_(i), this.myPacketOrderer.handleResponse(o, a)
            }, () => {
                this.onClosed_()
            }, this.urlFn);
            const r = {};
            r[jI] = "t", r[UP] = Math.floor(Math.random() * 1e8), this.scriptTagHolder.uniqueCallbackIdentifier && (r[g4] = this.scriptTagHolder.uniqueCallbackIdentifier), r[kP] = mS, this.transportSessionId && (r[IP] = this.transportSessionId), this.lastSessionId && (r[RP] = this.lastSessionId), this.applicationId && (r[OP] = this.applicationId), this.appCheckToken && (r[Rw] = this.appCheckToken), typeof location != "undefined" && location.hostname && AP.test(location.hostname) && (r[xP] = CP);
            const s = this.urlFn(r);
            this.log_("Connecting via long-poll to " + s), this.scriptTagHolder.addTag(s, () => {})
        })
    }
    start() {
        this.scriptTagHolder.startLongPoll(this.id, this.password), this.addDisconnectPingFrame(this.id, this.password)
    }
    static forceAllow() {
        gc.forceAllow_ = !0
    }
    static forceDisallow() {
        gc.forceDisallow_ = !0
    }
    static isAvailable() {
        return gc.forceAllow_ ? !0 : !gc.forceDisallow_ && typeof document != "undefined" && document.createElement != null && !e4() && !t4()
    }
    markConnectionHealthy() {}
    shutdown_() {
        this.isClosed_ = !0, this.scriptTagHolder && (this.scriptTagHolder.close(), this.scriptTagHolder = null), this.myDisconnFrame && (document.body.removeChild(this.myDisconnFrame), this.myDisconnFrame = null), this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null)
    }
    onClosed_() {
        this.isClosed_ || (this.log_("Longpoll is closing itself"), this.shutdown_(), this.onDisconnect_ && (this.onDisconnect_(this.everConnected_), this.onDisconnect_ = null))
    }
    close() {
        this.isClosed_ || (this.log_("Longpoll is being closed."), this.shutdown_())
    }
    send(t) {
        const n = rn(t);
        this.bytesSent += n.length, this.stats_.incrementCounter("bytes_sent", n.length);
        const r = rP(n),
            s = TP(r, w4);
        for (let i = 0; i < s.length; i++) this.scriptTagHolder.enqueueSegment(this.curSegmentNum, s.length, s[i]), this.curSegmentNum++
    }
    addDisconnectPingFrame(t, n) {
        this.myDisconnFrame = document.createElement("iframe");
        const r = {};
        r[b4] = "t", r[LP] = t, r[FP] = n, this.myDisconnFrame.src = this.urlFn(r), this.myDisconnFrame.style.display = "none", document.body.appendChild(this.myDisconnFrame)
    }
    incrementIncomingBytes_(t) {
        const n = rn(t).length;
        this.bytesReceived += n, this.stats_.incrementCounter("bytes_received", n)
    }
}
class _S {
    constructor(t, n, r, s) {
        this.onDisconnect = r, this.urlFn = s, this.outstandingRequests = new Set, this.pendingSegs = [], this.currentSerial = Math.floor(Math.random() * 1e8), this.sendNewPolls = !0; {
            this.uniqueCallbackIdentifier = K6(), window[p4 + this.uniqueCallbackIdentifier] = t, window[m4 + this.uniqueCallbackIdentifier] = n, this.myIFrame = _S.createIFrame_();
            let i = "";
            if (this.myIFrame.src && this.myIFrame.src.substr(0, 11) === "javascript:") {
                const a = document.domain;
                i = '<script>document.domain="' + a + '";<\/script>'
            }
            const o = "<html><body>" + i + "</body></html>";
            try {
                this.myIFrame.doc.open(), this.myIFrame.doc.write(o), this.myIFrame.doc.close()
            } catch (a) {
                Un("frame writing exception"), a.stack && Un(a.stack), Un(a)
            }
        }
    }
    static createIFrame_() {
        const t = document.createElement("iframe");
        if (t.style.display = "none", document.body) {
            document.body.appendChild(t);
            try {
                t.contentWindow.document || Un("No IE domain setting required")
            } catch {
                const r = document.domain;
                t.src = "javascript:void((function(){document.open();document.domain='" + r + "';document.close();})())"
            }
        } else throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
        return t.contentDocument ? t.doc = t.contentDocument : t.contentWindow ? t.doc = t.contentWindow.document : t.document && (t.doc = t.document), t
    }
    close() {
        this.alive = !1, this.myIFrame && (this.myIFrame.doc.body.textContent = "", setTimeout(() => {
            this.myIFrame !== null && (document.body.removeChild(this.myIFrame), this.myIFrame = null)
        }, Math.floor(0)));
        const t = this.onDisconnect;
        t && (this.onDisconnect = null, t())
    }
    startLongPoll(t, n) {
        for (this.myID = t, this.myPW = n, this.alive = !0; this.newRequest_(););
    }
    newRequest_() {
        if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
            this.currentSerial++;
            const t = {};
            t[LP] = this.myID, t[FP] = this.myPW, t[UP] = this.currentSerial;
            let n = this.urlFn(t),
                r = "",
                s = 0;
            for (; this.pendingSegs.length > 0 && this.pendingSegs[0].d.length + VP + r.length <= BP;) {
                const o = this.pendingSegs.shift();
                r = r + "&" + _4 + s + "=" + o.seg + "&" + y4 + s + "=" + o.ts + "&" + v4 + s + "=" + o.d, s++
            }
            return n = n + r, this.addLongPollTag_(n, this.currentSerial), !0
        } else return !1
    }
    enqueueSegment(t, n, r) {
        this.pendingSegs.push({
            seg: t,
            ts: n,
            d: r
        }), this.alive && this.newRequest_()
    }
    addLongPollTag_(t, n) {
        this.outstandingRequests.add(n);
        const r = () => {
                this.outstandingRequests.delete(n), this.newRequest_()
            },
            s = setTimeout(r, Math.floor(E4)),
            i = () => {
                clearTimeout(s), r()
            };
        this.addTag(t, i)
    }
    addTag(t, n) {
        setTimeout(() => {
            try {
                if (!this.sendNewPolls) return;
                const r = this.myIFrame.doc.createElement("script");
                r.type = "text/javascript", r.async = !0, r.src = t, r.onload = r.onreadystatechange = function() {
                    const s = r.readyState;
                    (!s || s === "loaded" || s === "complete") && (r.onload = r.onreadystatechange = null, r.parentNode && r.parentNode.removeChild(r), n())
                }, r.onerror = () => {
                    Un("Long-poll script failed to load: " + t), this.sendNewPolls = !1, this.close()
                }, this.myIFrame.doc.body.appendChild(r)
            } catch {}
        }, Math.floor(1))
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const T4 = 16384,
    $4 = 45e3;
let Ug = null;
typeof MozWebSocket != "undefined" ? Ug = MozWebSocket : typeof WebSocket != "undefined" && (Ug = WebSocket);
class ns {
    constructor(t, n, r, s, i, o, a) {
        this.connId = t, this.applicationId = r, this.appCheckToken = s, this.authToken = i, this.keepaliveTimer = null, this.frames = null, this.totalFrames = 0, this.bytesSent = 0, this.bytesReceived = 0, this.log_ = Xh(this.connId), this.stats_ = gS(n), this.connURL = ns.connectionURL_(n, o, a, s, r), this.nodeAdmin = n.nodeAdmin
    }
    static connectionURL_(t, n, r, s, i) {
        const o = {};
        return o[kP] = mS, typeof location != "undefined" && location.hostname && AP.test(location.hostname) && (o[xP] = CP), n && (o[IP] = n), r && (o[RP] = r), s && (o[Rw] = s), i && (o[OP] = i), MP(t, DP, o)
    }
    open(t, n) {
        this.onDisconnect = n, this.onMessage = t, this.log_("Websocket connecting to " + this.connURL), this.everConnected_ = !1, Ca.set("previous_websocket_failure", !0);
        try {
            let r;
            dP(), this.mySock = new Ug(this.connURL, [], r)
        } catch (r) {
            this.log_("Error instantiating WebSocket.");
            const s = r.message || r.data;
            s && this.log_(s), this.onClosed_();
            return
        }
        this.mySock.onopen = () => {
            this.log_("Websocket connected."), this.everConnected_ = !0
        }, this.mySock.onclose = () => {
            this.log_("Websocket connection was disconnected."), this.mySock = null, this.onClosed_()
        }, this.mySock.onmessage = r => {
            this.handleIncomingFrame(r)
        }, this.mySock.onerror = r => {
            this.log_("WebSocket error.  Closing connection.");
            const s = r.message || r.data;
            s && this.log_(s), this.onClosed_()
        }
    }
    start() {}
    static forceDisallow() {
        ns.forceDisallow_ = !0
    }
    static isAvailable() {
        let t = !1;
        if (typeof navigator != "undefined" && navigator.userAgent) {
            const n = /Android ([0-9]{0,}\.[0-9]{0,})/,
                r = navigator.userAgent.match(n);
            r && r.length > 1 && parseFloat(r[1]) < 4.4 && (t = !0)
        }
        return !t && Ug !== null && !ns.forceDisallow_
    }
    static previouslyFailed() {
        return Ca.isInMemoryStorage || Ca.get("previous_websocket_failure") === !0
    }
    markConnectionHealthy() {
        Ca.remove("previous_websocket_failure")
    }
    appendFrame_(t) {
        if (this.frames.push(t), this.frames.length === this.totalFrames) {
            const n = this.frames.join("");
            this.frames = null;
            const r = Mf(n);
            this.onMessage(r)
        }
    }
    handleNewFrameCount_(t) {
        this.totalFrames = t, this.frames = []
    }
    extractFrameCount_(t) {
        if (X(this.frames === null, "We already have a frame buffer"), t.length <= 6) {
            const n = Number(t);
            if (!isNaN(n)) return this.handleNewFrameCount_(n), null
        }
        return this.handleNewFrameCount_(1), t
    }
    handleIncomingFrame(t) {
        if (this.mySock === null) return;
        const n = t.data;
        if (this.bytesReceived += n.length, this.stats_.incrementCounter("bytes_received", n.length), this.resetKeepAlive(), this.frames !== null) this.appendFrame_(n);
        else {
            const r = this.extractFrameCount_(n);
            r !== null && this.appendFrame_(r)
        }
    }
    send(t) {
        this.resetKeepAlive();
        const n = rn(t);
        this.bytesSent += n.length, this.stats_.incrementCounter("bytes_sent", n.length);
        const r = TP(n, T4);
        r.length > 1 && this.sendString_(String(r.length));
        for (let s = 0; s < r.length; s++) this.sendString_(r[s])
    }
    shutdown_() {
        this.isClosed_ = !0, this.keepaliveTimer && (clearInterval(this.keepaliveTimer), this.keepaliveTimer = null), this.mySock && (this.mySock.close(), this.mySock = null)
    }
    onClosed_() {
        this.isClosed_ || (this.log_("WebSocket is closing itself"), this.shutdown_(), this.onDisconnect && (this.onDisconnect(this.everConnected_), this.onDisconnect = null))
    }
    close() {
        this.isClosed_ || (this.log_("WebSocket is being closed"), this.shutdown_())
    }
    resetKeepAlive() {
        clearInterval(this.keepaliveTimer), this.keepaliveTimer = setInterval(() => {
            this.mySock && this.sendString_("0"), this.resetKeepAlive()
        }, Math.floor($4))
    }
    sendString_(t) {
        try {
            this.mySock.send(t)
        } catch (n) {
            this.log_("Exception thrown from WebSocket.send():", n.message || n.data, "Closing connection."), setTimeout(this.onClosed_.bind(this), 0)
        }
    }
}
ns.responsesRequiredToBeHealthy = 2;
ns.healthyTimeout = 3e4;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bf {
    constructor(t) {
        this.initTransports_(t)
    }
    static get ALL_TRANSPORTS() {
        return [gc, ns]
    }
    static get IS_TRANSPORT_INITIALIZED() {
        return this.globalTransportInitialized_
    }
    initTransports_(t) {
        const n = ns && ns.isAvailable();
        let r = n && !ns.previouslyFailed();
        if (t.webSocketOnly && (n || Sr("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."), r = !0), r) this.transports_ = [ns];
        else {
            const s = this.transports_ = [];
            for (const i of Bf.ALL_TRANSPORTS) i && i.isAvailable() && s.push(i);
            Bf.globalTransportInitialized_ = !0
        }
    }
    initialTransport() {
        if (this.transports_.length > 0) return this.transports_[0];
        throw new Error("No transports available")
    }
    upgradeTransport() {
        return this.transports_.length > 1 ? this.transports_[1] : null
    }
}
Bf.globalTransportInitialized_ = !1;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const k4 = 6e4,
    I4 = 5e3,
    x4 = 10 * 1024,
    C4 = 100 * 1024,
    Gb = "t",
    zI = "d",
    A4 = "s",
    WI = "r",
    R4 = "e",
    GI = "o",
    qI = "a",
    YI = "n",
    KI = "p",
    O4 = "h";
class D4 {
    constructor(t, n, r, s, i, o, a, l, c, u) {
        this.id = t, this.repoInfo_ = n, this.applicationId_ = r, this.appCheckToken_ = s, this.authToken_ = i, this.onMessage_ = o, this.onReady_ = a, this.onDisconnect_ = l, this.onKill_ = c, this.lastSessionId = u, this.connectionCount = 0, this.pendingDataMessages = [], this.state_ = 0, this.log_ = Xh("c:" + this.id + ":"), this.transportManager_ = new Bf(n), this.log_("Connection created"), this.start_()
    }
    start_() {
        const t = this.transportManager_.initialTransport();
        this.conn_ = new t(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId), this.primaryResponsesRequired_ = t.responsesRequiredToBeHealthy || 0;
        const n = this.connReceiver_(this.conn_),
            r = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_, this.rx_ = this.conn_, this.secondaryConn_ = null, this.isHealthy_ = !1, setTimeout(() => {
            this.conn_ && this.conn_.open(n, r)
        }, Math.floor(0));
        const s = t.healthyTimeout || 0;
        s > 0 && (this.healthyTimeout_ = Gd(() => {
            this.healthyTimeout_ = null, this.isHealthy_ || (this.conn_ && this.conn_.bytesReceived > C4 ? (this.log_("Connection exceeded healthy timeout but has received " + this.conn_.bytesReceived + " bytes.  Marking connection healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()) : this.conn_ && this.conn_.bytesSent > x4 ? this.log_("Connection exceeded healthy timeout but has sent " + this.conn_.bytesSent + " bytes.  Leaving connection alive.") : (this.log_("Closing unhealthy connection after timeout."), this.close()))
        }, Math.floor(s)))
    }
    nextTransportId_() {
        return "c:" + this.id + ":" + this.connectionCount++
    }
    disconnReceiver_(t) {
        return n => {
            t === this.conn_ ? this.onConnectionLost_(n) : t === this.secondaryConn_ ? (this.log_("Secondary connection lost."), this.onSecondaryConnectionLost_()) : this.log_("closing an old connection")
        }
    }
    connReceiver_(t) {
        return n => {
            this.state_ !== 2 && (t === this.rx_ ? this.onPrimaryMessageReceived_(n) : t === this.secondaryConn_ ? this.onSecondaryMessageReceived_(n) : this.log_("message on old connection"))
        }
    }
    sendRequest(t) {
        const n = {
            t: "d",
            d: t
        };
        this.sendData_(n)
    }
    tryCleanupConnection() {
        this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_ && (this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId), this.conn_ = this.secondaryConn_, this.secondaryConn_ = null)
    }
    onSecondaryControl_(t) {
        if (Gb in t) {
            const n = t[Gb];
            n === qI ? this.upgradeIfSecondaryHealthy_() : n === WI ? (this.log_("Got a reset on secondary, closing it"), this.secondaryConn_.close(), (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) && this.close()) : n === GI && (this.log_("got pong on secondary."), this.secondaryResponsesRequired_--, this.upgradeIfSecondaryHealthy_())
        }
    }
    onSecondaryMessageReceived_(t) {
        const n = ld("t", t),
            r = ld("d", t);
        if (n === "c") this.onSecondaryControl_(r);
        else if (n === "d") this.pendingDataMessages.push(r);
        else throw new Error("Unknown protocol layer: " + n)
    }
    upgradeIfSecondaryHealthy_() {
        this.secondaryResponsesRequired_ <= 0 ? (this.log_("Secondary connection is healthy."), this.isHealthy_ = !0, this.secondaryConn_.markConnectionHealthy(), this.proceedWithUpgrade_()) : (this.log_("sending ping on secondary."), this.secondaryConn_.send({
            t: "c",
            d: {
                t: KI,
                d: {}
            }
        }))
    }
    proceedWithUpgrade_() {
        this.secondaryConn_.start(), this.log_("sending client ack on secondary"), this.secondaryConn_.send({
            t: "c",
            d: {
                t: qI,
                d: {}
            }
        }), this.log_("Ending transmission on primary"), this.conn_.send({
            t: "c",
            d: {
                t: YI,
                d: {}
            }
        }), this.tx_ = this.secondaryConn_, this.tryCleanupConnection()
    }
    onPrimaryMessageReceived_(t) {
        const n = ld("t", t),
            r = ld("d", t);
        n === "c" ? this.onControl_(r) : n === "d" && this.onDataMessage_(r)
    }
    onDataMessage_(t) {
        this.onPrimaryResponse_(), this.onMessage_(t)
    }
    onPrimaryResponse_() {
        this.isHealthy_ || (this.primaryResponsesRequired_--, this.primaryResponsesRequired_ <= 0 && (this.log_("Primary connection is healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()))
    }
    onControl_(t) {
        const n = ld(Gb, t);
        if (zI in t) {
            const r = t[zI];
            if (n === O4) {
                const s = Object.assign({}, r);
                this.repoInfo_.isUsingEmulator && (s.h = this.repoInfo_.host), this.onHandshake_(s)
            } else if (n === YI) {
                this.log_("recvd end transmission on primary"), this.rx_ = this.secondaryConn_;
                for (let s = 0; s < this.pendingDataMessages.length; ++s) this.onDataMessage_(this.pendingDataMessages[s]);
                this.pendingDataMessages = [], this.tryCleanupConnection()
            } else n === A4 ? this.onConnectionShutdown_(r) : n === WI ? this.onReset_(r) : n === R4 ? Aw("Server Error: " + r) : n === GI ? (this.log_("got pong on primary."), this.onPrimaryResponse_(), this.sendPingOnPrimaryIfNecessary_()) : Aw("Unknown control packet command: " + n)
        }
    }
    onHandshake_(t) {
        const n = t.ts,
            r = t.v,
            s = t.h;
        this.sessionId = t.s, this.repoInfo_.host = s, this.state_ === 0 && (this.conn_.start(), this.onConnectionEstablished_(this.conn_, n), mS !== r && Sr("Protocol version mismatch detected"), this.tryStartUpgrade_())
    }
    tryStartUpgrade_() {
        const t = this.transportManager_.upgradeTransport();
        t && this.startUpgrade_(t)
    }
    startUpgrade_(t) {
        this.secondaryConn_ = new t(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId), this.secondaryResponsesRequired_ = t.responsesRequiredToBeHealthy || 0;
        const n = this.connReceiver_(this.secondaryConn_),
            r = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(n, r), Gd(() => {
            this.secondaryConn_ && (this.log_("Timed out trying to upgrade."), this.secondaryConn_.close())
        }, Math.floor(k4))
    }
    onReset_(t) {
        this.log_("Reset packet received.  New host: " + t), this.repoInfo_.host = t, this.state_ === 1 ? this.close() : (this.closeConnections_(), this.start_())
    }
    onConnectionEstablished_(t, n) {
        this.log_("Realtime connection established."), this.conn_ = t, this.state_ = 1, this.onReady_ && (this.onReady_(n, this.sessionId), this.onReady_ = null), this.primaryResponsesRequired_ === 0 ? (this.log_("Primary connection is healthy."), this.isHealthy_ = !0) : Gd(() => {
            this.sendPingOnPrimaryIfNecessary_()
        }, Math.floor(I4))
    }
    sendPingOnPrimaryIfNecessary_() {
        !this.isHealthy_ && this.state_ === 1 && (this.log_("sending ping on primary."), this.sendData_({
            t: "c",
            d: {
                t: KI,
                d: {}
            }
        }))
    }
    onSecondaryConnectionLost_() {
        const t = this.secondaryConn_;
        this.secondaryConn_ = null, (this.tx_ === t || this.rx_ === t) && this.close()
    }
    onConnectionLost_(t) {
        this.conn_ = null, !t && this.state_ === 0 ? (this.log_("Realtime connection failed."), this.repoInfo_.isCacheableHost() && (Ca.remove("host:" + this.repoInfo_.host), this.repoInfo_.internalHost = this.repoInfo_.host)) : this.state_ === 1 && this.log_("Realtime connection lost."), this.close()
    }
    onConnectionShutdown_(t) {
        this.log_("Connection shutdown command received. Shutting down..."), this.onKill_ && (this.onKill_(t), this.onKill_ = null), this.onDisconnect_ = null, this.close()
    }
    sendData_(t) {
        if (this.state_ !== 1) throw "Connection is not connected";
        this.tx_.send(t)
    }
    close() {
        this.state_ !== 2 && (this.log_("Closing realtime connection."), this.state_ = 2, this.closeConnections_(), this.onDisconnect_ && (this.onDisconnect_(), this.onDisconnect_ = null))
    }
    closeConnections_() {
        this.log_("Shutting down all connections"), this.conn_ && (this.conn_.close(), this.conn_ = null), this.secondaryConn_ && (this.secondaryConn_.close(), this.secondaryConn_ = null), this.healthyTimeout_ && (clearTimeout(this.healthyTimeout_), this.healthyTimeout_ = null)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HP {
    put(t, n, r, s) {}
    merge(t, n, r, s) {}
    refreshAuthToken(t) {}
    refreshAppCheckToken(t) {}
    onDisconnectPut(t, n, r) {}
    onDisconnectMerge(t, n, r) {}
    onDisconnectCancel(t, n) {}
    reportStats(t) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jP {
    constructor(t) {
        this.allowedEvents_ = t, this.listeners_ = {}, X(Array.isArray(t) && t.length > 0, "Requires a non-empty array")
    }
    trigger(t, ...n) {
        if (Array.isArray(this.listeners_[t])) {
            const r = [...this.listeners_[t]];
            for (let s = 0; s < r.length; s++) r[s].callback.apply(r[s].context, n)
        }
    }
    on(t, n, r) {
        this.validateEventType_(t), this.listeners_[t] = this.listeners_[t] || [], this.listeners_[t].push({
            callback: n,
            context: r
        });
        const s = this.getInitialEvent(t);
        s && n.apply(r, s)
    }
    off(t, n, r) {
        this.validateEventType_(t);
        const s = this.listeners_[t] || [];
        for (let i = 0; i < s.length; i++)
            if (s[i].callback === n && (!r || r === s[i].context)) {
                s.splice(i, 1);
                return
            }
    }
    validateEventType_(t) {
        X(this.allowedEvents_.find(n => n === t), "Unknown event: " + t)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bg extends jP {
    constructor() {
        super(["online"]), this.online_ = !0, typeof window != "undefined" && typeof window.addEventListener != "undefined" && !dS() && (window.addEventListener("online", () => {
            this.online_ || (this.online_ = !0, this.trigger("online", !0))
        }, !1), window.addEventListener("offline", () => {
            this.online_ && (this.online_ = !1, this.trigger("online", !1))
        }, !1))
    }
    static getInstance() {
        return new Bg
    }
    getInitialEvent(t) {
        return X(t === "online", "Unknown event type: " + t), [this.online_]
    }
    currentlyOnline() {
        return this.online_
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const XI = 32,
    QI = 768;
class wt {
    constructor(t, n) {
        if (n === void 0) {
            this.pieces_ = t.split("/");
            let r = 0;
            for (let s = 0; s < this.pieces_.length; s++) this.pieces_[s].length > 0 && (this.pieces_[r] = this.pieces_[s], r++);
            this.pieces_.length = r, this.pieceNum_ = 0
        } else this.pieces_ = t, this.pieceNum_ = n
    }
    toString() {
        let t = "";
        for (let n = this.pieceNum_; n < this.pieces_.length; n++) this.pieces_[n] !== "" && (t += "/" + this.pieces_[n]);
        return t || "/"
    }
}

function nt() {
    return new wt("")
}

function He(e) {
    return e.pieceNum_ >= e.pieces_.length ? null : e.pieces_[e.pieceNum_]
}

function Lo(e) {
    return e.pieces_.length - e.pieceNum_
}

function Tt(e) {
    let t = e.pieceNum_;
    return t < e.pieces_.length && t++, new wt(e.pieces_, t)
}

function zP(e) {
    return e.pieceNum_ < e.pieces_.length ? e.pieces_[e.pieces_.length - 1] : null
}

function N4(e) {
    let t = "";
    for (let n = e.pieceNum_; n < e.pieces_.length; n++) e.pieces_[n] !== "" && (t += "/" + encodeURIComponent(String(e.pieces_[n])));
    return t || "/"
}

function WP(e, t = 0) {
    return e.pieces_.slice(e.pieceNum_ + t)
}

function GP(e) {
    if (e.pieceNum_ >= e.pieces_.length) return null;
    const t = [];
    for (let n = e.pieceNum_; n < e.pieces_.length - 1; n++) t.push(e.pieces_[n]);
    return new wt(t, 0)
}

function sn(e, t) {
    const n = [];
    for (let r = e.pieceNum_; r < e.pieces_.length; r++) n.push(e.pieces_[r]);
    if (t instanceof wt)
        for (let r = t.pieceNum_; r < t.pieces_.length; r++) n.push(t.pieces_[r]);
    else {
        const r = t.split("/");
        for (let s = 0; s < r.length; s++) r[s].length > 0 && n.push(r[s])
    }
    return new wt(n, 0)
}

function Be(e) {
    return e.pieceNum_ >= e.pieces_.length
}

function or(e, t) {
    const n = He(e),
        r = He(t);
    if (n === null) return t;
    if (n === r) return or(Tt(e), Tt(t));
    throw new Error("INTERNAL ERROR: innerPath (" + t + ") is not within outerPath (" + e + ")")
}

function qP(e, t) {
    if (Lo(e) !== Lo(t)) return !1;
    for (let n = e.pieceNum_, r = t.pieceNum_; n <= e.pieces_.length; n++, r++)
        if (e.pieces_[n] !== t.pieces_[r]) return !1;
    return !0
}

function ss(e, t) {
    let n = e.pieceNum_,
        r = t.pieceNum_;
    if (Lo(e) > Lo(t)) return !1;
    for (; n < e.pieces_.length;) {
        if (e.pieces_[n] !== t.pieces_[r]) return !1;
        ++n, ++r
    }
    return !0
}
class P4 {
    constructor(t, n) {
        this.errorPrefix_ = n, this.parts_ = WP(t, 0), this.byteLength_ = Math.max(1, this.parts_.length);
        for (let r = 0; r < this.parts_.length; r++) this.byteLength_ += By(this.parts_[r]);
        YP(this)
    }
}

function M4(e, t) {
    e.parts_.length > 0 && (e.byteLength_ += 1), e.parts_.push(t), e.byteLength_ += By(t), YP(e)
}

function L4(e) {
    const t = e.parts_.pop();
    e.byteLength_ -= By(t), e.parts_.length > 0 && (e.byteLength_ -= 1)
}

function YP(e) {
    if (e.byteLength_ > QI) throw new Error(e.errorPrefix_ + "has a key path longer than " + QI + " bytes (" + e.byteLength_ + ").");
    if (e.parts_.length > XI) throw new Error(e.errorPrefix_ + "path specified exceeds the maximum depth that can be written (" + XI + ") or object contains a cycle " + Ea(e))
}

function Ea(e) {
    return e.parts_.length === 0 ? "" : "in property '" + e.parts_.join(".") + "'"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yS extends jP {
    constructor() {
        super(["visible"]);
        let t, n;
        typeof document != "undefined" && typeof document.addEventListener != "undefined" && (typeof document.hidden != "undefined" ? (n = "visibilitychange", t = "hidden") : typeof document.mozHidden != "undefined" ? (n = "mozvisibilitychange", t = "mozHidden") : typeof document.msHidden != "undefined" ? (n = "msvisibilitychange", t = "msHidden") : typeof document.webkitHidden != "undefined" && (n = "webkitvisibilitychange", t = "webkitHidden")), this.visible_ = !0, n && document.addEventListener(n, () => {
            const r = !document[t];
            r !== this.visible_ && (this.visible_ = r, this.trigger("visible", r))
        }, !1)
    }
    static getInstance() {
        return new yS
    }
    getInitialEvent(t) {
        return X(t === "visible", "Unknown event type: " + t), [this.visible_]
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cd = 1e3,
    F4 = 60 * 5 * 1e3,
    JI = 30 * 1e3,
    U4 = 1.3,
    B4 = 3e4,
    V4 = "server_kill",
    ZI = 3;
class ci extends HP {
    constructor(t, n, r, s, i, o, a, l) {
        if (super(), this.repoInfo_ = t, this.applicationId_ = n, this.onDataUpdate_ = r, this.onConnectStatus_ = s, this.onServerInfoUpdate_ = i, this.authTokenProvider_ = o, this.appCheckTokenProvider_ = a, this.authOverride_ = l, this.id = ci.nextPersistentConnectionId_++, this.log_ = Xh("p:" + this.id + ":"), this.interruptReasons_ = {}, this.listens = new Map, this.outstandingPuts_ = [], this.outstandingGets_ = [], this.outstandingPutCount_ = 0, this.outstandingGetCount_ = 0, this.onDisconnectRequestQueue_ = [], this.connected_ = !1, this.reconnectDelay_ = cd, this.maxReconnectDelay_ = F4, this.securityDebugCallback_ = null, this.lastSessionId = null, this.establishConnectionTimer_ = null, this.visible_ = !1, this.requestCBHash_ = {}, this.requestNumber_ = 0, this.realtime_ = null, this.authToken_ = null, this.appCheckToken_ = null, this.forceTokenRefresh_ = !1, this.invalidAuthTokenCount_ = 0, this.invalidAppCheckTokenCount_ = 0, this.firstConnection_ = !0, this.lastConnectionAttemptTime_ = null, this.lastConnectionEstablishedTime_ = null, l && !dP()) throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
        yS.getInstance().on("visible", this.onVisible_, this), t.host.indexOf("fblocal") === -1 && Bg.getInstance().on("online", this.onOnline_, this)
    }
    sendRequest(t, n, r) {
        const s = ++this.requestNumber_,
            i = {
                r: s,
                a: t,
                b: n
            };
        this.log_(rn(i)), X(this.connected_, "sendRequest call when we're not connected not allowed."), this.realtime_.sendRequest(i), r && (this.requestCBHash_[s] = r)
    }
    get(t) {
        this.initConnection_();
        const n = new Mo,
            r = {
                p: t._path.toString(),
                q: t._queryObject
            },
            s = {
                action: "g",
                request: r,
                onComplete: o => {
                    const a = o.d;
                    o.s === "ok" ? n.resolve(a) : n.reject(a)
                }
            };
        this.outstandingGets_.push(s), this.outstandingGetCount_++;
        const i = this.outstandingGets_.length - 1;
        return this.connected_ && this.sendGet_(i), n.promise
    }
    listen(t, n, r, s) {
        this.initConnection_();
        const i = t._queryIdentifier,
            o = t._path.toString();
        this.log_("Listen called for " + o + " " + i), this.listens.has(o) || this.listens.set(o, new Map), X(t._queryParams.isDefault() || !t._queryParams.loadsAllData(), "listen() called for non-default but complete query"), X(!this.listens.get(o).has(i), "listen() called twice for same path/queryId.");
        const a = {
            onComplete: s,
            hashFn: n,
            query: t,
            tag: r
        };
        this.listens.get(o).set(i, a), this.connected_ && this.sendListen_(a)
    }
    sendGet_(t) {
        const n = this.outstandingGets_[t];
        this.sendRequest("g", n.request, r => {
            delete this.outstandingGets_[t], this.outstandingGetCount_--, this.outstandingGetCount_ === 0 && (this.outstandingGets_ = []), n.onComplete && n.onComplete(r)
        })
    }
    sendListen_(t) {
        const n = t.query,
            r = n._path.toString(),
            s = n._queryIdentifier;
        this.log_("Listen on " + r + " for " + s);
        const i = {
                p: r
            },
            o = "q";
        t.tag && (i.q = n._queryObject, i.t = t.tag), i.h = t.hashFn(), this.sendRequest(o, i, a => {
            const l = a.d,
                c = a.s;
            ci.warnOnListenWarnings_(l, n), (this.listens.get(r) && this.listens.get(r).get(s)) === t && (this.log_("listen response", a), c !== "ok" && this.removeListen_(r, s), t.onComplete && t.onComplete(c, l))
        })
    }
    static warnOnListenWarnings_(t, n) {
        if (t && typeof t == "object" && Pi(t, "w")) {
            const r = Jc(t, "w");
            if (Array.isArray(r) && ~r.indexOf("no_index")) {
                const s = '".indexOn": "' + n._queryParams.getIndex().toString() + '"',
                    i = n._path.toString();
                Sr(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${s} at ${i} to your security rules for better performance.`)
            }
        }
    }
    refreshAuthToken(t) {
        this.authToken_ = t, this.log_("Auth token refreshed"), this.authToken_ ? this.tryAuth() : this.connected_ && this.sendRequest("unauth", {}, () => {}), this.reduceReconnectDelayIfAdminCredential_(t)
    }
    reduceReconnectDelayIfAdminCredential_(t) {
        (t && t.length === 40 || xz(t)) && (this.log_("Admin auth credential detected.  Reducing max reconnect time."), this.maxReconnectDelay_ = JI)
    }
    refreshAppCheckToken(t) {
        this.appCheckToken_ = t, this.log_("App check token refreshed"), this.appCheckToken_ ? this.tryAppCheck() : this.connected_ && this.sendRequest("unappeck", {}, () => {})
    }
    tryAuth() {
        if (this.connected_ && this.authToken_) {
            const t = this.authToken_,
                n = Iz(t) ? "auth" : "gauth",
                r = {
                    cred: t
                };
            this.authOverride_ === null ? r.noauth = !0 : typeof this.authOverride_ == "object" && (r.authvar = this.authOverride_), this.sendRequest(n, r, s => {
                const i = s.s,
                    o = s.d || "error";
                this.authToken_ === t && (i === "ok" ? this.invalidAuthTokenCount_ = 0 : this.onAuthRevoked_(i, o))
            })
        }
    }
    tryAppCheck() {
        this.connected_ && this.appCheckToken_ && this.sendRequest("appcheck", {
            token: this.appCheckToken_
        }, t => {
            const n = t.s,
                r = t.d || "error";
            n === "ok" ? this.invalidAppCheckTokenCount_ = 0 : this.onAppCheckRevoked_(n, r)
        })
    }
    unlisten(t, n) {
        const r = t._path.toString(),
            s = t._queryIdentifier;
        this.log_("Unlisten called for " + r + " " + s), X(t._queryParams.isDefault() || !t._queryParams.loadsAllData(), "unlisten() called for non-default but complete query"), this.removeListen_(r, s) && this.connected_ && this.sendUnlisten_(r, s, t._queryObject, n)
    }
    sendUnlisten_(t, n, r, s) {
        this.log_("Unlisten on " + t + " for " + n);
        const i = {
                p: t
            },
            o = "n";
        s && (i.q = r, i.t = s), this.sendRequest(o, i)
    }
    onDisconnectPut(t, n, r) {
        this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("o", t, n, r) : this.onDisconnectRequestQueue_.push({
            pathString: t,
            action: "o",
            data: n,
            onComplete: r
        })
    }
    onDisconnectMerge(t, n, r) {
        this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("om", t, n, r) : this.onDisconnectRequestQueue_.push({
            pathString: t,
            action: "om",
            data: n,
            onComplete: r
        })
    }
    onDisconnectCancel(t, n) {
        this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("oc", t, null, n) : this.onDisconnectRequestQueue_.push({
            pathString: t,
            action: "oc",
            data: null,
            onComplete: n
        })
    }
    sendOnDisconnect_(t, n, r, s) {
        const i = {
            p: n,
            d: r
        };
        this.log_("onDisconnect " + t, i), this.sendRequest(t, i, o => {
            s && setTimeout(() => {
                s(o.s, o.d)
            }, Math.floor(0))
        })
    }
    put(t, n, r, s) {
        this.putInternal("p", t, n, r, s)
    }
    merge(t, n, r, s) {
        this.putInternal("m", t, n, r, s)
    }
    putInternal(t, n, r, s, i) {
        this.initConnection_();
        const o = {
            p: n,
            d: r
        };
        i !== void 0 && (o.h = i), this.outstandingPuts_.push({
            action: t,
            request: o,
            onComplete: s
        }), this.outstandingPutCount_++;
        const a = this.outstandingPuts_.length - 1;
        this.connected_ ? this.sendPut_(a) : this.log_("Buffering put: " + n)
    }
    sendPut_(t) {
        const n = this.outstandingPuts_[t].action,
            r = this.outstandingPuts_[t].request,
            s = this.outstandingPuts_[t].onComplete;
        this.outstandingPuts_[t].queued = this.connected_, this.sendRequest(n, r, i => {
            this.log_(n + " response", i), delete this.outstandingPuts_[t], this.outstandingPutCount_--, this.outstandingPutCount_ === 0 && (this.outstandingPuts_ = []), s && s(i.s, i.d)
        })
    }
    reportStats(t) {
        if (this.connected_) {
            const n = {
                c: t
            };
            this.log_("reportStats", n), this.sendRequest("s", n, r => {
                if (r.s !== "ok") {
                    const i = r.d;
                    this.log_("reportStats", "Error sending stats: " + i)
                }
            })
        }
    }
    onDataMessage_(t) {
        if ("r" in t) {
            this.log_("from server: " + rn(t));
            const n = t.r,
                r = this.requestCBHash_[n];
            r && (delete this.requestCBHash_[n], r(t.b))
        } else {
            if ("error" in t) throw "A server-side error has occurred: " + t.error;
            "a" in t && this.onDataPush_(t.a, t.b)
        }
    }
    onDataPush_(t, n) {
        this.log_("handleServerMessage", t, n), t === "d" ? this.onDataUpdate_(n.p, n.d, !1, n.t) : t === "m" ? this.onDataUpdate_(n.p, n.d, !0, n.t) : t === "c" ? this.onListenRevoked_(n.p, n.q) : t === "ac" ? this.onAuthRevoked_(n.s, n.d) : t === "apc" ? this.onAppCheckRevoked_(n.s, n.d) : t === "sd" ? this.onSecurityDebugPacket_(n) : Aw("Unrecognized action received from server: " + rn(t) + `
Are you using the latest client?`)
    }
    onReady_(t, n) {
        this.log_("connection ready"), this.connected_ = !0, this.lastConnectionEstablishedTime_ = new Date().getTime(), this.handleTimestamp_(t), this.lastSessionId = n, this.firstConnection_ && this.sendConnectStats_(), this.restoreState_(), this.firstConnection_ = !1, this.onConnectStatus_(!0)
    }
    scheduleConnect_(t) {
        X(!this.realtime_, "Scheduling a connect when we're already connected/ing?"), this.establishConnectionTimer_ && clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = setTimeout(() => {
            this.establishConnectionTimer_ = null, this.establishConnection_()
        }, Math.floor(t))
    }
    initConnection_() {
        !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0)
    }
    onVisible_(t) {
        t && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_ && (this.log_("Window became visible.  Reducing delay."), this.reconnectDelay_ = cd, this.realtime_ || this.scheduleConnect_(0)), this.visible_ = t
    }
    onOnline_(t) {
        t ? (this.log_("Browser went online."), this.reconnectDelay_ = cd, this.realtime_ || this.scheduleConnect_(0)) : (this.log_("Browser went offline.  Killing connection."), this.realtime_ && this.realtime_.close())
    }
    onRealtimeDisconnect_() {
        if (this.log_("data client disconnected"), this.connected_ = !1, this.realtime_ = null, this.cancelSentTransactions_(), this.requestCBHash_ = {}, this.shouldReconnect_()) {
            this.visible_ ? this.lastConnectionEstablishedTime_ && (new Date().getTime() - this.lastConnectionEstablishedTime_ > B4 && (this.reconnectDelay_ = cd), this.lastConnectionEstablishedTime_ = null) : (this.log_("Window isn't visible.  Delaying reconnect."), this.reconnectDelay_ = this.maxReconnectDelay_, this.lastConnectionAttemptTime_ = new Date().getTime());
            const t = new Date().getTime() - this.lastConnectionAttemptTime_;
            let n = Math.max(0, this.reconnectDelay_ - t);
            n = Math.random() * n, this.log_("Trying to reconnect in " + n + "ms"), this.scheduleConnect_(n), this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * U4)
        }
        this.onConnectStatus_(!1)
    }
    async establishConnection_() {
        if (this.shouldReconnect_()) {
            this.log_("Making a connection attempt"), this.lastConnectionAttemptTime_ = new Date().getTime(), this.lastConnectionEstablishedTime_ = null;
            const t = this.onDataMessage_.bind(this),
                n = this.onReady_.bind(this),
                r = this.onRealtimeDisconnect_.bind(this),
                s = this.id + ":" + ci.nextConnectionId_++,
                i = this.lastSessionId;
            let o = !1,
                a = null;
            const l = function() {
                    a ? a.close() : (o = !0, r())
                },
                c = function(d) {
                    X(a, "sendRequest call when we're not connected not allowed."), a.sendRequest(d)
                };
            this.realtime_ = {
                close: l,
                sendRequest: c
            };
            const u = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = !1;
            try {
                const [d, f] = await Promise.all([this.authTokenProvider_.getToken(u), this.appCheckTokenProvider_.getToken(u)]);
                o ? Un("getToken() completed but was canceled") : (Un("getToken() completed. Creating connection."), this.authToken_ = d && d.accessToken, this.appCheckToken_ = f && f.token, a = new D4(s, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, t, n, r, h => {
                    Sr(h + " (" + this.repoInfo_.toString() + ")"), this.interrupt(V4)
                }, i))
            } catch (d) {
                this.log_("Failed to get token: " + d), o || (this.repoInfo_.nodeAdmin && Sr(d), l())
            }
        }
    }
    interrupt(t) {
        Un("Interrupting connection for reason: " + t), this.interruptReasons_[t] = !0, this.realtime_ ? this.realtime_.close() : (this.establishConnectionTimer_ && (clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = null), this.connected_ && this.onRealtimeDisconnect_())
    }
    resume(t) {
        Un("Resuming connection for reason: " + t), delete this.interruptReasons_[t], Ew(this.interruptReasons_) && (this.reconnectDelay_ = cd, this.realtime_ || this.scheduleConnect_(0))
    }
    handleTimestamp_(t) {
        const n = t - new Date().getTime();
        this.onServerInfoUpdate_({
            serverTimeOffset: n
        })
    }
    cancelSentTransactions_() {
        for (let t = 0; t < this.outstandingPuts_.length; t++) {
            const n = this.outstandingPuts_[t];
            n && "h" in n.request && n.queued && (n.onComplete && n.onComplete("disconnect"), delete this.outstandingPuts_[t], this.outstandingPutCount_--)
        }
        this.outstandingPutCount_ === 0 && (this.outstandingPuts_ = [])
    }
    onListenRevoked_(t, n) {
        let r;
        n ? r = n.map(i => pS(i)).join("$") : r = "default";
        const s = this.removeListen_(t, r);
        s && s.onComplete && s.onComplete("permission_denied")
    }
    removeListen_(t, n) {
        const r = new wt(t).toString();
        let s;
        if (this.listens.has(r)) {
            const i = this.listens.get(r);
            s = i.get(n), i.delete(n), i.size === 0 && this.listens.delete(r)
        } else s = void 0;
        return s
    }
    onAuthRevoked_(t, n) {
        Un("Auth token revoked: " + t + "/" + n), this.authToken_ = null, this.forceTokenRefresh_ = !0, this.realtime_.close(), (t === "invalid_token" || t === "permission_denied") && (this.invalidAuthTokenCount_++, this.invalidAuthTokenCount_ >= ZI && (this.reconnectDelay_ = JI, this.authTokenProvider_.notifyForInvalidToken()))
    }
    onAppCheckRevoked_(t, n) {
        Un("App check token revoked: " + t + "/" + n), this.appCheckToken_ = null, this.forceTokenRefresh_ = !0, (t === "invalid_token" || t === "permission_denied") && (this.invalidAppCheckTokenCount_++, this.invalidAppCheckTokenCount_ >= ZI && this.appCheckTokenProvider_.notifyForInvalidToken())
    }
    onSecurityDebugPacket_(t) {
        this.securityDebugCallback_ ? this.securityDebugCallback_(t) : "msg" in t && console.log("FIREBASE: " + t.msg.replace(`
`, `
FIREBASE: `))
    }
    restoreState_() {
        this.tryAuth(), this.tryAppCheck();
        for (const t of this.listens.values())
            for (const n of t.values()) this.sendListen_(n);
        for (let t = 0; t < this.outstandingPuts_.length; t++) this.outstandingPuts_[t] && this.sendPut_(t);
        for (; this.onDisconnectRequestQueue_.length;) {
            const t = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(t.action, t.pathString, t.data, t.onComplete)
        }
        for (let t = 0; t < this.outstandingGets_.length; t++) this.outstandingGets_[t] && this.sendGet_(t)
    }
    sendConnectStats_() {
        const t = {};
        let n = "js";
        t["sdk." + n + "." + bP.replace(/\./g, "-")] = 1, dS() ? t["framework.cordova"] = 1 : uP() && (t["framework.reactnative"] = 1), this.reportStats(t)
    }
    shouldReconnect_() {
        const t = Bg.getInstance().currentlyOnline();
        return Ew(this.interruptReasons_) && t
    }
}
ci.nextPersistentConnectionId_ = 0;
ci.nextConnectionId_ = 0;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Le {
    constructor(t, n) {
        this.name = t, this.node = n
    }
    static Wrap(t, n) {
        return new Le(t, n)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vy {
    getCompare() {
        return this.compare.bind(this)
    }
    indexedValueChanged(t, n) {
        const r = new Le(Zc, t),
            s = new Le(Zc, n);
        return this.compare(r, s) !== 0
    }
    minPost() {
        return Le.MIN
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Yp;
class KP extends Vy {
    static get __EMPTY_NODE() {
        return Yp
    }
    static set __EMPTY_NODE(t) {
        Yp = t
    }
    compare(t, n) {
        return Wu(t.name, n.name)
    }
    isDefinedOn(t) {
        throw Hu("KeyIndex.isDefinedOn not expected to be called.")
    }
    indexedValueChanged(t, n) {
        return !1
    }
    minPost() {
        return Le.MIN
    }
    maxPost() {
        return new Le(el, Yp)
    }
    makePost(t, n) {
        return X(typeof t == "string", "KeyIndex indexValue must always be a string."), new Le(t, Yp)
    }
    toString() {
        return ".key"
    }
}
const $c = new KP;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Kp {
    constructor(t, n, r, s, i = null) {
        this.isReverse_ = s, this.resultGenerator_ = i, this.nodeStack_ = [];
        let o = 1;
        for (; !t.isEmpty();)
            if (t = t, o = n ? r(t.key, n) : 1, s && (o *= -1), o < 0) this.isReverse_ ? t = t.left : t = t.right;
            else if (o === 0) {
            this.nodeStack_.push(t);
            break
        } else this.nodeStack_.push(t), this.isReverse_ ? t = t.right : t = t.left
    }
    getNext() {
        if (this.nodeStack_.length === 0) return null;
        let t = this.nodeStack_.pop(),
            n;
        if (this.resultGenerator_ ? n = this.resultGenerator_(t.key, t.value) : n = {
                key: t.key,
                value: t.value
            }, this.isReverse_)
            for (t = t.left; !t.isEmpty();) this.nodeStack_.push(t), t = t.right;
        else
            for (t = t.right; !t.isEmpty();) this.nodeStack_.push(t), t = t.left;
        return n
    }
    hasNext() {
        return this.nodeStack_.length > 0
    }
    peek() {
        if (this.nodeStack_.length === 0) return null;
        const t = this.nodeStack_[this.nodeStack_.length - 1];
        return this.resultGenerator_ ? this.resultGenerator_(t.key, t.value) : {
            key: t.key,
            value: t.value
        }
    }
}
class yn {
    constructor(t, n, r, s, i) {
        this.key = t, this.value = n, this.color = r != null ? r : yn.RED, this.left = s != null ? s : br.EMPTY_NODE, this.right = i != null ? i : br.EMPTY_NODE
    }
    copy(t, n, r, s, i) {
        return new yn(t != null ? t : this.key, n != null ? n : this.value, r != null ? r : this.color, s != null ? s : this.left, i != null ? i : this.right)
    }
    count() {
        return this.left.count() + 1 + this.right.count()
    }
    isEmpty() {
        return !1
    }
    inorderTraversal(t) {
        return this.left.inorderTraversal(t) || !!t(this.key, this.value) || this.right.inorderTraversal(t)
    }
    reverseTraversal(t) {
        return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t)
    }
    min_() {
        return this.left.isEmpty() ? this : this.left.min_()
    }
    minKey() {
        return this.min_().key
    }
    maxKey() {
        return this.right.isEmpty() ? this.key : this.right.maxKey()
    }
    insert(t, n, r) {
        let s = this;
        const i = r(t, s.key);
        return i < 0 ? s = s.copy(null, null, null, s.left.insert(t, n, r), null) : i === 0 ? s = s.copy(null, n, null, null, null) : s = s.copy(null, null, null, null, s.right.insert(t, n, r)), s.fixUp_()
    }
    removeMin_() {
        if (this.left.isEmpty()) return br.EMPTY_NODE;
        let t = this;
        return !t.left.isRed_() && !t.left.left.isRed_() && (t = t.moveRedLeft_()), t = t.copy(null, null, null, t.left.removeMin_(), null), t.fixUp_()
    }
    remove(t, n) {
        let r, s;
        if (r = this, n(t, r.key) < 0) !r.left.isEmpty() && !r.left.isRed_() && !r.left.left.isRed_() && (r = r.moveRedLeft_()), r = r.copy(null, null, null, r.left.remove(t, n), null);
        else {
            if (r.left.isRed_() && (r = r.rotateRight_()), !r.right.isEmpty() && !r.right.isRed_() && !r.right.left.isRed_() && (r = r.moveRedRight_()), n(t, r.key) === 0) {
                if (r.right.isEmpty()) return br.EMPTY_NODE;
                s = r.right.min_(), r = r.copy(s.key, s.value, null, null, r.right.removeMin_())
            }
            r = r.copy(null, null, null, null, r.right.remove(t, n))
        }
        return r.fixUp_()
    }
    isRed_() {
        return this.color
    }
    fixUp_() {
        let t = this;
        return t.right.isRed_() && !t.left.isRed_() && (t = t.rotateLeft_()), t.left.isRed_() && t.left.left.isRed_() && (t = t.rotateRight_()), t.left.isRed_() && t.right.isRed_() && (t = t.colorFlip_()), t
    }
    moveRedLeft_() {
        let t = this.colorFlip_();
        return t.right.left.isRed_() && (t = t.copy(null, null, null, null, t.right.rotateRight_()), t = t.rotateLeft_(), t = t.colorFlip_()), t
    }
    moveRedRight_() {
        let t = this.colorFlip_();
        return t.left.left.isRed_() && (t = t.rotateRight_(), t = t.colorFlip_()), t
    }
    rotateLeft_() {
        const t = this.copy(null, null, yn.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, t, null)
    }
    rotateRight_() {
        const t = this.copy(null, null, yn.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, t)
    }
    colorFlip_() {
        const t = this.left.copy(null, null, !this.left.color, null, null),
            n = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, t, n)
    }
    checkMaxDepth_() {
        const t = this.check_();
        return Math.pow(2, t) <= this.count() + 1
    }
    check_() {
        if (this.isRed_() && this.left.isRed_()) throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
        if (this.right.isRed_()) throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
        const t = this.left.check_();
        if (t !== this.right.check_()) throw new Error("Black depths differ");
        return t + (this.isRed_() ? 0 : 1)
    }
}
yn.RED = !0;
yn.BLACK = !1;
class H4 {
    copy(t, n, r, s, i) {
        return this
    }
    insert(t, n, r) {
        return new yn(t, n, null)
    }
    remove(t, n) {
        return this
    }
    count() {
        return 0
    }
    isEmpty() {
        return !0
    }
    inorderTraversal(t) {
        return !1
    }
    reverseTraversal(t) {
        return !1
    }
    minKey() {
        return null
    }
    maxKey() {
        return null
    }
    check_() {
        return 0
    }
    isRed_() {
        return !1
    }
}
class br {
    constructor(t, n = br.EMPTY_NODE) {
        this.comparator_ = t, this.root_ = n
    }
    insert(t, n) {
        return new br(this.comparator_, this.root_.insert(t, n, this.comparator_).copy(null, null, yn.BLACK, null, null))
    }
    remove(t) {
        return new br(this.comparator_, this.root_.remove(t, this.comparator_).copy(null, null, yn.BLACK, null, null))
    }
    get(t) {
        let n, r = this.root_;
        for (; !r.isEmpty();) {
            if (n = this.comparator_(t, r.key), n === 0) return r.value;
            n < 0 ? r = r.left : n > 0 && (r = r.right)
        }
        return null
    }
    getPredecessorKey(t) {
        let n, r = this.root_,
            s = null;
        for (; !r.isEmpty();)
            if (n = this.comparator_(t, r.key), n === 0) {
                if (r.left.isEmpty()) return s ? s.key : null;
                for (r = r.left; !r.right.isEmpty();) r = r.right;
                return r.key
            } else n < 0 ? r = r.left : n > 0 && (s = r, r = r.right);
        throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?")
    }
    isEmpty() {
        return this.root_.isEmpty()
    }
    count() {
        return this.root_.count()
    }
    minKey() {
        return this.root_.minKey()
    }
    maxKey() {
        return this.root_.maxKey()
    }
    inorderTraversal(t) {
        return this.root_.inorderTraversal(t)
    }
    reverseTraversal(t) {
        return this.root_.reverseTraversal(t)
    }
    getIterator(t) {
        return new Kp(this.root_, null, this.comparator_, !1, t)
    }
    getIteratorFrom(t, n) {
        return new Kp(this.root_, t, this.comparator_, !1, n)
    }
    getReverseIteratorFrom(t, n) {
        return new Kp(this.root_, t, this.comparator_, !0, n)
    }
    getReverseIterator(t) {
        return new Kp(this.root_, null, this.comparator_, !0, t)
    }
}
br.EMPTY_NODE = new H4;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function j4(e, t) {
    return Wu(e.name, t.name)
}

function vS(e, t) {
    return Wu(e, t)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Ow;

function z4(e) {
    Ow = e
}
const XP = function(e) {
        return typeof e == "number" ? "number:" + $P(e) : "string:" + e
    },
    QP = function(e) {
        if (e.isLeafNode()) {
            const t = e.val();
            X(typeof t == "string" || typeof t == "number" || typeof t == "object" && Pi(t, ".sv"), "Priority must be a string or number.")
        } else X(e === Ow || e.isEmpty(), "priority of unexpected type.");
        X(e === Ow || e.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.")
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let ex;
class gn {
    constructor(t, n = gn.__childrenNodeConstructor.EMPTY_NODE) {
        this.value_ = t, this.priorityNode_ = n, this.lazyHash_ = null, X(this.value_ !== void 0 && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value."), QP(this.priorityNode_)
    }
    static set __childrenNodeConstructor(t) {
        ex = t
    }
    static get __childrenNodeConstructor() {
        return ex
    }
    isLeafNode() {
        return !0
    }
    getPriority() {
        return this.priorityNode_
    }
    updatePriority(t) {
        return new gn(this.value_, t)
    }
    getImmediateChild(t) {
        return t === ".priority" ? this.priorityNode_ : gn.__childrenNodeConstructor.EMPTY_NODE
    }
    getChild(t) {
        return Be(t) ? this : He(t) === ".priority" ? this.priorityNode_ : gn.__childrenNodeConstructor.EMPTY_NODE
    }
    hasChild() {
        return !1
    }
    getPredecessorChildName(t, n) {
        return null
    }
    updateImmediateChild(t, n) {
        return t === ".priority" ? this.updatePriority(n) : n.isEmpty() && t !== ".priority" ? this : gn.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(t, n).updatePriority(this.priorityNode_)
    }
    updateChild(t, n) {
        const r = He(t);
        return r === null ? n : n.isEmpty() && r !== ".priority" ? this : (X(r !== ".priority" || Lo(t) === 1, ".priority must be the last token in a path"), this.updateImmediateChild(r, gn.__childrenNodeConstructor.EMPTY_NODE.updateChild(Tt(t), n)))
    }
    isEmpty() {
        return !1
    }
    numChildren() {
        return 0
    }
    forEachChild(t, n) {
        return !1
    }
    val(t) {
        return t && !this.getPriority().isEmpty() ? {
            ".value": this.getValue(),
            ".priority": this.getPriority().val()
        } : this.getValue()
    }
    hash() {
        if (this.lazyHash_ === null) {
            let t = "";
            this.priorityNode_.isEmpty() || (t += "priority:" + XP(this.priorityNode_.val()) + ":");
            const n = typeof this.value_;
            t += n + ":", n === "number" ? t += $P(this.value_) : t += this.value_, this.lazyHash_ = EP(t)
        }
        return this.lazyHash_
    }
    getValue() {
        return this.value_
    }
    compareTo(t) {
        return t === gn.__childrenNodeConstructor.EMPTY_NODE ? 1 : t instanceof gn.__childrenNodeConstructor ? -1 : (X(t.isLeafNode(), "Unknown node type"), this.compareToLeafNode_(t))
    }
    compareToLeafNode_(t) {
        const n = typeof t.value_,
            r = typeof this.value_,
            s = gn.VALUE_TYPE_ORDER.indexOf(n),
            i = gn.VALUE_TYPE_ORDER.indexOf(r);
        return X(s >= 0, "Unknown leaf type: " + n), X(i >= 0, "Unknown leaf type: " + r), s === i ? r === "object" ? 0 : this.value_ < t.value_ ? -1 : this.value_ === t.value_ ? 0 : 1 : i - s
    }
    withIndex() {
        return this
    }
    isIndexed() {
        return !0
    }
    equals(t) {
        if (t === this) return !0;
        if (t.isLeafNode()) {
            const n = t;
            return this.value_ === n.value_ && this.priorityNode_.equals(n.priorityNode_)
        } else return !1
    }
}
gn.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let JP, ZP;

function W4(e) {
    JP = e
}

function G4(e) {
    ZP = e
}
class q4 extends Vy {
    compare(t, n) {
        const r = t.node.getPriority(),
            s = n.node.getPriority(),
            i = r.compareTo(s);
        return i === 0 ? Wu(t.name, n.name) : i
    }
    isDefinedOn(t) {
        return !t.getPriority().isEmpty()
    }
    indexedValueChanged(t, n) {
        return !t.getPriority().equals(n.getPriority())
    }
    minPost() {
        return Le.MIN
    }
    maxPost() {
        return new Le(el, new gn("[PRIORITY-POST]", ZP))
    }
    makePost(t, n) {
        const r = JP(t);
        return new Le(n, new gn("[PRIORITY-POST]", r))
    }
    toString() {
        return ".priority"
    }
}
const jt = new q4;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Y4 = Math.log(2);
class K4 {
    constructor(t) {
        const n = i => parseInt(Math.log(i) / Y4, 10),
            r = i => parseInt(Array(i + 1).join("1"), 2);
        this.count = n(t + 1), this.current_ = this.count - 1;
        const s = r(this.count);
        this.bits_ = t + 1 & s
    }
    nextBitIsOne() {
        const t = !(this.bits_ & 1 << this.current_);
        return this.current_--, t
    }
}
const Vg = function(e, t, n, r) {
    e.sort(t);
    const s = function(l, c) {
            const u = c - l;
            let d, f;
            if (u === 0) return null;
            if (u === 1) return d = e[l], f = n ? n(d) : d, new yn(f, d.node, yn.BLACK, null, null); {
                const h = parseInt(u / 2, 10) + l,
                    p = s(l, h),
                    m = s(h + 1, c);
                return d = e[h], f = n ? n(d) : d, new yn(f, d.node, yn.BLACK, p, m)
            }
        },
        i = function(l) {
            let c = null,
                u = null,
                d = e.length;
            const f = function(p, m) {
                    const g = d - p,
                        y = d;
                    d -= p;
                    const _ = s(g + 1, y),
                        E = e[g],
                        b = n ? n(E) : E;
                    h(new yn(b, E.node, m, null, _))
                },
                h = function(p) {
                    c ? (c.left = p, c = p) : (u = p, c = p)
                };
            for (let p = 0; p < l.count; ++p) {
                const m = l.nextBitIsOne(),
                    g = Math.pow(2, l.count - (p + 1));
                m ? f(g, yn.BLACK) : (f(g, yn.BLACK), f(g, yn.RED))
            }
            return u
        },
        o = new K4(e.length),
        a = i(o);
    return new br(r || t, a)
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let qb;
const Yl = {};
class ii {
    constructor(t, n) {
        this.indexes_ = t, this.indexSet_ = n
    }
    static get Default() {
        return X(Yl && jt, "ChildrenNode.ts has not been loaded"), qb = qb || new ii({
            ".priority": Yl
        }, {
            ".priority": jt
        }), qb
    }
    get(t) {
        const n = Jc(this.indexes_, t);
        if (!n) throw new Error("No index defined for " + t);
        return n instanceof br ? n : null
    }
    hasIndex(t) {
        return Pi(this.indexSet_, t.toString())
    }
    addIndex(t, n) {
        X(t !== $c, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        const r = [];
        let s = !1;
        const i = n.getIterator(Le.Wrap);
        let o = i.getNext();
        for (; o;) s = s || t.isDefinedOn(o.node), r.push(o), o = i.getNext();
        let a;
        s ? a = Vg(r, t.getCompare()) : a = Yl;
        const l = t.toString(),
            c = Object.assign({}, this.indexSet_);
        c[l] = t;
        const u = Object.assign({}, this.indexes_);
        return u[l] = a, new ii(u, c)
    }
    addToIndexes(t, n) {
        const r = Fg(this.indexes_, (s, i) => {
            const o = Jc(this.indexSet_, i);
            if (X(o, "Missing index implementation for " + i), s === Yl)
                if (o.isDefinedOn(t.node)) {
                    const a = [],
                        l = n.getIterator(Le.Wrap);
                    let c = l.getNext();
                    for (; c;) c.name !== t.name && a.push(c), c = l.getNext();
                    return a.push(t), Vg(a, o.getCompare())
                } else return Yl;
            else {
                const a = n.get(t.name);
                let l = s;
                return a && (l = l.remove(new Le(t.name, a))), l.insert(t, t.node)
            }
        });
        return new ii(r, this.indexSet_)
    }
    removeFromIndexes(t, n) {
        const r = Fg(this.indexes_, s => {
            if (s === Yl) return s; {
                const i = n.get(t.name);
                return i ? s.remove(new Le(t.name, i)) : s
            }
        });
        return new ii(r, this.indexSet_)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let ud;
class Ee {
    constructor(t, n, r) {
        this.children_ = t, this.priorityNode_ = n, this.indexMap_ = r, this.lazyHash_ = null, this.priorityNode_ && QP(this.priorityNode_), this.children_.isEmpty() && X(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority")
    }
    static get EMPTY_NODE() {
        return ud || (ud = new Ee(new br(vS), null, ii.Default))
    }
    isLeafNode() {
        return !1
    }
    getPriority() {
        return this.priorityNode_ || ud
    }
    updatePriority(t) {
        return this.children_.isEmpty() ? this : new Ee(this.children_, t, this.indexMap_)
    }
    getImmediateChild(t) {
        if (t === ".priority") return this.getPriority(); {
            const n = this.children_.get(t);
            return n === null ? ud : n
        }
    }
    getChild(t) {
        const n = He(t);
        return n === null ? this : this.getImmediateChild(n).getChild(Tt(t))
    }
    hasChild(t) {
        return this.children_.get(t) !== null
    }
    updateImmediateChild(t, n) {
        if (X(n, "We should always be passing snapshot nodes"), t === ".priority") return this.updatePriority(n); {
            const r = new Le(t, n);
            let s, i;
            n.isEmpty() ? (s = this.children_.remove(t), i = this.indexMap_.removeFromIndexes(r, this.children_)) : (s = this.children_.insert(t, n), i = this.indexMap_.addToIndexes(r, this.children_));
            const o = s.isEmpty() ? ud : this.priorityNode_;
            return new Ee(s, o, i)
        }
    }
    updateChild(t, n) {
        const r = He(t);
        if (r === null) return n; {
            X(He(t) !== ".priority" || Lo(t) === 1, ".priority must be the last token in a path");
            const s = this.getImmediateChild(r).updateChild(Tt(t), n);
            return this.updateImmediateChild(r, s)
        }
    }
    isEmpty() {
        return this.children_.isEmpty()
    }
    numChildren() {
        return this.children_.count()
    }
    val(t) {
        if (this.isEmpty()) return null;
        const n = {};
        let r = 0,
            s = 0,
            i = !0;
        if (this.forEachChild(jt, (o, a) => {
                n[o] = a.val(t), r++, i && Ee.INTEGER_REGEXP_.test(o) ? s = Math.max(s, Number(o)) : i = !1
            }), !t && i && s < 2 * r) {
            const o = [];
            for (const a in n) o[a] = n[a];
            return o
        } else return t && !this.getPriority().isEmpty() && (n[".priority"] = this.getPriority().val()), n
    }
    hash() {
        if (this.lazyHash_ === null) {
            let t = "";
            this.getPriority().isEmpty() || (t += "priority:" + XP(this.getPriority().val()) + ":"), this.forEachChild(jt, (n, r) => {
                const s = r.hash();
                s !== "" && (t += ":" + n + ":" + s)
            }), this.lazyHash_ = t === "" ? "" : EP(t)
        }
        return this.lazyHash_
    }
    getPredecessorChildName(t, n, r) {
        const s = this.resolveIndex_(r);
        if (s) {
            const i = s.getPredecessorKey(new Le(t, n));
            return i ? i.name : null
        } else return this.children_.getPredecessorKey(t)
    }
    getFirstChildName(t) {
        const n = this.resolveIndex_(t);
        if (n) {
            const r = n.minKey();
            return r && r.name
        } else return this.children_.minKey()
    }
    getFirstChild(t) {
        const n = this.getFirstChildName(t);
        return n ? new Le(n, this.children_.get(n)) : null
    }
    getLastChildName(t) {
        const n = this.resolveIndex_(t);
        if (n) {
            const r = n.maxKey();
            return r && r.name
        } else return this.children_.maxKey()
    }
    getLastChild(t) {
        const n = this.getLastChildName(t);
        return n ? new Le(n, this.children_.get(n)) : null
    }
    forEachChild(t, n) {
        const r = this.resolveIndex_(t);
        return r ? r.inorderTraversal(s => n(s.name, s.node)) : this.children_.inorderTraversal(n)
    }
    getIterator(t) {
        return this.getIteratorFrom(t.minPost(), t)
    }
    getIteratorFrom(t, n) {
        const r = this.resolveIndex_(n);
        if (r) return r.getIteratorFrom(t, s => s); {
            const s = this.children_.getIteratorFrom(t.name, Le.Wrap);
            let i = s.peek();
            for (; i != null && n.compare(i, t) < 0;) s.getNext(), i = s.peek();
            return s
        }
    }
    getReverseIterator(t) {
        return this.getReverseIteratorFrom(t.maxPost(), t)
    }
    getReverseIteratorFrom(t, n) {
        const r = this.resolveIndex_(n);
        if (r) return r.getReverseIteratorFrom(t, s => s); {
            const s = this.children_.getReverseIteratorFrom(t.name, Le.Wrap);
            let i = s.peek();
            for (; i != null && n.compare(i, t) > 0;) s.getNext(), i = s.peek();
            return s
        }
    }
    compareTo(t) {
        return this.isEmpty() ? t.isEmpty() ? 0 : -1 : t.isLeafNode() || t.isEmpty() ? 1 : t === Qh ? -1 : 0
    }
    withIndex(t) {
        if (t === $c || this.indexMap_.hasIndex(t)) return this; {
            const n = this.indexMap_.addIndex(t, this.children_);
            return new Ee(this.children_, this.priorityNode_, n)
        }
    }
    isIndexed(t) {
        return t === $c || this.indexMap_.hasIndex(t)
    }
    equals(t) {
        if (t === this) return !0;
        if (t.isLeafNode()) return !1; {
            const n = t;
            if (this.getPriority().equals(n.getPriority()))
                if (this.children_.count() === n.children_.count()) {
                    const r = this.getIterator(jt),
                        s = n.getIterator(jt);
                    let i = r.getNext(),
                        o = s.getNext();
                    for (; i && o;) {
                        if (i.name !== o.name || !i.node.equals(o.node)) return !1;
                        i = r.getNext(), o = s.getNext()
                    }
                    return i === null && o === null
                } else return !1;
            else return !1
        }
    }
    resolveIndex_(t) {
        return t === $c ? null : this.indexMap_.get(t.toString())
    }
}
Ee.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
class X4 extends Ee {
    constructor() {
        super(new br(vS), Ee.EMPTY_NODE, ii.Default)
    }
    compareTo(t) {
        return t === this ? 0 : 1
    }
    equals(t) {
        return t === this
    }
    getPriority() {
        return this
    }
    getImmediateChild(t) {
        return Ee.EMPTY_NODE
    }
    isEmpty() {
        return !1
    }
}
const Qh = new X4;
Object.defineProperties(Le, {
    MIN: {
        value: new Le(Zc, Ee.EMPTY_NODE)
    },
    MAX: {
        value: new Le(el, Qh)
    }
});
KP.__EMPTY_NODE = Ee.EMPTY_NODE;
gn.__childrenNodeConstructor = Ee;
z4(Qh);
G4(Qh);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Q4 = !0;

function bn(e, t = null) {
    if (e === null) return Ee.EMPTY_NODE;
    if (typeof e == "object" && ".priority" in e && (t = e[".priority"]), X(t === null || typeof t == "string" || typeof t == "number" || typeof t == "object" && ".sv" in t, "Invalid priority type found: " + typeof t), typeof e == "object" && ".value" in e && e[".value"] !== null && (e = e[".value"]), typeof e != "object" || ".sv" in e) {
        const n = e;
        return new gn(n, bn(t))
    }
    if (!(e instanceof Array) && Q4) {
        const n = [];
        let r = !1;
        if (kr(e, (o, a) => {
                if (o.substring(0, 1) !== ".") {
                    const l = bn(a);
                    l.isEmpty() || (r = r || !l.getPriority().isEmpty(), n.push(new Le(o, l)))
                }
            }), n.length === 0) return Ee.EMPTY_NODE;
        const i = Vg(n, j4, o => o.name, vS);
        if (r) {
            const o = Vg(n, jt.getCompare());
            return new Ee(i, bn(t), new ii({
                ".priority": o
            }, {
                ".priority": jt
            }))
        } else return new Ee(i, bn(t), ii.Default)
    } else {
        let n = Ee.EMPTY_NODE;
        return kr(e, (r, s) => {
            if (Pi(e, r) && r.substring(0, 1) !== ".") {
                const i = bn(s);
                (i.isLeafNode() || !i.isEmpty()) && (n = n.updateImmediateChild(r, i))
            }
        }), n.updatePriority(bn(t))
    }
}
W4(bn);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class J4 extends Vy {
    constructor(t) {
        super(), this.indexPath_ = t, X(!Be(t) && He(t) !== ".priority", "Can't create PathIndex with empty path or .priority key")
    }
    extractChild(t) {
        return t.getChild(this.indexPath_)
    }
    isDefinedOn(t) {
        return !t.getChild(this.indexPath_).isEmpty()
    }
    compare(t, n) {
        const r = this.extractChild(t.node),
            s = this.extractChild(n.node),
            i = r.compareTo(s);
        return i === 0 ? Wu(t.name, n.name) : i
    }
    makePost(t, n) {
        const r = bn(t),
            s = Ee.EMPTY_NODE.updateChild(this.indexPath_, r);
        return new Le(n, s)
    }
    maxPost() {
        const t = Ee.EMPTY_NODE.updateChild(this.indexPath_, Qh);
        return new Le(el, t)
    }
    toString() {
        return WP(this.indexPath_, 0).join("/")
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Z4 extends Vy {
    compare(t, n) {
        const r = t.node.compareTo(n.node);
        return r === 0 ? Wu(t.name, n.name) : r
    }
    isDefinedOn(t) {
        return !0
    }
    indexedValueChanged(t, n) {
        return !t.equals(n)
    }
    minPost() {
        return Le.MIN
    }
    maxPost() {
        return Le.MAX
    }
    makePost(t, n) {
        const r = bn(t);
        return new Le(n, r)
    }
    toString() {
        return ".value"
    }
}
const eW = new Z4;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function eM(e) {
    return {
        type: "value",
        snapshotNode: e
    }
}

function eu(e, t) {
    return {
        type: "child_added",
        snapshotNode: t,
        childName: e
    }
}

function Vf(e, t) {
    return {
        type: "child_removed",
        snapshotNode: t,
        childName: e
    }
}

function Hf(e, t, n) {
    return {
        type: "child_changed",
        snapshotNode: t,
        childName: e,
        oldSnap: n
    }
}

function tW(e, t) {
    return {
        type: "child_moved",
        snapshotNode: t,
        childName: e
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bS {
    constructor(t) {
        this.index_ = t
    }
    updateChild(t, n, r, s, i, o) {
        X(t.isIndexed(this.index_), "A node must be indexed if only a child is updated");
        const a = t.getImmediateChild(n);
        return a.getChild(s).equals(r.getChild(s)) && a.isEmpty() === r.isEmpty() || (o != null && (r.isEmpty() ? t.hasChild(n) ? o.trackChildChange(Vf(n, a)) : X(t.isLeafNode(), "A child remove without an old child only makes sense on a leaf node") : a.isEmpty() ? o.trackChildChange(eu(n, r)) : o.trackChildChange(Hf(n, r, a))), t.isLeafNode() && r.isEmpty()) ? t : t.updateImmediateChild(n, r).withIndex(this.index_)
    }
    updateFullNode(t, n, r) {
        return r != null && (t.isLeafNode() || t.forEachChild(jt, (s, i) => {
            n.hasChild(s) || r.trackChildChange(Vf(s, i))
        }), n.isLeafNode() || n.forEachChild(jt, (s, i) => {
            if (t.hasChild(s)) {
                const o = t.getImmediateChild(s);
                o.equals(i) || r.trackChildChange(Hf(s, i, o))
            } else r.trackChildChange(eu(s, i))
        })), n.withIndex(this.index_)
    }
    updatePriority(t, n) {
        return t.isEmpty() ? Ee.EMPTY_NODE : t.updatePriority(n)
    }
    filtersNodes() {
        return !1
    }
    getIndexedFilter() {
        return this
    }
    getIndex() {
        return this.index_
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jf {
    constructor(t) {
        this.indexedFilter_ = new bS(t.getIndex()), this.index_ = t.getIndex(), this.startPost_ = jf.getStartPost_(t), this.endPost_ = jf.getEndPost_(t), this.startIsInclusive_ = !t.startAfterSet_, this.endIsInclusive_ = !t.endBeforeSet_
    }
    getStartPost() {
        return this.startPost_
    }
    getEndPost() {
        return this.endPost_
    }
    matches(t) {
        const n = this.startIsInclusive_ ? this.index_.compare(this.getStartPost(), t) <= 0 : this.index_.compare(this.getStartPost(), t) < 0,
            r = this.endIsInclusive_ ? this.index_.compare(t, this.getEndPost()) <= 0 : this.index_.compare(t, this.getEndPost()) < 0;
        return n && r
    }
    updateChild(t, n, r, s, i, o) {
        return this.matches(new Le(n, r)) || (r = Ee.EMPTY_NODE), this.indexedFilter_.updateChild(t, n, r, s, i, o)
    }
    updateFullNode(t, n, r) {
        n.isLeafNode() && (n = Ee.EMPTY_NODE);
        let s = n.withIndex(this.index_);
        s = s.updatePriority(Ee.EMPTY_NODE);
        const i = this;
        return n.forEachChild(jt, (o, a) => {
            i.matches(new Le(o, a)) || (s = s.updateImmediateChild(o, Ee.EMPTY_NODE))
        }), this.indexedFilter_.updateFullNode(t, s, r)
    }
    updatePriority(t, n) {
        return t
    }
    filtersNodes() {
        return !0
    }
    getIndexedFilter() {
        return this.indexedFilter_
    }
    getIndex() {
        return this.index_
    }
    static getStartPost_(t) {
        if (t.hasStart()) {
            const n = t.getIndexStartName();
            return t.getIndex().makePost(t.getIndexStartValue(), n)
        } else return t.getIndex().minPost()
    }
    static getEndPost_(t) {
        if (t.hasEnd()) {
            const n = t.getIndexEndName();
            return t.getIndex().makePost(t.getIndexEndValue(), n)
        } else return t.getIndex().maxPost()
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nW {
    constructor(t) {
        this.withinDirectionalStart = n => this.reverse_ ? this.withinEndPost(n) : this.withinStartPost(n), this.withinDirectionalEnd = n => this.reverse_ ? this.withinStartPost(n) : this.withinEndPost(n), this.withinStartPost = n => {
            const r = this.index_.compare(this.rangedFilter_.getStartPost(), n);
            return this.startIsInclusive_ ? r <= 0 : r < 0
        }, this.withinEndPost = n => {
            const r = this.index_.compare(n, this.rangedFilter_.getEndPost());
            return this.endIsInclusive_ ? r <= 0 : r < 0
        }, this.rangedFilter_ = new jf(t), this.index_ = t.getIndex(), this.limit_ = t.getLimit(), this.reverse_ = !t.isViewFromLeft(), this.startIsInclusive_ = !t.startAfterSet_, this.endIsInclusive_ = !t.endBeforeSet_
    }
    updateChild(t, n, r, s, i, o) {
        return this.rangedFilter_.matches(new Le(n, r)) || (r = Ee.EMPTY_NODE), t.getImmediateChild(n).equals(r) ? t : t.numChildren() < this.limit_ ? this.rangedFilter_.getIndexedFilter().updateChild(t, n, r, s, i, o) : this.fullLimitUpdateChild_(t, n, r, i, o)
    }
    updateFullNode(t, n, r) {
        let s;
        if (n.isLeafNode() || n.isEmpty()) s = Ee.EMPTY_NODE.withIndex(this.index_);
        else if (this.limit_ * 2 < n.numChildren() && n.isIndexed(this.index_)) {
            s = Ee.EMPTY_NODE.withIndex(this.index_);
            let i;
            this.reverse_ ? i = n.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_) : i = n.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
            let o = 0;
            for (; i.hasNext() && o < this.limit_;) {
                const a = i.getNext();
                if (this.withinDirectionalStart(a))
                    if (this.withinDirectionalEnd(a)) s = s.updateImmediateChild(a.name, a.node), o++;
                    else break;
                else continue
            }
        } else {
            s = n.withIndex(this.index_), s = s.updatePriority(Ee.EMPTY_NODE);
            let i;
            this.reverse_ ? i = s.getReverseIterator(this.index_) : i = s.getIterator(this.index_);
            let o = 0;
            for (; i.hasNext();) {
                const a = i.getNext();
                o < this.limit_ && this.withinDirectionalStart(a) && this.withinDirectionalEnd(a) ? o++ : s = s.updateImmediateChild(a.name, Ee.EMPTY_NODE)
            }
        }
        return this.rangedFilter_.getIndexedFilter().updateFullNode(t, s, r)
    }
    updatePriority(t, n) {
        return t
    }
    filtersNodes() {
        return !0
    }
    getIndexedFilter() {
        return this.rangedFilter_.getIndexedFilter()
    }
    getIndex() {
        return this.index_
    }
    fullLimitUpdateChild_(t, n, r, s, i) {
        let o;
        if (this.reverse_) {
            const d = this.index_.getCompare();
            o = (f, h) => d(h, f)
        } else o = this.index_.getCompare();
        const a = t;
        X(a.numChildren() === this.limit_, "");
        const l = new Le(n, r),
            c = this.reverse_ ? a.getFirstChild(this.index_) : a.getLastChild(this.index_),
            u = this.rangedFilter_.matches(l);
        if (a.hasChild(n)) {
            const d = a.getImmediateChild(n);
            let f = s.getChildAfterChild(this.index_, c, this.reverse_);
            for (; f != null && (f.name === n || a.hasChild(f.name));) f = s.getChildAfterChild(this.index_, f, this.reverse_);
            const h = f == null ? 1 : o(f, l);
            if (u && !r.isEmpty() && h >= 0) return i != null && i.trackChildChange(Hf(n, r, d)), a.updateImmediateChild(n, r); {
                i != null && i.trackChildChange(Vf(n, d));
                const m = a.updateImmediateChild(n, Ee.EMPTY_NODE);
                return f != null && this.rangedFilter_.matches(f) ? (i != null && i.trackChildChange(eu(f.name, f.node)), m.updateImmediateChild(f.name, f.node)) : m
            }
        } else return r.isEmpty() ? t : u && o(c, l) >= 0 ? (i != null && (i.trackChildChange(Vf(c.name, c.node)), i.trackChildChange(eu(n, r))), a.updateImmediateChild(n, r).updateImmediateChild(c.name, Ee.EMPTY_NODE)) : t
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wS {
    constructor() {
        this.limitSet_ = !1, this.startSet_ = !1, this.startNameSet_ = !1, this.startAfterSet_ = !1, this.endSet_ = !1, this.endNameSet_ = !1, this.endBeforeSet_ = !1, this.limit_ = 0, this.viewFrom_ = "", this.indexStartValue_ = null, this.indexStartName_ = "", this.indexEndValue_ = null, this.indexEndName_ = "", this.index_ = jt
    }
    hasStart() {
        return this.startSet_
    }
    isViewFromLeft() {
        return this.viewFrom_ === "" ? this.startSet_ : this.viewFrom_ === "l"
    }
    getIndexStartValue() {
        return X(this.startSet_, "Only valid if start has been set"), this.indexStartValue_
    }
    getIndexStartName() {
        return X(this.startSet_, "Only valid if start has been set"), this.startNameSet_ ? this.indexStartName_ : Zc
    }
    hasEnd() {
        return this.endSet_
    }
    getIndexEndValue() {
        return X(this.endSet_, "Only valid if end has been set"), this.indexEndValue_
    }
    getIndexEndName() {
        return X(this.endSet_, "Only valid if end has been set"), this.endNameSet_ ? this.indexEndName_ : el
    }
    hasLimit() {
        return this.limitSet_
    }
    hasAnchoredLimit() {
        return this.limitSet_ && this.viewFrom_ !== ""
    }
    getLimit() {
        return X(this.limitSet_, "Only valid if limit has been set"), this.limit_
    }
    getIndex() {
        return this.index_
    }
    loadsAllData() {
        return !(this.startSet_ || this.endSet_ || this.limitSet_)
    }
    isDefault() {
        return this.loadsAllData() && this.index_ === jt
    }
    copy() {
        const t = new wS;
        return t.limitSet_ = this.limitSet_, t.limit_ = this.limit_, t.startSet_ = this.startSet_, t.startAfterSet_ = this.startAfterSet_, t.indexStartValue_ = this.indexStartValue_, t.startNameSet_ = this.startNameSet_, t.indexStartName_ = this.indexStartName_, t.endSet_ = this.endSet_, t.endBeforeSet_ = this.endBeforeSet_, t.indexEndValue_ = this.indexEndValue_, t.endNameSet_ = this.endNameSet_, t.indexEndName_ = this.indexEndName_, t.index_ = this.index_, t.viewFrom_ = this.viewFrom_, t
    }
}

function rW(e) {
    return e.loadsAllData() ? new bS(e.getIndex()) : e.hasLimit() ? new nW(e) : new jf(e)
}

function tx(e) {
    const t = {};
    if (e.isDefault()) return t;
    let n;
    if (e.index_ === jt ? n = "$priority" : e.index_ === eW ? n = "$value" : e.index_ === $c ? n = "$key" : (X(e.index_ instanceof J4, "Unrecognized index type!"), n = e.index_.toString()), t.orderBy = rn(n), e.startSet_) {
        const r = e.startAfterSet_ ? "startAfter" : "startAt";
        t[r] = rn(e.indexStartValue_), e.startNameSet_ && (t[r] += "," + rn(e.indexStartName_))
    }
    if (e.endSet_) {
        const r = e.endBeforeSet_ ? "endBefore" : "endAt";
        t[r] = rn(e.indexEndValue_), e.endNameSet_ && (t[r] += "," + rn(e.indexEndName_))
    }
    return e.limitSet_ && (e.isViewFromLeft() ? t.limitToFirst = e.limit_ : t.limitToLast = e.limit_), t
}

function nx(e) {
    const t = {};
    if (e.startSet_ && (t.sp = e.indexStartValue_, e.startNameSet_ && (t.sn = e.indexStartName_), t.sin = !e.startAfterSet_), e.endSet_ && (t.ep = e.indexEndValue_, e.endNameSet_ && (t.en = e.indexEndName_), t.ein = !e.endBeforeSet_), e.limitSet_) {
        t.l = e.limit_;
        let n = e.viewFrom_;
        n === "" && (e.isViewFromLeft() ? n = "l" : n = "r"), t.vf = n
    }
    return e.index_ !== jt && (t.i = e.index_.toString()), t
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Hg extends HP {
    constructor(t, n, r, s) {
        super(), this.repoInfo_ = t, this.onDataUpdate_ = n, this.authTokenProvider_ = r, this.appCheckTokenProvider_ = s, this.log_ = Xh("p:rest:"), this.listens_ = {}
    }
    reportStats(t) {
        throw new Error("Method not implemented.")
    }
    static getListenId_(t, n) {
        return n !== void 0 ? "tag$" + n : (X(t._queryParams.isDefault(), "should have a tag if it's not a default query."), t._path.toString())
    }
    listen(t, n, r, s) {
        const i = t._path.toString();
        this.log_("Listen called for " + i + " " + t._queryIdentifier);
        const o = Hg.getListenId_(t, r),
            a = {};
        this.listens_[o] = a;
        const l = tx(t._queryParams);
        this.restRequest_(i + ".json", l, (c, u) => {
            let d = u;
            if (c === 404 && (d = null, c = null), c === null && this.onDataUpdate_(i, d, !1, r), Jc(this.listens_, o) === a) {
                let f;
                c ? c === 401 ? f = "permission_denied" : f = "rest_error:" + c : f = "ok", s(f, null)
            }
        })
    }
    unlisten(t, n) {
        const r = Hg.getListenId_(t, n);
        delete this.listens_[r]
    }
    get(t) {
        const n = tx(t._queryParams),
            r = t._path.toString(),
            s = new Mo;
        return this.restRequest_(r + ".json", n, (i, o) => {
            let a = o;
            i === 404 && (a = null, i = null), i === null ? (this.onDataUpdate_(r, a, !1, null), s.resolve(a)) : s.reject(new Error(a))
        }), s.promise
    }
    refreshAuthToken(t) {}
    restRequest_(t, n = {}, r) {
        return n.format = "export", Promise.all([this.authTokenProvider_.getToken(!1), this.appCheckTokenProvider_.getToken(!1)]).then(([s, i]) => {
            s && s.accessToken && (n.auth = s.accessToken), i && i.token && (n.ac = i.token);
            const o = (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host + t + "?ns=" + this.repoInfo_.namespace + ju(n);
            this.log_("Sending REST request for " + o);
            const a = new XMLHttpRequest;
            a.onreadystatechange = () => {
                if (r && a.readyState === 4) {
                    this.log_("REST Response for " + o + " received. status:", a.status, "response:", a.responseText);
                    let l = null;
                    if (a.status >= 200 && a.status < 300) {
                        try {
                            l = Mf(a.responseText)
                        } catch {
                            Sr("Failed to parse JSON response for " + o + ": " + a.responseText)
                        }
                        r(null, l)
                    } else a.status !== 401 && a.status !== 404 && Sr("Got unsuccessful REST response for " + o + " Status: " + a.status), r(a.status);
                    r = null
                }
            }, a.open("GET", o, !0), a.send()
        })
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sW {
    constructor() {
        this.rootNode_ = Ee.EMPTY_NODE
    }
    getNode(t) {
        return this.rootNode_.getChild(t)
    }
    updateSnapshot(t, n) {
        this.rootNode_ = this.rootNode_.updateChild(t, n)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jg() {
    return {
        value: null,
        children: new Map
    }
}

function tM(e, t, n) {
    if (Be(t)) e.value = n, e.children.clear();
    else if (e.value !== null) e.value = e.value.updateChild(t, n);
    else {
        const r = He(t);
        e.children.has(r) || e.children.set(r, jg());
        const s = e.children.get(r);
        t = Tt(t), tM(s, t, n)
    }
}

function Dw(e, t, n) {
    e.value !== null ? n(t, e.value) : iW(e, (r, s) => {
        const i = new wt(t.toString() + "/" + r);
        Dw(s, i, n)
    })
}

function iW(e, t) {
    e.children.forEach((n, r) => {
        t(r, n)
    })
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oW {
    constructor(t) {
        this.collection_ = t, this.last_ = null
    }
    get() {
        const t = this.collection_.get(),
            n = Object.assign({}, t);
        return this.last_ && kr(this.last_, (r, s) => {
            n[r] = n[r] - s
        }), this.last_ = t, n
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const rx = 10 * 1e3,
    aW = 30 * 1e3,
    lW = 5 * 60 * 1e3;
class cW {
    constructor(t, n) {
        this.server_ = n, this.statsToReport_ = {}, this.statsListener_ = new oW(t);
        const r = rx + (aW - rx) * Math.random();
        Gd(this.reportStats_.bind(this), Math.floor(r))
    }
    reportStats_() {
        const t = this.statsListener_.get(),
            n = {};
        let r = !1;
        kr(t, (s, i) => {
            i > 0 && Pi(this.statsToReport_, s) && (n[s] = i, r = !0)
        }), r && this.server_.reportStats(n), Gd(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * lW))
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var is;
(function(e) {
    e[e.OVERWRITE = 0] = "OVERWRITE", e[e.MERGE = 1] = "MERGE", e[e.ACK_USER_WRITE = 2] = "ACK_USER_WRITE", e[e.LISTEN_COMPLETE = 3] = "LISTEN_COMPLETE"
})(is || (is = {}));

function nM() {
    return {
        fromUser: !0,
        fromServer: !1,
        queryId: null,
        tagged: !1
    }
}

function ES() {
    return {
        fromUser: !1,
        fromServer: !0,
        queryId: null,
        tagged: !1
    }
}

function SS(e) {
    return {
        fromUser: !1,
        fromServer: !0,
        queryId: e,
        tagged: !0
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zg {
    constructor(t, n, r) {
        this.path = t, this.affectedTree = n, this.revert = r, this.type = is.ACK_USER_WRITE, this.source = nM()
    }
    operationForChild(t) {
        if (Be(this.path)) {
            if (this.affectedTree.value != null) return X(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths."), this; {
                const n = this.affectedTree.subtree(new wt(t));
                return new zg(nt(), n, this.revert)
            }
        } else return X(He(this.path) === t, "operationForChild called for unrelated child."), new zg(Tt(this.path), this.affectedTree, this.revert)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zf {
    constructor(t, n) {
        this.source = t, this.path = n, this.type = is.LISTEN_COMPLETE
    }
    operationForChild(t) {
        return Be(this.path) ? new zf(this.source, nt()) : new zf(this.source, Tt(this.path))
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class tl {
    constructor(t, n, r) {
        this.source = t, this.path = n, this.snap = r, this.type = is.OVERWRITE
    }
    operationForChild(t) {
        return Be(this.path) ? new tl(this.source, nt(), this.snap.getImmediateChild(t)) : new tl(this.source, Tt(this.path), this.snap)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Wf {
    constructor(t, n, r) {
        this.source = t, this.path = n, this.children = r, this.type = is.MERGE
    }
    operationForChild(t) {
        if (Be(this.path)) {
            const n = this.children.subtree(new wt(t));
            return n.isEmpty() ? null : n.value ? new tl(this.source, nt(), n.value) : new Wf(this.source, nt(), n)
        } else return X(He(this.path) === t, "Can't get a merge for a child not on the path of the operation"), new Wf(this.source, Tt(this.path), this.children)
    }
    toString() {
        return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")"
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fo {
    constructor(t, n, r) {
        this.node_ = t, this.fullyInitialized_ = n, this.filtered_ = r
    }
    isFullyInitialized() {
        return this.fullyInitialized_
    }
    isFiltered() {
        return this.filtered_
    }
    isCompleteForPath(t) {
        if (Be(t)) return this.isFullyInitialized() && !this.filtered_;
        const n = He(t);
        return this.isCompleteForChild(n)
    }
    isCompleteForChild(t) {
        return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(t)
    }
    getNode() {
        return this.node_
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uW {
    constructor(t) {
        this.query_ = t, this.index_ = this.query_._queryParams.getIndex()
    }
}

function dW(e, t, n, r) {
    const s = [],
        i = [];
    return t.forEach(o => {
        o.type === "child_changed" && e.index_.indexedValueChanged(o.oldSnap, o.snapshotNode) && i.push(tW(o.childName, o.snapshotNode))
    }), dd(e, s, "child_removed", t, r, n), dd(e, s, "child_added", t, r, n), dd(e, s, "child_moved", i, r, n), dd(e, s, "child_changed", t, r, n), dd(e, s, "value", t, r, n), s
}

function dd(e, t, n, r, s, i) {
    const o = r.filter(a => a.type === n);
    o.sort((a, l) => hW(e, a, l)), o.forEach(a => {
        const l = fW(e, a, i);
        s.forEach(c => {
            c.respondsTo(a.type) && t.push(c.createEvent(l, e.query_))
        })
    })
}

function fW(e, t, n) {
    return t.type === "value" || t.type === "child_removed" || (t.prevName = n.getPredecessorChildName(t.childName, t.snapshotNode, e.index_)), t
}

function hW(e, t, n) {
    if (t.childName == null || n.childName == null) throw Hu("Should only compare child_ events.");
    const r = new Le(t.childName, t.snapshotNode),
        s = new Le(n.childName, n.snapshotNode);
    return e.index_.compare(r, s)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Hy(e, t) {
    return {
        eventCache: e,
        serverCache: t
    }
}

function qd(e, t, n, r) {
    return Hy(new Fo(t, n, r), e.serverCache)
}

function rM(e, t, n, r) {
    return Hy(e.eventCache, new Fo(t, n, r))
}

function Wg(e) {
    return e.eventCache.isFullyInitialized() ? e.eventCache.getNode() : null
}

function nl(e) {
    return e.serverCache.isFullyInitialized() ? e.serverCache.getNode() : null
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Yb;
const pW = () => (Yb || (Yb = new br(Z6)), Yb);
class It {
    constructor(t, n = pW()) {
        this.value = t, this.children = n
    }
    static fromObject(t) {
        let n = new It(null);
        return kr(t, (r, s) => {
            n = n.set(new wt(r), s)
        }), n
    }
    isEmpty() {
        return this.value === null && this.children.isEmpty()
    }
    findRootMostMatchingPathAndValue(t, n) {
        if (this.value != null && n(this.value)) return {
            path: nt(),
            value: this.value
        };
        if (Be(t)) return null; {
            const r = He(t),
                s = this.children.get(r);
            if (s !== null) {
                const i = s.findRootMostMatchingPathAndValue(Tt(t), n);
                return i != null ? {
                    path: sn(new wt(r), i.path),
                    value: i.value
                } : null
            } else return null
        }
    }
    findRootMostValueAndPath(t) {
        return this.findRootMostMatchingPathAndValue(t, () => !0)
    }
    subtree(t) {
        if (Be(t)) return this; {
            const n = He(t),
                r = this.children.get(n);
            return r !== null ? r.subtree(Tt(t)) : new It(null)
        }
    }
    set(t, n) {
        if (Be(t)) return new It(n, this.children); {
            const r = He(t),
                i = (this.children.get(r) || new It(null)).set(Tt(t), n),
                o = this.children.insert(r, i);
            return new It(this.value, o)
        }
    }
    remove(t) {
        if (Be(t)) return this.children.isEmpty() ? new It(null) : new It(null, this.children); {
            const n = He(t),
                r = this.children.get(n);
            if (r) {
                const s = r.remove(Tt(t));
                let i;
                return s.isEmpty() ? i = this.children.remove(n) : i = this.children.insert(n, s), this.value === null && i.isEmpty() ? new It(null) : new It(this.value, i)
            } else return this
        }
    }
    get(t) {
        if (Be(t)) return this.value; {
            const n = He(t),
                r = this.children.get(n);
            return r ? r.get(Tt(t)) : null
        }
    }
    setTree(t, n) {
        if (Be(t)) return n; {
            const r = He(t),
                i = (this.children.get(r) || new It(null)).setTree(Tt(t), n);
            let o;
            return i.isEmpty() ? o = this.children.remove(r) : o = this.children.insert(r, i), new It(this.value, o)
        }
    }
    fold(t) {
        return this.fold_(nt(), t)
    }
    fold_(t, n) {
        const r = {};
        return this.children.inorderTraversal((s, i) => {
            r[s] = i.fold_(sn(t, s), n)
        }), n(t, this.value, r)
    }
    findOnPath(t, n) {
        return this.findOnPath_(t, nt(), n)
    }
    findOnPath_(t, n, r) {
        const s = this.value ? r(n, this.value) : !1;
        if (s) return s;
        if (Be(t)) return null; {
            const i = He(t),
                o = this.children.get(i);
            return o ? o.findOnPath_(Tt(t), sn(n, i), r) : null
        }
    }
    foreachOnPath(t, n) {
        return this.foreachOnPath_(t, nt(), n)
    }
    foreachOnPath_(t, n, r) {
        if (Be(t)) return this; {
            this.value && r(n, this.value);
            const s = He(t),
                i = this.children.get(s);
            return i ? i.foreachOnPath_(Tt(t), sn(n, s), r) : new It(null)
        }
    }
    foreach(t) {
        this.foreach_(nt(), t)
    }
    foreach_(t, n) {
        this.children.inorderTraversal((r, s) => {
            s.foreach_(sn(t, r), n)
        }), this.value && n(t, this.value)
    }
    foreachChild(t) {
        this.children.inorderTraversal((n, r) => {
            r.value && t(n, r.value)
        })
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ds {
    constructor(t) {
        this.writeTree_ = t
    }
    static empty() {
        return new ds(new It(null))
    }
}

function Yd(e, t, n) {
    if (Be(t)) return new ds(new It(n)); {
        const r = e.writeTree_.findRootMostValueAndPath(t);
        if (r != null) {
            const s = r.path;
            let i = r.value;
            const o = or(s, t);
            return i = i.updateChild(o, n), new ds(e.writeTree_.set(s, i))
        } else {
            const s = new It(n),
                i = e.writeTree_.setTree(t, s);
            return new ds(i)
        }
    }
}

function sx(e, t, n) {
    let r = e;
    return kr(n, (s, i) => {
        r = Yd(r, sn(t, s), i)
    }), r
}

function ix(e, t) {
    if (Be(t)) return ds.empty(); {
        const n = e.writeTree_.setTree(t, new It(null));
        return new ds(n)
    }
}

function Nw(e, t) {
    return xl(e, t) != null
}

function xl(e, t) {
    const n = e.writeTree_.findRootMostValueAndPath(t);
    return n != null ? e.writeTree_.get(n.path).getChild(or(n.path, t)) : null
}

function ox(e) {
    const t = [],
        n = e.writeTree_.value;
    return n != null ? n.isLeafNode() || n.forEachChild(jt, (r, s) => {
        t.push(new Le(r, s))
    }) : e.writeTree_.children.inorderTraversal((r, s) => {
        s.value != null && t.push(new Le(r, s.value))
    }), t
}

function Io(e, t) {
    if (Be(t)) return e; {
        const n = xl(e, t);
        return n != null ? new ds(new It(n)) : new ds(e.writeTree_.subtree(t))
    }
}

function Pw(e) {
    return e.writeTree_.isEmpty()
}

function tu(e, t) {
    return sM(nt(), e.writeTree_, t)
}

function sM(e, t, n) {
    if (t.value != null) return n.updateChild(e, t.value); {
        let r = null;
        return t.children.inorderTraversal((s, i) => {
            s === ".priority" ? (X(i.value !== null, "Priority writes must always be leaf nodes"), r = i.value) : n = sM(sn(e, s), i, n)
        }), !n.getChild(e).isEmpty() && r !== null && (n = n.updateChild(sn(e, ".priority"), r)), n
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jy(e, t) {
    return lM(t, e)
}

function mW(e, t, n, r, s) {
    X(r > e.lastWriteId, "Stacking an older write on top of newer ones"), s === void 0 && (s = !0), e.allWrites.push({
        path: t,
        snap: n,
        writeId: r,
        visible: s
    }), s && (e.visibleWrites = Yd(e.visibleWrites, t, n)), e.lastWriteId = r
}

function gW(e, t) {
    for (let n = 0; n < e.allWrites.length; n++) {
        const r = e.allWrites[n];
        if (r.writeId === t) return r
    }
    return null
}

function _W(e, t) {
    const n = e.allWrites.findIndex(a => a.writeId === t);
    X(n >= 0, "removeWrite called with nonexistent writeId.");
    const r = e.allWrites[n];
    e.allWrites.splice(n, 1);
    let s = r.visible,
        i = !1,
        o = e.allWrites.length - 1;
    for (; s && o >= 0;) {
        const a = e.allWrites[o];
        a.visible && (o >= n && yW(a, r.path) ? s = !1 : ss(r.path, a.path) && (i = !0)), o--
    }
    if (s) {
        if (i) return vW(e), !0;
        if (r.snap) e.visibleWrites = ix(e.visibleWrites, r.path);
        else {
            const a = r.children;
            kr(a, l => {
                e.visibleWrites = ix(e.visibleWrites, sn(r.path, l))
            })
        }
        return !0
    } else return !1
}

function yW(e, t) {
    if (e.snap) return ss(e.path, t);
    for (const n in e.children)
        if (e.children.hasOwnProperty(n) && ss(sn(e.path, n), t)) return !0;
    return !1
}

function vW(e) {
    e.visibleWrites = iM(e.allWrites, bW, nt()), e.allWrites.length > 0 ? e.lastWriteId = e.allWrites[e.allWrites.length - 1].writeId : e.lastWriteId = -1
}

function bW(e) {
    return e.visible
}

function iM(e, t, n) {
    let r = ds.empty();
    for (let s = 0; s < e.length; ++s) {
        const i = e[s];
        if (t(i)) {
            const o = i.path;
            let a;
            if (i.snap) ss(n, o) ? (a = or(n, o), r = Yd(r, a, i.snap)) : ss(o, n) && (a = or(o, n), r = Yd(r, nt(), i.snap.getChild(a)));
            else if (i.children) {
                if (ss(n, o)) a = or(n, o), r = sx(r, a, i.children);
                else if (ss(o, n))
                    if (a = or(o, n), Be(a)) r = sx(r, nt(), i.children);
                    else {
                        const l = Jc(i.children, He(a));
                        if (l) {
                            const c = l.getChild(Tt(a));
                            r = Yd(r, nt(), c)
                        }
                    }
            } else throw Hu("WriteRecord should have .snap or .children")
        }
    }
    return r
}

function oM(e, t, n, r, s) {
    if (!r && !s) {
        const i = xl(e.visibleWrites, t);
        if (i != null) return i; {
            const o = Io(e.visibleWrites, t);
            if (Pw(o)) return n;
            if (n == null && !Nw(o, nt())) return null; {
                const a = n || Ee.EMPTY_NODE;
                return tu(o, a)
            }
        }
    } else {
        const i = Io(e.visibleWrites, t);
        if (!s && Pw(i)) return n;
        if (!s && n == null && !Nw(i, nt())) return null; {
            const o = function(c) {
                    return (c.visible || s) && (!r || !~r.indexOf(c.writeId)) && (ss(c.path, t) || ss(t, c.path))
                },
                a = iM(e.allWrites, o, t),
                l = n || Ee.EMPTY_NODE;
            return tu(a, l)
        }
    }
}

function wW(e, t, n) {
    let r = Ee.EMPTY_NODE;
    const s = xl(e.visibleWrites, t);
    if (s) return s.isLeafNode() || s.forEachChild(jt, (i, o) => {
        r = r.updateImmediateChild(i, o)
    }), r;
    if (n) {
        const i = Io(e.visibleWrites, t);
        return n.forEachChild(jt, (o, a) => {
            const l = tu(Io(i, new wt(o)), a);
            r = r.updateImmediateChild(o, l)
        }), ox(i).forEach(o => {
            r = r.updateImmediateChild(o.name, o.node)
        }), r
    } else {
        const i = Io(e.visibleWrites, t);
        return ox(i).forEach(o => {
            r = r.updateImmediateChild(o.name, o.node)
        }), r
    }
}

function EW(e, t, n, r, s) {
    X(r || s, "Either existingEventSnap or existingServerSnap must exist");
    const i = sn(t, n);
    if (Nw(e.visibleWrites, i)) return null; {
        const o = Io(e.visibleWrites, i);
        return Pw(o) ? s.getChild(n) : tu(o, s.getChild(n))
    }
}

function SW(e, t, n, r) {
    const s = sn(t, n),
        i = xl(e.visibleWrites, s);
    if (i != null) return i;
    if (r.isCompleteForChild(n)) {
        const o = Io(e.visibleWrites, s);
        return tu(o, r.getNode().getImmediateChild(n))
    } else return null
}

function TW(e, t) {
    return xl(e.visibleWrites, t)
}

function $W(e, t, n, r, s, i, o) {
    let a;
    const l = Io(e.visibleWrites, t),
        c = xl(l, nt());
    if (c != null) a = c;
    else if (n != null) a = tu(l, n);
    else return [];
    if (a = a.withIndex(o), !a.isEmpty() && !a.isLeafNode()) {
        const u = [],
            d = o.getCompare(),
            f = i ? a.getReverseIteratorFrom(r, o) : a.getIteratorFrom(r, o);
        let h = f.getNext();
        for (; h && u.length < s;) d(h, r) !== 0 && u.push(h), h = f.getNext();
        return u
    } else return []
}

function kW() {
    return {
        visibleWrites: ds.empty(),
        allWrites: [],
        lastWriteId: -1
    }
}

function Gg(e, t, n, r) {
    return oM(e.writeTree, e.treePath, t, n, r)
}

function TS(e, t) {
    return wW(e.writeTree, e.treePath, t)
}

function ax(e, t, n, r) {
    return EW(e.writeTree, e.treePath, t, n, r)
}

function qg(e, t) {
    return TW(e.writeTree, sn(e.treePath, t))
}

function IW(e, t, n, r, s, i) {
    return $W(e.writeTree, e.treePath, t, n, r, s, i)
}

function $S(e, t, n) {
    return SW(e.writeTree, e.treePath, t, n)
}

function aM(e, t) {
    return lM(sn(e.treePath, t), e.writeTree)
}

function lM(e, t) {
    return {
        treePath: e,
        writeTree: t
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xW {
    constructor() {
        this.changeMap = new Map
    }
    trackChildChange(t) {
        const n = t.type,
            r = t.childName;
        X(n === "child_added" || n === "child_changed" || n === "child_removed", "Only child changes supported for tracking"), X(r !== ".priority", "Only non-priority child changes can be tracked.");
        const s = this.changeMap.get(r);
        if (s) {
            const i = s.type;
            if (n === "child_added" && i === "child_removed") this.changeMap.set(r, Hf(r, t.snapshotNode, s.snapshotNode));
            else if (n === "child_removed" && i === "child_added") this.changeMap.delete(r);
            else if (n === "child_removed" && i === "child_changed") this.changeMap.set(r, Vf(r, s.oldSnap));
            else if (n === "child_changed" && i === "child_added") this.changeMap.set(r, eu(r, t.snapshotNode));
            else if (n === "child_changed" && i === "child_changed") this.changeMap.set(r, Hf(r, t.snapshotNode, s.oldSnap));
            else throw Hu("Illegal combination of changes: " + t + " occurred after " + s)
        } else this.changeMap.set(r, t)
    }
    getChanges() {
        return Array.from(this.changeMap.values())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CW {
    getCompleteChild(t) {
        return null
    }
    getChildAfterChild(t, n, r) {
        return null
    }
}
const cM = new CW;
class kS {
    constructor(t, n, r = null) {
        this.writes_ = t, this.viewCache_ = n, this.optCompleteServerCache_ = r
    }
    getCompleteChild(t) {
        const n = this.viewCache_.eventCache;
        if (n.isCompleteForChild(t)) return n.getNode().getImmediateChild(t); {
            const r = this.optCompleteServerCache_ != null ? new Fo(this.optCompleteServerCache_, !0, !1) : this.viewCache_.serverCache;
            return $S(this.writes_, t, r)
        }
    }
    getChildAfterChild(t, n, r) {
        const s = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : nl(this.viewCache_),
            i = IW(this.writes_, s, n, 1, r, t);
        return i.length === 0 ? null : i[0]
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function AW(e) {
    return {
        filter: e
    }
}

function RW(e, t) {
    X(t.eventCache.getNode().isIndexed(e.filter.getIndex()), "Event snap not indexed"), X(t.serverCache.getNode().isIndexed(e.filter.getIndex()), "Server snap not indexed")
}

function OW(e, t, n, r, s) {
    const i = new xW;
    let o, a;
    if (n.type === is.OVERWRITE) {
        const c = n;
        c.source.fromUser ? o = Mw(e, t, c.path, c.snap, r, s, i) : (X(c.source.fromServer, "Unknown source."), a = c.source.tagged || t.serverCache.isFiltered() && !Be(c.path), o = Yg(e, t, c.path, c.snap, r, s, a, i))
    } else if (n.type === is.MERGE) {
        const c = n;
        c.source.fromUser ? o = NW(e, t, c.path, c.children, r, s, i) : (X(c.source.fromServer, "Unknown source."), a = c.source.tagged || t.serverCache.isFiltered(), o = Lw(e, t, c.path, c.children, r, s, a, i))
    } else if (n.type === is.ACK_USER_WRITE) {
        const c = n;
        c.revert ? o = LW(e, t, c.path, r, s, i) : o = PW(e, t, c.path, c.affectedTree, r, s, i)
    } else if (n.type === is.LISTEN_COMPLETE) o = MW(e, t, n.path, r, i);
    else throw Hu("Unknown operation type: " + n.type);
    const l = i.getChanges();
    return DW(t, o, l), {
        viewCache: o,
        changes: l
    }
}

function DW(e, t, n) {
    const r = t.eventCache;
    if (r.isFullyInitialized()) {
        const s = r.getNode().isLeafNode() || r.getNode().isEmpty(),
            i = Wg(e);
        (n.length > 0 || !e.eventCache.isFullyInitialized() || s && !r.getNode().equals(i) || !r.getNode().getPriority().equals(i.getPriority())) && n.push(eM(Wg(t)))
    }
}

function uM(e, t, n, r, s, i) {
    const o = t.eventCache;
    if (qg(r, n) != null) return t; {
        let a, l;
        if (Be(n))
            if (X(t.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data"), t.serverCache.isFiltered()) {
                const c = nl(t),
                    u = c instanceof Ee ? c : Ee.EMPTY_NODE,
                    d = TS(r, u);
                a = e.filter.updateFullNode(t.eventCache.getNode(), d, i)
            } else {
                const c = Gg(r, nl(t));
                a = e.filter.updateFullNode(t.eventCache.getNode(), c, i)
            }
        else {
            const c = He(n);
            if (c === ".priority") {
                X(Lo(n) === 1, "Can't have a priority with additional path components");
                const u = o.getNode();
                l = t.serverCache.getNode();
                const d = ax(r, n, u, l);
                d != null ? a = e.filter.updatePriority(u, d) : a = o.getNode()
            } else {
                const u = Tt(n);
                let d;
                if (o.isCompleteForChild(c)) {
                    l = t.serverCache.getNode();
                    const f = ax(r, n, o.getNode(), l);
                    f != null ? d = o.getNode().getImmediateChild(c).updateChild(u, f) : d = o.getNode().getImmediateChild(c)
                } else d = $S(r, c, t.serverCache);
                d != null ? a = e.filter.updateChild(o.getNode(), c, d, u, s, i) : a = o.getNode()
            }
        }
        return qd(t, a, o.isFullyInitialized() || Be(n), e.filter.filtersNodes())
    }
}

function Yg(e, t, n, r, s, i, o, a) {
    const l = t.serverCache;
    let c;
    const u = o ? e.filter : e.filter.getIndexedFilter();
    if (Be(n)) c = u.updateFullNode(l.getNode(), r, null);
    else if (u.filtersNodes() && !l.isFiltered()) {
        const h = l.getNode().updateChild(n, r);
        c = u.updateFullNode(l.getNode(), h, null)
    } else {
        const h = He(n);
        if (!l.isCompleteForPath(n) && Lo(n) > 1) return t;
        const p = Tt(n),
            g = l.getNode().getImmediateChild(h).updateChild(p, r);
        h === ".priority" ? c = u.updatePriority(l.getNode(), g) : c = u.updateChild(l.getNode(), h, g, p, cM, null)
    }
    const d = rM(t, c, l.isFullyInitialized() || Be(n), u.filtersNodes()),
        f = new kS(s, d, i);
    return uM(e, d, n, s, f, a)
}

function Mw(e, t, n, r, s, i, o) {
    const a = t.eventCache;
    let l, c;
    const u = new kS(s, t, i);
    if (Be(n)) c = e.filter.updateFullNode(t.eventCache.getNode(), r, o), l = qd(t, c, !0, e.filter.filtersNodes());
    else {
        const d = He(n);
        if (d === ".priority") c = e.filter.updatePriority(t.eventCache.getNode(), r), l = qd(t, c, a.isFullyInitialized(), a.isFiltered());
        else {
            const f = Tt(n),
                h = a.getNode().getImmediateChild(d);
            let p;
            if (Be(f)) p = r;
            else {
                const m = u.getCompleteChild(d);
                m != null ? zP(f) === ".priority" && m.getChild(GP(f)).isEmpty() ? p = m : p = m.updateChild(f, r) : p = Ee.EMPTY_NODE
            }
            if (h.equals(p)) l = t;
            else {
                const m = e.filter.updateChild(a.getNode(), d, p, f, u, o);
                l = qd(t, m, a.isFullyInitialized(), e.filter.filtersNodes())
            }
        }
    }
    return l
}

function lx(e, t) {
    return e.eventCache.isCompleteForChild(t)
}

function NW(e, t, n, r, s, i, o) {
    let a = t;
    return r.foreach((l, c) => {
        const u = sn(n, l);
        lx(t, He(u)) && (a = Mw(e, a, u, c, s, i, o))
    }), r.foreach((l, c) => {
        const u = sn(n, l);
        lx(t, He(u)) || (a = Mw(e, a, u, c, s, i, o))
    }), a
}

function cx(e, t, n) {
    return n.foreach((r, s) => {
        t = t.updateChild(r, s)
    }), t
}

function Lw(e, t, n, r, s, i, o, a) {
    if (t.serverCache.getNode().isEmpty() && !t.serverCache.isFullyInitialized()) return t;
    let l = t,
        c;
    Be(n) ? c = r : c = new It(null).setTree(n, r);
    const u = t.serverCache.getNode();
    return c.children.inorderTraversal((d, f) => {
        if (u.hasChild(d)) {
            const h = t.serverCache.getNode().getImmediateChild(d),
                p = cx(e, h, f);
            l = Yg(e, l, new wt(d), p, s, i, o, a)
        }
    }), c.children.inorderTraversal((d, f) => {
        const h = !t.serverCache.isCompleteForChild(d) && f.value === null;
        if (!u.hasChild(d) && !h) {
            const p = t.serverCache.getNode().getImmediateChild(d),
                m = cx(e, p, f);
            l = Yg(e, l, new wt(d), m, s, i, o, a)
        }
    }), l
}

function PW(e, t, n, r, s, i, o) {
    if (qg(s, n) != null) return t;
    const a = t.serverCache.isFiltered(),
        l = t.serverCache;
    if (r.value != null) {
        if (Be(n) && l.isFullyInitialized() || l.isCompleteForPath(n)) return Yg(e, t, n, l.getNode().getChild(n), s, i, a, o);
        if (Be(n)) {
            let c = new It(null);
            return l.getNode().forEachChild($c, (u, d) => {
                c = c.set(new wt(u), d)
            }), Lw(e, t, n, c, s, i, a, o)
        } else return t
    } else {
        let c = new It(null);
        return r.foreach((u, d) => {
            const f = sn(n, u);
            l.isCompleteForPath(f) && (c = c.set(u, l.getNode().getChild(f)))
        }), Lw(e, t, n, c, s, i, a, o)
    }
}

function MW(e, t, n, r, s) {
    const i = t.serverCache,
        o = rM(t, i.getNode(), i.isFullyInitialized() || Be(n), i.isFiltered());
    return uM(e, o, n, r, cM, s)
}

function LW(e, t, n, r, s, i) {
    let o;
    if (qg(r, n) != null) return t; {
        const a = new kS(r, t, s),
            l = t.eventCache.getNode();
        let c;
        if (Be(n) || He(n) === ".priority") {
            let u;
            if (t.serverCache.isFullyInitialized()) u = Gg(r, nl(t));
            else {
                const d = t.serverCache.getNode();
                X(d instanceof Ee, "serverChildren would be complete if leaf node"), u = TS(r, d)
            }
            u = u, c = e.filter.updateFullNode(l, u, i)
        } else {
            const u = He(n);
            let d = $S(r, u, t.serverCache);
            d == null && t.serverCache.isCompleteForChild(u) && (d = l.getImmediateChild(u)), d != null ? c = e.filter.updateChild(l, u, d, Tt(n), a, i) : t.eventCache.getNode().hasChild(u) ? c = e.filter.updateChild(l, u, Ee.EMPTY_NODE, Tt(n), a, i) : c = l, c.isEmpty() && t.serverCache.isFullyInitialized() && (o = Gg(r, nl(t)), o.isLeafNode() && (c = e.filter.updateFullNode(c, o, i)))
        }
        return o = t.serverCache.isFullyInitialized() || qg(r, nt()) != null, qd(t, c, o, e.filter.filtersNodes())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FW {
    constructor(t, n) {
        this.query_ = t, this.eventRegistrations_ = [];
        const r = this.query_._queryParams,
            s = new bS(r.getIndex()),
            i = rW(r);
        this.processor_ = AW(i);
        const o = n.serverCache,
            a = n.eventCache,
            l = s.updateFullNode(Ee.EMPTY_NODE, o.getNode(), null),
            c = i.updateFullNode(Ee.EMPTY_NODE, a.getNode(), null),
            u = new Fo(l, o.isFullyInitialized(), s.filtersNodes()),
            d = new Fo(c, a.isFullyInitialized(), i.filtersNodes());
        this.viewCache_ = Hy(d, u), this.eventGenerator_ = new uW(this.query_)
    }
    get query() {
        return this.query_
    }
}

function UW(e) {
    return e.viewCache_.serverCache.getNode()
}

function BW(e) {
    return Wg(e.viewCache_)
}

function VW(e, t) {
    const n = nl(e.viewCache_);
    return n && (e.query._queryParams.loadsAllData() || !Be(t) && !n.getImmediateChild(He(t)).isEmpty()) ? n.getChild(t) : null
}

function ux(e) {
    return e.eventRegistrations_.length === 0
}

function HW(e, t) {
    e.eventRegistrations_.push(t)
}

function dx(e, t, n) {
    const r = [];
    if (n) {
        X(t == null, "A cancel should cancel all event registrations.");
        const s = e.query._path;
        e.eventRegistrations_.forEach(i => {
            const o = i.createCancelEvent(n, s);
            o && r.push(o)
        })
    }
    if (t) {
        let s = [];
        for (let i = 0; i < e.eventRegistrations_.length; ++i) {
            const o = e.eventRegistrations_[i];
            if (!o.matches(t)) s.push(o);
            else if (t.hasAnyCallback()) {
                s = s.concat(e.eventRegistrations_.slice(i + 1));
                break
            }
        }
        e.eventRegistrations_ = s
    } else e.eventRegistrations_ = [];
    return r
}

function fx(e, t, n, r) {
    t.type === is.MERGE && t.source.queryId !== null && (X(nl(e.viewCache_), "We should always have a full cache before handling merges"), X(Wg(e.viewCache_), "Missing event cache, even though we have a server cache"));
    const s = e.viewCache_,
        i = OW(e.processor_, s, t, n, r);
    return RW(e.processor_, i.viewCache), X(i.viewCache.serverCache.isFullyInitialized() || !s.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back"), e.viewCache_ = i.viewCache, dM(e, i.changes, i.viewCache.eventCache.getNode(), null)
}

function jW(e, t) {
    const n = e.viewCache_.eventCache,
        r = [];
    return n.getNode().isLeafNode() || n.getNode().forEachChild(jt, (i, o) => {
        r.push(eu(i, o))
    }), n.isFullyInitialized() && r.push(eM(n.getNode())), dM(e, r, n.getNode(), t)
}

function dM(e, t, n, r) {
    const s = r ? [r] : e.eventRegistrations_;
    return dW(e.eventGenerator_, t, n, s)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Kg;
class fM {
    constructor() {
        this.views = new Map
    }
}

function zW(e) {
    X(!Kg, "__referenceConstructor has already been defined"), Kg = e
}

function WW() {
    return X(Kg, "Reference.ts has not been loaded"), Kg
}

function GW(e) {
    return e.views.size === 0
}

function IS(e, t, n, r) {
    const s = t.source.queryId;
    if (s !== null) {
        const i = e.views.get(s);
        return X(i != null, "SyncTree gave us an op for an invalid query."), fx(i, t, n, r)
    } else {
        let i = [];
        for (const o of e.views.values()) i = i.concat(fx(o, t, n, r));
        return i
    }
}

function hM(e, t, n, r, s) {
    const i = t._queryIdentifier,
        o = e.views.get(i);
    if (!o) {
        let a = Gg(n, s ? r : null),
            l = !1;
        a ? l = !0 : r instanceof Ee ? (a = TS(n, r), l = !1) : (a = Ee.EMPTY_NODE, l = !1);
        const c = Hy(new Fo(a, l, !1), new Fo(r, s, !1));
        return new FW(t, c)
    }
    return o
}

function qW(e, t, n, r, s, i) {
    const o = hM(e, t, r, s, i);
    return e.views.has(t._queryIdentifier) || e.views.set(t._queryIdentifier, o), HW(o, n), jW(o, n)
}

function YW(e, t, n, r) {
    const s = t._queryIdentifier,
        i = [];
    let o = [];
    const a = Uo(e);
    if (s === "default")
        for (const [l, c] of e.views.entries()) o = o.concat(dx(c, n, r)), ux(c) && (e.views.delete(l), c.query._queryParams.loadsAllData() || i.push(c.query));
    else {
        const l = e.views.get(s);
        l && (o = o.concat(dx(l, n, r)), ux(l) && (e.views.delete(s), l.query._queryParams.loadsAllData() || i.push(l.query)))
    }
    return a && !Uo(e) && i.push(new(WW())(t._repo, t._path)), {
        removed: i,
        events: o
    }
}

function pM(e) {
    const t = [];
    for (const n of e.views.values()) n.query._queryParams.loadsAllData() || t.push(n);
    return t
}

function xo(e, t) {
    let n = null;
    for (const r of e.views.values()) n = n || VW(r, t);
    return n
}

function mM(e, t) {
    if (t._queryParams.loadsAllData()) return zy(e); {
        const r = t._queryIdentifier;
        return e.views.get(r)
    }
}

function gM(e, t) {
    return mM(e, t) != null
}

function Uo(e) {
    return zy(e) != null
}

function zy(e) {
    for (const t of e.views.values())
        if (t.query._queryParams.loadsAllData()) return t;
    return null
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Xg;

function KW(e) {
    X(!Xg, "__referenceConstructor has already been defined"), Xg = e
}

function XW() {
    return X(Xg, "Reference.ts has not been loaded"), Xg
}
let QW = 1;
class hx {
    constructor(t) {
        this.listenProvider_ = t, this.syncPointTree_ = new It(null), this.pendingWriteTree_ = kW(), this.tagToQueryMap = new Map, this.queryToTagMap = new Map
    }
}

function _M(e, t, n, r, s) {
    return mW(e.pendingWriteTree_, t, n, r, s), s ? Zh(e, new tl(nM(), t, n)) : []
}

function Aa(e, t, n = !1) {
    const r = gW(e.pendingWriteTree_, t);
    if (_W(e.pendingWriteTree_, t)) {
        let i = new It(null);
        return r.snap != null ? i = i.set(nt(), !0) : kr(r.children, o => {
            i = i.set(new wt(o), !0)
        }), Zh(e, new zg(r.path, i, n))
    } else return []
}

function Jh(e, t, n) {
    return Zh(e, new tl(ES(), t, n))
}

function JW(e, t, n) {
    const r = It.fromObject(n);
    return Zh(e, new Wf(ES(), t, r))
}

function ZW(e, t) {
    return Zh(e, new zf(ES(), t))
}

function eG(e, t, n) {
    const r = CS(e, n);
    if (r) {
        const s = AS(r),
            i = s.path,
            o = s.queryId,
            a = or(i, t),
            l = new zf(SS(o), a);
        return RS(e, i, l)
    } else return []
}

function yM(e, t, n, r, s = !1) {
    const i = t._path,
        o = e.syncPointTree_.get(i);
    let a = [];
    if (o && (t._queryIdentifier === "default" || gM(o, t))) {
        const l = YW(o, t, n, r);
        GW(o) && (e.syncPointTree_ = e.syncPointTree_.remove(i));
        const c = l.removed;
        if (a = l.events, !s) {
            const u = c.findIndex(f => f._queryParams.loadsAllData()) !== -1,
                d = e.syncPointTree_.findOnPath(i, (f, h) => Uo(h));
            if (u && !d) {
                const f = e.syncPointTree_.subtree(i);
                if (!f.isEmpty()) {
                    const h = sG(f);
                    for (let p = 0; p < h.length; ++p) {
                        const m = h[p],
                            g = m.query,
                            y = EM(e, m);
                        e.listenProvider_.startListening(Kd(g), Gf(e, g), y.hashFn, y.onComplete)
                    }
                }
            }!d && c.length > 0 && !r && (u ? e.listenProvider_.stopListening(Kd(t), null) : c.forEach(f => {
                const h = e.queryToTagMap.get(Wy(f));
                e.listenProvider_.stopListening(Kd(f), h)
            }))
        }
        iG(e, c)
    }
    return a
}

function vM(e, t, n, r) {
    const s = CS(e, r);
    if (s != null) {
        const i = AS(s),
            o = i.path,
            a = i.queryId,
            l = or(o, t),
            c = new tl(SS(a), l, n);
        return RS(e, o, c)
    } else return []
}

function tG(e, t, n, r) {
    const s = CS(e, r);
    if (s) {
        const i = AS(s),
            o = i.path,
            a = i.queryId,
            l = or(o, t),
            c = It.fromObject(n),
            u = new Wf(SS(a), l, c);
        return RS(e, o, u)
    } else return []
}

function nG(e, t, n, r = !1) {
    const s = t._path;
    let i = null,
        o = !1;
    e.syncPointTree_.foreachOnPath(s, (f, h) => {
        const p = or(f, s);
        i = i || xo(h, p), o = o || Uo(h)
    });
    let a = e.syncPointTree_.get(s);
    a ? (o = o || Uo(a), i = i || xo(a, nt())) : (a = new fM, e.syncPointTree_ = e.syncPointTree_.set(s, a));
    let l;
    i != null ? l = !0 : (l = !1, i = Ee.EMPTY_NODE, e.syncPointTree_.subtree(s).foreachChild((h, p) => {
        const m = xo(p, nt());
        m && (i = i.updateImmediateChild(h, m))
    }));
    const c = gM(a, t);
    if (!c && !t._queryParams.loadsAllData()) {
        const f = Wy(t);
        X(!e.queryToTagMap.has(f), "View does not exist, but we have a tag");
        const h = oG();
        e.queryToTagMap.set(f, h), e.tagToQueryMap.set(h, f)
    }
    const u = jy(e.pendingWriteTree_, s);
    let d = qW(a, t, n, u, i, l);
    if (!c && !o && !r) {
        const f = mM(a, t);
        d = d.concat(aG(e, t, f))
    }
    return d
}

function xS(e, t, n) {
    const s = e.pendingWriteTree_,
        i = e.syncPointTree_.findOnPath(t, (o, a) => {
            const l = or(o, t),
                c = xo(a, l);
            if (c) return c
        });
    return oM(s, t, i, n, !0)
}

function rG(e, t) {
    const n = t._path;
    let r = null;
    e.syncPointTree_.foreachOnPath(n, (c, u) => {
        const d = or(c, n);
        r = r || xo(u, d)
    });
    let s = e.syncPointTree_.get(n);
    s ? r = r || xo(s, nt()) : (s = new fM, e.syncPointTree_ = e.syncPointTree_.set(n, s));
    const i = r != null,
        o = i ? new Fo(r, !0, !1) : null,
        a = jy(e.pendingWriteTree_, t._path),
        l = hM(s, t, a, i ? o.getNode() : Ee.EMPTY_NODE, i);
    return BW(l)
}

function Zh(e, t) {
    return bM(t, e.syncPointTree_, null, jy(e.pendingWriteTree_, nt()))
}

function bM(e, t, n, r) {
    if (Be(e.path)) return wM(e, t, n, r); {
        const s = t.get(nt());
        n == null && s != null && (n = xo(s, nt()));
        let i = [];
        const o = He(e.path),
            a = e.operationForChild(o),
            l = t.children.get(o);
        if (l && a) {
            const c = n ? n.getImmediateChild(o) : null,
                u = aM(r, o);
            i = i.concat(bM(a, l, c, u))
        }
        return s && (i = i.concat(IS(s, e, r, n))), i
    }
}

function wM(e, t, n, r) {
    const s = t.get(nt());
    n == null && s != null && (n = xo(s, nt()));
    let i = [];
    return t.children.inorderTraversal((o, a) => {
        const l = n ? n.getImmediateChild(o) : null,
            c = aM(r, o),
            u = e.operationForChild(o);
        u && (i = i.concat(wM(u, a, l, c)))
    }), s && (i = i.concat(IS(s, e, r, n))), i
}

function EM(e, t) {
    const n = t.query,
        r = Gf(e, n);
    return {
        hashFn: () => (UW(t) || Ee.EMPTY_NODE).hash(),
        onComplete: s => {
            if (s === "ok") return r ? eG(e, n._path, r) : ZW(e, n._path); {
                const i = n4(s, n);
                return yM(e, n, null, i)
            }
        }
    }
}

function Gf(e, t) {
    const n = Wy(t);
    return e.queryToTagMap.get(n)
}

function Wy(e) {
    return e._path.toString() + "$" + e._queryIdentifier
}

function CS(e, t) {
    return e.tagToQueryMap.get(t)
}

function AS(e) {
    const t = e.indexOf("$");
    return X(t !== -1 && t < e.length - 1, "Bad queryKey."), {
        queryId: e.substr(t + 1),
        path: new wt(e.substr(0, t))
    }
}

function RS(e, t, n) {
    const r = e.syncPointTree_.get(t);
    X(r, "Missing sync point for query tag that we're tracking");
    const s = jy(e.pendingWriteTree_, t);
    return IS(r, n, s, null)
}

function sG(e) {
    return e.fold((t, n, r) => {
        if (n && Uo(n)) return [zy(n)]; {
            let s = [];
            return n && (s = pM(n)), kr(r, (i, o) => {
                s = s.concat(o)
            }), s
        }
    })
}

function Kd(e) {
    return e._queryParams.loadsAllData() && !e._queryParams.isDefault() ? new(XW())(e._repo, e._path) : e
}

function iG(e, t) {
    for (let n = 0; n < t.length; ++n) {
        const r = t[n];
        if (!r._queryParams.loadsAllData()) {
            const s = Wy(r),
                i = e.queryToTagMap.get(s);
            e.queryToTagMap.delete(s), e.tagToQueryMap.delete(i)
        }
    }
}

function oG() {
    return QW++
}

function aG(e, t, n) {
    const r = t._path,
        s = Gf(e, t),
        i = EM(e, n),
        o = e.listenProvider_.startListening(Kd(t), s, i.hashFn, i.onComplete),
        a = e.syncPointTree_.subtree(r);
    if (s) X(!Uo(a.value), "If we're adding a query, it shouldn't be shadowed");
    else {
        const l = a.fold((c, u, d) => {
            if (!Be(c) && u && Uo(u)) return [zy(u).query]; {
                let f = [];
                return u && (f = f.concat(pM(u).map(h => h.query))), kr(d, (h, p) => {
                    f = f.concat(p)
                }), f
            }
        });
        for (let c = 0; c < l.length; ++c) {
            const u = l[c];
            e.listenProvider_.stopListening(Kd(u), Gf(e, u))
        }
    }
    return o
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OS {
    constructor(t) {
        this.node_ = t
    }
    getImmediateChild(t) {
        const n = this.node_.getImmediateChild(t);
        return new OS(n)
    }
    node() {
        return this.node_
    }
}
class DS {
    constructor(t, n) {
        this.syncTree_ = t, this.path_ = n
    }
    getImmediateChild(t) {
        const n = sn(this.path_, t);
        return new DS(this.syncTree_, n)
    }
    node() {
        return xS(this.syncTree_, this.path_)
    }
}
const lG = function(e) {
        return e = e || {}, e.timestamp = e.timestamp || new Date().getTime(), e
    },
    px = function(e, t, n) {
        if (!e || typeof e != "object") return e;
        if (X(".sv" in e, "Unexpected leaf node or priority contents"), typeof e[".sv"] == "string") return cG(e[".sv"], t, n);
        if (typeof e[".sv"] == "object") return uG(e[".sv"], t);
        X(!1, "Unexpected server value: " + JSON.stringify(e, null, 2))
    },
    cG = function(e, t, n) {
        switch (e) {
            case "timestamp":
                return n.timestamp;
            default:
                X(!1, "Unexpected server value: " + e)
        }
    },
    uG = function(e, t, n) {
        e.hasOwnProperty("increment") || X(!1, "Unexpected server value: " + JSON.stringify(e, null, 2));
        const r = e.increment;
        typeof r != "number" && X(!1, "Unexpected increment value: " + r);
        const s = t.node();
        if (X(s !== null && typeof s != "undefined", "Expected ChildrenNode.EMPTY_NODE for nulls"), !s.isLeafNode()) return r;
        const o = s.getValue();
        return typeof o != "number" ? r : o + r
    },
    dG = function(e, t, n, r) {
        return NS(t, new DS(n, e), r)
    },
    SM = function(e, t, n) {
        return NS(e, new OS(t), n)
    };

function NS(e, t, n) {
    const r = e.getPriority().val(),
        s = px(r, t.getImmediateChild(".priority"), n);
    let i;
    if (e.isLeafNode()) {
        const o = e,
            a = px(o.getValue(), t, n);
        return a !== o.getValue() || s !== o.getPriority().val() ? new gn(a, bn(s)) : e
    } else {
        const o = e;
        return i = o, s !== o.getPriority().val() && (i = i.updatePriority(new gn(s))), o.forEachChild(jt, (a, l) => {
            const c = NS(l, t.getImmediateChild(a), n);
            c !== l && (i = i.updateImmediateChild(a, c))
        }), i
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PS {
    constructor(t = "", n = null, r = {
        children: {},
        childCount: 0
    }) {
        this.name = t, this.parent = n, this.node = r
    }
}

function MS(e, t) {
    let n = t instanceof wt ? t : new wt(t),
        r = e,
        s = He(n);
    for (; s !== null;) {
        const i = Jc(r.node.children, s) || {
            children: {},
            childCount: 0
        };
        r = new PS(s, r, i), n = Tt(n), s = He(n)
    }
    return r
}

function qu(e) {
    return e.node.value
}

function TM(e, t) {
    e.node.value = t, Fw(e)
}

function $M(e) {
    return e.node.childCount > 0
}

function fG(e) {
    return qu(e) === void 0 && !$M(e)
}

function Gy(e, t) {
    kr(e.node.children, (n, r) => {
        t(new PS(n, e, r))
    })
}

function kM(e, t, n, r) {
    n && !r && t(e), Gy(e, s => {
        kM(s, t, !0, r)
    }), n && r && t(e)
}

function hG(e, t, n) {
    let r = n ? e : e.parent;
    for (; r !== null;) {
        if (t(r)) return !0;
        r = r.parent
    }
    return !1
}

function ep(e) {
    return new wt(e.parent === null ? e.name : ep(e.parent) + "/" + e.name)
}

function Fw(e) {
    e.parent !== null && pG(e.parent, e.name, e)
}

function pG(e, t, n) {
    const r = fG(n),
        s = Pi(e.node.children, t);
    r && s ? (delete e.node.children[t], e.node.childCount--, Fw(e)) : !r && !s && (e.node.children[t] = n.node, e.node.childCount++, Fw(e))
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mG = /[\[\].#$\/\u0000-\u001F\u007F]/,
    gG = /[\[\].#$\u0000-\u001F\u007F]/,
    Kb = 10 * 1024 * 1024,
    IM = function(e) {
        return typeof e == "string" && e.length !== 0 && !mG.test(e)
    },
    xM = function(e) {
        return typeof e == "string" && e.length !== 0 && !gG.test(e)
    },
    _G = function(e) {
        return e && (e = e.replace(/^\/*\.info(\/|$)/, "/")), xM(e)
    },
    yG = function(e, t, n, r) {
        r && t === void 0 || LS(fS(e, "value"), t, n)
    },
    LS = function(e, t, n) {
        const r = n instanceof wt ? new P4(n, e) : n;
        if (t === void 0) throw new Error(e + "contains undefined " + Ea(r));
        if (typeof t == "function") throw new Error(e + "contains a function " + Ea(r) + " with contents = " + t.toString());
        if (SP(t)) throw new Error(e + "contains " + t.toString() + " " + Ea(r));
        if (typeof t == "string" && t.length > Kb / 3 && By(t) > Kb) throw new Error(e + "contains a string greater than " + Kb + " utf8 bytes " + Ea(r) + " ('" + t.substring(0, 50) + "...')");
        if (t && typeof t == "object") {
            let s = !1,
                i = !1;
            if (kr(t, (o, a) => {
                    if (o === ".value") s = !0;
                    else if (o !== ".priority" && o !== ".sv" && (i = !0, !IM(o))) throw new Error(e + " contains an invalid key (" + o + ") " + Ea(r) + `.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
                    M4(r, o), LS(e, a, r), L4(r)
                }), s && i) throw new Error(e + ' contains ".value" child ' + Ea(r) + " in addition to actual children.")
        }
    },
    CM = function(e, t, n, r) {
        if (!(r && n === void 0) && !xM(n)) throw new Error(fS(e, t) + 'was an invalid path = "' + n + `". Paths must be non-empty strings and can't contain ".", "#", "$", "[", or "]"`)
    },
    vG = function(e, t, n, r) {
        n && (n = n.replace(/^\/*\.info(\/|$)/, "/")), CM(e, t, n, r)
    },
    bG = function(e, t) {
        if (He(t) === ".info") throw new Error(e + " failed = Can't modify data under /.info/")
    },
    wG = function(e, t) {
        const n = t.path.toString();
        if (typeof t.repoInfo.host != "string" || t.repoInfo.host.length === 0 || !IM(t.repoInfo.namespace) && t.repoInfo.host.split(":")[0] !== "localhost" || n.length !== 0 && !_G(n)) throw new Error(fS(e, "url") + `must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`)
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EG {
    constructor() {
        this.eventLists_ = [], this.recursionDepth_ = 0
    }
}

function AM(e, t) {
    let n = null;
    for (let r = 0; r < t.length; r++) {
        const s = t[r],
            i = s.getPath();
        n !== null && !qP(i, n.path) && (e.eventLists_.push(n), n = null), n === null && (n = {
            events: [],
            path: i
        }), n.events.push(s)
    }
    n && e.eventLists_.push(n)
}

function Fs(e, t, n) {
    AM(e, n), SG(e, r => ss(r, t) || ss(t, r))
}

function SG(e, t) {
    e.recursionDepth_++;
    let n = !0;
    for (let r = 0; r < e.eventLists_.length; r++) {
        const s = e.eventLists_[r];
        if (s) {
            const i = s.path;
            t(i) ? (TG(e.eventLists_[r]), e.eventLists_[r] = null) : n = !1
        }
    }
    n && (e.eventLists_ = []), e.recursionDepth_--
}

function TG(e) {
    for (let t = 0; t < e.events.length; t++) {
        const n = e.events[t];
        if (n !== null) {
            e.events[t] = null;
            const r = n.getEventRunner();
            Ba && Un("event: " + n.toString()), Gu(r)
        }
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $G = "repo_interrupt",
    kG = 25;
class IG {
    constructor(t, n, r, s) {
        this.repoInfo_ = t, this.forceRestClient_ = n, this.authTokenProvider_ = r, this.appCheckProvider_ = s, this.dataUpdateCount = 0, this.statsListener_ = null, this.eventQueue_ = new EG, this.nextWriteId_ = 1, this.interceptServerDataCallback_ = null, this.onDisconnect_ = jg(), this.transactionQueueTree_ = new PS, this.persistentConnection_ = null, this.key = this.repoInfo_.toURLString()
    }
    toString() {
        return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host
    }
}

function xG(e, t, n) {
    if (e.stats_ = gS(e.repoInfo_), e.forceRestClient_ || o4()) e.server_ = new Hg(e.repoInfo_, (r, s, i, o) => {
        mx(e, r, s, i, o)
    }, e.authTokenProvider_, e.appCheckProvider_), setTimeout(() => gx(e, !0), 0);
    else {
        if (typeof n != "undefined" && n !== null) {
            if (typeof n != "object") throw new Error("Only objects are supported for option databaseAuthVariableOverride");
            try {
                rn(n)
            } catch (r) {
                throw new Error("Invalid authOverride provided: " + r)
            }
        }
        e.persistentConnection_ = new ci(e.repoInfo_, t, (r, s, i, o) => {
            mx(e, r, s, i, o)
        }, r => {
            gx(e, r)
        }, r => {
            AG(e, r)
        }, e.authTokenProvider_, e.appCheckProvider_, n), e.server_ = e.persistentConnection_
    }
    e.authTokenProvider_.addTokenChangeListener(r => {
        e.server_.refreshAuthToken(r)
    }), e.appCheckProvider_.addTokenChangeListener(r => {
        e.server_.refreshAppCheckToken(r.token)
    }), e.statsReporter_ = d4(e.repoInfo_, () => new cW(e.stats_, e.server_)), e.infoData_ = new sW, e.infoSyncTree_ = new hx({
        startListening: (r, s, i, o) => {
            let a = [];
            const l = e.infoData_.getNode(r._path);
            return l.isEmpty() || (a = Jh(e.infoSyncTree_, r._path, l), setTimeout(() => {
                o("ok")
            }, 0)), a
        },
        stopListening: () => {}
    }), US(e, "connected", !1), e.serverSyncTree_ = new hx({
        startListening: (r, s, i, o) => (e.server_.listen(r, i, s, (a, l) => {
            const c = o(a, l);
            Fs(e.eventQueue_, r._path, c)
        }), []),
        stopListening: (r, s) => {
            e.server_.unlisten(r, s)
        }
    })
}

function CG(e) {
    const n = e.infoData_.getNode(new wt(".info/serverTimeOffset")).val() || 0;
    return new Date().getTime() + n
}

function FS(e) {
    return lG({
        timestamp: CG(e)
    })
}

function mx(e, t, n, r, s) {
    e.dataUpdateCount++;
    const i = new wt(t);
    n = e.interceptServerDataCallback_ ? e.interceptServerDataCallback_(t, n) : n;
    let o = [];
    if (s)
        if (r) {
            const l = Fg(n, c => bn(c));
            o = tG(e.serverSyncTree_, i, l, s)
        } else {
            const l = bn(n);
            o = vM(e.serverSyncTree_, i, l, s)
        }
    else if (r) {
        const l = Fg(n, c => bn(c));
        o = JW(e.serverSyncTree_, i, l)
    } else {
        const l = bn(n);
        o = Jh(e.serverSyncTree_, i, l)
    }
    let a = i;
    o.length > 0 && (a = Yy(e, i)), Fs(e.eventQueue_, a, o)
}

function gx(e, t) {
    US(e, "connected", t), t === !1 && DG(e)
}

function AG(e, t) {
    kr(t, (n, r) => {
        US(e, n, r)
    })
}

function US(e, t, n) {
    const r = new wt("/.info/" + t),
        s = bn(n);
    e.infoData_.updateSnapshot(r, s);
    const i = Jh(e.infoSyncTree_, r, s);
    Fs(e.eventQueue_, r, i)
}

function RM(e) {
    return e.nextWriteId_++
}

function RG(e, t, n) {
    const r = rG(e.serverSyncTree_, t);
    return r != null ? Promise.resolve(r) : e.server_.get(t).then(s => {
        const i = bn(s).withIndex(t._queryParams.getIndex());
        nG(e.serverSyncTree_, t, n, !0);
        let o;
        if (t._queryParams.loadsAllData()) o = Jh(e.serverSyncTree_, t._path, i);
        else {
            const a = Gf(e.serverSyncTree_, t);
            o = vM(e.serverSyncTree_, t._path, i, a)
        }
        return Fs(e.eventQueue_, t._path, o), yM(e.serverSyncTree_, t, n, null, !0), i
    }, s => (qy(e, "get for query " + rn(t) + " failed: " + s), Promise.reject(new Error(s))))
}

function OG(e, t, n, r, s) {
    qy(e, "set", {
        path: t.toString(),
        value: n,
        priority: r
    });
    const i = FS(e),
        o = bn(n, r),
        a = xS(e.serverSyncTree_, t),
        l = SM(o, a, i),
        c = RM(e),
        u = _M(e.serverSyncTree_, t, l, c, !0);
    AM(e.eventQueue_, u), e.server_.put(t.toString(), o.val(!0), (f, h) => {
        const p = f === "ok";
        p || Sr("set at " + t + " failed: " + f);
        const m = Aa(e.serverSyncTree_, c, !p);
        Fs(e.eventQueue_, t, m), PG(e, s, f, h)
    });
    const d = MM(e, t);
    Yy(e, d), Fs(e.eventQueue_, d, [])
}

function DG(e) {
    qy(e, "onDisconnectEvents");
    const t = FS(e),
        n = jg();
    Dw(e.onDisconnect_, nt(), (s, i) => {
        const o = dG(s, i, e.serverSyncTree_, t);
        tM(n, s, o)
    });
    let r = [];
    Dw(n, nt(), (s, i) => {
        r = r.concat(Jh(e.serverSyncTree_, s, i));
        const o = MM(e, s);
        Yy(e, o)
    }), e.onDisconnect_ = jg(), Fs(e.eventQueue_, nt(), r)
}

function NG(e) {
    e.persistentConnection_ && e.persistentConnection_.interrupt($G)
}

function qy(e, ...t) {
    let n = "";
    e.persistentConnection_ && (n = e.persistentConnection_.id + ":"), Un(n, ...t)
}

function PG(e, t, n, r) {
    t && Gu(() => {
        if (n === "ok") t(null);
        else {
            const s = (n || "error").toUpperCase();
            let i = s;
            r && (i += ": " + r);
            const o = new Error(i);
            o.code = s, t(o)
        }
    })
}

function OM(e, t, n) {
    return xS(e.serverSyncTree_, t, n) || Ee.EMPTY_NODE
}

function BS(e, t = e.transactionQueueTree_) {
    if (t || Ky(e, t), qu(t)) {
        const n = NM(e, t);
        X(n.length > 0, "Sending zero length transaction queue"), n.every(s => s.status === 0) && MG(e, ep(t), n)
    } else $M(t) && Gy(t, n => {
        BS(e, n)
    })
}

function MG(e, t, n) {
    const r = n.map(c => c.currentWriteId),
        s = OM(e, t, r);
    let i = s;
    const o = s.hash();
    for (let c = 0; c < n.length; c++) {
        const u = n[c];
        X(u.status === 0, "tryToSendTransactionQueue_: items in queue should all be run."), u.status = 1, u.retryCount++;
        const d = or(t, u.path);
        i = i.updateChild(d, u.currentOutputSnapshotRaw)
    }
    const a = i.val(!0),
        l = t;
    e.server_.put(l.toString(), a, c => {
        qy(e, "transaction put response", {
            path: l.toString(),
            status: c
        });
        let u = [];
        if (c === "ok") {
            const d = [];
            for (let f = 0; f < n.length; f++) n[f].status = 2, u = u.concat(Aa(e.serverSyncTree_, n[f].currentWriteId)), n[f].onComplete && d.push(() => n[f].onComplete(null, !0, n[f].currentOutputSnapshotResolved)), n[f].unwatcher();
            Ky(e, MS(e.transactionQueueTree_, t)), BS(e, e.transactionQueueTree_), Fs(e.eventQueue_, t, u);
            for (let f = 0; f < d.length; f++) Gu(d[f])
        } else {
            if (c === "datastale")
                for (let d = 0; d < n.length; d++) n[d].status === 3 ? n[d].status = 4 : n[d].status = 0;
            else {
                Sr("transaction at " + l.toString() + " failed: " + c);
                for (let d = 0; d < n.length; d++) n[d].status = 4, n[d].abortReason = c
            }
            Yy(e, t)
        }
    }, o)
}

function Yy(e, t) {
    const n = DM(e, t),
        r = ep(n),
        s = NM(e, n);
    return LG(e, s, r), r
}

function LG(e, t, n) {
    if (t.length === 0) return;
    const r = [];
    let s = [];
    const o = t.filter(a => a.status === 0).map(a => a.currentWriteId);
    for (let a = 0; a < t.length; a++) {
        const l = t[a],
            c = or(n, l.path);
        let u = !1,
            d;
        if (X(c !== null, "rerunTransactionsUnderNode_: relativePath should not be null."), l.status === 4) u = !0, d = l.abortReason, s = s.concat(Aa(e.serverSyncTree_, l.currentWriteId, !0));
        else if (l.status === 0)
            if (l.retryCount >= kG) u = !0, d = "maxretry", s = s.concat(Aa(e.serverSyncTree_, l.currentWriteId, !0));
            else {
                const f = OM(e, l.path, o);
                l.currentInputSnapshot = f;
                const h = t[a].update(f.val());
                if (h !== void 0) {
                    LS("transaction failed: Data returned ", h, l.path);
                    let p = bn(h);
                    typeof h == "object" && h != null && Pi(h, ".priority") || (p = p.updatePriority(f.getPriority()));
                    const g = l.currentWriteId,
                        y = FS(e),
                        _ = SM(p, f, y);
                    l.currentOutputSnapshotRaw = p, l.currentOutputSnapshotResolved = _, l.currentWriteId = RM(e), o.splice(o.indexOf(g), 1), s = s.concat(_M(e.serverSyncTree_, l.path, _, l.currentWriteId, l.applyLocally)), s = s.concat(Aa(e.serverSyncTree_, g, !0))
                } else u = !0, d = "nodata", s = s.concat(Aa(e.serverSyncTree_, l.currentWriteId, !0))
            }
        Fs(e.eventQueue_, n, s), s = [], u && (t[a].status = 2, function(f) {
            setTimeout(f, Math.floor(0))
        }(t[a].unwatcher), t[a].onComplete && (d === "nodata" ? r.push(() => t[a].onComplete(null, !1, t[a].currentInputSnapshot)) : r.push(() => t[a].onComplete(new Error(d), !1, null))))
    }
    Ky(e, e.transactionQueueTree_);
    for (let a = 0; a < r.length; a++) Gu(r[a]);
    BS(e, e.transactionQueueTree_)
}

function DM(e, t) {
    let n, r = e.transactionQueueTree_;
    for (n = He(t); n !== null && qu(r) === void 0;) r = MS(r, n), t = Tt(t), n = He(t);
    return r
}

function NM(e, t) {
    const n = [];
    return PM(e, t, n), n.sort((r, s) => r.order - s.order), n
}

function PM(e, t, n) {
    const r = qu(t);
    if (r)
        for (let s = 0; s < r.length; s++) n.push(r[s]);
    Gy(t, s => {
        PM(e, s, n)
    })
}

function Ky(e, t) {
    const n = qu(t);
    if (n) {
        let r = 0;
        for (let s = 0; s < n.length; s++) n[s].status !== 2 && (n[r] = n[s], r++);
        n.length = r, TM(t, n.length > 0 ? n : void 0)
    }
    Gy(t, r => {
        Ky(e, r)
    })
}

function MM(e, t) {
    const n = ep(DM(e, t)),
        r = MS(e.transactionQueueTree_, t);
    return hG(r, s => {
        Xb(e, s)
    }), Xb(e, r), kM(r, s => {
        Xb(e, s)
    }), n
}

function Xb(e, t) {
    const n = qu(t);
    if (n) {
        const r = [];
        let s = [],
            i = -1;
        for (let o = 0; o < n.length; o++) n[o].status === 3 || (n[o].status === 1 ? (X(i === o - 1, "All SENT items should be at beginning of queue."), i = o, n[o].status = 3, n[o].abortReason = "set") : (X(n[o].status === 0, "Unexpected transaction status in abort"), n[o].unwatcher(), s = s.concat(Aa(e.serverSyncTree_, n[o].currentWriteId, !0)), n[o].onComplete && r.push(n[o].onComplete.bind(null, new Error("set"), !1, null))));
        i === -1 ? TM(t, void 0) : n.length = i + 1, Fs(e.eventQueue_, ep(t), s);
        for (let o = 0; o < r.length; o++) Gu(r[o])
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function FG(e) {
    let t = "";
    const n = e.split("/");
    for (let r = 0; r < n.length; r++)
        if (n[r].length > 0) {
            let s = n[r];
            try {
                s = decodeURIComponent(s.replace(/\+/g, " "))
            } catch {}
            t += "/" + s
        }
    return t
}

function UG(e) {
    const t = {};
    e.charAt(0) === "?" && (e = e.substring(1));
    for (const n of e.split("&")) {
        if (n.length === 0) continue;
        const r = n.split("=");
        r.length === 2 ? t[decodeURIComponent(r[0])] = decodeURIComponent(r[1]) : Sr(`Invalid query segment '${n}' in query '${e}'`)
    }
    return t
}
const _x = function(e, t) {
        const n = BG(e),
            r = n.namespace;
        n.domain === "firebase.com" && vi(n.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"), (!r || r === "undefined") && n.domain !== "localhost" && vi("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"), n.secure || Q6();
        const s = n.scheme === "ws" || n.scheme === "wss";
        return {
            repoInfo: new PP(n.host, n.secure, r, s, t, "", r !== n.subdomain),
            path: new wt(n.pathString)
        }
    },
    BG = function(e) {
        let t = "",
            n = "",
            r = "",
            s = "",
            i = "",
            o = !0,
            a = "https",
            l = 443;
        if (typeof e == "string") {
            let c = e.indexOf("//");
            c >= 0 && (a = e.substring(0, c - 1), e = e.substring(c + 2));
            let u = e.indexOf("/");
            u === -1 && (u = e.length);
            let d = e.indexOf("?");
            d === -1 && (d = e.length), t = e.substring(0, Math.min(u, d)), u < d && (s = FG(e.substring(u, d)));
            const f = UG(e.substring(Math.min(e.length, d)));
            c = t.indexOf(":"), c >= 0 ? (o = a === "https" || a === "wss", l = parseInt(t.substring(c + 1), 10)) : c = t.length;
            const h = t.slice(0, c);
            if (h.toLowerCase() === "localhost") n = "localhost";
            else if (h.split(".").length <= 2) n = h;
            else {
                const p = t.indexOf(".");
                r = t.substring(0, p).toLowerCase(), n = t.substring(p + 1), i = r
            }
            "ns" in f && (i = f.ns)
        }
        return {
            host: t,
            port: l,
            domain: n,
            subdomain: r,
            secure: o,
            scheme: a,
            pathString: s,
            namespace: i
        }
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VG {
    constructor(t, n, r, s) {
        this.eventType = t, this.eventRegistration = n, this.snapshot = r, this.prevName = s
    }
    getPath() {
        const t = this.snapshot.ref;
        return this.eventType === "value" ? t._path : t.parent._path
    }
    getEventType() {
        return this.eventType
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this)
    }
    toString() {
        return this.getPath().toString() + ":" + this.eventType + ":" + rn(this.snapshot.exportVal())
    }
}
class HG {
    constructor(t, n, r) {
        this.eventRegistration = t, this.error = n, this.path = r
    }
    getPath() {
        return this.path
    }
    getEventType() {
        return "cancel"
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this)
    }
    toString() {
        return this.path.toString() + ":cancel"
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jG {
    constructor(t, n) {
        this.snapshotCallback = t, this.cancelCallback = n
    }
    onValue(t, n) {
        this.snapshotCallback.call(null, t, n)
    }
    onCancel(t) {
        return X(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback"), this.cancelCallback.call(null, t)
    }
    get hasCancelCallback() {
        return !!this.cancelCallback
    }
    matches(t) {
        return this.snapshotCallback === t.snapshotCallback || this.snapshotCallback.userCallback !== void 0 && this.snapshotCallback.userCallback === t.snapshotCallback.userCallback && this.snapshotCallback.context === t.snapshotCallback.context
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VS {
    constructor(t, n, r, s) {
        this._repo = t, this._path = n, this._queryParams = r, this._orderByCalled = s
    }
    get key() {
        return Be(this._path) ? null : zP(this._path)
    }
    get ref() {
        return new Mi(this._repo, this._path)
    }
    get _queryIdentifier() {
        const t = nx(this._queryParams),
            n = pS(t);
        return n === "{}" ? "default" : n
    }
    get _queryObject() {
        return nx(this._queryParams)
    }
    isEqual(t) {
        if (t = st(t), !(t instanceof VS)) return !1;
        const n = this._repo === t._repo,
            r = qP(this._path, t._path),
            s = this._queryIdentifier === t._queryIdentifier;
        return n && r && s
    }
    toJSON() {
        return this.toString()
    }
    toString() {
        return this._repo.toString() + N4(this._path)
    }
}
class Mi extends VS {
    constructor(t, n) {
        super(t, n, new wS, !1)
    }
    get parent() {
        const t = GP(this._path);
        return t === null ? null : new Mi(this._repo, t)
    }
    get root() {
        let t = this;
        for (; t.parent !== null;) t = t.parent;
        return t
    }
}
class qf {
    constructor(t, n, r) {
        this._node = t, this.ref = n, this._index = r
    }
    get priority() {
        return this._node.getPriority().val()
    }
    get key() {
        return this.ref.key
    }
    get size() {
        return this._node.numChildren()
    }
    child(t) {
        const n = new wt(t),
            r = Qg(this.ref, t);
        return new qf(this._node.getChild(n), r, jt)
    }
    exists() {
        return !this._node.isEmpty()
    }
    exportVal() {
        return this._node.val(!0)
    }
    forEach(t) {
        return this._node.isLeafNode() ? !1 : !!this._node.forEachChild(this._index, (r, s) => t(new qf(s, Qg(this.ref, r), jt)))
    }
    hasChild(t) {
        const n = new wt(t);
        return !this._node.getChild(n).isEmpty()
    }
    hasChildren() {
        return this._node.isLeafNode() ? !1 : !this._node.isEmpty()
    }
    toJSON() {
        return this.exportVal()
    }
    val() {
        return this._node.val()
    }
}

function LM(e, t) {
    return e = st(e), e._checkNotDeleted("ref"), t !== void 0 ? Qg(e._root, t) : e._root
}

function Qg(e, t) {
    return e = st(e), He(e._path) === null ? vG("child", "path", t, !1) : CM("child", "path", t, !1), new Mi(e._repo, sn(e._path, t))
}

function zG(e, t) {
    e = st(e), bG("set", e._path), yG("set", t, e._path, !1);
    const n = new Mo;
    return OG(e._repo, e._path, t, null, n.wrapCallback(() => {})), n.promise
}

function WG(e) {
    e = st(e);
    const t = new jG(() => {}),
        n = new HS(t);
    return RG(e._repo, e, n).then(r => new qf(r, new Mi(e._repo, e._path), e._queryParams.getIndex()))
}
class HS {
    constructor(t) {
        this.callbackContext = t
    }
    respondsTo(t) {
        return t === "value"
    }
    createEvent(t, n) {
        const r = n._queryParams.getIndex();
        return new VG("value", this, new qf(t.snapshotNode, new Mi(n._repo, n._path), r))
    }
    getEventRunner(t) {
        return t.getEventType() === "cancel" ? () => this.callbackContext.onCancel(t.error) : () => this.callbackContext.onValue(t.snapshot, null)
    }
    createCancelEvent(t, n) {
        return this.callbackContext.hasCancelCallback ? new HG(this, t, n) : null
    }
    matches(t) {
        return t instanceof HS ? !t.callbackContext || !this.callbackContext ? !0 : t.callbackContext.matches(this.callbackContext) : !1
    }
    hasAnyCallback() {
        return this.callbackContext !== null
    }
}
zW(Mi);
KW(Mi);
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const GG = "FIREBASE_DATABASE_EMULATOR_HOST",
    Uw = {};
let qG = !1;

function YG(e, t, n, r) {
    e.repoInfo_ = new PP(`${t}:${n}`, !1, e.repoInfo_.namespace, e.repoInfo_.webSocketOnly, e.repoInfo_.nodeAdmin, e.repoInfo_.persistenceKey, e.repoInfo_.includeNamespaceInQueryParams, !0), r && (e.authTokenProvider_ = r)
}

function KG(e, t, n, r, s) {
    let i = r || e.options.databaseURL;
    i === void 0 && (e.options.projectId || vi("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."), Un("Using default host for project ", e.options.projectId), i = `${e.options.projectId}-default-rtdb.firebaseio.com`);
    let o = _x(i, s),
        a = o.repoInfo,
        l, c;
    typeof process != "undefined" && process.env && (c = process.env[GG]), c ? (l = !0, i = `http://${c}?ns=${a.namespace}`, o = _x(i, s), a = o.repoInfo) : l = !o.repoInfo.secure;
    const u = s && l ? new Tc(Tc.OWNER) : new l4(e.name, e.options, t);
    wG("Invalid Firebase Database URL", o), Be(o.path) || vi("Database URL must point to the root of a Firebase Database (not including a child path).");
    const d = QG(a, e, u, new a4(e.name, n));
    return new JG(d, e)
}

function XG(e, t) {
    const n = Uw[t];
    (!n || n[e.key] !== e) && vi(`Database ${t}(${e.repoInfo_}) has already been deleted.`), NG(e), delete n[e.key]
}

function QG(e, t, n, r) {
    let s = Uw[t.name];
    s || (s = {}, Uw[t.name] = s);
    let i = s[e.toURLString()];
    return i && vi("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call."), i = new IG(e, qG, n, r), s[e.toURLString()] = i, i
}
class JG {
    constructor(t, n) {
        this._repoInternal = t, this.app = n, this.type = "database", this._instanceStarted = !1
    }
    get _repo() {
        return this._instanceStarted || (xG(this._repoInternal, this.app.options.appId, this.app.options.databaseAuthVariableOverride), this._instanceStarted = !0), this._repoInternal
    }
    get _root() {
        return this._rootInternal || (this._rootInternal = new Mi(this._repo, nt())), this._rootInternal
    }
    _delete() {
        return this._rootInternal !== null && (XG(this._repo, this.app.name), this._repoInternal = null, this._rootInternal = null), Promise.resolve()
    }
    _checkNotDeleted(t) {
        this._rootInternal === null && vi("Cannot call " + t + " on a deleted database.")
    }
}

function ZG(e = Il(), t) {
    const n = vs(e, "database").getImmediate({
        identifier: t
    });
    if (!n._instanceStarted) {
        const r = uS("database");
        r && eq(n, ...r)
    }
    return n
}

function eq(e, t, n, r = {}) {
    e = st(e), e._checkNotDeleted("useEmulator"), e._instanceStarted && vi("Cannot call useEmulator() after instance has already been initialized.");
    const s = e._repoInternal;
    let i;
    if (s.repoInfo_.nodeAdmin) r.mockUserToken && vi('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".'), i = new Tc(Tc.OWNER);
    else if (r.mockUserToken) {
        const o = typeof r.mockUserToken == "string" ? r.mockUserToken : lP(r.mockUserToken, e.app.options.projectId);
        i = new Tc(o)
    }
    YG(s, t, n, i)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function tq(e) {
    G6(ia), dr(new Kn("database", (t, {
        instanceIdentifier: n
    }) => {
        const r = t.getProvider("app").getImmediate(),
            s = t.getProvider("auth-internal"),
            i = t.getProvider("app-check-internal");
        return KG(r, s, i, n)
    }, "PUBLIC").setMultipleInstances(!0)), cn(UI, BI, e), cn(UI, BI, "esm2017")
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nq = {
    ".sv": "timestamp"
};

function rq() {
    return nq
}
ci.prototype.simpleListen = function(e, t) {
    this.sendRequest("q", {
        p: e
    }, t)
};
ci.prototype.echo = function(e, t) {
    this.sendRequest("echo", {
        d: e
    }, t)
};
tq();
var sq = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {},
    pe, jS = jS || {},
    Ie = sq || self;

function Jg() {}

function Xy(e) {
    var t = typeof e;
    return t = t != "object" ? t : e ? Array.isArray(e) ? "array" : t : "null", t == "array" || t == "object" && typeof e.length == "number"
}

function tp(e) {
    var t = typeof e;
    return t == "object" && e != null || t == "function"
}

function iq(e) {
    return Object.prototype.hasOwnProperty.call(e, Qb) && e[Qb] || (e[Qb] = ++oq)
}
var Qb = "closure_uid_" + (1e9 * Math.random() >>> 0),
    oq = 0;

function aq(e, t, n) {
    return e.call.apply(e.bind, arguments)
}

function lq(e, t, n) {
    if (!e) throw Error();
    if (2 < arguments.length) {
        var r = Array.prototype.slice.call(arguments, 2);
        return function() {
            var s = Array.prototype.slice.call(arguments);
            return Array.prototype.unshift.apply(s, r), e.apply(t, s)
        }
    }
    return function() {
        return e.apply(t, arguments)
    }
}

function zn(e, t, n) {
    return Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? zn = aq : zn = lq, zn.apply(null, arguments)
}

function Xp(e, t) {
    var n = Array.prototype.slice.call(arguments, 1);
    return function() {
        var r = n.slice();
        return r.push.apply(r, arguments), e.apply(this, r)
    }
}

function Pn(e, t) {
    function n() {}
    n.prototype = t.prototype, e.X = t.prototype, e.prototype = new n, e.prototype.constructor = e, e.Wb = function(r, s, i) {
        for (var o = Array(arguments.length - 2), a = 2; a < arguments.length; a++) o[a - 2] = arguments[a];
        return t.prototype[s].apply(r, o)
    }
}

function oa() {
    this.s = this.s, this.o = this.o
}
var cq = 0;
oa.prototype.s = !1;
oa.prototype.na = function() {
    !this.s && (this.s = !0, this.M(), cq != 0) && iq(this)
};
oa.prototype.M = function() {
    if (this.o)
        for (; this.o.length;) this.o.shift()()
};
const FM = Array.prototype.indexOf ? function(e, t) {
    return Array.prototype.indexOf.call(e, t, void 0)
} : function(e, t) {
    if (typeof e == "string") return typeof t != "string" || t.length != 1 ? -1 : e.indexOf(t, 0);
    for (let n = 0; n < e.length; n++)
        if (n in e && e[n] === t) return n;
    return -1
};

function zS(e) {
    const t = e.length;
    if (0 < t) {
        const n = Array(t);
        for (let r = 0; r < t; r++) n[r] = e[r];
        return n
    }
    return []
}

function yx(e, t) {
    for (let n = 1; n < arguments.length; n++) {
        const r = arguments[n];
        if (Xy(r)) {
            const s = e.length || 0,
                i = r.length || 0;
            e.length = s + i;
            for (let o = 0; o < i; o++) e[s + o] = r[o]
        } else e.push(r)
    }
}

function Wn(e, t) {
    this.type = e, this.g = this.target = t, this.defaultPrevented = !1
}
Wn.prototype.h = function() {
    this.defaultPrevented = !0
};
var uq = function() {
    if (!Ie.addEventListener || !Object.defineProperty) return !1;
    var e = !1,
        t = Object.defineProperty({}, "passive", {
            get: function() {
                e = !0
            }
        });
    try {
        Ie.addEventListener("test", Jg, t), Ie.removeEventListener("test", Jg, t)
    } catch {}
    return e
}();

function Zg(e) {
    return /^[\s\xa0]*$/.test(e)
}
var vx = String.prototype.trim ? function(e) {
    return e.trim()
} : function(e) {
    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(e)[1]
};

function Jb(e, t) {
    return e < t ? -1 : e > t ? 1 : 0
}

function Qy() {
    var e = Ie.navigator;
    return e && (e = e.userAgent) ? e : ""
}

function ks(e) {
    return Qy().indexOf(e) != -1
}

function WS(e) {
    return WS[" "](e), e
}
WS[" "] = Jg;

function dq(e) {
    var t = pq;
    return Object.prototype.hasOwnProperty.call(t, 9) ? t[9] : t[9] = e(9)
}
var fq = ks("Opera"),
    nu = ks("Trident") || ks("MSIE"),
    UM = ks("Edge"),
    Bw = UM || nu,
    BM = ks("Gecko") && !(Qy().toLowerCase().indexOf("webkit") != -1 && !ks("Edge")) && !(ks("Trident") || ks("MSIE")) && !ks("Edge"),
    hq = Qy().toLowerCase().indexOf("webkit") != -1 && !ks("Edge");

function VM() {
    var e = Ie.document;
    return e ? e.documentMode : void 0
}
var e_;
e: {
    var Zb = "",
        e0 = function() {
            var e = Qy();
            if (BM) return /rv:([^\);]+)(\)|;)/.exec(e);
            if (UM) return /Edge\/([\d\.]+)/.exec(e);
            if (nu) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(e);
            if (hq) return /WebKit\/(\S+)/.exec(e);
            if (fq) return /(?:Version)[ \/]?(\S+)/.exec(e)
        }();
    if (e0 && (Zb = e0 ? e0[1] : ""), nu) {
        var t0 = VM();
        if (t0 != null && t0 > parseFloat(Zb)) {
            e_ = String(t0);
            break e
        }
    }
    e_ = Zb
}
var pq = {};

function mq() {
    return dq(function() {
        let e = 0;
        const t = vx(String(e_)).split("."),
            n = vx("9").split("."),
            r = Math.max(t.length, n.length);
        for (let o = 0; e == 0 && o < r; o++) {
            var s = t[o] || "",
                i = n[o] || "";
            do {
                if (s = /(\d*)(\D*)(.*)/.exec(s) || ["", "", "", ""], i = /(\d*)(\D*)(.*)/.exec(i) || ["", "", "", ""], s[0].length == 0 && i[0].length == 0) break;
                e = Jb(s[1].length == 0 ? 0 : parseInt(s[1], 10), i[1].length == 0 ? 0 : parseInt(i[1], 10)) || Jb(s[2].length == 0, i[2].length == 0) || Jb(s[2], i[2]), s = s[3], i = i[3]
            } while (e == 0)
        }
        return 0 <= e
    })
}
var Vw;
if (Ie.document && nu) {
    var bx = VM();
    Vw = bx || parseInt(e_, 10) || void 0
} else Vw = void 0;
var gq = Vw;

function Yf(e, t) {
    if (Wn.call(this, e ? e.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, e) {
        var n = this.type = e.type,
            r = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null;
        if (this.target = e.target || e.srcElement, this.g = t, t = e.relatedTarget) {
            if (BM) {
                e: {
                    try {
                        WS(t.nodeName);
                        var s = !0;
                        break e
                    } catch {}
                    s = !1
                }
                s || (t = null)
            }
        } else n == "mouseover" ? t = e.fromElement : n == "mouseout" && (t = e.toElement);
        this.relatedTarget = t, r ? (this.clientX = r.clientX !== void 0 ? r.clientX : r.pageX, this.clientY = r.clientY !== void 0 ? r.clientY : r.pageY, this.screenX = r.screenX || 0, this.screenY = r.screenY || 0) : (this.clientX = e.clientX !== void 0 ? e.clientX : e.pageX, this.clientY = e.clientY !== void 0 ? e.clientY : e.pageY, this.screenX = e.screenX || 0, this.screenY = e.screenY || 0), this.button = e.button, this.key = e.key || "", this.ctrlKey = e.ctrlKey, this.altKey = e.altKey, this.shiftKey = e.shiftKey, this.metaKey = e.metaKey, this.pointerId = e.pointerId || 0, this.pointerType = typeof e.pointerType == "string" ? e.pointerType : _q[e.pointerType] || "", this.state = e.state, this.i = e, e.defaultPrevented && Yf.X.h.call(this)
    }
}
Pn(Yf, Wn);
var _q = {
    2: "touch",
    3: "pen",
    4: "mouse"
};
Yf.prototype.h = function() {
    Yf.X.h.call(this);
    var e = this.i;
    e.preventDefault ? e.preventDefault() : e.returnValue = !1
};
var np = "closure_listenable_" + (1e6 * Math.random() | 0),
    yq = 0;

function vq(e, t, n, r, s) {
    this.listener = e, this.proxy = null, this.src = t, this.type = n, this.capture = !!r, this.ha = s, this.key = ++yq, this.ba = this.ea = !1
}

function Jy(e) {
    e.ba = !0, e.listener = null, e.proxy = null, e.src = null, e.ha = null
}

function GS(e, t, n) {
    for (const r in e) t.call(n, e[r], r, e)
}

function HM(e) {
    const t = {};
    for (const n in e) t[n] = e[n];
    return t
}
const wx = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");

function jM(e, t) {
    let n, r;
    for (let s = 1; s < arguments.length; s++) {
        r = arguments[s];
        for (n in r) e[n] = r[n];
        for (let i = 0; i < wx.length; i++) n = wx[i], Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
    }
}

function Zy(e) {
    this.src = e, this.g = {}, this.h = 0
}
Zy.prototype.add = function(e, t, n, r, s) {
    var i = e.toString();
    e = this.g[i], e || (e = this.g[i] = [], this.h++);
    var o = jw(e, t, r, s);
    return -1 < o ? (t = e[o], n || (t.ea = !1)) : (t = new vq(t, this.src, i, !!r, s), t.ea = n, e.push(t)), t
};

function Hw(e, t) {
    var n = t.type;
    if (n in e.g) {
        var r = e.g[n],
            s = FM(r, t),
            i;
        (i = 0 <= s) && Array.prototype.splice.call(r, s, 1), i && (Jy(t), e.g[n].length == 0 && (delete e.g[n], e.h--))
    }
}

function jw(e, t, n, r) {
    for (var s = 0; s < e.length; ++s) {
        var i = e[s];
        if (!i.ba && i.listener == t && i.capture == !!n && i.ha == r) return s
    }
    return -1
}
var qS = "closure_lm_" + (1e6 * Math.random() | 0),
    n0 = {};

function zM(e, t, n, r, s) {
    if (r && r.once) return GM(e, t, n, r, s);
    if (Array.isArray(t)) {
        for (var i = 0; i < t.length; i++) zM(e, t[i], n, r, s);
        return null
    }
    return n = XS(n), e && e[np] ? e.N(t, n, tp(r) ? !!r.capture : !!r, s) : WM(e, t, n, !1, r, s)
}

function WM(e, t, n, r, s, i) {
    if (!t) throw Error("Invalid event type");
    var o = tp(s) ? !!s.capture : !!s,
        a = KS(e);
    if (a || (e[qS] = a = new Zy(e)), n = a.add(t, n, r, o, i), n.proxy) return n;
    if (r = bq(), n.proxy = r, r.src = e, r.listener = n, e.addEventListener) uq || (s = o), s === void 0 && (s = !1), e.addEventListener(t.toString(), r, s);
    else if (e.attachEvent) e.attachEvent(YM(t.toString()), r);
    else if (e.addListener && e.removeListener) e.addListener(r);
    else throw Error("addEventListener and attachEvent are unavailable.");
    return n
}

function bq() {
    function e(n) {
        return t.call(e.src, e.listener, n)
    }
    const t = wq;
    return e
}

function GM(e, t, n, r, s) {
    if (Array.isArray(t)) {
        for (var i = 0; i < t.length; i++) GM(e, t[i], n, r, s);
        return null
    }
    return n = XS(n), e && e[np] ? e.O(t, n, tp(r) ? !!r.capture : !!r, s) : WM(e, t, n, !0, r, s)
}

function qM(e, t, n, r, s) {
    if (Array.isArray(t))
        for (var i = 0; i < t.length; i++) qM(e, t[i], n, r, s);
    else r = tp(r) ? !!r.capture : !!r, n = XS(n), e && e[np] ? (e = e.i, t = String(t).toString(), t in e.g && (i = e.g[t], n = jw(i, n, r, s), -1 < n && (Jy(i[n]), Array.prototype.splice.call(i, n, 1), i.length == 0 && (delete e.g[t], e.h--)))) : e && (e = KS(e)) && (t = e.g[t.toString()], e = -1, t && (e = jw(t, n, r, s)), (n = -1 < e ? t[e] : null) && YS(n))
}

function YS(e) {
    if (typeof e != "number" && e && !e.ba) {
        var t = e.src;
        if (t && t[np]) Hw(t.i, e);
        else {
            var n = e.type,
                r = e.proxy;
            t.removeEventListener ? t.removeEventListener(n, r, e.capture) : t.detachEvent ? t.detachEvent(YM(n), r) : t.addListener && t.removeListener && t.removeListener(r), (n = KS(t)) ? (Hw(n, e), n.h == 0 && (n.src = null, t[qS] = null)) : Jy(e)
        }
    }
}

function YM(e) {
    return e in n0 ? n0[e] : n0[e] = "on" + e
}

function wq(e, t) {
    if (e.ba) e = !0;
    else {
        t = new Yf(t, this);
        var n = e.listener,
            r = e.ha || e.src;
        e.ea && YS(e), e = n.call(r, t)
    }
    return e
}

function KS(e) {
    return e = e[qS], e instanceof Zy ? e : null
}
var r0 = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);

function XS(e) {
    return typeof e == "function" ? e : (e[r0] || (e[r0] = function(t) {
        return e.handleEvent(t)
    }), e[r0])
}

function Tn() {
    oa.call(this), this.i = new Zy(this), this.P = this, this.I = null
}
Pn(Tn, oa);
Tn.prototype[np] = !0;
Tn.prototype.removeEventListener = function(e, t, n, r) {
    qM(this, e, t, n, r)
};

function Dn(e, t) {
    var n, r = e.I;
    if (r)
        for (n = []; r; r = r.I) n.push(r);
    if (e = e.P, r = t.type || t, typeof t == "string") t = new Wn(t, e);
    else if (t instanceof Wn) t.target = t.target || e;
    else {
        var s = t;
        t = new Wn(r, e), jM(t, s)
    }
    if (s = !0, n)
        for (var i = n.length - 1; 0 <= i; i--) {
            var o = t.g = n[i];
            s = Qp(o, r, !0, t) && s
        }
    if (o = t.g = e, s = Qp(o, r, !0, t) && s, s = Qp(o, r, !1, t) && s, n)
        for (i = 0; i < n.length; i++) o = t.g = n[i], s = Qp(o, r, !1, t) && s
}
Tn.prototype.M = function() {
    if (Tn.X.M.call(this), this.i) {
        var e = this.i,
            t;
        for (t in e.g) {
            for (var n = e.g[t], r = 0; r < n.length; r++) Jy(n[r]);
            delete e.g[t], e.h--
        }
    }
    this.I = null
};
Tn.prototype.N = function(e, t, n, r) {
    return this.i.add(String(e), t, !1, n, r)
};
Tn.prototype.O = function(e, t, n, r) {
    return this.i.add(String(e), t, !0, n, r)
};

function Qp(e, t, n, r) {
    if (t = e.i.g[String(t)], !t) return !0;
    t = t.concat();
    for (var s = !0, i = 0; i < t.length; ++i) {
        var o = t[i];
        if (o && !o.ba && o.capture == n) {
            var a = o.listener,
                l = o.ha || o.src;
            o.ea && Hw(e.i, o), s = a.call(l, r) !== !1 && s
        }
    }
    return s && !r.defaultPrevented
}
var QS = Ie.JSON.stringify;

function Eq() {
    var e = QM;
    let t = null;
    return e.g && (t = e.g, e.g = e.g.next, e.g || (e.h = null), t.next = null), t
}
class Sq {
    constructor() {
        this.h = this.g = null
    }
    add(t, n) {
        const r = KM.get();
        r.set(t, n), this.h ? this.h.next = r : this.g = r, this.h = r
    }
}
var KM = new class {
    constructor(e, t) {
        this.i = e, this.j = t, this.h = 0, this.g = null
    }
    get() {
        let e;
        return 0 < this.h ? (this.h--, e = this.g, this.g = e.next, e.next = null) : e = this.i(), e
    }
}(() => new Tq, e => e.reset());
class Tq {
    constructor() {
        this.next = this.g = this.h = null
    }
    set(t, n) {
        this.h = t, this.g = n, this.next = null
    }
    reset() {
        this.next = this.g = this.h = null
    }
}

function $q(e) {
    Ie.setTimeout(() => {
        throw e
    }, 0)
}

function XM(e, t) {
    zw || kq(), Ww || (zw(), Ww = !0), QM.add(e, t)
}
var zw;

function kq() {
    var e = Ie.Promise.resolve(void 0);
    zw = function() {
        e.then(Iq)
    }
}
var Ww = !1,
    QM = new Sq;

function Iq() {
    for (var e; e = Eq();) {
        try {
            e.h.call(e.g)
        } catch (n) {
            $q(n)
        }
        var t = KM;
        t.j(e), 100 > t.h && (t.h++, e.next = t.g, t.g = e)
    }
    Ww = !1
}

function ev(e, t) {
    Tn.call(this), this.h = e || 1, this.g = t || Ie, this.j = zn(this.lb, this), this.l = Date.now()
}
Pn(ev, Tn);
pe = ev.prototype;
pe.ca = !1;
pe.R = null;
pe.lb = function() {
    if (this.ca) {
        var e = Date.now() - this.l;
        0 < e && e < .8 * this.h ? this.R = this.g.setTimeout(this.j, this.h - e) : (this.R && (this.g.clearTimeout(this.R), this.R = null), Dn(this, "tick"), this.ca && (JS(this), this.start()))
    }
};
pe.start = function() {
    this.ca = !0, this.R || (this.R = this.g.setTimeout(this.j, this.h), this.l = Date.now())
};

function JS(e) {
    e.ca = !1, e.R && (e.g.clearTimeout(e.R), e.R = null)
}
pe.M = function() {
    ev.X.M.call(this), JS(this), delete this.g
};

function ZS(e, t, n) {
    if (typeof e == "function") n && (e = zn(e, n));
    else if (e && typeof e.handleEvent == "function") e = zn(e.handleEvent, e);
    else throw Error("Invalid listener argument");
    return 2147483647 < Number(t) ? -1 : Ie.setTimeout(e, t || 0)
}

function JM(e) {
    e.g = ZS(() => {
        e.g = null, e.i && (e.i = !1, JM(e))
    }, e.j);
    const t = e.h;
    e.h = null, e.m.apply(null, t)
}
class xq extends oa {
    constructor(t, n) {
        super(), this.m = t, this.j = n, this.h = null, this.i = !1, this.g = null
    }
    l(t) {
        this.h = arguments, this.g ? this.i = !0 : JM(this)
    }
    M() {
        super.M(), this.g && (Ie.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null)
    }
}

function Kf(e) {
    oa.call(this), this.h = e, this.g = {}
}
Pn(Kf, oa);
var Ex = [];

function ZM(e, t, n, r) {
    Array.isArray(n) || (n && (Ex[0] = n.toString()), n = Ex);
    for (var s = 0; s < n.length; s++) {
        var i = zM(t, n[s], r || e.handleEvent, !1, e.h || e);
        if (!i) break;
        e.g[i.key] = i
    }
}

function eL(e) {
    GS(e.g, function(t, n) {
        this.g.hasOwnProperty(n) && YS(t)
    }, e), e.g = {}
}
Kf.prototype.M = function() {
    Kf.X.M.call(this), eL(this)
};
Kf.prototype.handleEvent = function() {
    throw Error("EventHandler.handleEvent not implemented")
};

function tv() {
    this.g = !0
}
tv.prototype.Aa = function() {
    this.g = !1
};

function Cq(e, t, n, r, s, i) {
    e.info(function() {
        if (e.g)
            if (i)
                for (var o = "", a = i.split("&"), l = 0; l < a.length; l++) {
                    var c = a[l].split("=");
                    if (1 < c.length) {
                        var u = c[0];
                        c = c[1];
                        var d = u.split("_");
                        o = 2 <= d.length && d[1] == "type" ? o + (u + "=" + c + "&") : o + (u + "=redacted&")
                    }
                } else o = null;
            else o = i;
        return "XMLHTTP REQ (" + r + ") [attempt " + s + "]: " + t + `
` + n + `
` + o
    })
}

function Aq(e, t, n, r, s, i, o) {
    e.info(function() {
        return "XMLHTTP RESP (" + r + ") [ attempt " + s + "]: " + t + `
` + n + `
` + i + " " + o
    })
}

function _c(e, t, n, r) {
    e.info(function() {
        return "XMLHTTP TEXT (" + t + "): " + Oq(e, n) + (r ? " " + r : "")
    })
}

function Rq(e, t) {
    e.info(function() {
        return "TIMEOUT: " + t
    })
}
tv.prototype.info = function() {};

function Oq(e, t) {
    if (!e.g) return t;
    if (!t) return null;
    try {
        var n = JSON.parse(t);
        if (n) {
            for (e = 0; e < n.length; e++)
                if (Array.isArray(n[e])) {
                    var r = n[e];
                    if (!(2 > r.length)) {
                        var s = r[1];
                        if (Array.isArray(s) && !(1 > s.length)) {
                            var i = s[0];
                            if (i != "noop" && i != "stop" && i != "close")
                                for (var o = 1; o < s.length; o++) s[o] = ""
                        }
                    }
                }
        }
        return QS(n)
    } catch {
        return t
    }
}
var Cl = {},
    Sx = null;

function nv() {
    return Sx = Sx || new Tn
}
Cl.Pa = "serverreachability";

function tL(e) {
    Wn.call(this, Cl.Pa, e)
}
Pn(tL, Wn);

function Xf(e) {
    const t = nv();
    Dn(t, new tL(t))
}
Cl.STAT_EVENT = "statevent";

function nL(e, t) {
    Wn.call(this, Cl.STAT_EVENT, e), this.stat = t
}
Pn(nL, Wn);

function ar(e) {
    const t = nv();
    Dn(t, new nL(t, e))
}
Cl.Qa = "timingevent";

function rL(e, t) {
    Wn.call(this, Cl.Qa, e), this.size = t
}
Pn(rL, Wn);

function rp(e, t) {
    if (typeof e != "function") throw Error("Fn must not be null and must be a function");
    return Ie.setTimeout(function() {
        e()
    }, t)
}
var rv = {
        NO_ERROR: 0,
        mb: 1,
        zb: 2,
        yb: 3,
        tb: 4,
        xb: 5,
        Ab: 6,
        Ma: 7,
        TIMEOUT: 8,
        Db: 9
    },
    sL = {
        rb: "complete",
        Nb: "success",
        Na: "error",
        Ma: "abort",
        Fb: "ready",
        Gb: "readystatechange",
        TIMEOUT: "timeout",
        Bb: "incrementaldata",
        Eb: "progress",
        ub: "downloadprogress",
        Vb: "uploadprogress"
    };

function eT() {}
eT.prototype.h = null;

function Tx(e) {
    return e.h || (e.h = e.i())
}

function iL() {}
var sp = {
    OPEN: "a",
    qb: "b",
    Na: "c",
    Cb: "d"
};

function tT() {
    Wn.call(this, "d")
}
Pn(tT, Wn);

function nT() {
    Wn.call(this, "c")
}
Pn(nT, Wn);
var Gw;

function sv() {}
Pn(sv, eT);
sv.prototype.g = function() {
    return new XMLHttpRequest
};
sv.prototype.i = function() {
    return {}
};
Gw = new sv;

function ip(e, t, n, r) {
    this.l = e, this.j = t, this.m = n, this.U = r || 1, this.S = new Kf(this), this.O = Dq, e = Bw ? 125 : void 0, this.T = new ev(e), this.H = null, this.i = !1, this.s = this.A = this.v = this.K = this.F = this.V = this.B = null, this.D = [], this.g = null, this.C = 0, this.o = this.u = null, this.Y = -1, this.I = !1, this.N = 0, this.L = null, this.$ = this.J = this.Z = this.P = !1, this.h = new oL
}

function oL() {
    this.i = null, this.g = "", this.h = !1
}
var Dq = 45e3,
    qw = {},
    t_ = {};
pe = ip.prototype;
pe.setTimeout = function(e) {
    this.O = e
};

function Yw(e, t, n) {
    e.K = 1, e.v = ov(bi(t)), e.s = n, e.P = !0, aL(e, null)
}

function aL(e, t) {
    e.F = Date.now(), op(e), e.A = bi(e.v);
    var n = e.A,
        r = e.U;
    Array.isArray(r) || (r = [String(r)]), mL(n.i, "t", r), e.C = 0, n = e.l.H, e.h = new oL, e.g = ML(e.l, n ? t : null, !e.s), 0 < e.N && (e.L = new xq(zn(e.La, e, e.g), e.N)), ZM(e.S, e.g, "readystatechange", e.ib), t = e.H ? HM(e.H) : {}, e.s ? (e.u || (e.u = "POST"), t["Content-Type"] = "application/x-www-form-urlencoded", e.g.da(e.A, e.u, e.s, t)) : (e.u = "GET", e.g.da(e.A, e.u, null, t)), Xf(), Cq(e.j, e.u, e.A, e.m, e.U, e.s)
}
pe.ib = function(e) {
    e = e.target;
    const t = this.L;
    t && oi(e) == 3 ? t.l() : this.La(e)
};
pe.La = function(e) {
    try {
        if (e == this.g) e: {
            const u = oi(this.g);
            var t = this.g.Ea();
            const d = this.g.aa();
            if (!(3 > u) && (u != 3 || Bw || this.g && (this.h.h || this.g.fa() || xx(this.g)))) {
                this.I || u != 4 || t == 7 || (t == 8 || 0 >= d ? Xf(3) : Xf(2)), iv(this);
                var n = this.g.aa();
                this.Y = n;
                t: if (lL(this)) {
                    var r = xx(this.g);
                    e = "";
                    var s = r.length,
                        i = oi(this.g) == 4;
                    if (!this.h.i) {
                        if (typeof TextDecoder == "undefined") {
                            Ra(this), Xd(this);
                            var o = "";
                            break t
                        }
                        this.h.i = new Ie.TextDecoder
                    }
                    for (t = 0; t < s; t++) this.h.h = !0, e += this.h.i.decode(r[t], {
                        stream: i && t == s - 1
                    });
                    r.splice(0, s), this.h.g += e, this.C = 0, o = this.h.g
                } else o = this.g.fa();
                if (this.i = n == 200, Aq(this.j, this.u, this.A, this.m, this.U, u, n), this.i) {
                    if (this.Z && !this.J) {
                        t: {
                            if (this.g) {
                                var a, l = this.g;
                                if ((a = l.g ? l.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !Zg(a)) {
                                    var c = a;
                                    break t
                                }
                            }
                            c = null
                        }
                        if (n = c) _c(this.j, this.m, n, "Initial handshake response via X-HTTP-Initial-Response"),
                        this.J = !0,
                        Kw(this, n);
                        else {
                            this.i = !1, this.o = 3, ar(12), Ra(this), Xd(this);
                            break e
                        }
                    }
                    this.P ? (cL(this, u, o), Bw && this.i && u == 3 && (ZM(this.S, this.T, "tick", this.hb), this.T.start())) : (_c(this.j, this.m, o, null), Kw(this, o)), u == 4 && Ra(this), this.i && !this.I && (u == 4 ? OL(this.l, this) : (this.i = !1, op(this)))
                } else n == 400 && 0 < o.indexOf("Unknown SID") ? (this.o = 3, ar(12)) : (this.o = 0, ar(13)), Ra(this), Xd(this)
            }
        }
    } catch {} finally {}
};

function lL(e) {
    return e.g ? e.u == "GET" && e.K != 2 && e.l.Da : !1
}

function cL(e, t, n) {
    let r = !0,
        s;
    for (; !e.I && e.C < n.length;)
        if (s = Nq(e, n), s == t_) {
            t == 4 && (e.o = 4, ar(14), r = !1), _c(e.j, e.m, null, "[Incomplete Response]");
            break
        } else if (s == qw) {
        e.o = 4, ar(15), _c(e.j, e.m, n, "[Invalid Chunk]"), r = !1;
        break
    } else _c(e.j, e.m, s, null), Kw(e, s);
    lL(e) && s != t_ && s != qw && (e.h.g = "", e.C = 0), t != 4 || n.length != 0 || e.h.h || (e.o = 1, ar(16), r = !1), e.i = e.i && r, r ? 0 < n.length && !e.$ && (e.$ = !0, t = e.l, t.g == e && t.$ && !t.K && (t.j.info("Great, no buffering proxy detected. Bytes received: " + n.length), cT(t), t.K = !0, ar(11))) : (_c(e.j, e.m, n, "[Invalid Chunked Response]"), Ra(e), Xd(e))
}
pe.hb = function() {
    if (this.g) {
        var e = oi(this.g),
            t = this.g.fa();
        this.C < t.length && (iv(this), cL(this, e, t), this.i && e != 4 && op(this))
    }
};

function Nq(e, t) {
    var n = e.C,
        r = t.indexOf(`
`, n);
    return r == -1 ? t_ : (n = Number(t.substring(n, r)), isNaN(n) ? qw : (r += 1, r + n > t.length ? t_ : (t = t.substr(r, n), e.C = r + n, t)))
}
pe.cancel = function() {
    this.I = !0, Ra(this)
};

function op(e) {
    e.V = Date.now() + e.O, uL(e, e.O)
}

function uL(e, t) {
    if (e.B != null) throw Error("WatchDog timer not null");
    e.B = rp(zn(e.gb, e), t)
}

function iv(e) {
    e.B && (Ie.clearTimeout(e.B), e.B = null)
}
pe.gb = function() {
    this.B = null;
    const e = Date.now();
    0 <= e - this.V ? (Rq(this.j, this.A), this.K != 2 && (Xf(), ar(17)), Ra(this), this.o = 2, Xd(this)) : uL(this, this.V - e)
};

function Xd(e) {
    e.l.G == 0 || e.I || OL(e.l, e)
}

function Ra(e) {
    iv(e);
    var t = e.L;
    t && typeof t.na == "function" && t.na(), e.L = null, JS(e.T), eL(e.S), e.g && (t = e.g, e.g = null, t.abort(), t.na())
}

function Kw(e, t) {
    try {
        var n = e.l;
        if (n.G != 0 && (n.g == e || Xw(n.h, e))) {
            if (!e.J && Xw(n.h, e) && n.G == 3) {
                try {
                    var r = n.Fa.g.parse(t)
                } catch {
                    r = null
                }
                if (Array.isArray(r) && r.length == 3) {
                    var s = r;
                    if (s[0] == 0) {
                        e: if (!n.u) {
                            if (n.g)
                                if (n.g.F + 3e3 < e.F) s_(n), cv(n);
                                else break e;
                            lT(n), ar(18)
                        }
                    }
                    else n.Ba = s[1], 0 < n.Ba - n.T && 37500 > s[2] && n.L && n.A == 0 && !n.v && (n.v = rp(zn(n.cb, n), 6e3));
                    if (1 >= yL(n.h) && n.ja) {
                        try {
                            n.ja()
                        } catch {}
                        n.ja = void 0
                    }
                } else Oa(n, 11)
            } else if ((e.J || n.g == e) && s_(n), !Zg(t))
                for (s = n.Fa.g.parse(t), t = 0; t < s.length; t++) {
                    let c = s[t];
                    if (n.T = c[0], c = c[1], n.G == 2)
                        if (c[0] == "c") {
                            n.I = c[1], n.ka = c[2];
                            const u = c[3];
                            u != null && (n.ma = u, n.j.info("VER=" + n.ma));
                            const d = c[4];
                            d != null && (n.Ca = d, n.j.info("SVER=" + n.Ca));
                            const f = c[5];
                            f != null && typeof f == "number" && 0 < f && (r = 1.5 * f, n.J = r, n.j.info("backChannelRequestTimeoutMs_=" + r)), r = n;
                            const h = e.g;
                            if (h) {
                                const p = h.g ? h.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                                if (p) {
                                    var i = r.h;
                                    i.g || p.indexOf("spdy") == -1 && p.indexOf("quic") == -1 && p.indexOf("h2") == -1 || (i.j = i.l, i.g = new Set, i.h && (rT(i, i.h), i.h = null))
                                }
                                if (r.D) {
                                    const m = h.g ? h.g.getResponseHeader("X-HTTP-Session-Id") : null;
                                    m && (r.za = m, Ot(r.F, r.D, m))
                                }
                            }
                            n.G = 3, n.l && n.l.xa(), n.$ && (n.P = Date.now() - e.F, n.j.info("Handshake RTT: " + n.P + "ms")), r = n;
                            var o = e;
                            if (r.sa = PL(r, r.H ? r.ka : null, r.V), o.J) {
                                vL(r.h, o);
                                var a = o,
                                    l = r.J;
                                l && a.setTimeout(l), a.B && (iv(a), op(a)), r.g = o
                            } else AL(r);
                            0 < n.i.length && uv(n)
                        } else c[0] != "stop" && c[0] != "close" || Oa(n, 7);
                    else n.G == 3 && (c[0] == "stop" || c[0] == "close" ? c[0] == "stop" ? Oa(n, 7) : aT(n) : c[0] != "noop" && n.l && n.l.wa(c), n.A = 0)
                }
        }
        Xf(4)
    } catch {}
}

function Pq(e) {
    if (e.W && typeof e.W == "function") return e.W();
    if (typeof Map != "undefined" && e instanceof Map || typeof Set != "undefined" && e instanceof Set) return Array.from(e.values());
    if (typeof e == "string") return e.split("");
    if (Xy(e)) {
        for (var t = [], n = e.length, r = 0; r < n; r++) t.push(e[r]);
        return t
    }
    t = [], n = 0;
    for (r in e) t[n++] = e[r];
    return t
}

function Mq(e) {
    if (e.oa && typeof e.oa == "function") return e.oa();
    if (!e.W || typeof e.W != "function") {
        if (typeof Map != "undefined" && e instanceof Map) return Array.from(e.keys());
        if (!(typeof Set != "undefined" && e instanceof Set)) {
            if (Xy(e) || typeof e == "string") {
                var t = [];
                e = e.length;
                for (var n = 0; n < e; n++) t.push(n);
                return t
            }
            t = [], n = 0;
            for (const r in e) t[n++] = r;
            return t
        }
    }
}

function dL(e, t) {
    if (e.forEach && typeof e.forEach == "function") e.forEach(t, void 0);
    else if (Xy(e) || typeof e == "string") Array.prototype.forEach.call(e, t, void 0);
    else
        for (var n = Mq(e), r = Pq(e), s = r.length, i = 0; i < s; i++) t.call(void 0, r[i], n && n[i], e)
}
var fL = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");

function Lq(e, t) {
    if (e) {
        e = e.split("&");
        for (var n = 0; n < e.length; n++) {
            var r = e[n].indexOf("="),
                s = null;
            if (0 <= r) {
                var i = e[n].substring(0, r);
                s = e[n].substring(r + 1)
            } else i = e[n];
            t(i, s ? decodeURIComponent(s.replace(/\+/g, " ")) : "")
        }
    }
}

function Va(e, t) {
    if (this.g = this.s = this.j = "", this.m = null, this.o = this.l = "", this.h = !1, e instanceof Va) {
        this.h = t !== void 0 ? t : e.h, n_(this, e.j), this.s = e.s, this.g = e.g, r_(this, e.m), this.l = e.l, t = e.i;
        var n = new Qf;
        n.i = t.i, t.g && (n.g = new Map(t.g), n.h = t.h), $x(this, n), this.o = e.o
    } else e && (n = String(e).match(fL)) ? (this.h = !!t, n_(this, n[1] || "", !0), this.s = Rd(n[2] || ""), this.g = Rd(n[3] || "", !0), r_(this, n[4]), this.l = Rd(n[5] || "", !0), $x(this, n[6] || "", !0), this.o = Rd(n[7] || "")) : (this.h = !!t, this.i = new Qf(null, this.h))
}
Va.prototype.toString = function() {
    var e = [],
        t = this.j;
    t && e.push(Od(t, kx, !0), ":");
    var n = this.g;
    return (n || t == "file") && (e.push("//"), (t = this.s) && e.push(Od(t, kx, !0), "@"), e.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), n = this.m, n != null && e.push(":", String(n))), (n = this.l) && (this.g && n.charAt(0) != "/" && e.push("/"), e.push(Od(n, n.charAt(0) == "/" ? Bq : Uq, !0))), (n = this.i.toString()) && e.push("?", n), (n = this.o) && e.push("#", Od(n, Hq)), e.join("")
};

function bi(e) {
    return new Va(e)
}

function n_(e, t, n) {
    e.j = n ? Rd(t, !0) : t, e.j && (e.j = e.j.replace(/:$/, ""))
}

function r_(e, t) {
    if (t) {
        if (t = Number(t), isNaN(t) || 0 > t) throw Error("Bad port number " + t);
        e.m = t
    } else e.m = null
}

function $x(e, t, n) {
    t instanceof Qf ? (e.i = t, jq(e.i, e.h)) : (n || (t = Od(t, Vq)), e.i = new Qf(t, e.h))
}

function Ot(e, t, n) {
    e.i.set(t, n)
}

function ov(e) {
    return Ot(e, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), e
}

function Rd(e, t) {
    return e ? t ? decodeURI(e.replace(/%25/g, "%2525")) : decodeURIComponent(e) : ""
}

function Od(e, t, n) {
    return typeof e == "string" ? (e = encodeURI(e).replace(t, Fq), n && (e = e.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), e) : null
}

function Fq(e) {
    return e = e.charCodeAt(0), "%" + (e >> 4 & 15).toString(16) + (e & 15).toString(16)
}
var kx = /[#\/\?@]/g,
    Uq = /[#\?:]/g,
    Bq = /[#\?]/g,
    Vq = /[#\?@]/g,
    Hq = /#/g;

function Qf(e, t) {
    this.h = this.g = null, this.i = e || null, this.j = !!t
}

function aa(e) {
    e.g || (e.g = new Map, e.h = 0, e.i && Lq(e.i, function(t, n) {
        e.add(decodeURIComponent(t.replace(/\+/g, " ")), n)
    }))
}
pe = Qf.prototype;
pe.add = function(e, t) {
    aa(this), this.i = null, e = Yu(this, e);
    var n = this.g.get(e);
    return n || this.g.set(e, n = []), n.push(t), this.h += 1, this
};

function hL(e, t) {
    aa(e), t = Yu(e, t), e.g.has(t) && (e.i = null, e.h -= e.g.get(t).length, e.g.delete(t))
}

function pL(e, t) {
    return aa(e), t = Yu(e, t), e.g.has(t)
}
pe.forEach = function(e, t) {
    aa(this), this.g.forEach(function(n, r) {
        n.forEach(function(s) {
            e.call(t, s, r, this)
        }, this)
    }, this)
};
pe.oa = function() {
    aa(this);
    const e = Array.from(this.g.values()),
        t = Array.from(this.g.keys()),
        n = [];
    for (let r = 0; r < t.length; r++) {
        const s = e[r];
        for (let i = 0; i < s.length; i++) n.push(t[r])
    }
    return n
};
pe.W = function(e) {
    aa(this);
    let t = [];
    if (typeof e == "string") pL(this, e) && (t = t.concat(this.g.get(Yu(this, e))));
    else {
        e = Array.from(this.g.values());
        for (let n = 0; n < e.length; n++) t = t.concat(e[n])
    }
    return t
};
pe.set = function(e, t) {
    return aa(this), this.i = null, e = Yu(this, e), pL(this, e) && (this.h -= this.g.get(e).length), this.g.set(e, [t]), this.h += 1, this
};
pe.get = function(e, t) {
    return e ? (e = this.W(e), 0 < e.length ? String(e[0]) : t) : t
};

function mL(e, t, n) {
    hL(e, t), 0 < n.length && (e.i = null, e.g.set(Yu(e, t), zS(n)), e.h += n.length)
}
pe.toString = function() {
    if (this.i) return this.i;
    if (!this.g) return "";
    const e = [],
        t = Array.from(this.g.keys());
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        const i = encodeURIComponent(String(r)),
            o = this.W(r);
        for (r = 0; r < o.length; r++) {
            var s = i;
            o[r] !== "" && (s += "=" + encodeURIComponent(String(o[r]))), e.push(s)
        }
    }
    return this.i = e.join("&")
};

function Yu(e, t) {
    return t = String(t), e.j && (t = t.toLowerCase()), t
}

function jq(e, t) {
    t && !e.j && (aa(e), e.i = null, e.g.forEach(function(n, r) {
        var s = r.toLowerCase();
        r != s && (hL(this, r), mL(this, s, n))
    }, e)), e.j = t
}
var zq = class {
    constructor(e, t) {
        this.h = e, this.g = t
    }
};

function gL(e) {
    this.l = e || Wq, Ie.PerformanceNavigationTiming ? (e = Ie.performance.getEntriesByType("navigation"), e = 0 < e.length && (e[0].nextHopProtocol == "hq" || e[0].nextHopProtocol == "h2")) : e = !!(Ie.g && Ie.g.Ga && Ie.g.Ga() && Ie.g.Ga().$b), this.j = e ? this.l : 1, this.g = null, 1 < this.j && (this.g = new Set), this.h = null, this.i = []
}
var Wq = 10;

function _L(e) {
    return e.h ? !0 : e.g ? e.g.size >= e.j : !1
}

function yL(e) {
    return e.h ? 1 : e.g ? e.g.size : 0
}

function Xw(e, t) {
    return e.h ? e.h == t : e.g ? e.g.has(t) : !1
}

function rT(e, t) {
    e.g ? e.g.add(t) : e.h = t
}

function vL(e, t) {
    e.h && e.h == t ? e.h = null : e.g && e.g.has(t) && e.g.delete(t)
}
gL.prototype.cancel = function() {
    if (this.i = bL(this), this.h) this.h.cancel(), this.h = null;
    else if (this.g && this.g.size !== 0) {
        for (const e of this.g.values()) e.cancel();
        this.g.clear()
    }
};

function bL(e) {
    if (e.h != null) return e.i.concat(e.h.D);
    if (e.g != null && e.g.size !== 0) {
        let t = e.i;
        for (const n of e.g.values()) t = t.concat(n.D);
        return t
    }
    return zS(e.i)
}

function sT() {}
sT.prototype.stringify = function(e) {
    return Ie.JSON.stringify(e, void 0)
};
sT.prototype.parse = function(e) {
    return Ie.JSON.parse(e, void 0)
};

function Gq() {
    this.g = new sT
}

function qq(e, t, n) {
    const r = n || "";
    try {
        dL(e, function(s, i) {
            let o = s;
            tp(s) && (o = QS(s)), t.push(r + i + "=" + encodeURIComponent(o))
        })
    } catch (s) {
        throw t.push(r + "type=" + encodeURIComponent("_badmap")), s
    }
}

function Yq(e, t) {
    const n = new tv;
    if (Ie.Image) {
        const r = new Image;
        r.onload = Xp(Jp, n, r, "TestLoadImage: loaded", !0, t), r.onerror = Xp(Jp, n, r, "TestLoadImage: error", !1, t), r.onabort = Xp(Jp, n, r, "TestLoadImage: abort", !1, t), r.ontimeout = Xp(Jp, n, r, "TestLoadImage: timeout", !1, t), Ie.setTimeout(function() {
            r.ontimeout && r.ontimeout()
        }, 1e4), r.src = e
    } else t(!1)
}

function Jp(e, t, n, r, s) {
    try {
        t.onload = null, t.onerror = null, t.onabort = null, t.ontimeout = null, s(r)
    } catch {}
}

function ap(e) {
    this.l = e.ac || null, this.j = e.jb || !1
}
Pn(ap, eT);
ap.prototype.g = function() {
    return new av(this.l, this.j)
};
ap.prototype.i = function(e) {
    return function() {
        return e
    }
}({});

function av(e, t) {
    Tn.call(this), this.D = e, this.u = t, this.m = void 0, this.readyState = iT, this.status = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.v = new Headers, this.h = null, this.C = "GET", this.B = "", this.g = !1, this.A = this.j = this.l = null
}
Pn(av, Tn);
var iT = 0;
pe = av.prototype;
pe.open = function(e, t) {
    if (this.readyState != iT) throw this.abort(), Error("Error reopening a connection");
    this.C = e, this.B = t, this.readyState = 1, Jf(this)
};
pe.send = function(e) {
    if (this.readyState != 1) throw this.abort(), Error("need to call open() first. ");
    this.g = !0;
    const t = {
        headers: this.v,
        method: this.C,
        credentials: this.m,
        cache: void 0
    };
    e && (t.body = e), (this.D || Ie).fetch(new Request(this.B, t)).then(this.Wa.bind(this), this.ga.bind(this))
};
pe.abort = function() {
    this.response = this.responseText = "", this.v = new Headers, this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => {}), 1 <= this.readyState && this.g && this.readyState != 4 && (this.g = !1, lp(this)), this.readyState = iT
};
pe.Wa = function(e) {
    if (this.g && (this.l = e, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = e.headers, this.readyState = 2, Jf(this)), this.g && (this.readyState = 3, Jf(this), this.g)))
        if (this.responseType === "arraybuffer") e.arrayBuffer().then(this.Ua.bind(this), this.ga.bind(this));
        else if (typeof Ie.ReadableStream != "undefined" && "body" in e) {
        if (this.j = e.body.getReader(), this.u) {
            if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
            this.response = []
        } else this.response = this.responseText = "", this.A = new TextDecoder;
        wL(this)
    } else e.text().then(this.Va.bind(this), this.ga.bind(this))
};

function wL(e) {
    e.j.read().then(e.Ta.bind(e)).catch(e.ga.bind(e))
}
pe.Ta = function(e) {
    if (this.g) {
        if (this.u && e.value) this.response.push(e.value);
        else if (!this.u) {
            var t = e.value ? e.value : new Uint8Array(0);
            (t = this.A.decode(t, {
                stream: !e.done
            })) && (this.response = this.responseText += t)
        }
        e.done ? lp(this) : Jf(this), this.readyState == 3 && wL(this)
    }
};
pe.Va = function(e) {
    this.g && (this.response = this.responseText = e, lp(this))
};
pe.Ua = function(e) {
    this.g && (this.response = e, lp(this))
};
pe.ga = function() {
    this.g && lp(this)
};

function lp(e) {
    e.readyState = 4, e.l = null, e.j = null, e.A = null, Jf(e)
}
pe.setRequestHeader = function(e, t) {
    this.v.append(e, t)
};
pe.getResponseHeader = function(e) {
    return this.h && this.h.get(e.toLowerCase()) || ""
};
pe.getAllResponseHeaders = function() {
    if (!this.h) return "";
    const e = [],
        t = this.h.entries();
    for (var n = t.next(); !n.done;) n = n.value, e.push(n[0] + ": " + n[1]), n = t.next();
    return e.join(`\r
`)
};

function Jf(e) {
    e.onreadystatechange && e.onreadystatechange.call(e)
}
Object.defineProperty(av.prototype, "withCredentials", {
    get: function() {
        return this.m === "include"
    },
    set: function(e) {
        this.m = e ? "include" : "same-origin"
    }
});
var Kq = Ie.JSON.parse;

function Wt(e) {
    Tn.call(this), this.headers = new Map, this.u = e || null, this.h = !1, this.C = this.g = null, this.H = "", this.m = 0, this.j = "", this.l = this.F = this.v = this.D = !1, this.B = 0, this.A = null, this.J = EL, this.K = this.L = !1
}
Pn(Wt, Tn);
var EL = "",
    Xq = /^https?$/i,
    Qq = ["POST", "PUT"];
pe = Wt.prototype;
pe.Ka = function(e) {
    this.L = e
};
pe.da = function(e, t, n, r) {
    if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + e);
    t = t ? t.toUpperCase() : "GET", this.H = e, this.j = "", this.m = 0, this.D = !1, this.h = !0, this.g = this.u ? this.u.g() : Gw.g(), this.C = this.u ? Tx(this.u) : Tx(Gw), this.g.onreadystatechange = zn(this.Ha, this);
    try {
        this.F = !0, this.g.open(t, String(e), !0), this.F = !1
    } catch (i) {
        Ix(this, i);
        return
    }
    if (e = n || "", n = new Map(this.headers), r)
        if (Object.getPrototypeOf(r) === Object.prototype)
            for (var s in r) n.set(s, r[s]);
        else if (typeof r.keys == "function" && typeof r.get == "function")
        for (const i of r.keys()) n.set(i, r.get(i));
    else throw Error("Unknown input type for opt_headers: " + String(r));
    r = Array.from(n.keys()).find(i => i.toLowerCase() == "content-type"), s = Ie.FormData && e instanceof Ie.FormData, !(0 <= FM(Qq, t)) || r || s || n.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
    for (const [i, o] of n) this.g.setRequestHeader(i, o);
    this.J && (this.g.responseType = this.J), "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
    try {
        $L(this), 0 < this.B && ((this.K = Jq(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = zn(this.qa, this)) : this.A = ZS(this.qa, this.B, this)), this.v = !0, this.g.send(e), this.v = !1
    } catch (i) {
        Ix(this, i)
    }
};

function Jq(e) {
    return nu && mq() && typeof e.timeout == "number" && e.ontimeout !== void 0
}
pe.qa = function() {
    typeof jS != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, Dn(this, "timeout"), this.abort(8))
};

function Ix(e, t) {
    e.h = !1, e.g && (e.l = !0, e.g.abort(), e.l = !1), e.j = t, e.m = 5, SL(e), lv(e)
}

function SL(e) {
    e.D || (e.D = !0, Dn(e, "complete"), Dn(e, "error"))
}
pe.abort = function(e) {
    this.g && this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1, this.m = e || 7, Dn(this, "complete"), Dn(this, "abort"), lv(this))
};
pe.M = function() {
    this.g && (this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1), lv(this, !0)), Wt.X.M.call(this)
};
pe.Ha = function() {
    this.s || (this.F || this.v || this.l ? TL(this) : this.fb())
};
pe.fb = function() {
    TL(this)
};

function TL(e) {
    if (e.h && typeof jS != "undefined" && (!e.C[1] || oi(e) != 4 || e.aa() != 2)) {
        if (e.v && oi(e) == 4) ZS(e.Ha, 0, e);
        else if (Dn(e, "readystatechange"), oi(e) == 4) {
            e.h = !1;
            try {
                const a = e.aa();
                e: switch (a) {
                    case 200:
                    case 201:
                    case 202:
                    case 204:
                    case 206:
                    case 304:
                    case 1223:
                        var t = !0;
                        break e;
                    default:
                        t = !1
                }
                var n;
                if (!(n = t)) {
                    var r;
                    if (r = a === 0) {
                        var s = String(e.H).match(fL)[1] || null;
                        if (!s && Ie.self && Ie.self.location) {
                            var i = Ie.self.location.protocol;
                            s = i.substr(0, i.length - 1)
                        }
                        r = !Xq.test(s ? s.toLowerCase() : "")
                    }
                    n = r
                }
                if (n) Dn(e, "complete"), Dn(e, "success");
                else {
                    e.m = 6;
                    try {
                        var o = 2 < oi(e) ? e.g.statusText : ""
                    } catch {
                        o = ""
                    }
                    e.j = o + " [" + e.aa() + "]", SL(e)
                }
            } finally {
                lv(e)
            }
        }
    }
}

function lv(e, t) {
    if (e.g) {
        $L(e);
        const n = e.g,
            r = e.C[0] ? Jg : null;
        e.g = null, e.C = null, t || Dn(e, "ready");
        try {
            n.onreadystatechange = r
        } catch {}
    }
}

function $L(e) {
    e.g && e.K && (e.g.ontimeout = null), e.A && (Ie.clearTimeout(e.A), e.A = null)
}

function oi(e) {
    return e.g ? e.g.readyState : 0
}
pe.aa = function() {
    try {
        return 2 < oi(this) ? this.g.status : -1
    } catch {
        return -1
    }
};
pe.fa = function() {
    try {
        return this.g ? this.g.responseText : ""
    } catch {
        return ""
    }
};
pe.Sa = function(e) {
    if (this.g) {
        var t = this.g.responseText;
        return e && t.indexOf(e) == 0 && (t = t.substring(e.length)), Kq(t)
    }
};

function xx(e) {
    try {
        if (!e.g) return null;
        if ("response" in e.g) return e.g.response;
        switch (e.J) {
            case EL:
            case "text":
                return e.g.responseText;
            case "arraybuffer":
                if ("mozResponseArrayBuffer" in e.g) return e.g.mozResponseArrayBuffer
        }
        return null
    } catch {
        return null
    }
}
pe.Ea = function() {
    return this.m
};
pe.Oa = function() {
    return typeof this.j == "string" ? this.j : String(this.j)
};

function kL(e) {
    let t = "";
    return GS(e, function(n, r) {
        t += r, t += ":", t += n, t += `\r
`
    }), t
}

function oT(e, t, n) {
    e: {
        for (r in n) {
            var r = !1;
            break e
        }
        r = !0
    }
    r || (n = kL(n), typeof e == "string" ? n != null && encodeURIComponent(String(n)) : Ot(e, t, n))
}

function fd(e, t, n) {
    return n && n.internalChannelParams && n.internalChannelParams[e] || t
}

function IL(e) {
    this.Ca = 0, this.i = [], this.j = new tv, this.ka = this.sa = this.F = this.V = this.g = this.za = this.D = this.ia = this.o = this.S = this.s = null, this.ab = this.U = 0, this.Za = fd("failFast", !1, e), this.L = this.v = this.u = this.m = this.l = null, this.Y = !0, this.pa = this.Ba = this.T = -1, this.Z = this.A = this.C = 0, this.Xa = fd("baseRetryDelayMs", 5e3, e), this.bb = fd("retryDelaySeedMs", 1e4, e), this.$a = fd("forwardChannelMaxRetries", 2, e), this.ta = fd("forwardChannelRequestTimeoutMs", 2e4, e), this.ra = e && e.xmlHttpFactory || void 0, this.Da = e && e.Zb || !1, this.J = void 0, this.H = e && e.supportsCrossDomainXhr || !1, this.I = "", this.h = new gL(e && e.concurrentRequestLimit), this.Fa = new Gq, this.O = e && e.fastHandshake || !1, this.N = e && e.encodeInitMessageHeaders || !1, this.O && this.N && (this.N = !1), this.Ya = e && e.Xb || !1, e && e.Aa && this.j.Aa(), e && e.forceLongPolling && (this.Y = !1), this.$ = !this.O && this.Y && e && e.detectBufferingProxy || !1, this.ja = void 0, this.P = 0, this.K = !1, this.la = this.B = null
}
pe = IL.prototype;
pe.ma = 8;
pe.G = 1;

function aT(e) {
    if (xL(e), e.G == 3) {
        var t = e.U++,
            n = bi(e.F);
        Ot(n, "SID", e.I), Ot(n, "RID", t), Ot(n, "TYPE", "terminate"), cp(e, n), t = new ip(e, e.j, t, void 0), t.K = 2, t.v = ov(bi(n)), n = !1, Ie.navigator && Ie.navigator.sendBeacon && (n = Ie.navigator.sendBeacon(t.v.toString(), "")), !n && Ie.Image && (new Image().src = t.v, n = !0), n || (t.g = ML(t.l, null), t.g.da(t.v)), t.F = Date.now(), op(t)
    }
    NL(e)
}

function cv(e) {
    e.g && (cT(e), e.g.cancel(), e.g = null)
}

function xL(e) {
    cv(e), e.u && (Ie.clearTimeout(e.u), e.u = null), s_(e), e.h.cancel(), e.m && (typeof e.m == "number" && Ie.clearTimeout(e.m), e.m = null)
}

function uv(e) {
    _L(e.h) || e.m || (e.m = !0, XM(e.Ja, e), e.C = 0)
}

function Zq(e, t) {
    return yL(e.h) >= e.h.j - (e.m ? 1 : 0) ? !1 : e.m ? (e.i = t.D.concat(e.i), !0) : e.G == 1 || e.G == 2 || e.C >= (e.Za ? 0 : e.$a) ? !1 : (e.m = rp(zn(e.Ja, e, t), DL(e, e.C)), e.C++, !0)
}
pe.Ja = function(e) {
    if (this.m)
        if (this.m = null, this.G == 1) {
            if (!e) {
                this.U = Math.floor(1e5 * Math.random()), e = this.U++;
                const s = new ip(this, this.j, e, void 0);
                let i = this.s;
                if (this.S && (i ? (i = HM(i), jM(i, this.S)) : i = this.S), this.o !== null || this.N || (s.H = i, i = null), this.O) e: {
                    for (var t = 0, n = 0; n < this.i.length; n++) {
                        t: {
                            var r = this.i[n];
                            if ("__data__" in r.g && (r = r.g.__data__, typeof r == "string")) {
                                r = r.length;
                                break t
                            }
                            r = void 0
                        }
                        if (r === void 0) break;
                        if (t += r, 4096 < t) {
                            t = n;
                            break e
                        }
                        if (t === 4096 || n === this.i.length - 1) {
                            t = n + 1;
                            break e
                        }
                    }
                    t = 1e3
                }
                else t = 1e3;
                t = CL(this, s, t), n = bi(this.F), Ot(n, "RID", e), Ot(n, "CVER", 22), this.D && Ot(n, "X-HTTP-Session-Id", this.D), cp(this, n), i && (this.N ? t = "headers=" + encodeURIComponent(String(kL(i))) + "&" + t : this.o && oT(n, this.o, i)), rT(this.h, s), this.Ya && Ot(n, "TYPE", "init"), this.O ? (Ot(n, "$req", t), Ot(n, "SID", "null"), s.Z = !0, Yw(s, n, null)) : Yw(s, n, t), this.G = 2
            }
        } else this.G == 3 && (e ? Cx(this, e) : this.i.length == 0 || _L(this.h) || Cx(this))
};

function Cx(e, t) {
    var n;
    t ? n = t.m : n = e.U++;
    const r = bi(e.F);
    Ot(r, "SID", e.I), Ot(r, "RID", n), Ot(r, "AID", e.T), cp(e, r), e.o && e.s && oT(r, e.o, e.s), n = new ip(e, e.j, n, e.C + 1), e.o === null && (n.H = e.s), t && (e.i = t.D.concat(e.i)), t = CL(e, n, 1e3), n.setTimeout(Math.round(.5 * e.ta) + Math.round(.5 * e.ta * Math.random())), rT(e.h, n), Yw(n, r, t)
}

function cp(e, t) {
    e.ia && GS(e.ia, function(n, r) {
        Ot(t, r, n)
    }), e.l && dL({}, function(n, r) {
        Ot(t, r, n)
    })
}

function CL(e, t, n) {
    n = Math.min(e.i.length, n);
    var r = e.l ? zn(e.l.Ra, e.l, e) : null;
    e: {
        var s = e.i;
        let i = -1;
        for (;;) {
            const o = ["count=" + n];
            i == -1 ? 0 < n ? (i = s[0].h, o.push("ofs=" + i)) : i = 0 : o.push("ofs=" + i);
            let a = !0;
            for (let l = 0; l < n; l++) {
                let c = s[l].h;
                const u = s[l].g;
                if (c -= i, 0 > c) i = Math.max(0, s[l].h - 100), a = !1;
                else try {
                    qq(u, o, "req" + c + "_")
                } catch {
                    r && r(u)
                }
            }
            if (a) {
                r = o.join("&");
                break e
            }
        }
    }
    return e = e.i.splice(0, n), t.D = e, r
}

function AL(e) {
    e.g || e.u || (e.Z = 1, XM(e.Ia, e), e.A = 0)
}

function lT(e) {
    return e.g || e.u || 3 <= e.A ? !1 : (e.Z++, e.u = rp(zn(e.Ia, e), DL(e, e.A)), e.A++, !0)
}
pe.Ia = function() {
    if (this.u = null, RL(this), this.$ && !(this.K || this.g == null || 0 >= this.P)) {
        var e = 2 * this.P;
        this.j.info("BP detection timer enabled: " + e), this.B = rp(zn(this.eb, this), e)
    }
};
pe.eb = function() {
    this.B && (this.B = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.L = !1, this.K = !0, ar(10), cv(this), RL(this))
};

function cT(e) {
    e.B != null && (Ie.clearTimeout(e.B), e.B = null)
}

function RL(e) {
    e.g = new ip(e, e.j, "rpc", e.Z), e.o === null && (e.g.H = e.s), e.g.N = 0;
    var t = bi(e.sa);
    Ot(t, "RID", "rpc"), Ot(t, "SID", e.I), Ot(t, "CI", e.L ? "0" : "1"), Ot(t, "AID", e.T), Ot(t, "TYPE", "xmlhttp"), cp(e, t), e.o && e.s && oT(t, e.o, e.s), e.J && e.g.setTimeout(e.J);
    var n = e.g;
    e = e.ka, n.K = 1, n.v = ov(bi(t)), n.s = null, n.P = !0, aL(n, e)
}
pe.cb = function() {
    this.v != null && (this.v = null, cv(this), lT(this), ar(19))
};

function s_(e) {
    e.v != null && (Ie.clearTimeout(e.v), e.v = null)
}

function OL(e, t) {
    var n = null;
    if (e.g == t) {
        s_(e), cT(e), e.g = null;
        var r = 2
    } else if (Xw(e.h, t)) n = t.D, vL(e.h, t), r = 1;
    else return;
    if (e.G != 0) {
        if (e.pa = t.Y, t.i)
            if (r == 1) {
                n = t.s ? t.s.length : 0, t = Date.now() - t.F;
                var s = e.C;
                r = nv(), Dn(r, new rL(r, n)), uv(e)
            } else AL(e);
        else if (s = t.o, s == 3 || s == 0 && 0 < e.pa || !(r == 1 && Zq(e, t) || r == 2 && lT(e))) switch (n && 0 < n.length && (t = e.h, t.i = t.i.concat(n)), s) {
            case 1:
                Oa(e, 5);
                break;
            case 4:
                Oa(e, 10);
                break;
            case 3:
                Oa(e, 6);
                break;
            default:
                Oa(e, 2)
        }
    }
}

function DL(e, t) {
    let n = e.Xa + Math.floor(Math.random() * e.bb);
    return e.l || (n *= 2), n * t
}

function Oa(e, t) {
    if (e.j.info("Error code " + t), t == 2) {
        var n = null;
        e.l && (n = null);
        var r = zn(e.kb, e);
        n || (n = new Va("//www.google.com/images/cleardot.gif"), Ie.location && Ie.location.protocol == "http" || n_(n, "https"), ov(n)), Yq(n.toString(), r)
    } else ar(2);
    e.G = 0, e.l && e.l.va(t), NL(e), xL(e)
}
pe.kb = function(e) {
    e ? (this.j.info("Successfully pinged google.com"), ar(2)) : (this.j.info("Failed to ping google.com"), ar(1))
};

function NL(e) {
    if (e.G = 0, e.la = [], e.l) {
        const t = bL(e.h);
        (t.length != 0 || e.i.length != 0) && (yx(e.la, t), yx(e.la, e.i), e.h.i.length = 0, zS(e.i), e.i.length = 0), e.l.ua()
    }
}

function PL(e, t, n) {
    var r = n instanceof Va ? bi(n) : new Va(n, void 0);
    if (r.g != "") t && (r.g = t + "." + r.g), r_(r, r.m);
    else {
        var s = Ie.location;
        r = s.protocol, t = t ? t + "." + s.hostname : s.hostname, s = +s.port;
        var i = new Va(null, void 0);
        r && n_(i, r), t && (i.g = t), s && r_(i, s), n && (i.l = n), r = i
    }
    return n = e.D, t = e.za, n && t && Ot(r, n, t), Ot(r, "VER", e.ma), cp(e, r), r
}

function ML(e, t, n) {
    if (t && !e.H) throw Error("Can't create secondary domain capable XhrIo object.");
    return t = n && e.Da && !e.ra ? new Wt(new ap({
        jb: !0
    })) : new Wt(e.ra), t.Ka(e.H), t
}

function LL() {}
pe = LL.prototype;
pe.xa = function() {};
pe.wa = function() {};
pe.va = function() {};
pe.ua = function() {};
pe.Ra = function() {};

function i_() {
    if (nu && !(10 <= Number(gq))) throw Error("Environmental error: no available transport.")
}
i_.prototype.g = function(e, t) {
    return new Ur(e, t)
};

function Ur(e, t) {
    Tn.call(this), this.g = new IL(t), this.l = e, this.h = t && t.messageUrlParams || null, e = t && t.messageHeaders || null, t && t.clientProtocolHeaderRequired && (e ? e["X-Client-Protocol"] = "webchannel" : e = {
        "X-Client-Protocol": "webchannel"
    }), this.g.s = e, e = t && t.initMessageHeaders || null, t && t.messageContentType && (e ? e["X-WebChannel-Content-Type"] = t.messageContentType : e = {
        "X-WebChannel-Content-Type": t.messageContentType
    }), t && t.ya && (e ? e["X-WebChannel-Client-Profile"] = t.ya : e = {
        "X-WebChannel-Client-Profile": t.ya
    }), this.g.S = e, (e = t && t.Yb) && !Zg(e) && (this.g.o = e), this.A = t && t.supportsCrossDomainXhr || !1, this.v = t && t.sendRawJson || !1, (t = t && t.httpSessionIdParam) && !Zg(t) && (this.g.D = t, e = this.h, e !== null && t in e && (e = this.h, t in e && delete e[t])), this.j = new Ku(this)
}
Pn(Ur, Tn);
Ur.prototype.m = function() {
    this.g.l = this.j, this.A && (this.g.H = !0);
    var e = this.g,
        t = this.l,
        n = this.h || void 0;
    ar(0), e.V = t, e.ia = n || {}, e.L = e.Y, e.F = PL(e, null, e.V), uv(e)
};
Ur.prototype.close = function() {
    aT(this.g)
};
Ur.prototype.u = function(e) {
    var t = this.g;
    if (typeof e == "string") {
        var n = {};
        n.__data__ = e, e = n
    } else this.v && (n = {}, n.__data__ = QS(e), e = n);
    t.i.push(new zq(t.ab++, e)), t.G == 3 && uv(t)
};
Ur.prototype.M = function() {
    this.g.l = null, delete this.j, aT(this.g), delete this.g, Ur.X.M.call(this)
};

function FL(e) {
    tT.call(this);
    var t = e.__sm__;
    if (t) {
        e: {
            for (const n in t) {
                e = n;
                break e
            }
            e = void 0
        }(this.i = e) && (e = this.i, t = t !== null && e in t ? t[e] : void 0),
        this.data = t
    }
    else this.data = e
}
Pn(FL, tT);

function UL() {
    nT.call(this), this.status = 1
}
Pn(UL, nT);

function Ku(e) {
    this.g = e
}
Pn(Ku, LL);
Ku.prototype.xa = function() {
    Dn(this.g, "a")
};
Ku.prototype.wa = function(e) {
    Dn(this.g, new FL(e))
};
Ku.prototype.va = function(e) {
    Dn(this.g, new UL)
};
Ku.prototype.ua = function() {
    Dn(this.g, "b")
};
i_.prototype.createWebChannel = i_.prototype.g;
Ur.prototype.send = Ur.prototype.u;
Ur.prototype.open = Ur.prototype.m;
Ur.prototype.close = Ur.prototype.close;
rv.NO_ERROR = 0;
rv.TIMEOUT = 8;
rv.HTTP_ERROR = 6;
sL.COMPLETE = "complete";
iL.EventType = sp;
sp.OPEN = "a";
sp.CLOSE = "b";
sp.ERROR = "c";
sp.MESSAGE = "d";
Tn.prototype.listen = Tn.prototype.N;
Wt.prototype.listenOnce = Wt.prototype.O;
Wt.prototype.getLastError = Wt.prototype.Oa;
Wt.prototype.getLastErrorCode = Wt.prototype.Ea;
Wt.prototype.getStatus = Wt.prototype.aa;
Wt.prototype.getResponseJson = Wt.prototype.Sa;
Wt.prototype.getResponseText = Wt.prototype.fa;
Wt.prototype.send = Wt.prototype.da;
Wt.prototype.setWithCredentials = Wt.prototype.Ka;
var e8 = function() {
        return new i_
    },
    t8 = function() {
        return nv()
    },
    s0 = rv,
    n8 = sL,
    r8 = Cl,
    Ax = {
        sb: 0,
        vb: 1,
        wb: 2,
        Pb: 3,
        Ub: 4,
        Rb: 5,
        Sb: 6,
        Qb: 7,
        Ob: 8,
        Tb: 9,
        PROXY: 10,
        NOPROXY: 11,
        Mb: 12,
        Ib: 13,
        Jb: 14,
        Hb: 15,
        Kb: 16,
        Lb: 17,
        ob: 18,
        nb: 19,
        pb: 20
    },
    s8 = ap,
    Zp = iL,
    i8 = Wt;
const Rx = "@firebase/firestore";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fn {
    constructor(t) {
        this.uid = t
    }
    isAuthenticated() {
        return this.uid != null
    }
    toKey() {
        return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user"
    }
    isEqual(t) {
        return t.uid === this.uid
    }
}
Fn.UNAUTHENTICATED = new Fn(null), Fn.GOOGLE_CREDENTIALS = new Fn("google-credentials-uid"), Fn.FIRST_PARTY = new Fn("first-party-uid"), Fn.MOCK_USER = new Fn("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Xu = "9.20.0";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const rl = new zu("@firebase/firestore");

function Ox() {
    return rl.logLevel
}

function me(e, ...t) {
    if (rl.logLevel <= Xe.DEBUG) {
        const n = t.map(uT);
        rl.debug(`Firestore (${Xu}): ${e}`, ...n)
    }
}

function wi(e, ...t) {
    if (rl.logLevel <= Xe.ERROR) {
        const n = t.map(uT);
        rl.error(`Firestore (${Xu}): ${e}`, ...n)
    }
}

function o_(e, ...t) {
    if (rl.logLevel <= Xe.WARN) {
        const n = t.map(uT);
        rl.warn(`Firestore (${Xu}): ${e}`, ...n)
    }
}

function uT(e) {
    if (typeof e == "string") return e;
    try {
        return t = e, JSON.stringify(t)
    } catch {
        return e
    }
    /**
     * @license
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var t
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $e(e = "Unexpected state") {
    const t = `FIRESTORE (${Xu}) INTERNAL ASSERTION FAILED: ` + e;
    throw wi(t), new Error(t)
}

function Ct(e, t) {
    e || $e()
}

function Oe(e, t) {
    return e
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const U = {
    OK: "ok",
    CANCELLED: "cancelled",
    UNKNOWN: "unknown",
    INVALID_ARGUMENT: "invalid-argument",
    DEADLINE_EXCEEDED: "deadline-exceeded",
    NOT_FOUND: "not-found",
    ALREADY_EXISTS: "already-exists",
    PERMISSION_DENIED: "permission-denied",
    UNAUTHENTICATED: "unauthenticated",
    RESOURCE_EXHAUSTED: "resource-exhausted",
    FAILED_PRECONDITION: "failed-precondition",
    ABORTED: "aborted",
    OUT_OF_RANGE: "out-of-range",
    UNIMPLEMENTED: "unimplemented",
    INTERNAL: "internal",
    UNAVAILABLE: "unavailable",
    DATA_LOSS: "data-loss"
};
class re extends zr {
    constructor(t, n) {
        super(t, n), this.code = t, this.message = n, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ui {
    constructor() {
        this.promise = new Promise((t, n) => {
            this.resolve = t, this.reject = n
        })
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BL {
    constructor(t, n) {
        this.user = n, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", `Bearer ${t}`)
    }
}
class o8 {
    getToken() {
        return Promise.resolve(null)
    }
    invalidateToken() {}
    start(t, n) {
        t.enqueueRetryable(() => n(Fn.UNAUTHENTICATED))
    }
    shutdown() {}
}
class a8 {
    constructor(t) {
        this.token = t, this.changeListener = null
    }
    getToken() {
        return Promise.resolve(this.token)
    }
    invalidateToken() {}
    start(t, n) {
        this.changeListener = n, t.enqueueRetryable(() => n(this.token.user))
    }
    shutdown() {
        this.changeListener = null
    }
}
class l8 {
    constructor(t) {
        this.t = t, this.currentUser = Fn.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null
    }
    start(t, n) {
        let r = this.i;
        const s = l => this.i !== r ? (r = this.i, n(l)) : Promise.resolve();
        let i = new ui;
        this.o = () => {
            this.i++, this.currentUser = this.u(), i.resolve(), i = new ui, t.enqueueRetryable(() => s(this.currentUser))
        };
        const o = () => {
                const l = i;
                t.enqueueRetryable(async () => {
                    await l.promise, await s(this.currentUser)
                })
            },
            a = l => {
                me("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = l, this.auth.addAuthTokenListener(this.o), o()
            };
        this.t.onInit(l => a(l)), setTimeout(() => {
            if (!this.auth) {
                const l = this.t.getImmediate({
                    optional: !0
                });
                l ? a(l) : (me("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new ui)
            }
        }, 0), o()
    }
    getToken() {
        const t = this.i,
            n = this.forceRefresh;
        return this.forceRefresh = !1, this.auth ? this.auth.getToken(n).then(r => this.i !== t ? (me("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : r ? (Ct(typeof r.accessToken == "string"), new BL(r.accessToken, this.currentUser)) : null) : Promise.resolve(null)
    }
    invalidateToken() {
        this.forceRefresh = !0
    }
    shutdown() {
        this.auth && this.auth.removeAuthTokenListener(this.o)
    }
    u() {
        const t = this.auth && this.auth.getUid();
        return Ct(t === null || typeof t == "string"), new Fn(t)
    }
}
class c8 {
    constructor(t, n, r) {
        this.h = t, this.l = n, this.m = r, this.type = "FirstParty", this.user = Fn.FIRST_PARTY, this.g = new Map
    }
    p() {
        return this.m ? this.m() : null
    }
    get headers() {
        this.g.set("X-Goog-AuthUser", this.h);
        const t = this.p();
        return t && this.g.set("Authorization", t), this.l && this.g.set("X-Goog-Iam-Authorization-Token", this.l), this.g
    }
}
class u8 {
    constructor(t, n, r) {
        this.h = t, this.l = n, this.m = r
    }
    getToken() {
        return Promise.resolve(new c8(this.h, this.l, this.m))
    }
    start(t, n) {
        t.enqueueRetryable(() => n(Fn.FIRST_PARTY))
    }
    shutdown() {}
    invalidateToken() {}
}
class d8 {
    constructor(t) {
        this.value = t, this.type = "AppCheck", this.headers = new Map, t && t.length > 0 && this.headers.set("x-firebase-appcheck", this.value)
    }
}
class f8 {
    constructor(t) {
        this.I = t, this.forceRefresh = !1, this.appCheck = null, this.T = null
    }
    start(t, n) {
        const r = i => {
            i.error != null && me("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${i.error.message}`);
            const o = i.token !== this.T;
            return this.T = i.token, me("FirebaseAppCheckTokenProvider", `Received ${o?"new":"existing"} token.`), o ? n(i.token) : Promise.resolve()
        };
        this.o = i => {
            t.enqueueRetryable(() => r(i))
        };
        const s = i => {
            me("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = i, this.appCheck.addTokenListener(this.o)
        };
        this.I.onInit(i => s(i)), setTimeout(() => {
            if (!this.appCheck) {
                const i = this.I.getImmediate({
                    optional: !0
                });
                i ? s(i) : me("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
            }
        }, 0)
    }
    getToken() {
        const t = this.forceRefresh;
        return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(t).then(n => n ? (Ct(typeof n.token == "string"), this.T = n.token, new d8(n.token)) : null) : Promise.resolve(null)
    }
    invalidateToken() {
        this.forceRefresh = !0
    }
    shutdown() {
        this.appCheck && this.appCheck.removeTokenListener(this.o)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function h8(e) {
    const t = typeof self != "undefined" && (self.crypto || self.msCrypto),
        n = new Uint8Array(e);
    if (t && typeof t.getRandomValues == "function") t.getRandomValues(n);
    else
        for (let r = 0; r < e; r++) n[r] = Math.floor(256 * Math.random());
    return n
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VL {
    static A() {
        const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
            n = Math.floor(256 / t.length) * t.length;
        let r = "";
        for (; r.length < 20;) {
            const s = h8(40);
            for (let i = 0; i < s.length; ++i) r.length < 20 && s[i] < n && (r += t.charAt(s[i] % t.length))
        }
        return r
    }
}

function ut(e, t) {
    return e < t ? -1 : e > t ? 1 : 0
}

function ru(e, t, n) {
    return e.length === t.length && e.every((r, s) => n(r, t[s]))
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class un {
    constructor(t, n) {
        if (this.seconds = t, this.nanoseconds = n, n < 0) throw new re(U.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + n);
        if (n >= 1e9) throw new re(U.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + n);
        if (t < -62135596800) throw new re(U.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t);
        if (t >= 253402300800) throw new re(U.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t)
    }
    static now() {
        return un.fromMillis(Date.now())
    }
    static fromDate(t) {
        return un.fromMillis(t.getTime())
    }
    static fromMillis(t) {
        const n = Math.floor(t / 1e3),
            r = Math.floor(1e6 * (t - 1e3 * n));
        return new un(n, r)
    }
    toDate() {
        return new Date(this.toMillis())
    }
    toMillis() {
        return 1e3 * this.seconds + this.nanoseconds / 1e6
    }
    _compareTo(t) {
        return this.seconds === t.seconds ? ut(this.nanoseconds, t.nanoseconds) : ut(this.seconds, t.seconds)
    }
    isEqual(t) {
        return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds
    }
    toString() {
        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")"
    }
    toJSON() {
        return {
            seconds: this.seconds,
            nanoseconds: this.nanoseconds
        }
    }
    valueOf() {
        const t = this.seconds - -62135596800;
        return String(t).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0")
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ce {
    constructor(t) {
        this.timestamp = t
    }
    static fromTimestamp(t) {
        return new Ce(t)
    }
    static min() {
        return new Ce(new un(0, 0))
    }
    static max() {
        return new Ce(new un(253402300799, 999999999))
    }
    compareTo(t) {
        return this.timestamp._compareTo(t.timestamp)
    }
    isEqual(t) {
        return this.timestamp.isEqual(t.timestamp)
    }
    toMicroseconds() {
        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3
    }
    toString() {
        return "SnapshotVersion(" + this.timestamp.toString() + ")"
    }
    toTimestamp() {
        return this.timestamp
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zf {
    constructor(t, n, r) {
        n === void 0 ? n = 0 : n > t.length && $e(), r === void 0 ? r = t.length - n : r > t.length - n && $e(), this.segments = t, this.offset = n, this.len = r
    }
    get length() {
        return this.len
    }
    isEqual(t) {
        return Zf.comparator(this, t) === 0
    }
    child(t) {
        const n = this.segments.slice(this.offset, this.limit());
        return t instanceof Zf ? t.forEach(r => {
            n.push(r)
        }) : n.push(t), this.construct(n)
    }
    limit() {
        return this.offset + this.length
    }
    popFirst(t) {
        return t = t === void 0 ? 1 : t, this.construct(this.segments, this.offset + t, this.length - t)
    }
    popLast() {
        return this.construct(this.segments, this.offset, this.length - 1)
    }
    firstSegment() {
        return this.segments[this.offset]
    }
    lastSegment() {
        return this.get(this.length - 1)
    }
    get(t) {
        return this.segments[this.offset + t]
    }
    isEmpty() {
        return this.length === 0
    }
    isPrefixOf(t) {
        if (t.length < this.length) return !1;
        for (let n = 0; n < this.length; n++)
            if (this.get(n) !== t.get(n)) return !1;
        return !0
    }
    isImmediateParentOf(t) {
        if (this.length + 1 !== t.length) return !1;
        for (let n = 0; n < this.length; n++)
            if (this.get(n) !== t.get(n)) return !1;
        return !0
    }
    forEach(t) {
        for (let n = this.offset, r = this.limit(); n < r; n++) t(this.segments[n])
    }
    toArray() {
        return this.segments.slice(this.offset, this.limit())
    }
    static comparator(t, n) {
        const r = Math.min(t.length, n.length);
        for (let s = 0; s < r; s++) {
            const i = t.get(s),
                o = n.get(s);
            if (i < o) return -1;
            if (i > o) return 1
        }
        return t.length < n.length ? -1 : t.length > n.length ? 1 : 0
    }
}
class xt extends Zf {
    construct(t, n, r) {
        return new xt(t, n, r)
    }
    canonicalString() {
        return this.toArray().join("/")
    }
    toString() {
        return this.canonicalString()
    }
    static fromString(...t) {
        const n = [];
        for (const r of t) {
            if (r.indexOf("//") >= 0) throw new re(U.INVALID_ARGUMENT, `Invalid segment (${r}). Paths must not contain // in them.`);
            n.push(...r.split("/").filter(s => s.length > 0))
        }
        return new xt(n)
    }
    static emptyPath() {
        return new xt([])
    }
}
const p8 = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class Hn extends Zf {
    construct(t, n, r) {
        return new Hn(t, n, r)
    }
    static isValidIdentifier(t) {
        return p8.test(t)
    }
    canonicalString() {
        return this.toArray().map(t => (t = t.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Hn.isValidIdentifier(t) || (t = "`" + t + "`"), t)).join(".")
    }
    toString() {
        return this.canonicalString()
    }
    isKeyField() {
        return this.length === 1 && this.get(0) === "__name__"
    }
    static keyField() {
        return new Hn(["__name__"])
    }
    static fromServerFormat(t) {
        const n = [];
        let r = "",
            s = 0;
        const i = () => {
            if (r.length === 0) throw new re(U.INVALID_ARGUMENT, `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
            n.push(r), r = ""
        };
        let o = !1;
        for (; s < t.length;) {
            const a = t[s];
            if (a === "\\") {
                if (s + 1 === t.length) throw new re(U.INVALID_ARGUMENT, "Path has trailing escape character: " + t);
                const l = t[s + 1];
                if (l !== "\\" && l !== "." && l !== "`") throw new re(U.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t);
                r += l, s += 2
            } else a === "`" ? (o = !o, s++) : a !== "." || o ? (r += a, s++) : (i(), s++)
        }
        if (i(), o) throw new re(U.INVALID_ARGUMENT, "Unterminated ` in path: " + t);
        return new Hn(n)
    }
    static emptyPath() {
        return new Hn([])
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ve {
    constructor(t) {
        this.path = t
    }
    static fromPath(t) {
        return new ve(xt.fromString(t))
    }
    static fromName(t) {
        return new ve(xt.fromString(t).popFirst(5))
    }
    static empty() {
        return new ve(xt.emptyPath())
    }
    get collectionGroup() {
        return this.path.popLast().lastSegment()
    }
    hasCollectionId(t) {
        return this.path.length >= 2 && this.path.get(this.path.length - 2) === t
    }
    getCollectionGroup() {
        return this.path.get(this.path.length - 2)
    }
    getCollectionPath() {
        return this.path.popLast()
    }
    isEqual(t) {
        return t !== null && xt.comparator(this.path, t.path) === 0
    }
    toString() {
        return this.path.toString()
    }
    static comparator(t, n) {
        return xt.comparator(t.path, n.path)
    }
    static isDocumentKey(t) {
        return t.length % 2 == 0
    }
    static fromSegments(t) {
        return new ve(new xt(t.slice()))
    }
}

function m8(e, t) {
    const n = e.toTimestamp().seconds,
        r = e.toTimestamp().nanoseconds + 1,
        s = Ce.fromTimestamp(r === 1e9 ? new un(n + 1, 0) : new un(n, r));
    return new Bo(s, ve.empty(), t)
}

function g8(e) {
    return new Bo(e.readTime, e.key, -1)
}
class Bo {
    constructor(t, n, r) {
        this.readTime = t, this.documentKey = n, this.largestBatchId = r
    }
    static min() {
        return new Bo(Ce.min(), ve.empty(), -1)
    }
    static max() {
        return new Bo(Ce.max(), ve.empty(), -1)
    }
}

function _8(e, t) {
    let n = e.readTime.compareTo(t.readTime);
    return n !== 0 ? n : (n = ve.comparator(e.documentKey, t.documentKey), n !== 0 ? n : ut(e.largestBatchId, t.largestBatchId))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const y8 = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class v8 {
    constructor() {
        this.onCommittedListeners = []
    }
    addOnCommittedListener(t) {
        this.onCommittedListeners.push(t)
    }
    raiseOnCommittedEvent() {
        this.onCommittedListeners.forEach(t => t())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function up(e) {
    if (e.code !== U.FAILED_PRECONDITION || e.message !== y8) throw e;
    me("LocalStore", "Unexpectedly lost primary lease")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class W {
    constructor(t) {
        this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, t(n => {
            this.isDone = !0, this.result = n, this.nextCallback && this.nextCallback(n)
        }, n => {
            this.isDone = !0, this.error = n, this.catchCallback && this.catchCallback(n)
        })
    } catch (t) {
        return this.next(void 0, t)
    }
    next(t, n) {
        return this.callbackAttached && $e(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(n, this.error) : this.wrapSuccess(t, this.result) : new W((r, s) => {
            this.nextCallback = i => {
                this.wrapSuccess(t, i).next(r, s)
            }, this.catchCallback = i => {
                this.wrapFailure(n, i).next(r, s)
            }
        })
    }
    toPromise() {
        return new Promise((t, n) => {
            this.next(t, n)
        })
    }
    wrapUserFunction(t) {
        try {
            const n = t();
            return n instanceof W ? n : W.resolve(n)
        } catch (n) {
            return W.reject(n)
        }
    }
    wrapSuccess(t, n) {
        return t ? this.wrapUserFunction(() => t(n)) : W.resolve(n)
    }
    wrapFailure(t, n) {
        return t ? this.wrapUserFunction(() => t(n)) : W.reject(n)
    }
    static resolve(t) {
        return new W((n, r) => {
            n(t)
        })
    }
    static reject(t) {
        return new W((n, r) => {
            r(t)
        })
    }
    static waitFor(t) {
        return new W((n, r) => {
            let s = 0,
                i = 0,
                o = !1;
            t.forEach(a => {
                ++s, a.next(() => {
                    ++i, o && i === s && n()
                }, l => r(l))
            }), o = !0, i === s && n()
        })
    }
    static or(t) {
        let n = W.resolve(!1);
        for (const r of t) n = n.next(s => s ? W.resolve(s) : r());
        return n
    }
    static forEach(t, n) {
        const r = [];
        return t.forEach((s, i) => {
            r.push(n.call(this, s, i))
        }), this.waitFor(r)
    }
    static mapArray(t, n) {
        return new W((r, s) => {
            const i = t.length,
                o = new Array(i);
            let a = 0;
            for (let l = 0; l < i; l++) {
                const c = l;
                n(t[c]).next(u => {
                    o[c] = u, ++a, a === i && r(o)
                }, u => s(u))
            }
        })
    }
    static doWhile(t, n) {
        return new W((r, s) => {
            const i = () => {
                t() === !0 ? n().next(() => {
                    i()
                }, s) : r()
            };
            i()
        })
    }
}

function dp(e) {
    return e.name === "IndexedDbTransactionError"
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dT {
    constructor(t, n) {
        this.previousValue = t, n && (n.sequenceNumberHandler = r => this.ot(r), this.ut = r => n.writeSequenceNumber(r))
    }
    ot(t) {
        return this.previousValue = Math.max(t, this.previousValue), this.previousValue
    }
    next() {
        const t = ++this.previousValue;
        return this.ut && this.ut(t), t
    }
}
dT.ct = -1;

function dv(e) {
    return e == null
}

function a_(e) {
    return e === 0 && 1 / e == -1 / 0
}

function b8(e) {
    return typeof e == "number" && Number.isInteger(e) && !a_(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Dx(e) {
    let t = 0;
    for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t++;
    return t
}

function Al(e, t) {
    for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t(n, e[n])
}

function HL(e) {
    for (const t in e)
        if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
    return !0
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fn {
    constructor(t, n) {
        this.comparator = t, this.root = n || An.EMPTY
    }
    insert(t, n) {
        return new fn(this.comparator, this.root.insert(t, n, this.comparator).copy(null, null, An.BLACK, null, null))
    }
    remove(t) {
        return new fn(this.comparator, this.root.remove(t, this.comparator).copy(null, null, An.BLACK, null, null))
    }
    get(t) {
        let n = this.root;
        for (; !n.isEmpty();) {
            const r = this.comparator(t, n.key);
            if (r === 0) return n.value;
            r < 0 ? n = n.left : r > 0 && (n = n.right)
        }
        return null
    }
    indexOf(t) {
        let n = 0,
            r = this.root;
        for (; !r.isEmpty();) {
            const s = this.comparator(t, r.key);
            if (s === 0) return n + r.left.size;
            s < 0 ? r = r.left : (n += r.left.size + 1, r = r.right)
        }
        return -1
    }
    isEmpty() {
        return this.root.isEmpty()
    }
    get size() {
        return this.root.size
    }
    minKey() {
        return this.root.minKey()
    }
    maxKey() {
        return this.root.maxKey()
    }
    inorderTraversal(t) {
        return this.root.inorderTraversal(t)
    }
    forEach(t) {
        this.inorderTraversal((n, r) => (t(n, r), !1))
    }
    toString() {
        const t = [];
        return this.inorderTraversal((n, r) => (t.push(`${n}:${r}`), !1)), `{${t.join(", ")}}`
    }
    reverseTraversal(t) {
        return this.root.reverseTraversal(t)
    }
    getIterator() {
        return new em(this.root, null, this.comparator, !1)
    }
    getIteratorFrom(t) {
        return new em(this.root, t, this.comparator, !1)
    }
    getReverseIterator() {
        return new em(this.root, null, this.comparator, !0)
    }
    getReverseIteratorFrom(t) {
        return new em(this.root, t, this.comparator, !0)
    }
}
class em {
    constructor(t, n, r, s) {
        this.isReverse = s, this.nodeStack = [];
        let i = 1;
        for (; !t.isEmpty();)
            if (i = n ? r(t.key, n) : 1, n && s && (i *= -1), i < 0) t = this.isReverse ? t.left : t.right;
            else {
                if (i === 0) {
                    this.nodeStack.push(t);
                    break
                }
                this.nodeStack.push(t), t = this.isReverse ? t.right : t.left
            }
    }
    getNext() {
        let t = this.nodeStack.pop();
        const n = {
            key: t.key,
            value: t.value
        };
        if (this.isReverse)
            for (t = t.left; !t.isEmpty();) this.nodeStack.push(t), t = t.right;
        else
            for (t = t.right; !t.isEmpty();) this.nodeStack.push(t), t = t.left;
        return n
    }
    hasNext() {
        return this.nodeStack.length > 0
    }
    peek() {
        if (this.nodeStack.length === 0) return null;
        const t = this.nodeStack[this.nodeStack.length - 1];
        return {
            key: t.key,
            value: t.value
        }
    }
}
class An {
    constructor(t, n, r, s, i) {
        this.key = t, this.value = n, this.color = r != null ? r : An.RED, this.left = s != null ? s : An.EMPTY, this.right = i != null ? i : An.EMPTY, this.size = this.left.size + 1 + this.right.size
    }
    copy(t, n, r, s, i) {
        return new An(t != null ? t : this.key, n != null ? n : this.value, r != null ? r : this.color, s != null ? s : this.left, i != null ? i : this.right)
    }
    isEmpty() {
        return !1
    }
    inorderTraversal(t) {
        return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t)
    }
    reverseTraversal(t) {
        return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t)
    }
    min() {
        return this.left.isEmpty() ? this : this.left.min()
    }
    minKey() {
        return this.min().key
    }
    maxKey() {
        return this.right.isEmpty() ? this.key : this.right.maxKey()
    }
    insert(t, n, r) {
        let s = this;
        const i = r(t, s.key);
        return s = i < 0 ? s.copy(null, null, null, s.left.insert(t, n, r), null) : i === 0 ? s.copy(null, n, null, null, null) : s.copy(null, null, null, null, s.right.insert(t, n, r)), s.fixUp()
    }
    removeMin() {
        if (this.left.isEmpty()) return An.EMPTY;
        let t = this;
        return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), t = t.copy(null, null, null, t.left.removeMin(), null), t.fixUp()
    }
    remove(t, n) {
        let r, s = this;
        if (n(t, s.key) < 0) s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t, n), null);
        else {
            if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), n(t, s.key) === 0) {
                if (s.right.isEmpty()) return An.EMPTY;
                r = s.right.min(), s = s.copy(r.key, r.value, null, null, s.right.removeMin())
            }
            s = s.copy(null, null, null, null, s.right.remove(t, n))
        }
        return s.fixUp()
    }
    isRed() {
        return this.color
    }
    fixUp() {
        let t = this;
        return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t
    }
    moveRedLeft() {
        let t = this.colorFlip();
        return t.right.left.isRed() && (t = t.copy(null, null, null, null, t.right.rotateRight()), t = t.rotateLeft(), t = t.colorFlip()), t
    }
    moveRedRight() {
        let t = this.colorFlip();
        return t.left.left.isRed() && (t = t.rotateRight(), t = t.colorFlip()), t
    }
    rotateLeft() {
        const t = this.copy(null, null, An.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, t, null)
    }
    rotateRight() {
        const t = this.copy(null, null, An.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, t)
    }
    colorFlip() {
        const t = this.left.copy(null, null, !this.left.color, null, null),
            n = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, t, n)
    }
    checkMaxDepth() {
        const t = this.check();
        return Math.pow(2, t) <= this.size + 1
    }
    check() {
        if (this.isRed() && this.left.isRed() || this.right.isRed()) throw $e();
        const t = this.left.check();
        if (t !== this.right.check()) throw $e();
        return t + (this.isRed() ? 0 : 1)
    }
}
An.EMPTY = null, An.RED = !0, An.BLACK = !1;
An.EMPTY = new class {
    constructor() {
        this.size = 0
    }
    get key() {
        throw $e()
    }
    get value() {
        throw $e()
    }
    get color() {
        throw $e()
    }
    get left() {
        throw $e()
    }
    get right() {
        throw $e()
    }
    copy(e, t, n, r, s) {
        return this
    }
    insert(e, t, n) {
        return new An(e, t)
    }
    remove(e, t) {
        return this
    }
    isEmpty() {
        return !0
    }
    inorderTraversal(e) {
        return !1
    }
    reverseTraversal(e) {
        return !1
    }
    minKey() {
        return null
    }
    maxKey() {
        return null
    }
    isRed() {
        return !1
    }
    checkMaxDepth() {
        return !0
    }
    check() {
        return 0
    }
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dn {
    constructor(t) {
        this.comparator = t, this.data = new fn(this.comparator)
    }
    has(t) {
        return this.data.get(t) !== null
    }
    first() {
        return this.data.minKey()
    }
    last() {
        return this.data.maxKey()
    }
    get size() {
        return this.data.size
    }
    indexOf(t) {
        return this.data.indexOf(t)
    }
    forEach(t) {
        this.data.inorderTraversal((n, r) => (t(n), !1))
    }
    forEachInRange(t, n) {
        const r = this.data.getIteratorFrom(t[0]);
        for (; r.hasNext();) {
            const s = r.getNext();
            if (this.comparator(s.key, t[1]) >= 0) return;
            n(s.key)
        }
    }
    forEachWhile(t, n) {
        let r;
        for (r = n !== void 0 ? this.data.getIteratorFrom(n) : this.data.getIterator(); r.hasNext();)
            if (!t(r.getNext().key)) return
    }
    firstAfterOrEqual(t) {
        const n = this.data.getIteratorFrom(t);
        return n.hasNext() ? n.getNext().key : null
    }
    getIterator() {
        return new Nx(this.data.getIterator())
    }
    getIteratorFrom(t) {
        return new Nx(this.data.getIteratorFrom(t))
    }
    add(t) {
        return this.copy(this.data.remove(t).insert(t, !0))
    }
    delete(t) {
        return this.has(t) ? this.copy(this.data.remove(t)) : this
    }
    isEmpty() {
        return this.data.isEmpty()
    }
    unionWith(t) {
        let n = this;
        return n.size < t.size && (n = t, t = this), t.forEach(r => {
            n = n.add(r)
        }), n
    }
    isEqual(t) {
        if (!(t instanceof dn) || this.size !== t.size) return !1;
        const n = this.data.getIterator(),
            r = t.data.getIterator();
        for (; n.hasNext();) {
            const s = n.getNext().key,
                i = r.getNext().key;
            if (this.comparator(s, i) !== 0) return !1
        }
        return !0
    }
    toArray() {
        const t = [];
        return this.forEach(n => {
            t.push(n)
        }), t
    }
    toString() {
        const t = [];
        return this.forEach(n => t.push(n)), "SortedSet(" + t.toString() + ")"
    }
    copy(t) {
        const n = new dn(this.comparator);
        return n.data = t, n
    }
}
class Nx {
    constructor(t) {
        this.iter = t
    }
    getNext() {
        return this.iter.getNext().key
    }
    hasNext() {
        return this.iter.hasNext()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dr {
    constructor(t) {
        this.fields = t, t.sort(Hn.comparator)
    }
    static empty() {
        return new Dr([])
    }
    unionWith(t) {
        let n = new dn(Hn.comparator);
        for (const r of this.fields) n = n.add(r);
        for (const r of t) n = n.add(r);
        return new Dr(n.toArray())
    }
    covers(t) {
        for (const n of this.fields)
            if (n.isPrefixOf(t)) return !0;
        return !1
    }
    isEqual(t) {
        return ru(this.fields, t.fields, (n, r) => n.isEqual(r))
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class w8 extends Error {
    constructor() {
        super(...arguments), this.name = "Base64DecodeError"
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xn {
    constructor(t) {
        this.binaryString = t
    }
    static fromBase64String(t) {
        const n = function(r) {
            try {
                return atob(r)
            } catch (s) {
                throw typeof DOMException != "undefined" && s instanceof DOMException ? new w8("Invalid base64 string: " + s) : s
            }
        }(t);
        return new Xn(n)
    }
    static fromUint8Array(t) {
        const n = function(r) {
            let s = "";
            for (let i = 0; i < r.length; ++i) s += String.fromCharCode(r[i]);
            return s
        }(t);
        return new Xn(n)
    }[Symbol.iterator]() {
        let t = 0;
        return {
            next: () => t < this.binaryString.length ? {
                value: this.binaryString.charCodeAt(t++),
                done: !1
            } : {
                value: void 0,
                done: !0
            }
        }
    }
    toBase64() {
        return t = this.binaryString, btoa(t);
        var t
    }
    toUint8Array() {
        return function(t) {
            const n = new Uint8Array(t.length);
            for (let r = 0; r < t.length; r++) n[r] = t.charCodeAt(r);
            return n
        }(this.binaryString)
    }
    approximateByteSize() {
        return 2 * this.binaryString.length
    }
    compareTo(t) {
        return ut(this.binaryString, t.binaryString)
    }
    isEqual(t) {
        return this.binaryString === t.binaryString
    }
}
Xn.EMPTY_BYTE_STRING = new Xn("");
const E8 = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);

function Vo(e) {
    if (Ct(!!e), typeof e == "string") {
        let t = 0;
        const n = E8.exec(e);
        if (Ct(!!n), n[1]) {
            let s = n[1];
            s = (s + "000000000").substr(0, 9), t = Number(s)
        }
        const r = new Date(e);
        return {
            seconds: Math.floor(r.getTime() / 1e3),
            nanos: t
        }
    }
    return {
        seconds: Qt(e.seconds),
        nanos: Qt(e.nanos)
    }
}

function Qt(e) {
    return typeof e == "number" ? e : typeof e == "string" ? Number(e) : 0
}

function su(e) {
    return typeof e == "string" ? Xn.fromBase64String(e) : Xn.fromUint8Array(e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jL(e) {
    var t, n;
    return ((n = (((t = e == null ? void 0 : e.mapValue) === null || t === void 0 ? void 0 : t.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp"
}

function zL(e) {
    const t = e.mapValue.fields.__previous_value__;
    return jL(t) ? zL(t) : t
}

function eh(e) {
    const t = Vo(e.mapValue.fields.__local_write_time__.timestampValue);
    return new un(t.seconds, t.nanos)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class S8 {
    constructor(t, n, r, s, i, o, a, l) {
        this.databaseId = t, this.appId = n, this.persistenceKey = r, this.host = s, this.ssl = i, this.forceLongPolling = o, this.autoDetectLongPolling = a, this.useFetchStreams = l
    }
}
class th {
    constructor(t, n) {
        this.projectId = t, this.database = n || "(default)"
    }
    static empty() {
        return new th("", "")
    }
    get isDefaultDatabase() {
        return this.database === "(default)"
    }
    isEqual(t) {
        return t instanceof th && t.projectId === this.projectId && t.database === this.database
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tm = {
    mapValue: {
        fields: {
            __type__: {
                stringValue: "__max__"
            }
        }
    }
};

function sl(e) {
    return "nullValue" in e ? 0 : "booleanValue" in e ? 1 : "integerValue" in e || "doubleValue" in e ? 2 : "timestampValue" in e ? 3 : "stringValue" in e ? 5 : "bytesValue" in e ? 6 : "referenceValue" in e ? 7 : "geoPointValue" in e ? 8 : "arrayValue" in e ? 9 : "mapValue" in e ? jL(e) ? 4 : T8(e) ? 9007199254740991 : 10 : $e()
}

function Us(e, t) {
    if (e === t) return !0;
    const n = sl(e);
    if (n !== sl(t)) return !1;
    switch (n) {
        case 0:
        case 9007199254740991:
            return !0;
        case 1:
            return e.booleanValue === t.booleanValue;
        case 4:
            return eh(e).isEqual(eh(t));
        case 3:
            return function(r, s) {
                if (typeof r.timestampValue == "string" && typeof s.timestampValue == "string" && r.timestampValue.length === s.timestampValue.length) return r.timestampValue === s.timestampValue;
                const i = Vo(r.timestampValue),
                    o = Vo(s.timestampValue);
                return i.seconds === o.seconds && i.nanos === o.nanos
            }(e, t);
        case 5:
            return e.stringValue === t.stringValue;
        case 6:
            return function(r, s) {
                return su(r.bytesValue).isEqual(su(s.bytesValue))
            }(e, t);
        case 7:
            return e.referenceValue === t.referenceValue;
        case 8:
            return function(r, s) {
                return Qt(r.geoPointValue.latitude) === Qt(s.geoPointValue.latitude) && Qt(r.geoPointValue.longitude) === Qt(s.geoPointValue.longitude)
            }(e, t);
        case 2:
            return function(r, s) {
                if ("integerValue" in r && "integerValue" in s) return Qt(r.integerValue) === Qt(s.integerValue);
                if ("doubleValue" in r && "doubleValue" in s) {
                    const i = Qt(r.doubleValue),
                        o = Qt(s.doubleValue);
                    return i === o ? a_(i) === a_(o) : isNaN(i) && isNaN(o)
                }
                return !1
            }(e, t);
        case 9:
            return ru(e.arrayValue.values || [], t.arrayValue.values || [], Us);
        case 10:
            return function(r, s) {
                const i = r.mapValue.fields || {},
                    o = s.mapValue.fields || {};
                if (Dx(i) !== Dx(o)) return !1;
                for (const a in i)
                    if (i.hasOwnProperty(a) && (o[a] === void 0 || !Us(i[a], o[a]))) return !1;
                return !0
            }(e, t);
        default:
            return $e()
    }
}

function nh(e, t) {
    return (e.values || []).find(n => Us(n, t)) !== void 0
}

function iu(e, t) {
    if (e === t) return 0;
    const n = sl(e),
        r = sl(t);
    if (n !== r) return ut(n, r);
    switch (n) {
        case 0:
        case 9007199254740991:
            return 0;
        case 1:
            return ut(e.booleanValue, t.booleanValue);
        case 2:
            return function(s, i) {
                const o = Qt(s.integerValue || s.doubleValue),
                    a = Qt(i.integerValue || i.doubleValue);
                return o < a ? -1 : o > a ? 1 : o === a ? 0 : isNaN(o) ? isNaN(a) ? 0 : -1 : 1
            }(e, t);
        case 3:
            return Px(e.timestampValue, t.timestampValue);
        case 4:
            return Px(eh(e), eh(t));
        case 5:
            return ut(e.stringValue, t.stringValue);
        case 6:
            return function(s, i) {
                const o = su(s),
                    a = su(i);
                return o.compareTo(a)
            }(e.bytesValue, t.bytesValue);
        case 7:
            return function(s, i) {
                const o = s.split("/"),
                    a = i.split("/");
                for (let l = 0; l < o.length && l < a.length; l++) {
                    const c = ut(o[l], a[l]);
                    if (c !== 0) return c
                }
                return ut(o.length, a.length)
            }(e.referenceValue, t.referenceValue);
        case 8:
            return function(s, i) {
                const o = ut(Qt(s.latitude), Qt(i.latitude));
                return o !== 0 ? o : ut(Qt(s.longitude), Qt(i.longitude))
            }(e.geoPointValue, t.geoPointValue);
        case 9:
            return function(s, i) {
                const o = s.values || [],
                    a = i.values || [];
                for (let l = 0; l < o.length && l < a.length; ++l) {
                    const c = iu(o[l], a[l]);
                    if (c) return c
                }
                return ut(o.length, a.length)
            }(e.arrayValue, t.arrayValue);
        case 10:
            return function(s, i) {
                if (s === tm.mapValue && i === tm.mapValue) return 0;
                if (s === tm.mapValue) return 1;
                if (i === tm.mapValue) return -1;
                const o = s.fields || {},
                    a = Object.keys(o),
                    l = i.fields || {},
                    c = Object.keys(l);
                a.sort(), c.sort();
                for (let u = 0; u < a.length && u < c.length; ++u) {
                    const d = ut(a[u], c[u]);
                    if (d !== 0) return d;
                    const f = iu(o[a[u]], l[c[u]]);
                    if (f !== 0) return f
                }
                return ut(a.length, c.length)
            }(e.mapValue, t.mapValue);
        default:
            throw $e()
    }
}

function Px(e, t) {
    if (typeof e == "string" && typeof t == "string" && e.length === t.length) return ut(e, t);
    const n = Vo(e),
        r = Vo(t),
        s = ut(n.seconds, r.seconds);
    return s !== 0 ? s : ut(n.nanos, r.nanos)
}

function ou(e) {
    return Qw(e)
}

function Qw(e) {
    return "nullValue" in e ? "null" : "booleanValue" in e ? "" + e.booleanValue : "integerValue" in e ? "" + e.integerValue : "doubleValue" in e ? "" + e.doubleValue : "timestampValue" in e ? function(r) {
        const s = Vo(r);
        return `time(${s.seconds},${s.nanos})`
    }(e.timestampValue) : "stringValue" in e ? e.stringValue : "bytesValue" in e ? su(e.bytesValue).toBase64() : "referenceValue" in e ? (n = e.referenceValue, ve.fromName(n).toString()) : "geoPointValue" in e ? `geo(${(t=e.geoPointValue).latitude},${t.longitude})` : "arrayValue" in e ? function(r) {
        let s = "[",
            i = !0;
        for (const o of r.values || []) i ? i = !1 : s += ",", s += Qw(o);
        return s + "]"
    }(e.arrayValue) : "mapValue" in e ? function(r) {
        const s = Object.keys(r.fields || {}).sort();
        let i = "{",
            o = !0;
        for (const a of s) o ? o = !1 : i += ",", i += `${a}:${Qw(r.fields[a])}`;
        return i + "}"
    }(e.mapValue) : $e();
    var t, n
}

function Mx(e, t) {
    return {
        referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}`
    }
}

function Jw(e) {
    return !!e && "integerValue" in e
}

function fT(e) {
    return !!e && "arrayValue" in e
}

function Lx(e) {
    return !!e && "nullValue" in e
}

function Fx(e) {
    return !!e && "doubleValue" in e && isNaN(Number(e.doubleValue))
}

function tg(e) {
    return !!e && "mapValue" in e
}

function Qd(e) {
    if (e.geoPointValue) return {
        geoPointValue: Object.assign({}, e.geoPointValue)
    };
    if (e.timestampValue && typeof e.timestampValue == "object") return {
        timestampValue: Object.assign({}, e.timestampValue)
    };
    if (e.mapValue) {
        const t = {
            mapValue: {
                fields: {}
            }
        };
        return Al(e.mapValue.fields, (n, r) => t.mapValue.fields[n] = Qd(r)), t
    }
    if (e.arrayValue) {
        const t = {
            arrayValue: {
                values: []
            }
        };
        for (let n = 0; n < (e.arrayValue.values || []).length; ++n) t.arrayValue.values[n] = Qd(e.arrayValue.values[n]);
        return t
    }
    return Object.assign({}, e)
}

function T8(e) {
    return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vr {
    constructor(t) {
        this.value = t
    }
    static empty() {
        return new vr({
            mapValue: {}
        })
    }
    field(t) {
        if (t.isEmpty()) return this.value; {
            let n = this.value;
            for (let r = 0; r < t.length - 1; ++r)
                if (n = (n.mapValue.fields || {})[t.get(r)], !tg(n)) return null;
            return n = (n.mapValue.fields || {})[t.lastSegment()], n || null
        }
    }
    set(t, n) {
        this.getFieldsMap(t.popLast())[t.lastSegment()] = Qd(n)
    }
    setAll(t) {
        let n = Hn.emptyPath(),
            r = {},
            s = [];
        t.forEach((o, a) => {
            if (!n.isImmediateParentOf(a)) {
                const l = this.getFieldsMap(n);
                this.applyChanges(l, r, s), r = {}, s = [], n = a.popLast()
            }
            o ? r[a.lastSegment()] = Qd(o) : s.push(a.lastSegment())
        });
        const i = this.getFieldsMap(n);
        this.applyChanges(i, r, s)
    }
    delete(t) {
        const n = this.field(t.popLast());
        tg(n) && n.mapValue.fields && delete n.mapValue.fields[t.lastSegment()]
    }
    isEqual(t) {
        return Us(this.value, t.value)
    }
    getFieldsMap(t) {
        let n = this.value;
        n.mapValue.fields || (n.mapValue = {
            fields: {}
        });
        for (let r = 0; r < t.length; ++r) {
            let s = n.mapValue.fields[t.get(r)];
            tg(s) && s.mapValue.fields || (s = {
                mapValue: {
                    fields: {}
                }
            }, n.mapValue.fields[t.get(r)] = s), n = s
        }
        return n.mapValue.fields
    }
    applyChanges(t, n, r) {
        Al(n, (s, i) => t[s] = i);
        for (const s of r) delete t[s]
    }
    clone() {
        return new vr(Qd(this.value))
    }
}

function WL(e) {
    const t = [];
    return Al(e.fields, (n, r) => {
        const s = new Hn([n]);
        if (tg(r)) {
            const i = WL(r.mapValue).fields;
            if (i.length === 0) t.push(s);
            else
                for (const o of i) t.push(s.child(o))
        } else t.push(s)
    }), new Dr(t)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bn {
    constructor(t, n, r, s, i, o, a) {
        this.key = t, this.documentType = n, this.version = r, this.readTime = s, this.createTime = i, this.data = o, this.documentState = a
    }
    static newInvalidDocument(t) {
        return new Bn(t, 0, Ce.min(), Ce.min(), Ce.min(), vr.empty(), 0)
    }
    static newFoundDocument(t, n, r, s) {
        return new Bn(t, 1, n, Ce.min(), r, s, 0)
    }
    static newNoDocument(t, n) {
        return new Bn(t, 2, n, Ce.min(), Ce.min(), vr.empty(), 0)
    }
    static newUnknownDocument(t, n) {
        return new Bn(t, 3, n, Ce.min(), Ce.min(), vr.empty(), 2)
    }
    convertToFoundDocument(t, n) {
        return !this.createTime.isEqual(Ce.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = t), this.version = t, this.documentType = 1, this.data = n, this.documentState = 0, this
    }
    convertToNoDocument(t) {
        return this.version = t, this.documentType = 2, this.data = vr.empty(), this.documentState = 0, this
    }
    convertToUnknownDocument(t) {
        return this.version = t, this.documentType = 3, this.data = vr.empty(), this.documentState = 2, this
    }
    setHasCommittedMutations() {
        return this.documentState = 2, this
    }
    setHasLocalMutations() {
        return this.documentState = 1, this.version = Ce.min(), this
    }
    setReadTime(t) {
        return this.readTime = t, this
    }
    get hasLocalMutations() {
        return this.documentState === 1
    }
    get hasCommittedMutations() {
        return this.documentState === 2
    }
    get hasPendingWrites() {
        return this.hasLocalMutations || this.hasCommittedMutations
    }
    isValidDocument() {
        return this.documentType !== 0
    }
    isFoundDocument() {
        return this.documentType === 1
    }
    isNoDocument() {
        return this.documentType === 2
    }
    isUnknownDocument() {
        return this.documentType === 3
    }
    isEqual(t) {
        return t instanceof Bn && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.documentType === t.documentType && this.documentState === t.documentState && this.data.isEqual(t.data)
    }
    mutableCopy() {
        return new Bn(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState)
    }
    toString() {
        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`
    }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class l_ {
    constructor(t, n) {
        this.position = t, this.inclusive = n
    }
}

function Ux(e, t, n) {
    let r = 0;
    for (let s = 0; s < e.position.length; s++) {
        const i = t[s],
            o = e.position[s];
        if (i.field.isKeyField() ? r = ve.comparator(ve.fromName(o.referenceValue), n.key) : r = iu(o, n.data.field(i.field)), i.dir === "desc" && (r *= -1), r !== 0) break
    }
    return r
}

function Bx(e, t) {
    if (e === null) return t === null;
    if (t === null || e.inclusive !== t.inclusive || e.position.length !== t.position.length) return !1;
    for (let n = 0; n < e.position.length; n++)
        if (!Us(e.position[n], t.position[n])) return !1;
    return !0
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kc {
    constructor(t, n = "asc") {
        this.field = t, this.dir = n
    }
}

function $8(e, t) {
    return e.dir === t.dir && e.field.isEqual(t.field)
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GL {}
class Jt extends GL {
    constructor(t, n, r) {
        super(), this.field = t, this.op = n, this.value = r
    }
    static create(t, n, r) {
        return t.isKeyField() ? n === "in" || n === "not-in" ? this.createKeyFieldInFilter(t, n, r) : new I8(t, n, r) : n === "array-contains" ? new A8(t, r) : n === "in" ? new R8(t, r) : n === "not-in" ? new O8(t, r) : n === "array-contains-any" ? new D8(t, r) : new Jt(t, n, r)
    }
    static createKeyFieldInFilter(t, n, r) {
        return n === "in" ? new x8(t, r) : new C8(t, r)
    }
    matches(t) {
        const n = t.data.field(this.field);
        return this.op === "!=" ? n !== null && this.matchesComparison(iu(n, this.value)) : n !== null && sl(this.value) === sl(n) && this.matchesComparison(iu(n, this.value))
    }
    matchesComparison(t) {
        switch (this.op) {
            case "<":
                return t < 0;
            case "<=":
                return t <= 0;
            case "==":
                return t === 0;
            case "!=":
                return t !== 0;
            case ">":
                return t > 0;
            case ">=":
                return t >= 0;
            default:
                return $e()
        }
    }
    isInequality() {
        return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0
    }
    getFlattenedFilters() {
        return [this]
    }
    getFilters() {
        return [this]
    }
    getFirstInequalityField() {
        return this.isInequality() ? this.field : null
    }
}
class gs extends GL {
    constructor(t, n) {
        super(), this.filters = t, this.op = n, this.ht = null
    }
    static create(t, n) {
        return new gs(t, n)
    }
    matches(t) {
        return qL(this) ? this.filters.find(n => !n.matches(t)) === void 0 : this.filters.find(n => n.matches(t)) !== void 0
    }
    getFlattenedFilters() {
        return this.ht !== null || (this.ht = this.filters.reduce((t, n) => t.concat(n.getFlattenedFilters()), [])), this.ht
    }
    getFilters() {
        return Object.assign([], this.filters)
    }
    getFirstInequalityField() {
        const t = this.lt(n => n.isInequality());
        return t !== null ? t.field : null
    }
    lt(t) {
        for (const n of this.getFlattenedFilters())
            if (t(n)) return n;
        return null
    }
}

function qL(e) {
    return e.op === "and"
}

function YL(e) {
    return k8(e) && qL(e)
}

function k8(e) {
    for (const t of e.filters)
        if (t instanceof gs) return !1;
    return !0
}

function Zw(e) {
    if (e instanceof Jt) return e.field.canonicalString() + e.op.toString() + ou(e.value);
    if (YL(e)) return e.filters.map(t => Zw(t)).join(","); {
        const t = e.filters.map(n => Zw(n)).join(",");
        return `${e.op}(${t})`
    }
}

function KL(e, t) {
    return e instanceof Jt ? function(n, r) {
        return r instanceof Jt && n.op === r.op && n.field.isEqual(r.field) && Us(n.value, r.value)
    }(e, t) : e instanceof gs ? function(n, r) {
        return r instanceof gs && n.op === r.op && n.filters.length === r.filters.length ? n.filters.reduce((s, i, o) => s && KL(i, r.filters[o]), !0) : !1
    }(e, t) : void $e()
}

function XL(e) {
    return e instanceof Jt ? function(t) {
        return `${t.field.canonicalString()} ${t.op} ${ou(t.value)}`
    }(e) : e instanceof gs ? function(t) {
        return t.op.toString() + " {" + t.getFilters().map(XL).join(" ,") + "}"
    }(e) : "Filter"
}
class I8 extends Jt {
    constructor(t, n, r) {
        super(t, n, r), this.key = ve.fromName(r.referenceValue)
    }
    matches(t) {
        const n = ve.comparator(t.key, this.key);
        return this.matchesComparison(n)
    }
}
class x8 extends Jt {
    constructor(t, n) {
        super(t, "in", n), this.keys = QL("in", n)
    }
    matches(t) {
        return this.keys.some(n => n.isEqual(t.key))
    }
}
class C8 extends Jt {
    constructor(t, n) {
        super(t, "not-in", n), this.keys = QL("not-in", n)
    }
    matches(t) {
        return !this.keys.some(n => n.isEqual(t.key))
    }
}

function QL(e, t) {
    var n;
    return (((n = t.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map(r => ve.fromName(r.referenceValue))
}
class A8 extends Jt {
    constructor(t, n) {
        super(t, "array-contains", n)
    }
    matches(t) {
        const n = t.data.field(this.field);
        return fT(n) && nh(n.arrayValue, this.value)
    }
}
class R8 extends Jt {
    constructor(t, n) {
        super(t, "in", n)
    }
    matches(t) {
        const n = t.data.field(this.field);
        return n !== null && nh(this.value.arrayValue, n)
    }
}
class O8 extends Jt {
    constructor(t, n) {
        super(t, "not-in", n)
    }
    matches(t) {
        if (nh(this.value.arrayValue, {
                nullValue: "NULL_VALUE"
            })) return !1;
        const n = t.data.field(this.field);
        return n !== null && !nh(this.value.arrayValue, n)
    }
}
class D8 extends Jt {
    constructor(t, n) {
        super(t, "array-contains-any", n)
    }
    matches(t) {
        const n = t.data.field(this.field);
        return !(!fT(n) || !n.arrayValue.values) && n.arrayValue.values.some(r => nh(this.value.arrayValue, r))
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class N8 {
    constructor(t, n = null, r = [], s = [], i = null, o = null, a = null) {
        this.path = t, this.collectionGroup = n, this.orderBy = r, this.filters = s, this.limit = i, this.startAt = o, this.endAt = a, this.ft = null
    }
}

function Vx(e, t = null, n = [], r = [], s = null, i = null, o = null) {
    return new N8(e, t, n, r, s, i, o)
}

function hT(e) {
    const t = Oe(e);
    if (t.ft === null) {
        let n = t.path.canonicalString();
        t.collectionGroup !== null && (n += "|cg:" + t.collectionGroup), n += "|f:", n += t.filters.map(r => Zw(r)).join(","), n += "|ob:", n += t.orderBy.map(r => function(s) {
            return s.field.canonicalString() + s.dir
        }(r)).join(","), dv(t.limit) || (n += "|l:", n += t.limit), t.startAt && (n += "|lb:", n += t.startAt.inclusive ? "b:" : "a:", n += t.startAt.position.map(r => ou(r)).join(",")), t.endAt && (n += "|ub:", n += t.endAt.inclusive ? "a:" : "b:", n += t.endAt.position.map(r => ou(r)).join(",")), t.ft = n
    }
    return t.ft
}

function pT(e, t) {
    if (e.limit !== t.limit || e.orderBy.length !== t.orderBy.length) return !1;
    for (let n = 0; n < e.orderBy.length; n++)
        if (!$8(e.orderBy[n], t.orderBy[n])) return !1;
    if (e.filters.length !== t.filters.length) return !1;
    for (let n = 0; n < e.filters.length; n++)
        if (!KL(e.filters[n], t.filters[n])) return !1;
    return e.collectionGroup === t.collectionGroup && !!e.path.isEqual(t.path) && !!Bx(e.startAt, t.startAt) && Bx(e.endAt, t.endAt)
}

function eE(e) {
    return ve.isDocumentKey(e.path) && e.collectionGroup === null && e.filters.length === 0
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qu {
    constructor(t, n = null, r = [], s = [], i = null, o = "F", a = null, l = null) {
        this.path = t, this.collectionGroup = n, this.explicitOrderBy = r, this.filters = s, this.limit = i, this.limitType = o, this.startAt = a, this.endAt = l, this.dt = null, this.wt = null, this.startAt, this.endAt
    }
}

function P8(e, t, n, r, s, i, o, a) {
    return new Qu(e, t, n, r, s, i, o, a)
}

function fv(e) {
    return new Qu(e)
}

function Hx(e) {
    return e.filters.length === 0 && e.limit === null && e.startAt == null && e.endAt == null && (e.explicitOrderBy.length === 0 || e.explicitOrderBy.length === 1 && e.explicitOrderBy[0].field.isKeyField())
}

function mT(e) {
    return e.explicitOrderBy.length > 0 ? e.explicitOrderBy[0].field : null
}

function hv(e) {
    for (const t of e.filters) {
        const n = t.getFirstInequalityField();
        if (n !== null) return n
    }
    return null
}

function JL(e) {
    return e.collectionGroup !== null
}

function Ic(e) {
    const t = Oe(e);
    if (t.dt === null) {
        t.dt = [];
        const n = hv(t),
            r = mT(t);
        if (n !== null && r === null) n.isKeyField() || t.dt.push(new kc(n)), t.dt.push(new kc(Hn.keyField(), "asc"));
        else {
            let s = !1;
            for (const i of t.explicitOrderBy) t.dt.push(i), i.field.isKeyField() && (s = !0);
            if (!s) {
                const i = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : "asc";
                t.dt.push(new kc(Hn.keyField(), i))
            }
        }
    }
    return t.dt
}

function Ei(e) {
    const t = Oe(e);
    if (!t.wt)
        if (t.limitType === "F") t.wt = Vx(t.path, t.collectionGroup, Ic(t), t.filters, t.limit, t.startAt, t.endAt);
        else {
            const n = [];
            for (const i of Ic(t)) {
                const o = i.dir === "desc" ? "asc" : "desc";
                n.push(new kc(i.field, o))
            }
            const r = t.endAt ? new l_(t.endAt.position, t.endAt.inclusive) : null,
                s = t.startAt ? new l_(t.startAt.position, t.startAt.inclusive) : null;
            t.wt = Vx(t.path, t.collectionGroup, n, t.filters, t.limit, r, s)
        }
    return t.wt
}

function tE(e, t) {
    t.getFirstInequalityField(), hv(e);
    const n = e.filters.concat([t]);
    return new Qu(e.path, e.collectionGroup, e.explicitOrderBy.slice(), n, e.limit, e.limitType, e.startAt, e.endAt)
}

function c_(e, t, n) {
    return new Qu(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), t, n, e.startAt, e.endAt)
}

function pv(e, t) {
    return pT(Ei(e), Ei(t)) && e.limitType === t.limitType
}

function ZL(e) {
    return `${hT(Ei(e))}|lt:${e.limitType}`
}

function nE(e) {
    return `Query(target=${function(t){let n=t.path.canonicalString();return t.collectionGroup!==null&&(n+=" collectionGroup="+t.collectionGroup),t.filters.length>0&&(n+=`, filters: [${t.filters.map(r=>XL(r)).join(", ")}]`),dv(t.limit)||(n+=", limit: "+t.limit),t.orderBy.length>0&&(n+=`, orderBy: [${t.orderBy.map(r=>function(s){return`${s.field.canonicalString()} (${s.dir})`}(r)).join(", ")}]`),t.startAt&&(n+=", startAt: ",n+=t.startAt.inclusive?"b:":"a:",n+=t.startAt.position.map(r=>ou(r)).join(",")),t.endAt&&(n+=", endAt: ",n+=t.endAt.inclusive?"a:":"b:",n+=t.endAt.position.map(r=>ou(r)).join(",")),`Target(${n})`}(Ei(e))}; limitType=${e.limitType})`
}

function mv(e, t) {
    return t.isFoundDocument() && function(n, r) {
        const s = r.key.path;
        return n.collectionGroup !== null ? r.key.hasCollectionId(n.collectionGroup) && n.path.isPrefixOf(s) : ve.isDocumentKey(n.path) ? n.path.isEqual(s) : n.path.isImmediateParentOf(s)
    }(e, t) && function(n, r) {
        for (const s of Ic(n))
            if (!s.field.isKeyField() && r.data.field(s.field) === null) return !1;
        return !0
    }(e, t) && function(n, r) {
        for (const s of n.filters)
            if (!s.matches(r)) return !1;
        return !0
    }(e, t) && function(n, r) {
        return !(n.startAt && ! function(s, i, o) {
            const a = Ux(s, i, o);
            return s.inclusive ? a <= 0 : a < 0
        }(n.startAt, Ic(n), r) || n.endAt && ! function(s, i, o) {
            const a = Ux(s, i, o);
            return s.inclusive ? a >= 0 : a > 0
        }(n.endAt, Ic(n), r))
    }(e, t)
}

function M8(e) {
    return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2))
}

function e2(e) {
    return (t, n) => {
        let r = !1;
        for (const s of Ic(e)) {
            const i = L8(s, t, n);
            if (i !== 0) return i;
            r = r || s.field.isKeyField()
        }
        return 0
    }
}

function L8(e, t, n) {
    const r = e.field.isKeyField() ? ve.comparator(t.key, n.key) : function(s, i, o) {
        const a = i.data.field(s),
            l = o.data.field(s);
        return a !== null && l !== null ? iu(a, l) : $e()
    }(e.field, t, n);
    switch (e.dir) {
        case "asc":
            return r;
        case "desc":
            return -1 * r;
        default:
            return $e()
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ju {
    constructor(t, n) {
        this.mapKeyFn = t, this.equalsFn = n, this.inner = {}, this.innerSize = 0
    }
    get(t) {
        const n = this.mapKeyFn(t),
            r = this.inner[n];
        if (r !== void 0) {
            for (const [s, i] of r)
                if (this.equalsFn(s, t)) return i
        }
    }
    has(t) {
        return this.get(t) !== void 0
    }
    set(t, n) {
        const r = this.mapKeyFn(t),
            s = this.inner[r];
        if (s === void 0) return this.inner[r] = [
            [t, n]
        ], void this.innerSize++;
        for (let i = 0; i < s.length; i++)
            if (this.equalsFn(s[i][0], t)) return void(s[i] = [t, n]);
        s.push([t, n]), this.innerSize++
    }
    delete(t) {
        const n = this.mapKeyFn(t),
            r = this.inner[n];
        if (r === void 0) return !1;
        for (let s = 0; s < r.length; s++)
            if (this.equalsFn(r[s][0], t)) return r.length === 1 ? delete this.inner[n] : r.splice(s, 1), this.innerSize--, !0;
        return !1
    }
    forEach(t) {
        Al(this.inner, (n, r) => {
            for (const [s, i] of r) t(s, i)
        })
    }
    isEmpty() {
        return HL(this.inner)
    }
    size() {
        return this.innerSize
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const F8 = new fn(ve.comparator);

function Si() {
    return F8
}
const t2 = new fn(ve.comparator);

function Dd(...e) {
    let t = t2;
    for (const n of e) t = t.insert(n.key, n);
    return t
}

function n2(e) {
    let t = t2;
    return e.forEach((n, r) => t = t.insert(n, r.overlayedDocument)), t
}

function Da() {
    return Jd()
}

function r2() {
    return Jd()
}

function Jd() {
    return new Ju(e => e.toString(), (e, t) => e.isEqual(t))
}
const U8 = new fn(ve.comparator),
    B8 = new dn(ve.comparator);

function je(...e) {
    let t = B8;
    for (const n of e) t = t.add(n);
    return t
}
const V8 = new dn(ut);

function s2() {
    return V8
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function i2(e, t) {
    if (e.useProto3Json) {
        if (isNaN(t)) return {
            doubleValue: "NaN"
        };
        if (t === 1 / 0) return {
            doubleValue: "Infinity"
        };
        if (t === -1 / 0) return {
            doubleValue: "-Infinity"
        }
    }
    return {
        doubleValue: a_(t) ? "-0" : t
    }
}

function o2(e) {
    return {
        integerValue: "" + e
    }
}

function H8(e, t) {
    return b8(t) ? o2(t) : i2(e, t)
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gv {
    constructor() {
        this._ = void 0
    }
}

function j8(e, t, n) {
    return e instanceof rh ? function(r, s) {
        const i = {
            fields: {
                __type__: {
                    stringValue: "server_timestamp"
                },
                __local_write_time__: {
                    timestampValue: {
                        seconds: r.seconds,
                        nanos: r.nanoseconds
                    }
                }
            }
        };
        return s && (i.fields.__previous_value__ = s), {
            mapValue: i
        }
    }(n, t) : e instanceof sh ? l2(e, t) : e instanceof ih ? c2(e, t) : function(r, s) {
        const i = a2(r, s),
            o = jx(i) + jx(r._t);
        return Jw(i) && Jw(r._t) ? o2(o) : i2(r.serializer, o)
    }(e, t)
}

function z8(e, t, n) {
    return e instanceof sh ? l2(e, t) : e instanceof ih ? c2(e, t) : n
}

function a2(e, t) {
    return e instanceof u_ ? Jw(n = t) || function(r) {
        return !!r && "doubleValue" in r
    }(n) ? t : {
        integerValue: 0
    } : null;
    var n
}
class rh extends gv {}
class sh extends gv {
    constructor(t) {
        super(), this.elements = t
    }
}

function l2(e, t) {
    const n = u2(t);
    for (const r of e.elements) n.some(s => Us(s, r)) || n.push(r);
    return {
        arrayValue: {
            values: n
        }
    }
}
class ih extends gv {
    constructor(t) {
        super(), this.elements = t
    }
}

function c2(e, t) {
    let n = u2(t);
    for (const r of e.elements) n = n.filter(s => !Us(s, r));
    return {
        arrayValue: {
            values: n
        }
    }
}
class u_ extends gv {
    constructor(t, n) {
        super(), this.serializer = t, this._t = n
    }
}

function jx(e) {
    return Qt(e.integerValue || e.doubleValue)
}

function u2(e) {
    return fT(e) && e.arrayValue.values ? e.arrayValue.values.slice() : []
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class W8 {
    constructor(t, n) {
        this.field = t, this.transform = n
    }
}

function G8(e, t) {
    return e.field.isEqual(t.field) && function(n, r) {
        return n instanceof sh && r instanceof sh || n instanceof ih && r instanceof ih ? ru(n.elements, r.elements, Us) : n instanceof u_ && r instanceof u_ ? Us(n._t, r._t) : n instanceof rh && r instanceof rh
    }(e.transform, t.transform)
}
class q8 {
    constructor(t, n) {
        this.version = t, this.transformResults = n
    }
}
class Cs {
    constructor(t, n) {
        this.updateTime = t, this.exists = n
    }
    static none() {
        return new Cs
    }
    static exists(t) {
        return new Cs(void 0, t)
    }
    static updateTime(t) {
        return new Cs(t)
    }
    get isNone() {
        return this.updateTime === void 0 && this.exists === void 0
    }
    isEqual(t) {
        return this.exists === t.exists && (this.updateTime ? !!t.updateTime && this.updateTime.isEqual(t.updateTime) : !t.updateTime)
    }
}

function ng(e, t) {
    return e.updateTime !== void 0 ? t.isFoundDocument() && t.version.isEqual(e.updateTime) : e.exists === void 0 || e.exists === t.isFoundDocument()
}
class _v {}

function d2(e, t) {
    if (!e.hasLocalMutations || t && t.fields.length === 0) return null;
    if (t === null) return e.isNoDocument() ? new h2(e.key, Cs.none()) : new fp(e.key, e.data, Cs.none()); {
        const n = e.data,
            r = vr.empty();
        let s = new dn(Hn.comparator);
        for (let i of t.fields)
            if (!s.has(i)) {
                let o = n.field(i);
                o === null && i.length > 1 && (i = i.popLast(), o = n.field(i)), o === null ? r.delete(i) : r.set(i, o), s = s.add(i)
            }
        return new la(e.key, r, new Dr(s.toArray()), Cs.none())
    }
}

function Y8(e, t, n) {
    e instanceof fp ? function(r, s, i) {
        const o = r.value.clone(),
            a = Wx(r.fieldTransforms, s, i.transformResults);
        o.setAll(a), s.convertToFoundDocument(i.version, o).setHasCommittedMutations()
    }(e, t, n) : e instanceof la ? function(r, s, i) {
        if (!ng(r.precondition, s)) return void s.convertToUnknownDocument(i.version);
        const o = Wx(r.fieldTransforms, s, i.transformResults),
            a = s.data;
        a.setAll(f2(r)), a.setAll(o), s.convertToFoundDocument(i.version, a).setHasCommittedMutations()
    }(e, t, n) : function(r, s, i) {
        s.convertToNoDocument(i.version).setHasCommittedMutations()
    }(0, t, n)
}

function Zd(e, t, n, r) {
    return e instanceof fp ? function(s, i, o, a) {
        if (!ng(s.precondition, i)) return o;
        const l = s.value.clone(),
            c = Gx(s.fieldTransforms, a, i);
        return l.setAll(c), i.convertToFoundDocument(i.version, l).setHasLocalMutations(), null
    }(e, t, n, r) : e instanceof la ? function(s, i, o, a) {
        if (!ng(s.precondition, i)) return o;
        const l = Gx(s.fieldTransforms, a, i),
            c = i.data;
        return c.setAll(f2(s)), c.setAll(l), i.convertToFoundDocument(i.version, c).setHasLocalMutations(), o === null ? null : o.unionWith(s.fieldMask.fields).unionWith(s.fieldTransforms.map(u => u.field))
    }(e, t, n, r) : function(s, i, o) {
        return ng(s.precondition, i) ? (i.convertToNoDocument(i.version).setHasLocalMutations(), null) : o
    }(e, t, n)
}

function K8(e, t) {
    let n = null;
    for (const r of e.fieldTransforms) {
        const s = t.data.field(r.field),
            i = a2(r.transform, s || null);
        i != null && (n === null && (n = vr.empty()), n.set(r.field, i))
    }
    return n || null
}

function zx(e, t) {
    return e.type === t.type && !!e.key.isEqual(t.key) && !!e.precondition.isEqual(t.precondition) && !! function(n, r) {
        return n === void 0 && r === void 0 || !(!n || !r) && ru(n, r, (s, i) => G8(s, i))
    }(e.fieldTransforms, t.fieldTransforms) && (e.type === 0 ? e.value.isEqual(t.value) : e.type !== 1 || e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask))
}
class fp extends _v {
    constructor(t, n, r, s = []) {
        super(), this.key = t, this.value = n, this.precondition = r, this.fieldTransforms = s, this.type = 0
    }
    getFieldMask() {
        return null
    }
}
class la extends _v {
    constructor(t, n, r, s, i = []) {
        super(), this.key = t, this.data = n, this.fieldMask = r, this.precondition = s, this.fieldTransforms = i, this.type = 1
    }
    getFieldMask() {
        return this.fieldMask
    }
}

function f2(e) {
    const t = new Map;
    return e.fieldMask.fields.forEach(n => {
        if (!n.isEmpty()) {
            const r = e.data.field(n);
            t.set(n, r)
        }
    }), t
}

function Wx(e, t, n) {
    const r = new Map;
    Ct(e.length === n.length);
    for (let s = 0; s < n.length; s++) {
        const i = e[s],
            o = i.transform,
            a = t.data.field(i.field);
        r.set(i.field, z8(o, a, n[s]))
    }
    return r
}

function Gx(e, t, n) {
    const r = new Map;
    for (const s of e) {
        const i = s.transform,
            o = n.data.field(s.field);
        r.set(s.field, j8(i, o, t))
    }
    return r
}
class h2 extends _v {
    constructor(t, n) {
        super(), this.key = t, this.precondition = n, this.type = 2, this.fieldTransforms = []
    }
    getFieldMask() {
        return null
    }
}
class X8 extends _v {
    constructor(t, n) {
        super(), this.key = t, this.precondition = n, this.type = 3, this.fieldTransforms = []
    }
    getFieldMask() {
        return null
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Q8 {
    constructor(t, n, r, s) {
        this.batchId = t, this.localWriteTime = n, this.baseMutations = r, this.mutations = s
    }
    applyToRemoteDocument(t, n) {
        const r = n.mutationResults;
        for (let s = 0; s < this.mutations.length; s++) {
            const i = this.mutations[s];
            i.key.isEqual(t.key) && Y8(i, t, r[s])
        }
    }
    applyToLocalView(t, n) {
        for (const r of this.baseMutations) r.key.isEqual(t.key) && (n = Zd(r, t, n, this.localWriteTime));
        for (const r of this.mutations) r.key.isEqual(t.key) && (n = Zd(r, t, n, this.localWriteTime));
        return n
    }
    applyToLocalDocumentSet(t, n) {
        const r = r2();
        return this.mutations.forEach(s => {
            const i = t.get(s.key),
                o = i.overlayedDocument;
            let a = this.applyToLocalView(o, i.mutatedFields);
            a = n.has(s.key) ? null : a;
            const l = d2(o, a);
            l !== null && r.set(s.key, l), o.isValidDocument() || o.convertToNoDocument(Ce.min())
        }), r
    }
    keys() {
        return this.mutations.reduce((t, n) => t.add(n.key), je())
    }
    isEqual(t) {
        return this.batchId === t.batchId && ru(this.mutations, t.mutations, (n, r) => zx(n, r)) && ru(this.baseMutations, t.baseMutations, (n, r) => zx(n, r))
    }
}
class gT {
    constructor(t, n, r, s) {
        this.batch = t, this.commitVersion = n, this.mutationResults = r, this.docVersions = s
    }
    static from(t, n, r) {
        Ct(t.mutations.length === r.length);
        let s = U8;
        const i = t.mutations;
        for (let o = 0; o < i.length; o++) s = s.insert(i[o].key, r[o].version);
        return new gT(t, n, r, s)
    }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class J8 {
    constructor(t, n) {
        this.largestBatchId = t, this.mutation = n
    }
    getKey() {
        return this.mutation.key
    }
    isEqual(t) {
        return t !== null && this.mutation === t.mutation
    }
    toString() {
        return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Z8 {
    constructor(t) {
        this.count = t
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Xt, Ge;

function eY(e) {
    switch (e) {
        default: return $e();
        case U.CANCELLED:
                case U.UNKNOWN:
                case U.DEADLINE_EXCEEDED:
                case U.RESOURCE_EXHAUSTED:
                case U.INTERNAL:
                case U.UNAVAILABLE:
                case U.UNAUTHENTICATED:
                return !1;
        case U.INVALID_ARGUMENT:
                case U.NOT_FOUND:
                case U.ALREADY_EXISTS:
                case U.PERMISSION_DENIED:
                case U.FAILED_PRECONDITION:
                case U.ABORTED:
                case U.OUT_OF_RANGE:
                case U.UNIMPLEMENTED:
                case U.DATA_LOSS:
                return !0
    }
}

function p2(e) {
    if (e === void 0) return wi("GRPC error has no .code"), U.UNKNOWN;
    switch (e) {
        case Xt.OK:
            return U.OK;
        case Xt.CANCELLED:
            return U.CANCELLED;
        case Xt.UNKNOWN:
            return U.UNKNOWN;
        case Xt.DEADLINE_EXCEEDED:
            return U.DEADLINE_EXCEEDED;
        case Xt.RESOURCE_EXHAUSTED:
            return U.RESOURCE_EXHAUSTED;
        case Xt.INTERNAL:
            return U.INTERNAL;
        case Xt.UNAVAILABLE:
            return U.UNAVAILABLE;
        case Xt.UNAUTHENTICATED:
            return U.UNAUTHENTICATED;
        case Xt.INVALID_ARGUMENT:
            return U.INVALID_ARGUMENT;
        case Xt.NOT_FOUND:
            return U.NOT_FOUND;
        case Xt.ALREADY_EXISTS:
            return U.ALREADY_EXISTS;
        case Xt.PERMISSION_DENIED:
            return U.PERMISSION_DENIED;
        case Xt.FAILED_PRECONDITION:
            return U.FAILED_PRECONDITION;
        case Xt.ABORTED:
            return U.ABORTED;
        case Xt.OUT_OF_RANGE:
            return U.OUT_OF_RANGE;
        case Xt.UNIMPLEMENTED:
            return U.UNIMPLEMENTED;
        case Xt.DATA_LOSS:
            return U.DATA_LOSS;
        default:
            return $e()
    }
}(Ge = Xt || (Xt = {}))[Ge.OK = 0] = "OK", Ge[Ge.CANCELLED = 1] = "CANCELLED", Ge[Ge.UNKNOWN = 2] = "UNKNOWN", Ge[Ge.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Ge[Ge.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Ge[Ge.NOT_FOUND = 5] = "NOT_FOUND", Ge[Ge.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Ge[Ge.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Ge[Ge.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Ge[Ge.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Ge[Ge.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Ge[Ge.ABORTED = 10] = "ABORTED", Ge[Ge.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Ge[Ge.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Ge[Ge.INTERNAL = 13] = "INTERNAL", Ge[Ge.UNAVAILABLE = 14] = "UNAVAILABLE", Ge[Ge.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _T {
    constructor() {
        this.onExistenceFilterMismatchCallbacks = new Map
    }
    static get instance() {
        return nm
    }
    static getOrCreateInstance() {
        return nm === null && (nm = new _T), nm
    }
    onExistenceFilterMismatch(t) {
        const n = Symbol();
        return this.onExistenceFilterMismatchCallbacks.set(n, t), () => this.onExistenceFilterMismatchCallbacks.delete(n)
    }
    notifyOnExistenceFilterMismatch(t) {
        this.onExistenceFilterMismatchCallbacks.forEach(n => n(t))
    }
}
let nm = null;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yv {
    constructor(t, n, r, s, i) {
        this.snapshotVersion = t, this.targetChanges = n, this.targetMismatches = r, this.documentUpdates = s, this.resolvedLimboDocuments = i
    }
    static createSynthesizedRemoteEventForCurrentChange(t, n, r) {
        const s = new Map;
        return s.set(t, hp.createSynthesizedTargetChangeForCurrentChange(t, n, r)), new yv(Ce.min(), s, s2(), Si(), je())
    }
}
class hp {
    constructor(t, n, r, s, i) {
        this.resumeToken = t, this.current = n, this.addedDocuments = r, this.modifiedDocuments = s, this.removedDocuments = i
    }
    static createSynthesizedTargetChangeForCurrentChange(t, n, r) {
        return new hp(r, n, je(), je(), je())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rg {
    constructor(t, n, r, s) {
        this.It = t, this.removedTargetIds = n, this.key = r, this.Tt = s
    }
}
class m2 {
    constructor(t, n) {
        this.targetId = t, this.Et = n
    }
}
class g2 {
    constructor(t, n, r = Xn.EMPTY_BYTE_STRING, s = null) {
        this.state = t, this.targetIds = n, this.resumeToken = r, this.cause = s
    }
}
class qx {
    constructor() {
        this.At = 0, this.Rt = Kx(), this.vt = Xn.EMPTY_BYTE_STRING, this.bt = !1, this.Pt = !0
    }
    get current() {
        return this.bt
    }
    get resumeToken() {
        return this.vt
    }
    get Vt() {
        return this.At !== 0
    }
    get St() {
        return this.Pt
    }
    Dt(t) {
        t.approximateByteSize() > 0 && (this.Pt = !0, this.vt = t)
    }
    Ct() {
        let t = je(),
            n = je(),
            r = je();
        return this.Rt.forEach((s, i) => {
            switch (i) {
                case 0:
                    t = t.add(s);
                    break;
                case 2:
                    n = n.add(s);
                    break;
                case 1:
                    r = r.add(s);
                    break;
                default:
                    $e()
            }
        }), new hp(this.vt, this.bt, t, n, r)
    }
    xt() {
        this.Pt = !1, this.Rt = Kx()
    }
    Nt(t, n) {
        this.Pt = !0, this.Rt = this.Rt.insert(t, n)
    }
    kt(t) {
        this.Pt = !0, this.Rt = this.Rt.remove(t)
    }
    Ot() {
        this.At += 1
    }
    $t() {
        this.At -= 1
    }
    Mt() {
        this.Pt = !0, this.bt = !0
    }
}
class tY {
    constructor(t) {
        this.Ft = t, this.Bt = new Map, this.Lt = Si(), this.qt = Yx(), this.Ut = new dn(ut)
    }
    Kt(t) {
        for (const n of t.It) t.Tt && t.Tt.isFoundDocument() ? this.Gt(n, t.Tt) : this.Qt(n, t.key, t.Tt);
        for (const n of t.removedTargetIds) this.Qt(n, t.key, t.Tt)
    }
    zt(t) {
        this.forEachTarget(t, n => {
            const r = this.jt(n);
            switch (t.state) {
                case 0:
                    this.Wt(n) && r.Dt(t.resumeToken);
                    break;
                case 1:
                    r.$t(), r.Vt || r.xt(), r.Dt(t.resumeToken);
                    break;
                case 2:
                    r.$t(), r.Vt || this.removeTarget(n);
                    break;
                case 3:
                    this.Wt(n) && (r.Mt(), r.Dt(t.resumeToken));
                    break;
                case 4:
                    this.Wt(n) && (this.Ht(n), r.Dt(t.resumeToken));
                    break;
                default:
                    $e()
            }
        })
    }
    forEachTarget(t, n) {
        t.targetIds.length > 0 ? t.targetIds.forEach(n) : this.Bt.forEach((r, s) => {
            this.Wt(s) && n(s)
        })
    }
    Jt(t) {
        var n;
        const r = t.targetId,
            s = t.Et.count,
            i = this.Yt(r);
        if (i) {
            const o = i.target;
            if (eE(o))
                if (s === 0) {
                    const a = new ve(o.path);
                    this.Qt(r, a, Bn.newNoDocument(a, Ce.min()))
                } else Ct(s === 1);
            else {
                const a = this.Zt(r);
                a !== s && (this.Ht(r), this.Ut = this.Ut.add(r), (n = _T.instance) === null || n === void 0 || n.notifyOnExistenceFilterMismatch({
                    localCacheCount: a,
                    existenceFilterCount: t.Et.count
                }))
            }
        }
    }
    Xt(t) {
        const n = new Map;
        this.Bt.forEach((i, o) => {
            const a = this.Yt(o);
            if (a) {
                if (i.current && eE(a.target)) {
                    const l = new ve(a.target.path);
                    this.Lt.get(l) !== null || this.te(o, l) || this.Qt(o, l, Bn.newNoDocument(l, t))
                }
                i.St && (n.set(o, i.Ct()), i.xt())
            }
        });
        let r = je();
        this.qt.forEach((i, o) => {
            let a = !0;
            o.forEachWhile(l => {
                const c = this.Yt(l);
                return !c || c.purpose === 2 || (a = !1, !1)
            }), a && (r = r.add(i))
        }), this.Lt.forEach((i, o) => o.setReadTime(t));
        const s = new yv(t, n, this.Ut, this.Lt, r);
        return this.Lt = Si(), this.qt = Yx(), this.Ut = new dn(ut), s
    }
    Gt(t, n) {
        if (!this.Wt(t)) return;
        const r = this.te(t, n.key) ? 2 : 0;
        this.jt(t).Nt(n.key, r), this.Lt = this.Lt.insert(n.key, n), this.qt = this.qt.insert(n.key, this.ee(n.key).add(t))
    }
    Qt(t, n, r) {
        if (!this.Wt(t)) return;
        const s = this.jt(t);
        this.te(t, n) ? s.Nt(n, 1) : s.kt(n), this.qt = this.qt.insert(n, this.ee(n).delete(t)), r && (this.Lt = this.Lt.insert(n, r))
    }
    removeTarget(t) {
        this.Bt.delete(t)
    }
    Zt(t) {
        const n = this.jt(t).Ct();
        return this.Ft.getRemoteKeysForTarget(t).size + n.addedDocuments.size - n.removedDocuments.size
    }
    Ot(t) {
        this.jt(t).Ot()
    }
    jt(t) {
        let n = this.Bt.get(t);
        return n || (n = new qx, this.Bt.set(t, n)), n
    }
    ee(t) {
        let n = this.qt.get(t);
        return n || (n = new dn(ut), this.qt = this.qt.insert(t, n)), n
    }
    Wt(t) {
        const n = this.Yt(t) !== null;
        return n || me("WatchChangeAggregator", "Detected inactive target", t), n
    }
    Yt(t) {
        const n = this.Bt.get(t);
        return n && n.Vt ? null : this.Ft.ne(t)
    }
    Ht(t) {
        this.Bt.set(t, new qx), this.Ft.getRemoteKeysForTarget(t).forEach(n => {
            this.Qt(t, n, null)
        })
    }
    te(t, n) {
        return this.Ft.getRemoteKeysForTarget(t).has(n)
    }
}

function Yx() {
    return new fn(ve.comparator)
}

function Kx() {
    return new fn(ve.comparator)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nY = (() => ({
        asc: "ASCENDING",
        desc: "DESCENDING"
    }))(),
    rY = (() => ({
        "<": "LESS_THAN",
        "<=": "LESS_THAN_OR_EQUAL",
        ">": "GREATER_THAN",
        ">=": "GREATER_THAN_OR_EQUAL",
        "==": "EQUAL",
        "!=": "NOT_EQUAL",
        "array-contains": "ARRAY_CONTAINS",
        in: "IN",
        "not-in": "NOT_IN",
        "array-contains-any": "ARRAY_CONTAINS_ANY"
    }))(),
    sY = (() => ({
        and: "AND",
        or: "OR"
    }))();
class iY {
    constructor(t, n) {
        this.databaseId = t, this.useProto3Json = n
    }
}

function d_(e, t) {
    return e.useProto3Json ? `${new Date(1e3*t.seconds).toISOString().replace(/\.\d*/,"").replace("Z","")}.${("000000000"+t.nanoseconds).slice(-9)}Z` : {
        seconds: "" + t.seconds,
        nanos: t.nanoseconds
    }
}

function _2(e, t) {
    return e.useProto3Json ? t.toBase64() : t.toUint8Array()
}

function oY(e, t) {
    return d_(e, t.toTimestamp())
}

function As(e) {
    return Ct(!!e), Ce.fromTimestamp(function(t) {
        const n = Vo(t);
        return new un(n.seconds, n.nanos)
    }(e))
}

function yT(e, t) {
    return function(n) {
        return new xt(["projects", n.projectId, "databases", n.database])
    }(e).child("documents").child(t).canonicalString()
}

function y2(e) {
    const t = xt.fromString(e);
    return Ct(E2(t)), t
}

function rE(e, t) {
    return yT(e.databaseId, t.path)
}

function i0(e, t) {
    const n = y2(t);
    if (n.get(1) !== e.databaseId.projectId) throw new re(U.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + e.databaseId.projectId);
    if (n.get(3) !== e.databaseId.database) throw new re(U.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + e.databaseId.database);
    return new ve(v2(n))
}

function sE(e, t) {
    return yT(e.databaseId, t)
}

function aY(e) {
    const t = y2(e);
    return t.length === 4 ? xt.emptyPath() : v2(t)
}

function iE(e) {
    return new xt(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString()
}

function v2(e) {
    return Ct(e.length > 4 && e.get(4) === "documents"), e.popFirst(5)
}

function Xx(e, t, n) {
    return {
        name: rE(e, t),
        fields: n.value.mapValue.fields
    }
}

function lY(e, t) {
    let n;
    if ("targetChange" in t) {
        t.targetChange;
        const r = function(l) {
                return l === "NO_CHANGE" ? 0 : l === "ADD" ? 1 : l === "REMOVE" ? 2 : l === "CURRENT" ? 3 : l === "RESET" ? 4 : $e()
            }(t.targetChange.targetChangeType || "NO_CHANGE"),
            s = t.targetChange.targetIds || [],
            i = function(l, c) {
                return l.useProto3Json ? (Ct(c === void 0 || typeof c == "string"), Xn.fromBase64String(c || "")) : (Ct(c === void 0 || c instanceof Uint8Array), Xn.fromUint8Array(c || new Uint8Array))
            }(e, t.targetChange.resumeToken),
            o = t.targetChange.cause,
            a = o && function(l) {
                const c = l.code === void 0 ? U.UNKNOWN : p2(l.code);
                return new re(c, l.message || "")
            }(o);
        n = new g2(r, s, i, a || null)
    } else if ("documentChange" in t) {
        t.documentChange;
        const r = t.documentChange;
        r.document, r.document.name, r.document.updateTime;
        const s = i0(e, r.document.name),
            i = As(r.document.updateTime),
            o = r.document.createTime ? As(r.document.createTime) : Ce.min(),
            a = new vr({
                mapValue: {
                    fields: r.document.fields
                }
            }),
            l = Bn.newFoundDocument(s, i, o, a),
            c = r.targetIds || [],
            u = r.removedTargetIds || [];
        n = new rg(c, u, l.key, l)
    } else if ("documentDelete" in t) {
        t.documentDelete;
        const r = t.documentDelete;
        r.document;
        const s = i0(e, r.document),
            i = r.readTime ? As(r.readTime) : Ce.min(),
            o = Bn.newNoDocument(s, i),
            a = r.removedTargetIds || [];
        n = new rg([], a, o.key, o)
    } else if ("documentRemove" in t) {
        t.documentRemove;
        const r = t.documentRemove;
        r.document;
        const s = i0(e, r.document),
            i = r.removedTargetIds || [];
        n = new rg([], i, s, null)
    } else {
        if (!("filter" in t)) return $e(); {
            t.filter;
            const r = t.filter;
            r.targetId;
            const s = r.count || 0,
                i = new Z8(s),
                o = r.targetId;
            n = new m2(o, i)
        }
    }
    return n
}

function cY(e, t) {
    let n;
    if (t instanceof fp) n = {
        update: Xx(e, t.key, t.value)
    };
    else if (t instanceof h2) n = {
        delete: rE(e, t.key)
    };
    else if (t instanceof la) n = {
        update: Xx(e, t.key, t.data),
        updateMask: yY(t.fieldMask)
    };
    else {
        if (!(t instanceof X8)) return $e();
        n = {
            verify: rE(e, t.key)
        }
    }
    return t.fieldTransforms.length > 0 && (n.updateTransforms = t.fieldTransforms.map(r => function(s, i) {
        const o = i.transform;
        if (o instanceof rh) return {
            fieldPath: i.field.canonicalString(),
            setToServerValue: "REQUEST_TIME"
        };
        if (o instanceof sh) return {
            fieldPath: i.field.canonicalString(),
            appendMissingElements: {
                values: o.elements
            }
        };
        if (o instanceof ih) return {
            fieldPath: i.field.canonicalString(),
            removeAllFromArray: {
                values: o.elements
            }
        };
        if (o instanceof u_) return {
            fieldPath: i.field.canonicalString(),
            increment: o._t
        };
        throw $e()
    }(0, r))), t.precondition.isNone || (n.currentDocument = function(r, s) {
        return s.updateTime !== void 0 ? {
            updateTime: oY(r, s.updateTime)
        } : s.exists !== void 0 ? {
            exists: s.exists
        } : $e()
    }(e, t.precondition)), n
}

function uY(e, t) {
    return e && e.length > 0 ? (Ct(t !== void 0), e.map(n => function(r, s) {
        let i = r.updateTime ? As(r.updateTime) : As(s);
        return i.isEqual(Ce.min()) && (i = As(s)), new q8(i, r.transformResults || [])
    }(n, t))) : []
}

function dY(e, t) {
    return {
        documents: [sE(e, t.path)]
    }
}

function fY(e, t) {
    const n = {
            structuredQuery: {}
        },
        r = t.path;
    t.collectionGroup !== null ? (n.parent = sE(e, r), n.structuredQuery.from = [{
        collectionId: t.collectionGroup,
        allDescendants: !0
    }]) : (n.parent = sE(e, r.popLast()), n.structuredQuery.from = [{
        collectionId: r.lastSegment()
    }]);
    const s = function(l) {
        if (l.length !== 0) return w2(gs.create(l, "and"))
    }(t.filters);
    s && (n.structuredQuery.where = s);
    const i = function(l) {
        if (l.length !== 0) return l.map(c => function(u) {
            return {
                field: ic(u.field),
                direction: mY(u.dir)
            }
        }(c))
    }(t.orderBy);
    i && (n.structuredQuery.orderBy = i);
    const o = function(l, c) {
        return l.useProto3Json || dv(c) ? c : {
            value: c
        }
    }(e, t.limit);
    var a;
    return o !== null && (n.structuredQuery.limit = o), t.startAt && (n.structuredQuery.startAt = {
        before: (a = t.startAt).inclusive,
        values: a.position
    }), t.endAt && (n.structuredQuery.endAt = function(l) {
        return {
            before: !l.inclusive,
            values: l.position
        }
    }(t.endAt)), n
}

function hY(e) {
    let t = aY(e.parent);
    const n = e.structuredQuery,
        r = n.from ? n.from.length : 0;
    let s = null;
    if (r > 0) {
        Ct(r === 1);
        const u = n.from[0];
        u.allDescendants ? s = u.collectionId : t = t.child(u.collectionId)
    }
    let i = [];
    n.where && (i = function(u) {
        const d = b2(u);
        return d instanceof gs && YL(d) ? d.getFilters() : [d]
    }(n.where));
    let o = [];
    n.orderBy && (o = n.orderBy.map(u => function(d) {
        return new kc(oc(d.field), function(f) {
            switch (f) {
                case "ASCENDING":
                    return "asc";
                case "DESCENDING":
                    return "desc";
                default:
                    return
            }
        }(d.direction))
    }(u)));
    let a = null;
    n.limit && (a = function(u) {
        let d;
        return d = typeof u == "object" ? u.value : u, dv(d) ? null : d
    }(n.limit));
    let l = null;
    n.startAt && (l = function(u) {
        const d = !!u.before,
            f = u.values || [];
        return new l_(f, d)
    }(n.startAt));
    let c = null;
    return n.endAt && (c = function(u) {
        const d = !u.before,
            f = u.values || [];
        return new l_(f, d)
    }(n.endAt)), P8(t, s, o, i, a, "F", l, c)
}

function pY(e, t) {
    const n = function(r, s) {
        switch (s) {
            case 0:
                return null;
            case 1:
                return "existence-filter-mismatch";
            case 2:
                return "limbo-document";
            default:
                return $e()
        }
    }(0, t.purpose);
    return n == null ? null : {
        "goog-listen-tags": n
    }
}

function b2(e) {
    return e.unaryFilter !== void 0 ? function(t) {
        switch (t.unaryFilter.op) {
            case "IS_NAN":
                const n = oc(t.unaryFilter.field);
                return Jt.create(n, "==", {
                    doubleValue: NaN
                });
            case "IS_NULL":
                const r = oc(t.unaryFilter.field);
                return Jt.create(r, "==", {
                    nullValue: "NULL_VALUE"
                });
            case "IS_NOT_NAN":
                const s = oc(t.unaryFilter.field);
                return Jt.create(s, "!=", {
                    doubleValue: NaN
                });
            case "IS_NOT_NULL":
                const i = oc(t.unaryFilter.field);
                return Jt.create(i, "!=", {
                    nullValue: "NULL_VALUE"
                });
            default:
                return $e()
        }
    }(e) : e.fieldFilter !== void 0 ? function(t) {
        return Jt.create(oc(t.fieldFilter.field), function(n) {
            switch (n) {
                case "EQUAL":
                    return "==";
                case "NOT_EQUAL":
                    return "!=";
                case "GREATER_THAN":
                    return ">";
                case "GREATER_THAN_OR_EQUAL":
                    return ">=";
                case "LESS_THAN":
                    return "<";
                case "LESS_THAN_OR_EQUAL":
                    return "<=";
                case "ARRAY_CONTAINS":
                    return "array-contains";
                case "IN":
                    return "in";
                case "NOT_IN":
                    return "not-in";
                case "ARRAY_CONTAINS_ANY":
                    return "array-contains-any";
                default:
                    return $e()
            }
        }(t.fieldFilter.op), t.fieldFilter.value)
    }(e) : e.compositeFilter !== void 0 ? function(t) {
        return gs.create(t.compositeFilter.filters.map(n => b2(n)), function(n) {
            switch (n) {
                case "AND":
                    return "and";
                case "OR":
                    return "or";
                default:
                    return $e()
            }
        }(t.compositeFilter.op))
    }(e) : $e()
}

function mY(e) {
    return nY[e]
}

function gY(e) {
    return rY[e]
}

function _Y(e) {
    return sY[e]
}

function ic(e) {
    return {
        fieldPath: e.canonicalString()
    }
}

function oc(e) {
    return Hn.fromServerFormat(e.fieldPath)
}

function w2(e) {
    return e instanceof Jt ? function(t) {
        if (t.op === "==") {
            if (Fx(t.value)) return {
                unaryFilter: {
                    field: ic(t.field),
                    op: "IS_NAN"
                }
            };
            if (Lx(t.value)) return {
                unaryFilter: {
                    field: ic(t.field),
                    op: "IS_NULL"
                }
            }
        } else if (t.op === "!=") {
            if (Fx(t.value)) return {
                unaryFilter: {
                    field: ic(t.field),
                    op: "IS_NOT_NAN"
                }
            };
            if (Lx(t.value)) return {
                unaryFilter: {
                    field: ic(t.field),
                    op: "IS_NOT_NULL"
                }
            }
        }
        return {
            fieldFilter: {
                field: ic(t.field),
                op: gY(t.op),
                value: t.value
            }
        }
    }(e) : e instanceof gs ? function(t) {
        const n = t.getFilters().map(r => w2(r));
        return n.length === 1 ? n[0] : {
            compositeFilter: {
                op: _Y(t.op),
                filters: n
            }
        }
    }(e) : $e()
}

function yY(e) {
    const t = [];
    return e.fields.forEach(n => t.push(n.canonicalString())), {
        fieldPaths: t
    }
}

function E2(e) {
    return e.length >= 4 && e.get(0) === "projects" && e.get(2) === "databases"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ha {
    constructor(t, n, r, s, i = Ce.min(), o = Ce.min(), a = Xn.EMPTY_BYTE_STRING) {
        this.target = t, this.targetId = n, this.purpose = r, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = o, this.resumeToken = a
    }
    withSequenceNumber(t) {
        return new Ha(this.target, this.targetId, this.purpose, t, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken)
    }
    withResumeToken(t, n) {
        return new Ha(this.target, this.targetId, this.purpose, this.sequenceNumber, n, this.lastLimboFreeSnapshotVersion, t)
    }
    withLastLimboFreeSnapshotVersion(t) {
        return new Ha(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t, this.resumeToken)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vY {
    constructor(t) {
        this.se = t
    }
}

function bY(e) {
    const t = hY({
        parent: e.parent,
        structuredQuery: e.structuredQuery
    });
    return e.limitType === "LAST" ? c_(t, t.limit, "L") : t
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wY {
    constructor() {
        this.He = new EY
    }
    addToCollectionParentIndex(t, n) {
        return this.He.add(n), W.resolve()
    }
    getCollectionParents(t, n) {
        return W.resolve(this.He.getEntries(n))
    }
    addFieldIndex(t, n) {
        return W.resolve()
    }
    deleteFieldIndex(t, n) {
        return W.resolve()
    }
    getDocumentsMatchingTarget(t, n) {
        return W.resolve(null)
    }
    getIndexType(t, n) {
        return W.resolve(0)
    }
    getFieldIndexes(t, n) {
        return W.resolve([])
    }
    getNextCollectionGroupToUpdate(t) {
        return W.resolve(null)
    }
    getMinOffset(t, n) {
        return W.resolve(Bo.min())
    }
    getMinOffsetFromCollectionGroup(t, n) {
        return W.resolve(Bo.min())
    }
    updateCollectionGroup(t, n, r) {
        return W.resolve()
    }
    updateIndexEntries(t, n) {
        return W.resolve()
    }
}
class EY {
    constructor() {
        this.index = {}
    }
    add(t) {
        const n = t.lastSegment(),
            r = t.popLast(),
            s = this.index[n] || new dn(xt.comparator),
            i = !s.has(r);
        return this.index[n] = s.add(r), i
    }
    has(t) {
        const n = t.lastSegment(),
            r = t.popLast(),
            s = this.index[n];
        return s && s.has(r)
    }
    getEntries(t) {
        return (this.index[t] || new dn(xt.comparator)).toArray()
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class au {
    constructor(t) {
        this.Rn = t
    }
    next() {
        return this.Rn += 2, this.Rn
    }
    static vn() {
        return new au(0)
    }
    static bn() {
        return new au(-1)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SY {
    constructor() {
        this.changes = new Ju(t => t.toString(), (t, n) => t.isEqual(n)), this.changesApplied = !1
    }
    addEntry(t) {
        this.assertNotApplied(), this.changes.set(t.key, t)
    }
    removeEntry(t, n) {
        this.assertNotApplied(), this.changes.set(t, Bn.newInvalidDocument(t).setReadTime(n))
    }
    getEntry(t, n) {
        this.assertNotApplied();
        const r = this.changes.get(n);
        return r !== void 0 ? W.resolve(r) : this.getFromCache(t, n)
    }
    getEntries(t, n) {
        return this.getAllFromCache(t, n)
    }
    apply(t) {
        return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(t)
    }
    assertNotApplied() {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TY {
    constructor(t, n) {
        this.overlayedDocument = t, this.mutatedFields = n
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $Y {
    constructor(t, n, r, s) {
        this.remoteDocumentCache = t, this.mutationQueue = n, this.documentOverlayCache = r, this.indexManager = s
    }
    getDocument(t, n) {
        let r = null;
        return this.documentOverlayCache.getOverlay(t, n).next(s => (r = s, this.remoteDocumentCache.getEntry(t, n))).next(s => (r !== null && Zd(r.mutation, s, Dr.empty(), un.now()), s))
    }
    getDocuments(t, n) {
        return this.remoteDocumentCache.getEntries(t, n).next(r => this.getLocalViewOfDocuments(t, r, je()).next(() => r))
    }
    getLocalViewOfDocuments(t, n, r = je()) {
        const s = Da();
        return this.populateOverlays(t, s, n).next(() => this.computeViews(t, n, s, r).next(i => {
            let o = Dd();
            return i.forEach((a, l) => {
                o = o.insert(a, l.overlayedDocument)
            }), o
        }))
    }
    getOverlayedDocuments(t, n) {
        const r = Da();
        return this.populateOverlays(t, r, n).next(() => this.computeViews(t, n, r, je()))
    }
    populateOverlays(t, n, r) {
        const s = [];
        return r.forEach(i => {
            n.has(i) || s.push(i)
        }), this.documentOverlayCache.getOverlays(t, s).next(i => {
            i.forEach((o, a) => {
                n.set(o, a)
            })
        })
    }
    computeViews(t, n, r, s) {
        let i = Si();
        const o = Jd(),
            a = Jd();
        return n.forEach((l, c) => {
            const u = r.get(c.key);
            s.has(c.key) && (u === void 0 || u.mutation instanceof la) ? i = i.insert(c.key, c) : u !== void 0 ? (o.set(c.key, u.mutation.getFieldMask()), Zd(u.mutation, c, u.mutation.getFieldMask(), un.now())) : o.set(c.key, Dr.empty())
        }), this.recalculateAndSaveOverlays(t, i).next(l => (l.forEach((c, u) => o.set(c, u)), n.forEach((c, u) => {
            var d;
            return a.set(c, new TY(u, (d = o.get(c)) !== null && d !== void 0 ? d : null))
        }), a))
    }
    recalculateAndSaveOverlays(t, n) {
        const r = Jd();
        let s = new fn((o, a) => o - a),
            i = je();
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t, n).next(o => {
            for (const a of o) a.keys().forEach(l => {
                const c = n.get(l);
                if (c === null) return;
                let u = r.get(l) || Dr.empty();
                u = a.applyToLocalView(c, u), r.set(l, u);
                const d = (s.get(a.batchId) || je()).add(l);
                s = s.insert(a.batchId, d)
            })
        }).next(() => {
            const o = [],
                a = s.getReverseIterator();
            for (; a.hasNext();) {
                const l = a.getNext(),
                    c = l.key,
                    u = l.value,
                    d = r2();
                u.forEach(f => {
                    if (!i.has(f)) {
                        const h = d2(n.get(f), r.get(f));
                        h !== null && d.set(f, h), i = i.add(f)
                    }
                }), o.push(this.documentOverlayCache.saveOverlays(t, c, d))
            }
            return W.waitFor(o)
        }).next(() => r)
    }
    recalculateAndSaveOverlaysForDocumentKeys(t, n) {
        return this.remoteDocumentCache.getEntries(t, n).next(r => this.recalculateAndSaveOverlays(t, r))
    }
    getDocumentsMatchingQuery(t, n, r) {
        return function(s) {
            return ve.isDocumentKey(s.path) && s.collectionGroup === null && s.filters.length === 0
        }(n) ? this.getDocumentsMatchingDocumentQuery(t, n.path) : JL(n) ? this.getDocumentsMatchingCollectionGroupQuery(t, n, r) : this.getDocumentsMatchingCollectionQuery(t, n, r)
    }
    getNextDocuments(t, n, r, s) {
        return this.remoteDocumentCache.getAllFromCollectionGroup(t, n, r, s).next(i => {
            const o = s - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t, n, r.largestBatchId, s - i.size) : W.resolve(Da());
            let a = -1,
                l = i;
            return o.next(c => W.forEach(c, (u, d) => (a < d.largestBatchId && (a = d.largestBatchId), i.get(u) ? W.resolve() : this.remoteDocumentCache.getEntry(t, u).next(f => {
                l = l.insert(u, f)
            }))).next(() => this.populateOverlays(t, c, i)).next(() => this.computeViews(t, l, c, je())).next(u => ({
                batchId: a,
                changes: n2(u)
            })))
        })
    }
    getDocumentsMatchingDocumentQuery(t, n) {
        return this.getDocument(t, new ve(n)).next(r => {
            let s = Dd();
            return r.isFoundDocument() && (s = s.insert(r.key, r)), s
        })
    }
    getDocumentsMatchingCollectionGroupQuery(t, n, r) {
        const s = n.collectionGroup;
        let i = Dd();
        return this.indexManager.getCollectionParents(t, s).next(o => W.forEach(o, a => {
            const l = function(c, u) {
                return new Qu(u, null, c.explicitOrderBy.slice(), c.filters.slice(), c.limit, c.limitType, c.startAt, c.endAt)
            }(n, a.child(s));
            return this.getDocumentsMatchingCollectionQuery(t, l, r).next(c => {
                c.forEach((u, d) => {
                    i = i.insert(u, d)
                })
            })
        }).next(() => i))
    }
    getDocumentsMatchingCollectionQuery(t, n, r) {
        let s;
        return this.documentOverlayCache.getOverlaysForCollection(t, n.path, r.largestBatchId).next(i => (s = i, this.remoteDocumentCache.getDocumentsMatchingQuery(t, n, r, s))).next(i => {
            s.forEach((a, l) => {
                const c = l.getKey();
                i.get(c) === null && (i = i.insert(c, Bn.newInvalidDocument(c)))
            });
            let o = Dd();
            return i.forEach((a, l) => {
                const c = s.get(a);
                c !== void 0 && Zd(c.mutation, l, Dr.empty(), un.now()), mv(n, l) && (o = o.insert(a, l))
            }), o
        })
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kY {
    constructor(t) {
        this.serializer = t, this.Zn = new Map, this.Xn = new Map
    }
    getBundleMetadata(t, n) {
        return W.resolve(this.Zn.get(n))
    }
    saveBundleMetadata(t, n) {
        var r;
        return this.Zn.set(n.id, {
            id: (r = n).id,
            version: r.version,
            createTime: As(r.createTime)
        }), W.resolve()
    }
    getNamedQuery(t, n) {
        return W.resolve(this.Xn.get(n))
    }
    saveNamedQuery(t, n) {
        return this.Xn.set(n.name, function(r) {
            return {
                name: r.name,
                query: bY(r.bundledQuery),
                readTime: As(r.readTime)
            }
        }(n)), W.resolve()
    }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IY {
    constructor() {
        this.overlays = new fn(ve.comparator), this.ts = new Map
    }
    getOverlay(t, n) {
        return W.resolve(this.overlays.get(n))
    }
    getOverlays(t, n) {
        const r = Da();
        return W.forEach(n, s => this.getOverlay(t, s).next(i => {
            i !== null && r.set(s, i)
        })).next(() => r)
    }
    saveOverlays(t, n, r) {
        return r.forEach((s, i) => {
            this.re(t, n, i)
        }), W.resolve()
    }
    removeOverlaysForBatchId(t, n, r) {
        const s = this.ts.get(r);
        return s !== void 0 && (s.forEach(i => this.overlays = this.overlays.remove(i)), this.ts.delete(r)), W.resolve()
    }
    getOverlaysForCollection(t, n, r) {
        const s = Da(),
            i = n.length + 1,
            o = new ve(n.child("")),
            a = this.overlays.getIteratorFrom(o);
        for (; a.hasNext();) {
            const l = a.getNext().value,
                c = l.getKey();
            if (!n.isPrefixOf(c.path)) break;
            c.path.length === i && l.largestBatchId > r && s.set(l.getKey(), l)
        }
        return W.resolve(s)
    }
    getOverlaysForCollectionGroup(t, n, r, s) {
        let i = new fn((c, u) => c - u);
        const o = this.overlays.getIterator();
        for (; o.hasNext();) {
            const c = o.getNext().value;
            if (c.getKey().getCollectionGroup() === n && c.largestBatchId > r) {
                let u = i.get(c.largestBatchId);
                u === null && (u = Da(), i = i.insert(c.largestBatchId, u)), u.set(c.getKey(), c)
            }
        }
        const a = Da(),
            l = i.getIterator();
        for (; l.hasNext() && (l.getNext().value.forEach((c, u) => a.set(c, u)), !(a.size() >= s)););
        return W.resolve(a)
    }
    re(t, n, r) {
        const s = this.overlays.get(r.key);
        if (s !== null) {
            const o = this.ts.get(s.largestBatchId).delete(r.key);
            this.ts.set(s.largestBatchId, o)
        }
        this.overlays = this.overlays.insert(r.key, new J8(n, r));
        let i = this.ts.get(n);
        i === void 0 && (i = je(), this.ts.set(n, i)), this.ts.set(n, i.add(r.key))
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vT {
    constructor() {
        this.es = new dn(_n.ns), this.ss = new dn(_n.rs)
    }
    isEmpty() {
        return this.es.isEmpty()
    }
    addReference(t, n) {
        const r = new _n(t, n);
        this.es = this.es.add(r), this.ss = this.ss.add(r)
    }
    os(t, n) {
        t.forEach(r => this.addReference(r, n))
    }
    removeReference(t, n) {
        this.us(new _n(t, n))
    }
    cs(t, n) {
        t.forEach(r => this.removeReference(r, n))
    }
    hs(t) {
        const n = new ve(new xt([])),
            r = new _n(n, t),
            s = new _n(n, t + 1),
            i = [];
        return this.ss.forEachInRange([r, s], o => {
            this.us(o), i.push(o.key)
        }), i
    }
    ls() {
        this.es.forEach(t => this.us(t))
    }
    us(t) {
        this.es = this.es.delete(t), this.ss = this.ss.delete(t)
    }
    fs(t) {
        const n = new ve(new xt([])),
            r = new _n(n, t),
            s = new _n(n, t + 1);
        let i = je();
        return this.ss.forEachInRange([r, s], o => {
            i = i.add(o.key)
        }), i
    }
    containsKey(t) {
        const n = new _n(t, 0),
            r = this.es.firstAfterOrEqual(n);
        return r !== null && t.isEqual(r.key)
    }
}
class _n {
    constructor(t, n) {
        this.key = t, this.ds = n
    }
    static ns(t, n) {
        return ve.comparator(t.key, n.key) || ut(t.ds, n.ds)
    }
    static rs(t, n) {
        return ut(t.ds, n.ds) || ve.comparator(t.key, n.key)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xY {
    constructor(t, n) {
        this.indexManager = t, this.referenceDelegate = n, this.mutationQueue = [], this.ws = 1, this._s = new dn(_n.ns)
    }
    checkEmpty(t) {
        return W.resolve(this.mutationQueue.length === 0)
    }
    addMutationBatch(t, n, r, s) {
        const i = this.ws;
        this.ws++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
        const o = new Q8(i, n, r, s);
        this.mutationQueue.push(o);
        for (const a of s) this._s = this._s.add(new _n(a.key, i)), this.indexManager.addToCollectionParentIndex(t, a.key.path.popLast());
        return W.resolve(o)
    }
    lookupMutationBatch(t, n) {
        return W.resolve(this.gs(n))
    }
    getNextMutationBatchAfterBatchId(t, n) {
        const r = n + 1,
            s = this.ys(r),
            i = s < 0 ? 0 : s;
        return W.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null)
    }
    getHighestUnacknowledgedBatchId() {
        return W.resolve(this.mutationQueue.length === 0 ? -1 : this.ws - 1)
    }
    getAllMutationBatches(t) {
        return W.resolve(this.mutationQueue.slice())
    }
    getAllMutationBatchesAffectingDocumentKey(t, n) {
        const r = new _n(n, 0),
            s = new _n(n, Number.POSITIVE_INFINITY),
            i = [];
        return this._s.forEachInRange([r, s], o => {
            const a = this.gs(o.ds);
            i.push(a)
        }), W.resolve(i)
    }
    getAllMutationBatchesAffectingDocumentKeys(t, n) {
        let r = new dn(ut);
        return n.forEach(s => {
            const i = new _n(s, 0),
                o = new _n(s, Number.POSITIVE_INFINITY);
            this._s.forEachInRange([i, o], a => {
                r = r.add(a.ds)
            })
        }), W.resolve(this.ps(r))
    }
    getAllMutationBatchesAffectingQuery(t, n) {
        const r = n.path,
            s = r.length + 1;
        let i = r;
        ve.isDocumentKey(i) || (i = i.child(""));
        const o = new _n(new ve(i), 0);
        let a = new dn(ut);
        return this._s.forEachWhile(l => {
            const c = l.key.path;
            return !!r.isPrefixOf(c) && (c.length === s && (a = a.add(l.ds)), !0)
        }, o), W.resolve(this.ps(a))
    }
    ps(t) {
        const n = [];
        return t.forEach(r => {
            const s = this.gs(r);
            s !== null && n.push(s)
        }), n
    }
    removeMutationBatch(t, n) {
        Ct(this.Is(n.batchId, "removed") === 0), this.mutationQueue.shift();
        let r = this._s;
        return W.forEach(n.mutations, s => {
            const i = new _n(s.key, n.batchId);
            return r = r.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t, s.key)
        }).next(() => {
            this._s = r
        })
    }
    En(t) {}
    containsKey(t, n) {
        const r = new _n(n, 0),
            s = this._s.firstAfterOrEqual(r);
        return W.resolve(n.isEqual(s && s.key))
    }
    performConsistencyCheck(t) {
        return this.mutationQueue.length, W.resolve()
    }
    Is(t, n) {
        return this.ys(t)
    }
    ys(t) {
        return this.mutationQueue.length === 0 ? 0 : t - this.mutationQueue[0].batchId
    }
    gs(t) {
        const n = this.ys(t);
        return n < 0 || n >= this.mutationQueue.length ? null : this.mutationQueue[n]
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CY {
    constructor(t) {
        this.Ts = t, this.docs = new fn(ve.comparator), this.size = 0
    }
    setIndexManager(t) {
        this.indexManager = t
    }
    addEntry(t, n) {
        const r = n.key,
            s = this.docs.get(r),
            i = s ? s.size : 0,
            o = this.Ts(n);
        return this.docs = this.docs.insert(r, {
            document: n.mutableCopy(),
            size: o
        }), this.size += o - i, this.indexManager.addToCollectionParentIndex(t, r.path.popLast())
    }
    removeEntry(t) {
        const n = this.docs.get(t);
        n && (this.docs = this.docs.remove(t), this.size -= n.size)
    }
    getEntry(t, n) {
        const r = this.docs.get(n);
        return W.resolve(r ? r.document.mutableCopy() : Bn.newInvalidDocument(n))
    }
    getEntries(t, n) {
        let r = Si();
        return n.forEach(s => {
            const i = this.docs.get(s);
            r = r.insert(s, i ? i.document.mutableCopy() : Bn.newInvalidDocument(s))
        }), W.resolve(r)
    }
    getDocumentsMatchingQuery(t, n, r, s) {
        let i = Si();
        const o = n.path,
            a = new ve(o.child("")),
            l = this.docs.getIteratorFrom(a);
        for (; l.hasNext();) {
            const {
                key: c,
                value: {
                    document: u
                }
            } = l.getNext();
            if (!o.isPrefixOf(c.path)) break;
            c.path.length > o.length + 1 || _8(g8(u), r) <= 0 || (s.has(u.key) || mv(n, u)) && (i = i.insert(u.key, u.mutableCopy()))
        }
        return W.resolve(i)
    }
    getAllFromCollectionGroup(t, n, r, s) {
        $e()
    }
    Es(t, n) {
        return W.forEach(this.docs, r => n(r))
    }
    newChangeBuffer(t) {
        return new AY(this)
    }
    getSize(t) {
        return W.resolve(this.size)
    }
}
class AY extends SY {
    constructor(t) {
        super(), this.Jn = t
    }
    applyChanges(t) {
        const n = [];
        return this.changes.forEach((r, s) => {
            s.isValidDocument() ? n.push(this.Jn.addEntry(t, s)) : this.Jn.removeEntry(r)
        }), W.waitFor(n)
    }
    getFromCache(t, n) {
        return this.Jn.getEntry(t, n)
    }
    getAllFromCache(t, n) {
        return this.Jn.getEntries(t, n)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RY {
    constructor(t) {
        this.persistence = t, this.As = new Ju(n => hT(n), pT), this.lastRemoteSnapshotVersion = Ce.min(), this.highestTargetId = 0, this.Rs = 0, this.vs = new vT, this.targetCount = 0, this.bs = au.vn()
    }
    forEachTarget(t, n) {
        return this.As.forEach((r, s) => n(s)), W.resolve()
    }
    getLastRemoteSnapshotVersion(t) {
        return W.resolve(this.lastRemoteSnapshotVersion)
    }
    getHighestSequenceNumber(t) {
        return W.resolve(this.Rs)
    }
    allocateTargetId(t) {
        return this.highestTargetId = this.bs.next(), W.resolve(this.highestTargetId)
    }
    setTargetsMetadata(t, n, r) {
        return r && (this.lastRemoteSnapshotVersion = r), n > this.Rs && (this.Rs = n), W.resolve()
    }
    Sn(t) {
        this.As.set(t.target, t);
        const n = t.targetId;
        n > this.highestTargetId && (this.bs = new au(n), this.highestTargetId = n), t.sequenceNumber > this.Rs && (this.Rs = t.sequenceNumber)
    }
    addTargetData(t, n) {
        return this.Sn(n), this.targetCount += 1, W.resolve()
    }
    updateTargetData(t, n) {
        return this.Sn(n), W.resolve()
    }
    removeTargetData(t, n) {
        return this.As.delete(n.target), this.vs.hs(n.targetId), this.targetCount -= 1, W.resolve()
    }
    removeTargets(t, n, r) {
        let s = 0;
        const i = [];
        return this.As.forEach((o, a) => {
            a.sequenceNumber <= n && r.get(a.targetId) === null && (this.As.delete(o), i.push(this.removeMatchingKeysForTargetId(t, a.targetId)), s++)
        }), W.waitFor(i).next(() => s)
    }
    getTargetCount(t) {
        return W.resolve(this.targetCount)
    }
    getTargetData(t, n) {
        const r = this.As.get(n) || null;
        return W.resolve(r)
    }
    addMatchingKeys(t, n, r) {
        return this.vs.os(n, r), W.resolve()
    }
    removeMatchingKeys(t, n, r) {
        this.vs.cs(n, r);
        const s = this.persistence.referenceDelegate,
            i = [];
        return s && n.forEach(o => {
            i.push(s.markPotentiallyOrphaned(t, o))
        }), W.waitFor(i)
    }
    removeMatchingKeysForTargetId(t, n) {
        return this.vs.hs(n), W.resolve()
    }
    getMatchingKeysForTargetId(t, n) {
        const r = this.vs.fs(n);
        return W.resolve(r)
    }
    containsKey(t, n) {
        return W.resolve(this.vs.containsKey(n))
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OY {
    constructor(t, n) {
        this.Ps = {}, this.overlays = {}, this.Vs = new dT(0), this.Ss = !1, this.Ss = !0, this.referenceDelegate = t(this), this.Ds = new RY(this), this.indexManager = new wY, this.remoteDocumentCache = function(r) {
            return new CY(r)
        }(r => this.referenceDelegate.Cs(r)), this.serializer = new vY(n), this.xs = new kY(this.serializer)
    }
    start() {
        return Promise.resolve()
    }
    shutdown() {
        return this.Ss = !1, Promise.resolve()
    }
    get started() {
        return this.Ss
    }
    setDatabaseDeletedListener() {}
    setNetworkEnabled() {}
    getIndexManager(t) {
        return this.indexManager
    }
    getDocumentOverlayCache(t) {
        let n = this.overlays[t.toKey()];
        return n || (n = new IY, this.overlays[t.toKey()] = n), n
    }
    getMutationQueue(t, n) {
        let r = this.Ps[t.toKey()];
        return r || (r = new xY(n, this.referenceDelegate), this.Ps[t.toKey()] = r), r
    }
    getTargetCache() {
        return this.Ds
    }
    getRemoteDocumentCache() {
        return this.remoteDocumentCache
    }
    getBundleCache() {
        return this.xs
    }
    runTransaction(t, n, r) {
        me("MemoryPersistence", "Starting transaction:", t);
        const s = new DY(this.Vs.next());
        return this.referenceDelegate.Ns(), r(s).next(i => this.referenceDelegate.ks(s).next(() => i)).toPromise().then(i => (s.raiseOnCommittedEvent(), i))
    }
    Os(t, n) {
        return W.or(Object.values(this.Ps).map(r => () => r.containsKey(t, n)))
    }
}
class DY extends v8 {
    constructor(t) {
        super(), this.currentSequenceNumber = t
    }
}
class bT {
    constructor(t) {
        this.persistence = t, this.$s = new vT, this.Ms = null
    }
    static Fs(t) {
        return new bT(t)
    }
    get Bs() {
        if (this.Ms) return this.Ms;
        throw $e()
    }
    addReference(t, n, r) {
        return this.$s.addReference(r, n), this.Bs.delete(r.toString()), W.resolve()
    }
    removeReference(t, n, r) {
        return this.$s.removeReference(r, n), this.Bs.add(r.toString()), W.resolve()
    }
    markPotentiallyOrphaned(t, n) {
        return this.Bs.add(n.toString()), W.resolve()
    }
    removeTarget(t, n) {
        this.$s.hs(n.targetId).forEach(s => this.Bs.add(s.toString()));
        const r = this.persistence.getTargetCache();
        return r.getMatchingKeysForTargetId(t, n.targetId).next(s => {
            s.forEach(i => this.Bs.add(i.toString()))
        }).next(() => r.removeTargetData(t, n))
    }
    Ns() {
        this.Ms = new Set
    }
    ks(t) {
        const n = this.persistence.getRemoteDocumentCache().newChangeBuffer();
        return W.forEach(this.Bs, r => {
            const s = ve.fromPath(r);
            return this.Ls(t, s).next(i => {
                i || n.removeEntry(s, Ce.min())
            })
        }).next(() => (this.Ms = null, n.apply(t)))
    }
    updateLimboDocument(t, n) {
        return this.Ls(t, n).next(r => {
            r ? this.Bs.delete(n.toString()) : this.Bs.add(n.toString())
        })
    }
    Cs(t) {
        return 0
    }
    Ls(t, n) {
        return W.or([() => W.resolve(this.$s.containsKey(n)), () => this.persistence.getTargetCache().containsKey(t, n), () => this.persistence.Os(t, n)])
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wT {
    constructor(t, n, r, s) {
        this.targetId = t, this.fromCache = n, this.Vi = r, this.Si = s
    }
    static Di(t, n) {
        let r = je(),
            s = je();
        for (const i of n.docChanges) switch (i.type) {
            case 0:
                r = r.add(i.doc.key);
                break;
            case 1:
                s = s.add(i.doc.key)
        }
        return new wT(t, n.fromCache, r, s)
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NY {
    constructor() {
        this.Ci = !1
    }
    initialize(t, n) {
        this.xi = t, this.indexManager = n, this.Ci = !0
    }
    getDocumentsMatchingQuery(t, n, r, s) {
        return this.Ni(t, n).next(i => i || this.ki(t, n, s, r)).next(i => i || this.Oi(t, n))
    }
    Ni(t, n) {
        if (Hx(n)) return W.resolve(null);
        let r = Ei(n);
        return this.indexManager.getIndexType(t, r).next(s => s === 0 ? null : (n.limit !== null && s === 1 && (n = c_(n, null, "F"), r = Ei(n)), this.indexManager.getDocumentsMatchingTarget(t, r).next(i => {
            const o = je(...i);
            return this.xi.getDocuments(t, o).next(a => this.indexManager.getMinOffset(t, r).next(l => {
                const c = this.$i(n, a);
                return this.Mi(n, c, o, l.readTime) ? this.Ni(t, c_(n, null, "F")) : this.Fi(t, c, n, l)
            }))
        })))
    }
    ki(t, n, r, s) {
        return Hx(n) || s.isEqual(Ce.min()) ? this.Oi(t, n) : this.xi.getDocuments(t, r).next(i => {
            const o = this.$i(n, i);
            return this.Mi(n, o, r, s) ? this.Oi(t, n) : (Ox() <= Xe.DEBUG && me("QueryEngine", "Re-using previous result from %s to execute query: %s", s.toString(), nE(n)), this.Fi(t, o, n, m8(s, -1)))
        })
    }
    $i(t, n) {
        let r = new dn(e2(t));
        return n.forEach((s, i) => {
            mv(t, i) && (r = r.add(i))
        }), r
    }
    Mi(t, n, r, s) {
        if (t.limit === null) return !1;
        if (r.size !== n.size) return !0;
        const i = t.limitType === "F" ? n.last() : n.first();
        return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0)
    }
    Oi(t, n) {
        return Ox() <= Xe.DEBUG && me("QueryEngine", "Using full collection scan to execute query:", nE(n)), this.xi.getDocumentsMatchingQuery(t, n, Bo.min())
    }
    Fi(t, n, r, s) {
        return this.xi.getDocumentsMatchingQuery(t, r, s).next(i => (n.forEach(o => {
            i = i.insert(o.key, o)
        }), i))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PY {
    constructor(t, n, r, s) {
        this.persistence = t, this.Bi = n, this.serializer = s, this.Li = new fn(ut), this.qi = new Ju(i => hT(i), pT), this.Ui = new Map, this.Ki = t.getRemoteDocumentCache(), this.Ds = t.getTargetCache(), this.xs = t.getBundleCache(), this.Gi(r)
    }
    Gi(t) {
        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t), this.indexManager = this.persistence.getIndexManager(t), this.mutationQueue = this.persistence.getMutationQueue(t, this.indexManager), this.localDocuments = new $Y(this.Ki, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Ki.setIndexManager(this.indexManager), this.Bi.initialize(this.localDocuments, this.indexManager)
    }
    collectGarbage(t) {
        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", n => t.collect(n, this.Li))
    }
}

function MY(e, t, n, r) {
    return new PY(e, t, n, r)
}
async function S2(e, t) {
    const n = Oe(e);
    return await n.persistence.runTransaction("Handle user change", "readonly", r => {
        let s;
        return n.mutationQueue.getAllMutationBatches(r).next(i => (s = i, n.Gi(t), n.mutationQueue.getAllMutationBatches(r))).next(i => {
            const o = [],
                a = [];
            let l = je();
            for (const c of s) {
                o.push(c.batchId);
                for (const u of c.mutations) l = l.add(u.key)
            }
            for (const c of i) {
                a.push(c.batchId);
                for (const u of c.mutations) l = l.add(u.key)
            }
            return n.localDocuments.getDocuments(r, l).next(c => ({
                Qi: c,
                removedBatchIds: o,
                addedBatchIds: a
            }))
        })
    })
}

function LY(e, t) {
    const n = Oe(e);
    return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", r => {
        const s = t.batch.keys(),
            i = n.Ki.newChangeBuffer({
                trackRemovals: !0
            });
        return function(o, a, l, c) {
            const u = l.batch,
                d = u.keys();
            let f = W.resolve();
            return d.forEach(h => {
                f = f.next(() => c.getEntry(a, h)).next(p => {
                    const m = l.docVersions.get(h);
                    Ct(m !== null), p.version.compareTo(m) < 0 && (u.applyToRemoteDocument(p, l), p.isValidDocument() && (p.setReadTime(l.commitVersion), c.addEntry(p)))
                })
            }), f.next(() => o.mutationQueue.removeMutationBatch(a, u))
        }(n, r, t, i).next(() => i.apply(r)).next(() => n.mutationQueue.performConsistencyCheck(r)).next(() => n.documentOverlayCache.removeOverlaysForBatchId(r, s, t.batch.batchId)).next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(r, function(o) {
            let a = je();
            for (let l = 0; l < o.mutationResults.length; ++l) o.mutationResults[l].transformResults.length > 0 && (a = a.add(o.batch.mutations[l].key));
            return a
        }(t))).next(() => n.localDocuments.getDocuments(r, s))
    })
}

function T2(e) {
    const t = Oe(e);
    return t.persistence.runTransaction("Get last remote snapshot version", "readonly", n => t.Ds.getLastRemoteSnapshotVersion(n))
}

function FY(e, t) {
    const n = Oe(e),
        r = t.snapshotVersion;
    let s = n.Li;
    return n.persistence.runTransaction("Apply remote event", "readwrite-primary", i => {
        const o = n.Ki.newChangeBuffer({
            trackRemovals: !0
        });
        s = n.Li;
        const a = [];
        t.targetChanges.forEach((u, d) => {
            const f = s.get(d);
            if (!f) return;
            a.push(n.Ds.removeMatchingKeys(i, u.removedDocuments, d).next(() => n.Ds.addMatchingKeys(i, u.addedDocuments, d)));
            let h = f.withSequenceNumber(i.currentSequenceNumber);
            t.targetMismatches.has(d) ? h = h.withResumeToken(Xn.EMPTY_BYTE_STRING, Ce.min()).withLastLimboFreeSnapshotVersion(Ce.min()) : u.resumeToken.approximateByteSize() > 0 && (h = h.withResumeToken(u.resumeToken, r)), s = s.insert(d, h),
                function(p, m, g) {
                    return p.resumeToken.approximateByteSize() === 0 || m.snapshotVersion.toMicroseconds() - p.snapshotVersion.toMicroseconds() >= 3e8 ? !0 : g.addedDocuments.size + g.modifiedDocuments.size + g.removedDocuments.size > 0
                }(f, h, u) && a.push(n.Ds.updateTargetData(i, h))
        });
        let l = Si(),
            c = je();
        if (t.documentUpdates.forEach(u => {
                t.resolvedLimboDocuments.has(u) && a.push(n.persistence.referenceDelegate.updateLimboDocument(i, u))
            }), a.push(UY(i, o, t.documentUpdates).next(u => {
                l = u.zi, c = u.ji
            })), !r.isEqual(Ce.min())) {
            const u = n.Ds.getLastRemoteSnapshotVersion(i).next(d => n.Ds.setTargetsMetadata(i, i.currentSequenceNumber, r));
            a.push(u)
        }
        return W.waitFor(a).next(() => o.apply(i)).next(() => n.localDocuments.getLocalViewOfDocuments(i, l, c)).next(() => l)
    }).then(i => (n.Li = s, i))
}

function UY(e, t, n) {
    let r = je(),
        s = je();
    return n.forEach(i => r = r.add(i)), t.getEntries(e, r).next(i => {
        let o = Si();
        return n.forEach((a, l) => {
            const c = i.get(a);
            l.isFoundDocument() !== c.isFoundDocument() && (s = s.add(a)), l.isNoDocument() && l.version.isEqual(Ce.min()) ? (t.removeEntry(a, l.readTime), o = o.insert(a, l)) : !c.isValidDocument() || l.version.compareTo(c.version) > 0 || l.version.compareTo(c.version) === 0 && c.hasPendingWrites ? (t.addEntry(l), o = o.insert(a, l)) : me("LocalStore", "Ignoring outdated watch update for ", a, ". Current version:", c.version, " Watch version:", l.version)
        }), {
            zi: o,
            ji: s
        }
    })
}

function BY(e, t) {
    const n = Oe(e);
    return n.persistence.runTransaction("Get next mutation batch", "readonly", r => (t === void 0 && (t = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(r, t)))
}

function VY(e, t) {
    const n = Oe(e);
    return n.persistence.runTransaction("Allocate target", "readwrite", r => {
        let s;
        return n.Ds.getTargetData(r, t).next(i => i ? (s = i, W.resolve(s)) : n.Ds.allocateTargetId(r).next(o => (s = new Ha(t, o, 0, r.currentSequenceNumber), n.Ds.addTargetData(r, s).next(() => s))))
    }).then(r => {
        const s = n.Li.get(r.targetId);
        return (s === null || r.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.Li = n.Li.insert(r.targetId, r), n.qi.set(t, r.targetId)), r
    })
}
async function oE(e, t, n) {
    const r = Oe(e),
        s = r.Li.get(t),
        i = n ? "readwrite" : "readwrite-primary";
    try {
        n || await r.persistence.runTransaction("Release target", i, o => r.persistence.referenceDelegate.removeTarget(o, s))
    } catch (o) {
        if (!dp(o)) throw o;
        me("LocalStore", `Failed to update sequence numbers for target ${t}: ${o}`)
    }
    r.Li = r.Li.remove(t), r.qi.delete(s.target)
}

function Qx(e, t, n) {
    const r = Oe(e);
    let s = Ce.min(),
        i = je();
    return r.persistence.runTransaction("Execute query", "readonly", o => function(a, l, c) {
        const u = Oe(a),
            d = u.qi.get(c);
        return d !== void 0 ? W.resolve(u.Li.get(d)) : u.Ds.getTargetData(l, c)
    }(r, o, Ei(t)).next(a => {
        if (a) return s = a.lastLimboFreeSnapshotVersion, r.Ds.getMatchingKeysForTargetId(o, a.targetId).next(l => {
            i = l
        })
    }).next(() => r.Bi.getDocumentsMatchingQuery(o, t, n ? s : Ce.min(), n ? i : je())).next(a => (HY(r, M8(t), a), {
        documents: a,
        Wi: i
    })))
}

function HY(e, t, n) {
    let r = e.Ui.get(t) || Ce.min();
    n.forEach((s, i) => {
        i.readTime.compareTo(r) > 0 && (r = i.readTime)
    }), e.Ui.set(t, r)
}
class Jx {
    constructor() {
        this.activeTargetIds = s2()
    }
    tr(t) {
        this.activeTargetIds = this.activeTargetIds.add(t)
    }
    er(t) {
        this.activeTargetIds = this.activeTargetIds.delete(t)
    }
    Xi() {
        const t = {
            activeTargetIds: this.activeTargetIds.toArray(),
            updateTimeMs: Date.now()
        };
        return JSON.stringify(t)
    }
}
class jY {
    constructor() {
        this.Br = new Jx, this.Lr = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null
    }
    addPendingMutation(t) {}
    updateMutationState(t, n, r) {}
    addLocalQueryTarget(t) {
        return this.Br.tr(t), this.Lr[t] || "not-current"
    }
    updateQueryState(t, n, r) {
        this.Lr[t] = n
    }
    removeLocalQueryTarget(t) {
        this.Br.er(t)
    }
    isLocalQueryTarget(t) {
        return this.Br.activeTargetIds.has(t)
    }
    clearQueryState(t) {
        delete this.Lr[t]
    }
    getAllActiveQueryTargets() {
        return this.Br.activeTargetIds
    }
    isActiveQueryTarget(t) {
        return this.Br.activeTargetIds.has(t)
    }
    start() {
        return this.Br = new Jx, Promise.resolve()
    }
    handleUserChange(t, n, r) {}
    setOnlineState(t) {}
    shutdown() {}
    writeSequenceNumber(t) {}
    notifyBundleLoaded(t) {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zY {
    qr(t) {}
    shutdown() {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zx {
    constructor() {
        this.Ur = () => this.Kr(), this.Gr = () => this.Qr(), this.zr = [], this.jr()
    }
    qr(t) {
        this.zr.push(t)
    }
    shutdown() {
        window.removeEventListener("online", this.Ur), window.removeEventListener("offline", this.Gr)
    }
    jr() {
        window.addEventListener("online", this.Ur), window.addEventListener("offline", this.Gr)
    }
    Kr() {
        me("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
        for (const t of this.zr) t(0)
    }
    Qr() {
        me("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
        for (const t of this.zr) t(1)
    }
    static D() {
        return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let rm = null;

function o0() {
    return rm === null ? rm = 268435456 + Math.round(2147483648 * Math.random()) : rm++, "0x" + rm.toString(16)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WY = {
    BatchGetDocuments: "batchGet",
    Commit: "commit",
    RunQuery: "runQuery",
    RunAggregationQuery: "runAggregationQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GY {
    constructor(t) {
        this.Wr = t.Wr, this.Hr = t.Hr
    }
    Jr(t) {
        this.Yr = t
    }
    Zr(t) {
        this.Xr = t
    }
    onMessage(t) {
        this.eo = t
    }
    close() {
        this.Hr()
    }
    send(t) {
        this.Wr(t)
    }
    no() {
        this.Yr()
    }
    so(t) {
        this.Xr(t)
    }
    io(t) {
        this.eo(t)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Mn = "WebChannelConnection";
class qY extends class {
    constructor(t) {
        this.databaseInfo = t, this.databaseId = t.databaseId;
        const n = t.ssl ? "https" : "http";
        this.ro = n + "://" + t.host, this.oo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents"
    }
    get uo() {
        return !1
    }
    co(t, n, r, s, i) {
        const o = o0(),
            a = this.ao(t, n);
        me("RestConnection", `Sending RPC '${t}' ${o}:`, a, r);
        const l = {};
        return this.ho(l, s, i), this.lo(t, a, l, r).then(c => (me("RestConnection", `Received RPC '${t}' ${o}: `, c), c), c => {
            throw o_("RestConnection", `RPC '${t}' ${o} failed with error: `, c, "url: ", a, "request:", r), c
        })
    }
    fo(t, n, r, s, i, o) {
        return this.co(t, n, r, s, i)
    }
    ho(t, n, r) {
        t["X-Goog-Api-Client"] = "gl-js/ fire/" + Xu, t["Content-Type"] = "text/plain", this.databaseInfo.appId && (t["X-Firebase-GMPID"] = this.databaseInfo.appId), n && n.headers.forEach((s, i) => t[i] = s), r && r.headers.forEach((s, i) => t[i] = s)
    }
    ao(t, n) {
        const r = WY[t];
        return `${this.ro}/v1/${n}:${r}`
    }
} {
    constructor(t) {
        super(t), this.forceLongPolling = t.forceLongPolling, this.autoDetectLongPolling = t.autoDetectLongPolling, this.useFetchStreams = t.useFetchStreams
    }
    lo(t, n, r, s) {
        const i = o0();
        return new Promise((o, a) => {
            const l = new i8;
            l.setWithCredentials(!0), l.listenOnce(n8.COMPLETE, () => {
                try {
                    switch (l.getLastErrorCode()) {
                        case s0.NO_ERROR:
                            const u = l.getResponseJson();
                            me(Mn, `XHR for RPC '${t}' ${i} received:`, JSON.stringify(u)), o(u);
                            break;
                        case s0.TIMEOUT:
                            me(Mn, `RPC '${t}' ${i} timed out`), a(new re(U.DEADLINE_EXCEEDED, "Request time out"));
                            break;
                        case s0.HTTP_ERROR:
                            const d = l.getStatus();
                            if (me(Mn, `RPC '${t}' ${i} failed with status:`, d, "response text:", l.getResponseText()), d > 0) {
                                let f = l.getResponseJson();
                                Array.isArray(f) && (f = f[0]);
                                const h = f == null ? void 0 : f.error;
                                if (h && h.status && h.message) {
                                    const p = function(m) {
                                        const g = m.toLowerCase().replace(/_/g, "-");
                                        return Object.values(U).indexOf(g) >= 0 ? g : U.UNKNOWN
                                    }(h.status);
                                    a(new re(p, h.message))
                                } else a(new re(U.UNKNOWN, "Server responded with status " + l.getStatus()))
                            } else a(new re(U.UNAVAILABLE, "Connection failed."));
                            break;
                        default:
                            $e()
                    }
                } finally {
                    me(Mn, `RPC '${t}' ${i} completed.`)
                }
            });
            const c = JSON.stringify(s);
            me(Mn, `RPC '${t}' ${i} sending request:`, s), l.send(n, "POST", c, r, 15)
        })
    }
    wo(t, n, r) {
        const s = o0(),
            i = [this.ro, "/", "google.firestore.v1.Firestore", "/", t, "/channel"],
            o = e8(),
            a = t8(),
            l = {
                httpSessionIdParam: "gsessionid",
                initMessageHeaders: {},
                messageUrlParams: {
                    database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
                },
                sendRawJson: !0,
                supportsCrossDomainXhr: !0,
                internalChannelParams: {
                    forwardChannelRequestTimeoutMs: 6e5
                },
                forceLongPolling: this.forceLongPolling,
                detectBufferingProxy: this.autoDetectLongPolling
            };
        this.useFetchStreams && (l.xmlHttpFactory = new s8({})), this.ho(l.initMessageHeaders, n, r), l.encodeInitMessageHeaders = !0;
        const c = i.join("");
        me(Mn, `Creating RPC '${t}' stream ${s}: ${c}`, l);
        const u = o.createWebChannel(c, l);
        let d = !1,
            f = !1;
        const h = new GY({
                Wr: m => {
                    f ? me(Mn, `Not sending because RPC '${t}' stream ${s} is closed:`, m) : (d || (me(Mn, `Opening RPC '${t}' stream ${s} transport.`), u.open(), d = !0), me(Mn, `RPC '${t}' stream ${s} sending:`, m), u.send(m))
                },
                Hr: () => u.close()
            }),
            p = (m, g, y) => {
                m.listen(g, _ => {
                    try {
                        y(_)
                    } catch (E) {
                        setTimeout(() => {
                            throw E
                        }, 0)
                    }
                })
            };
        return p(u, Zp.EventType.OPEN, () => {
            f || me(Mn, `RPC '${t}' stream ${s} transport opened.`)
        }), p(u, Zp.EventType.CLOSE, () => {
            f || (f = !0, me(Mn, `RPC '${t}' stream ${s} transport closed`), h.so())
        }), p(u, Zp.EventType.ERROR, m => {
            f || (f = !0, o_(Mn, `RPC '${t}' stream ${s} transport errored:`, m), h.so(new re(U.UNAVAILABLE, "The operation could not be completed")))
        }), p(u, Zp.EventType.MESSAGE, m => {
            var g;
            if (!f) {
                const y = m.data[0];
                Ct(!!y);
                const _ = y,
                    E = _.error || ((g = _[0]) === null || g === void 0 ? void 0 : g.error);
                if (E) {
                    me(Mn, `RPC '${t}' stream ${s} received error:`, E);
                    const b = E.status;
                    let w = function(S) {
                            const v = Xt[S];
                            if (v !== void 0) return p2(v)
                        }(b),
                        T = E.message;
                    w === void 0 && (w = U.INTERNAL, T = "Unknown error status: " + b + " with message " + E.message), f = !0, h.so(new re(w, T)), u.close()
                } else me(Mn, `RPC '${t}' stream ${s} received:`, y), h.io(y)
            }
        }), p(a, r8.STAT_EVENT, m => {
            m.stat === Ax.PROXY ? me(Mn, `RPC '${t}' stream ${s} detected buffering proxy`) : m.stat === Ax.NOPROXY && me(Mn, `RPC '${t}' stream ${s} detected no buffering proxy`)
        }), setTimeout(() => {
            h.no()
        }, 0), h
    }
}

function a0() {
    return typeof document != "undefined" ? document : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function vv(e) {
    return new iY(e, !0)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $2 {
    constructor(t, n, r = 1e3, s = 1.5, i = 6e4) {
        this.Ws = t, this.timerId = n, this._o = r, this.mo = s, this.yo = i, this.po = 0, this.Io = null, this.To = Date.now(), this.reset()
    }
    reset() {
        this.po = 0
    }
    Eo() {
        this.po = this.yo
    }
    Ao(t) {
        this.cancel();
        const n = Math.floor(this.po + this.Ro()),
            r = Math.max(0, Date.now() - this.To),
            s = Math.max(0, n - r);
        s > 0 && me("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.po} ms, delay with jitter: ${n} ms, last attempt: ${r} ms ago)`), this.Io = this.Ws.enqueueAfterDelay(this.timerId, s, () => (this.To = Date.now(), t())), this.po *= this.mo, this.po < this._o && (this.po = this._o), this.po > this.yo && (this.po = this.yo)
    }
    vo() {
        this.Io !== null && (this.Io.skipDelay(), this.Io = null)
    }
    cancel() {
        this.Io !== null && (this.Io.cancel(), this.Io = null)
    }
    Ro() {
        return (Math.random() - .5) * this.po
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class k2 {
    constructor(t, n, r, s, i, o, a, l) {
        this.Ws = t, this.bo = r, this.Po = s, this.connection = i, this.authCredentialsProvider = o, this.appCheckCredentialsProvider = a, this.listener = l, this.state = 0, this.Vo = 0, this.So = null, this.Do = null, this.stream = null, this.Co = new $2(t, n)
    }
    xo() {
        return this.state === 1 || this.state === 5 || this.No()
    }
    No() {
        return this.state === 2 || this.state === 3
    }
    start() {
        this.state !== 4 ? this.auth() : this.ko()
    }
    async stop() {
        this.xo() && await this.close(0)
    }
    Oo() {
        this.state = 0, this.Co.reset()
    }
    $o() {
        this.No() && this.So === null && (this.So = this.Ws.enqueueAfterDelay(this.bo, 6e4, () => this.Mo()))
    }
    Fo(t) {
        this.Bo(), this.stream.send(t)
    }
    async Mo() {
        if (this.No()) return this.close(0)
    }
    Bo() {
        this.So && (this.So.cancel(), this.So = null)
    }
    Lo() {
        this.Do && (this.Do.cancel(), this.Do = null)
    }
    async close(t, n) {
        this.Bo(), this.Lo(), this.Co.cancel(), this.Vo++, t !== 4 ? this.Co.reset() : n && n.code === U.RESOURCE_EXHAUSTED ? (wi(n.toString()), wi("Using maximum backoff delay to prevent overloading the backend."), this.Co.Eo()) : n && n.code === U.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.qo(), this.stream.close(), this.stream = null), this.state = t, await this.listener.Zr(n)
    }
    qo() {}
    auth() {
        this.state = 1;
        const t = this.Uo(this.Vo),
            n = this.Vo;
        Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([r, s]) => {
            this.Vo === n && this.Ko(r, s)
        }, r => {
            t(() => {
                const s = new re(U.UNKNOWN, "Fetching auth token failed: " + r.message);
                return this.Go(s)
            })
        })
    }
    Ko(t, n) {
        const r = this.Uo(this.Vo);
        this.stream = this.Qo(t, n), this.stream.Jr(() => {
            r(() => (this.state = 2, this.Do = this.Ws.enqueueAfterDelay(this.Po, 1e4, () => (this.No() && (this.state = 3), Promise.resolve())), this.listener.Jr()))
        }), this.stream.Zr(s => {
            r(() => this.Go(s))
        }), this.stream.onMessage(s => {
            r(() => this.onMessage(s))
        })
    }
    ko() {
        this.state = 5, this.Co.Ao(async () => {
            this.state = 0, this.start()
        })
    }
    Go(t) {
        return me("PersistentStream", `close with error: ${t}`), this.stream = null, this.close(4, t)
    }
    Uo(t) {
        return n => {
            this.Ws.enqueueAndForget(() => this.Vo === t ? n() : (me("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()))
        }
    }
}
class YY extends k2 {
    constructor(t, n, r, s, i, o) {
        super(t, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", n, r, s, o), this.serializer = i
    }
    Qo(t, n) {
        return this.connection.wo("Listen", t, n)
    }
    onMessage(t) {
        this.Co.reset();
        const n = lY(this.serializer, t),
            r = function(s) {
                if (!("targetChange" in s)) return Ce.min();
                const i = s.targetChange;
                return i.targetIds && i.targetIds.length ? Ce.min() : i.readTime ? As(i.readTime) : Ce.min()
            }(t);
        return this.listener.zo(n, r)
    }
    jo(t) {
        const n = {};
        n.database = iE(this.serializer), n.addTarget = function(s, i) {
            let o;
            const a = i.target;
            return o = eE(a) ? {
                documents: dY(s, a)
            } : {
                query: fY(s, a)
            }, o.targetId = i.targetId, i.resumeToken.approximateByteSize() > 0 ? o.resumeToken = _2(s, i.resumeToken) : i.snapshotVersion.compareTo(Ce.min()) > 0 && (o.readTime = d_(s, i.snapshotVersion.toTimestamp())), o
        }(this.serializer, t);
        const r = pY(this.serializer, t);
        r && (n.labels = r), this.Fo(n)
    }
    Wo(t) {
        const n = {};
        n.database = iE(this.serializer), n.removeTarget = t, this.Fo(n)
    }
}
class KY extends k2 {
    constructor(t, n, r, s, i, o) {
        super(t, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", n, r, s, o), this.serializer = i, this.Ho = !1
    }
    get Jo() {
        return this.Ho
    }
    start() {
        this.Ho = !1, this.lastStreamToken = void 0, super.start()
    }
    qo() {
        this.Ho && this.Yo([])
    }
    Qo(t, n) {
        return this.connection.wo("Write", t, n)
    }
    onMessage(t) {
        if (Ct(!!t.streamToken), this.lastStreamToken = t.streamToken, this.Ho) {
            this.Co.reset();
            const n = uY(t.writeResults, t.commitTime),
                r = As(t.commitTime);
            return this.listener.Zo(r, n)
        }
        return Ct(!t.writeResults || t.writeResults.length === 0), this.Ho = !0, this.listener.Xo()
    }
    tu() {
        const t = {};
        t.database = iE(this.serializer), this.Fo(t)
    }
    Yo(t) {
        const n = {
            streamToken: this.lastStreamToken,
            writes: t.map(r => cY(this.serializer, r))
        };
        this.Fo(n)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class XY extends class {} {
    constructor(t, n, r, s) {
        super(), this.authCredentials = t, this.appCheckCredentials = n, this.connection = r, this.serializer = s, this.eu = !1
    }
    nu() {
        if (this.eu) throw new re(U.FAILED_PRECONDITION, "The client has already been terminated.")
    }
    co(t, n, r) {
        return this.nu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.connection.co(t, n, r, s, i)).catch(s => {
            throw s.name === "FirebaseError" ? (s.code === U.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new re(U.UNKNOWN, s.toString())
        })
    }
    fo(t, n, r, s) {
        return this.nu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i, o]) => this.connection.fo(t, n, r, i, o, s)).catch(i => {
            throw i.name === "FirebaseError" ? (i.code === U.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), i) : new re(U.UNKNOWN, i.toString())
        })
    }
    terminate() {
        this.eu = !0
    }
}
class QY {
    constructor(t, n) {
        this.asyncQueue = t, this.onlineStateHandler = n, this.state = "Unknown", this.su = 0, this.iu = null, this.ru = !0
    }
    ou() {
        this.su === 0 && (this.uu("Unknown"), this.iu = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.iu = null, this.cu("Backend didn't respond within 10 seconds."), this.uu("Offline"), Promise.resolve())))
    }
    au(t) {
        this.state === "Online" ? this.uu("Unknown") : (this.su++, this.su >= 1 && (this.hu(), this.cu(`Connection failed 1 times. Most recent error: ${t.toString()}`), this.uu("Offline")))
    }
    set(t) {
        this.hu(), this.su = 0, t === "Online" && (this.ru = !1), this.uu(t)
    }
    uu(t) {
        t !== this.state && (this.state = t, this.onlineStateHandler(t))
    }
    cu(t) {
        const n = `Could not reach Cloud Firestore backend. ${t}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
        this.ru ? (wi(n), this.ru = !1) : me("OnlineStateTracker", n)
    }
    hu() {
        this.iu !== null && (this.iu.cancel(), this.iu = null)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JY {
    constructor(t, n, r, s, i) {
        this.localStore = t, this.datastore = n, this.asyncQueue = r, this.remoteSyncer = {}, this.lu = [], this.fu = new Map, this.du = new Set, this.wu = [], this._u = i, this._u.qr(o => {
            r.enqueueAndForget(async () => {
                Rl(this) && (me("RemoteStore", "Restarting streams for network reachability change."), await async function(a) {
                    const l = Oe(a);
                    l.du.add(4), await pp(l), l.mu.set("Unknown"), l.du.delete(4), await bv(l)
                }(this))
            })
        }), this.mu = new QY(r, s)
    }
}
async function bv(e) {
    if (Rl(e))
        for (const t of e.wu) await t(!0)
}
async function pp(e) {
    for (const t of e.wu) await t(!1)
}

function I2(e, t) {
    const n = Oe(e);
    n.fu.has(t.targetId) || (n.fu.set(t.targetId, t), TT(n) ? ST(n) : Zu(n).No() && ET(n, t))
}

function x2(e, t) {
    const n = Oe(e),
        r = Zu(n);
    n.fu.delete(t), r.No() && C2(n, t), n.fu.size === 0 && (r.No() ? r.$o() : Rl(n) && n.mu.set("Unknown"))
}

function ET(e, t) {
    e.gu.Ot(t.targetId), Zu(e).jo(t)
}

function C2(e, t) {
    e.gu.Ot(t), Zu(e).Wo(t)
}

function ST(e) {
    e.gu = new tY({
        getRemoteKeysForTarget: t => e.remoteSyncer.getRemoteKeysForTarget(t),
        ne: t => e.fu.get(t) || null
    }), Zu(e).start(), e.mu.ou()
}

function TT(e) {
    return Rl(e) && !Zu(e).xo() && e.fu.size > 0
}

function Rl(e) {
    return Oe(e).du.size === 0
}

function A2(e) {
    e.gu = void 0
}
async function ZY(e) {
    e.fu.forEach((t, n) => {
        ET(e, t)
    })
}
async function eK(e, t) {
    A2(e), TT(e) ? (e.mu.au(t), ST(e)) : e.mu.set("Unknown")
}
async function tK(e, t, n) {
    if (e.mu.set("Online"), t instanceof g2 && t.state === 2 && t.cause) try {
        await async function(r, s) {
            const i = s.cause;
            for (const o of s.targetIds) r.fu.has(o) && (await r.remoteSyncer.rejectListen(o, i), r.fu.delete(o), r.gu.removeTarget(o))
        }(e, t)
    } catch (r) {
        me("RemoteStore", "Failed to remove targets %s: %s ", t.targetIds.join(","), r), await f_(e, r)
    } else if (t instanceof rg ? e.gu.Kt(t) : t instanceof m2 ? e.gu.Jt(t) : e.gu.zt(t), !n.isEqual(Ce.min())) try {
        const r = await T2(e.localStore);
        n.compareTo(r) >= 0 && await
        function(s, i) {
            const o = s.gu.Xt(i);
            return o.targetChanges.forEach((a, l) => {
                if (a.resumeToken.approximateByteSize() > 0) {
                    const c = s.fu.get(l);
                    c && s.fu.set(l, c.withResumeToken(a.resumeToken, i))
                }
            }), o.targetMismatches.forEach(a => {
                const l = s.fu.get(a);
                if (!l) return;
                s.fu.set(a, l.withResumeToken(Xn.EMPTY_BYTE_STRING, l.snapshotVersion)), C2(s, a);
                const c = new Ha(l.target, a, 1, l.sequenceNumber);
                ET(s, c)
            }), s.remoteSyncer.applyRemoteEvent(o)
        }(e, n)
    } catch (r) {
        me("RemoteStore", "Failed to raise snapshot:", r), await f_(e, r)
    }
}
async function f_(e, t, n) {
    if (!dp(t)) throw t;
    e.du.add(1), await pp(e), e.mu.set("Offline"), n || (n = () => T2(e.localStore)), e.asyncQueue.enqueueRetryable(async () => {
        me("RemoteStore", "Retrying IndexedDB access"), await n(), e.du.delete(1), await bv(e)
    })
}

function R2(e, t) {
    return t().catch(n => f_(e, n, t))
}
async function wv(e) {
    const t = Oe(e),
        n = Ho(t);
    let r = t.lu.length > 0 ? t.lu[t.lu.length - 1].batchId : -1;
    for (; nK(t);) try {
        const s = await BY(t.localStore, r);
        if (s === null) {
            t.lu.length === 0 && n.$o();
            break
        }
        r = s.batchId, rK(t, s)
    } catch (s) {
        await f_(t, s)
    }
    O2(t) && D2(t)
}

function nK(e) {
    return Rl(e) && e.lu.length < 10
}

function rK(e, t) {
    e.lu.push(t);
    const n = Ho(e);
    n.No() && n.Jo && n.Yo(t.mutations)
}

function O2(e) {
    return Rl(e) && !Ho(e).xo() && e.lu.length > 0
}

function D2(e) {
    Ho(e).start()
}
async function sK(e) {
    Ho(e).tu()
}
async function iK(e) {
    const t = Ho(e);
    for (const n of e.lu) t.Yo(n.mutations)
}
async function oK(e, t, n) {
    const r = e.lu.shift(),
        s = gT.from(r, t, n);
    await R2(e, () => e.remoteSyncer.applySuccessfulWrite(s)), await wv(e)
}
async function aK(e, t) {
    t && Ho(e).Jo && await async function(n, r) {
        if (s = r.code, eY(s) && s !== U.ABORTED) {
            const i = n.lu.shift();
            Ho(n).Oo(), await R2(n, () => n.remoteSyncer.rejectFailedWrite(i.batchId, r)), await wv(n)
        }
        var s
    }(e, t), O2(e) && D2(e)
}
async function eC(e, t) {
    const n = Oe(e);
    n.asyncQueue.verifyOperationInProgress(), me("RemoteStore", "RemoteStore received new credentials");
    const r = Rl(n);
    n.du.add(3), await pp(n), r && n.mu.set("Unknown"), await n.remoteSyncer.handleCredentialChange(t), n.du.delete(3), await bv(n)
}
async function lK(e, t) {
    const n = Oe(e);
    t ? (n.du.delete(2), await bv(n)) : t || (n.du.add(2), await pp(n), n.mu.set("Unknown"))
}

function Zu(e) {
    return e.yu || (e.yu = function(t, n, r) {
        const s = Oe(t);
        return s.nu(), new YY(n, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, r)
    }(e.datastore, e.asyncQueue, {
        Jr: ZY.bind(null, e),
        Zr: eK.bind(null, e),
        zo: tK.bind(null, e)
    }), e.wu.push(async t => {
        t ? (e.yu.Oo(), TT(e) ? ST(e) : e.mu.set("Unknown")) : (await e.yu.stop(), A2(e))
    })), e.yu
}

function Ho(e) {
    return e.pu || (e.pu = function(t, n, r) {
        const s = Oe(t);
        return s.nu(), new KY(n, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, r)
    }(e.datastore, e.asyncQueue, {
        Jr: sK.bind(null, e),
        Zr: aK.bind(null, e),
        Xo: iK.bind(null, e),
        Zo: oK.bind(null, e)
    }), e.wu.push(async t => {
        t ? (e.pu.Oo(), await wv(e)) : (await e.pu.stop(), e.lu.length > 0 && (me("RemoteStore", `Stopping write stream with ${e.lu.length} pending writes`), e.lu = []))
    })), e.pu
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $T {
    constructor(t, n, r, s, i) {
        this.asyncQueue = t, this.timerId = n, this.targetTimeMs = r, this.op = s, this.removalCallback = i, this.deferred = new ui, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch(o => {})
    }
    static createAndSchedule(t, n, r, s, i) {
        const o = Date.now() + r,
            a = new $T(t, n, o, s, i);
        return a.start(r), a
    }
    start(t) {
        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t)
    }
    skipDelay() {
        return this.handleDelayElapsed()
    }
    cancel(t) {
        this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new re(U.CANCELLED, "Operation cancelled" + (t ? ": " + t : ""))))
    }
    handleDelayElapsed() {
        this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then(t => this.deferred.resolve(t))) : Promise.resolve())
    }
    clearTimeout() {
        this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null)
    }
}

function kT(e, t) {
    if (wi("AsyncQueue", `${t}: ${e}`), dp(e)) return new re(U.UNAVAILABLE, `${t}: ${e}`);
    throw e
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xc {
    constructor(t) {
        this.comparator = t ? (n, r) => t(n, r) || ve.comparator(n.key, r.key) : (n, r) => ve.comparator(n.key, r.key), this.keyedMap = Dd(), this.sortedSet = new fn(this.comparator)
    }
    static emptySet(t) {
        return new xc(t.comparator)
    }
    has(t) {
        return this.keyedMap.get(t) != null
    }
    get(t) {
        return this.keyedMap.get(t)
    }
    first() {
        return this.sortedSet.minKey()
    }
    last() {
        return this.sortedSet.maxKey()
    }
    isEmpty() {
        return this.sortedSet.isEmpty()
    }
    indexOf(t) {
        const n = this.keyedMap.get(t);
        return n ? this.sortedSet.indexOf(n) : -1
    }
    get size() {
        return this.sortedSet.size
    }
    forEach(t) {
        this.sortedSet.inorderTraversal((n, r) => (t(n), !1))
    }
    add(t) {
        const n = this.delete(t.key);
        return n.copy(n.keyedMap.insert(t.key, t), n.sortedSet.insert(t, null))
    }
    delete(t) {
        const n = this.get(t);
        return n ? this.copy(this.keyedMap.remove(t), this.sortedSet.remove(n)) : this
    }
    isEqual(t) {
        if (!(t instanceof xc) || this.size !== t.size) return !1;
        const n = this.sortedSet.getIterator(),
            r = t.sortedSet.getIterator();
        for (; n.hasNext();) {
            const s = n.getNext().key,
                i = r.getNext().key;
            if (!s.isEqual(i)) return !1
        }
        return !0
    }
    toString() {
        const t = [];
        return this.forEach(n => {
            t.push(n.toString())
        }), t.length === 0 ? "DocumentSet ()" : `DocumentSet (
  ` + t.join(`  
`) + `
)`
    }
    copy(t, n) {
        const r = new xc;
        return r.comparator = this.comparator, r.keyedMap = t, r.sortedSet = n, r
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class tC {
    constructor() {
        this.Iu = new fn(ve.comparator)
    }
    track(t) {
        const n = t.doc.key,
            r = this.Iu.get(n);
        r ? t.type !== 0 && r.type === 3 ? this.Iu = this.Iu.insert(n, t) : t.type === 3 && r.type !== 1 ? this.Iu = this.Iu.insert(n, {
            type: r.type,
            doc: t.doc
        }) : t.type === 2 && r.type === 2 ? this.Iu = this.Iu.insert(n, {
            type: 2,
            doc: t.doc
        }) : t.type === 2 && r.type === 0 ? this.Iu = this.Iu.insert(n, {
            type: 0,
            doc: t.doc
        }) : t.type === 1 && r.type === 0 ? this.Iu = this.Iu.remove(n) : t.type === 1 && r.type === 2 ? this.Iu = this.Iu.insert(n, {
            type: 1,
            doc: r.doc
        }) : t.type === 0 && r.type === 1 ? this.Iu = this.Iu.insert(n, {
            type: 2,
            doc: t.doc
        }) : $e() : this.Iu = this.Iu.insert(n, t)
    }
    Tu() {
        const t = [];
        return this.Iu.inorderTraversal((n, r) => {
            t.push(r)
        }), t
    }
}
class lu {
    constructor(t, n, r, s, i, o, a, l, c) {
        this.query = t, this.docs = n, this.oldDocs = r, this.docChanges = s, this.mutatedKeys = i, this.fromCache = o, this.syncStateChanged = a, this.excludesMetadataChanges = l, this.hasCachedResults = c
    }
    static fromInitialDocuments(t, n, r, s, i) {
        const o = [];
        return n.forEach(a => {
            o.push({
                type: 0,
                doc: a
            })
        }), new lu(t, n, xc.emptySet(n), o, r, s, !0, !1, i)
    }
    get hasPendingWrites() {
        return !this.mutatedKeys.isEmpty()
    }
    isEqual(t) {
        if (!(this.fromCache === t.fromCache && this.hasCachedResults === t.hasCachedResults && this.syncStateChanged === t.syncStateChanged && this.mutatedKeys.isEqual(t.mutatedKeys) && pv(this.query, t.query) && this.docs.isEqual(t.docs) && this.oldDocs.isEqual(t.oldDocs))) return !1;
        const n = this.docChanges,
            r = t.docChanges;
        if (n.length !== r.length) return !1;
        for (let s = 0; s < n.length; s++)
            if (n[s].type !== r[s].type || !n[s].doc.isEqual(r[s].doc)) return !1;
        return !0
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cK {
    constructor() {
        this.Eu = void 0, this.listeners = []
    }
}
class uK {
    constructor() {
        this.queries = new Ju(t => ZL(t), pv), this.onlineState = "Unknown", this.Au = new Set
    }
}
async function IT(e, t) {
    const n = Oe(e),
        r = t.query;
    let s = !1,
        i = n.queries.get(r);
    if (i || (s = !0, i = new cK), s) try {
        i.Eu = await n.onListen(r)
    } catch (o) {
        const a = kT(o, `Initialization of query '${nE(t.query)}' failed`);
        return void t.onError(a)
    }
    n.queries.set(r, i), i.listeners.push(t), t.Ru(n.onlineState), i.Eu && t.vu(i.Eu) && CT(n)
}
async function xT(e, t) {
    const n = Oe(e),
        r = t.query;
    let s = !1;
    const i = n.queries.get(r);
    if (i) {
        const o = i.listeners.indexOf(t);
        o >= 0 && (i.listeners.splice(o, 1), s = i.listeners.length === 0)
    }
    if (s) return n.queries.delete(r), n.onUnlisten(r)
}

function dK(e, t) {
    const n = Oe(e);
    let r = !1;
    for (const s of t) {
        const i = s.query,
            o = n.queries.get(i);
        if (o) {
            for (const a of o.listeners) a.vu(s) && (r = !0);
            o.Eu = s
        }
    }
    r && CT(n)
}

function fK(e, t, n) {
    const r = Oe(e),
        s = r.queries.get(t);
    if (s)
        for (const i of s.listeners) i.onError(n);
    r.queries.delete(t)
}

function CT(e) {
    e.Au.forEach(t => {
        t.next()
    })
}
class AT {
    constructor(t, n, r) {
        this.query = t, this.bu = n, this.Pu = !1, this.Vu = null, this.onlineState = "Unknown", this.options = r || {}
    }
    vu(t) {
        if (!this.options.includeMetadataChanges) {
            const r = [];
            for (const s of t.docChanges) s.type !== 3 && r.push(s);
            t = new lu(t.query, t.docs, t.oldDocs, r, t.mutatedKeys, t.fromCache, t.syncStateChanged, !0, t.hasCachedResults)
        }
        let n = !1;
        return this.Pu ? this.Su(t) && (this.bu.next(t), n = !0) : this.Du(t, this.onlineState) && (this.Cu(t), n = !0), this.Vu = t, n
    }
    onError(t) {
        this.bu.error(t)
    }
    Ru(t) {
        this.onlineState = t;
        let n = !1;
        return this.Vu && !this.Pu && this.Du(this.Vu, t) && (this.Cu(this.Vu), n = !0), n
    }
    Du(t, n) {
        if (!t.fromCache) return !0;
        const r = n !== "Offline";
        return (!this.options.xu || !r) && (!t.docs.isEmpty() || t.hasCachedResults || n === "Offline")
    }
    Su(t) {
        if (t.docChanges.length > 0) return !0;
        const n = this.Vu && this.Vu.hasPendingWrites !== t.hasPendingWrites;
        return !(!t.syncStateChanged && !n) && this.options.includeMetadataChanges === !0
    }
    Cu(t) {
        t = lu.fromInitialDocuments(t.query, t.docs, t.mutatedKeys, t.fromCache, t.hasCachedResults), this.Pu = !0, this.bu.next(t)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class N2 {
    constructor(t) {
        this.key = t
    }
}
class P2 {
    constructor(t) {
        this.key = t
    }
}
class hK {
    constructor(t, n) {
        this.query = t, this.Lu = n, this.qu = null, this.hasCachedResults = !1, this.current = !1, this.Uu = je(), this.mutatedKeys = je(), this.Ku = e2(t), this.Gu = new xc(this.Ku)
    }
    get Qu() {
        return this.Lu
    }
    zu(t, n) {
        const r = n ? n.ju : new tC,
            s = n ? n.Gu : this.Gu;
        let i = n ? n.mutatedKeys : this.mutatedKeys,
            o = s,
            a = !1;
        const l = this.query.limitType === "F" && s.size === this.query.limit ? s.last() : null,
            c = this.query.limitType === "L" && s.size === this.query.limit ? s.first() : null;
        if (t.inorderTraversal((u, d) => {
                const f = s.get(u),
                    h = mv(this.query, d) ? d : null,
                    p = !!f && this.mutatedKeys.has(f.key),
                    m = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
                let g = !1;
                f && h ? f.data.isEqual(h.data) ? p !== m && (r.track({
                    type: 3,
                    doc: h
                }), g = !0) : this.Wu(f, h) || (r.track({
                    type: 2,
                    doc: h
                }), g = !0, (l && this.Ku(h, l) > 0 || c && this.Ku(h, c) < 0) && (a = !0)) : !f && h ? (r.track({
                    type: 0,
                    doc: h
                }), g = !0) : f && !h && (r.track({
                    type: 1,
                    doc: f
                }), g = !0, (l || c) && (a = !0)), g && (h ? (o = o.add(h), i = m ? i.add(u) : i.delete(u)) : (o = o.delete(u), i = i.delete(u)))
            }), this.query.limit !== null)
            for (; o.size > this.query.limit;) {
                const u = this.query.limitType === "F" ? o.last() : o.first();
                o = o.delete(u.key), i = i.delete(u.key), r.track({
                    type: 1,
                    doc: u
                })
            }
        return {
            Gu: o,
            ju: r,
            Mi: a,
            mutatedKeys: i
        }
    }
    Wu(t, n) {
        return t.hasLocalMutations && n.hasCommittedMutations && !n.hasLocalMutations
    }
    applyChanges(t, n, r) {
        const s = this.Gu;
        this.Gu = t.Gu, this.mutatedKeys = t.mutatedKeys;
        const i = t.ju.Tu();
        i.sort((c, u) => function(d, f) {
            const h = p => {
                switch (p) {
                    case 0:
                        return 1;
                    case 2:
                    case 3:
                        return 2;
                    case 1:
                        return 0;
                    default:
                        return $e()
                }
            };
            return h(d) - h(f)
        }(c.type, u.type) || this.Ku(c.doc, u.doc)), this.Hu(r);
        const o = n ? this.Ju() : [],
            a = this.Uu.size === 0 && this.current ? 1 : 0,
            l = a !== this.qu;
        return this.qu = a, i.length !== 0 || l ? {
            snapshot: new lu(this.query, t.Gu, s, i, t.mutatedKeys, a === 0, l, !1, !!r && r.resumeToken.approximateByteSize() > 0),
            Yu: o
        } : {
            Yu: o
        }
    }
    Ru(t) {
        return this.current && t === "Offline" ? (this.current = !1, this.applyChanges({
            Gu: this.Gu,
            ju: new tC,
            mutatedKeys: this.mutatedKeys,
            Mi: !1
        }, !1)) : {
            Yu: []
        }
    }
    Zu(t) {
        return !this.Lu.has(t) && !!this.Gu.has(t) && !this.Gu.get(t).hasLocalMutations
    }
    Hu(t) {
        t && (t.addedDocuments.forEach(n => this.Lu = this.Lu.add(n)), t.modifiedDocuments.forEach(n => {}), t.removedDocuments.forEach(n => this.Lu = this.Lu.delete(n)), this.current = t.current)
    }
    Ju() {
        if (!this.current) return [];
        const t = this.Uu;
        this.Uu = je(), this.Gu.forEach(r => {
            this.Zu(r.key) && (this.Uu = this.Uu.add(r.key))
        });
        const n = [];
        return t.forEach(r => {
            this.Uu.has(r) || n.push(new P2(r))
        }), this.Uu.forEach(r => {
            t.has(r) || n.push(new N2(r))
        }), n
    }
    Xu(t) {
        this.Lu = t.Wi, this.Uu = je();
        const n = this.zu(t.documents);
        return this.applyChanges(n, !0)
    }
    tc() {
        return lu.fromInitialDocuments(this.query, this.Gu, this.mutatedKeys, this.qu === 0, this.hasCachedResults)
    }
}
class pK {
    constructor(t, n, r) {
        this.query = t, this.targetId = n, this.view = r
    }
}
class mK {
    constructor(t) {
        this.key = t, this.ec = !1
    }
}
class gK {
    constructor(t, n, r, s, i, o) {
        this.localStore = t, this.remoteStore = n, this.eventManager = r, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = o, this.nc = {}, this.sc = new Ju(a => ZL(a), pv), this.ic = new Map, this.rc = new Set, this.oc = new fn(ve.comparator), this.uc = new Map, this.cc = new vT, this.ac = {}, this.hc = new Map, this.lc = au.bn(), this.onlineState = "Unknown", this.fc = void 0
    }
    get isPrimaryClient() {
        return this.fc === !0
    }
}
async function _K(e, t) {
    const n = IK(e);
    let r, s;
    const i = n.sc.get(t);
    if (i) r = i.targetId, n.sharedClientState.addLocalQueryTarget(r), s = i.view.tc();
    else {
        const o = await VY(n.localStore, Ei(t));
        n.isPrimaryClient && I2(n.remoteStore, o);
        const a = n.sharedClientState.addLocalQueryTarget(o.targetId);
        r = o.targetId, s = await yK(n, t, r, a === "current", o.resumeToken)
    }
    return s
}
async function yK(e, t, n, r, s) {
    e.dc = (d, f, h) => async function(p, m, g, y) {
        let _ = m.view.zu(g);
        _.Mi && (_ = await Qx(p.localStore, m.query, !1).then(({
            documents: w
        }) => m.view.zu(w, _)));
        const E = y && y.targetChanges.get(m.targetId),
            b = m.view.applyChanges(_, p.isPrimaryClient, E);
        return rC(p, m.targetId, b.Yu), b.snapshot
    }(e, d, f, h);
    const i = await Qx(e.localStore, t, !0),
        o = new hK(t, i.Wi),
        a = o.zu(i.documents),
        l = hp.createSynthesizedTargetChangeForCurrentChange(n, r && e.onlineState !== "Offline", s),
        c = o.applyChanges(a, e.isPrimaryClient, l);
    rC(e, n, c.Yu);
    const u = new pK(t, n, o);
    return e.sc.set(t, u), e.ic.has(n) ? e.ic.get(n).push(t) : e.ic.set(n, [t]), c.snapshot
}
async function vK(e, t) {
    const n = Oe(e),
        r = n.sc.get(t),
        s = n.ic.get(r.targetId);
    if (s.length > 1) return n.ic.set(r.targetId, s.filter(i => !pv(i, t))), void n.sc.delete(t);
    n.isPrimaryClient ? (n.sharedClientState.removeLocalQueryTarget(r.targetId), n.sharedClientState.isActiveQueryTarget(r.targetId) || await oE(n.localStore, r.targetId, !1).then(() => {
        n.sharedClientState.clearQueryState(r.targetId), x2(n.remoteStore, r.targetId), aE(n, r.targetId)
    }).catch(up)) : (aE(n, r.targetId), await oE(n.localStore, r.targetId, !0))
}
async function bK(e, t, n) {
    const r = xK(e);
    try {
        const s = await
        function(i, o) {
            const a = Oe(i),
                l = un.now(),
                c = o.reduce((f, h) => f.add(h.key), je());
            let u, d;
            return a.persistence.runTransaction("Locally write mutations", "readwrite", f => {
                let h = Si(),
                    p = je();
                return a.Ki.getEntries(f, c).next(m => {
                    h = m, h.forEach((g, y) => {
                        y.isValidDocument() || (p = p.add(g))
                    })
                }).next(() => a.localDocuments.getOverlayedDocuments(f, h)).next(m => {
                    u = m;
                    const g = [];
                    for (const y of o) {
                        const _ = K8(y, u.get(y.key).overlayedDocument);
                        _ != null && g.push(new la(y.key, _, WL(_.value.mapValue), Cs.exists(!0)))
                    }
                    return a.mutationQueue.addMutationBatch(f, l, g, o)
                }).next(m => {
                    d = m;
                    const g = m.applyToLocalDocumentSet(u, p);
                    return a.documentOverlayCache.saveOverlays(f, m.batchId, g)
                })
            }).then(() => ({
                batchId: d.batchId,
                changes: n2(u)
            }))
        }(r.localStore, t);
        r.sharedClientState.addPendingMutation(s.batchId),
            function(i, o, a) {
                let l = i.ac[i.currentUser.toKey()];
                l || (l = new fn(ut)), l = l.insert(o, a), i.ac[i.currentUser.toKey()] = l
            }(r, s.batchId, n), await mp(r, s.changes), await wv(r.remoteStore)
    } catch (s) {
        const i = kT(s, "Failed to persist write");
        n.reject(i)
    }
}
async function M2(e, t) {
    const n = Oe(e);
    try {
        const r = await FY(n.localStore, t);
        t.targetChanges.forEach((s, i) => {
            const o = n.uc.get(i);
            o && (Ct(s.addedDocuments.size + s.modifiedDocuments.size + s.removedDocuments.size <= 1), s.addedDocuments.size > 0 ? o.ec = !0 : s.modifiedDocuments.size > 0 ? Ct(o.ec) : s.removedDocuments.size > 0 && (Ct(o.ec), o.ec = !1))
        }), await mp(n, r, t)
    } catch (r) {
        await up(r)
    }
}

function nC(e, t, n) {
    const r = Oe(e);
    if (r.isPrimaryClient && n === 0 || !r.isPrimaryClient && n === 1) {
        const s = [];
        r.sc.forEach((i, o) => {
                const a = o.view.Ru(t);
                a.snapshot && s.push(a.snapshot)
            }),
            function(i, o) {
                const a = Oe(i);
                a.onlineState = o;
                let l = !1;
                a.queries.forEach((c, u) => {
                    for (const d of u.listeners) d.Ru(o) && (l = !0)
                }), l && CT(a)
            }(r.eventManager, t), s.length && r.nc.zo(s), r.onlineState = t, r.isPrimaryClient && r.sharedClientState.setOnlineState(t)
    }
}
async function wK(e, t, n) {
    const r = Oe(e);
    r.sharedClientState.updateQueryState(t, "rejected", n);
    const s = r.uc.get(t),
        i = s && s.key;
    if (i) {
        let o = new fn(ve.comparator);
        o = o.insert(i, Bn.newNoDocument(i, Ce.min()));
        const a = je().add(i),
            l = new yv(Ce.min(), new Map, new dn(ut), o, a);
        await M2(r, l), r.oc = r.oc.remove(i), r.uc.delete(t), RT(r)
    } else await oE(r.localStore, t, !1).then(() => aE(r, t, n)).catch(up)
}
async function EK(e, t) {
    const n = Oe(e),
        r = t.batch.batchId;
    try {
        const s = await LY(n.localStore, t);
        F2(n, r, null), L2(n, r), n.sharedClientState.updateMutationState(r, "acknowledged"), await mp(n, s)
    } catch (s) {
        await up(s)
    }
}
async function SK(e, t, n) {
    const r = Oe(e);
    try {
        const s = await
        function(i, o) {
            const a = Oe(i);
            return a.persistence.runTransaction("Reject batch", "readwrite-primary", l => {
                let c;
                return a.mutationQueue.lookupMutationBatch(l, o).next(u => (Ct(u !== null), c = u.keys(), a.mutationQueue.removeMutationBatch(l, u))).next(() => a.mutationQueue.performConsistencyCheck(l)).next(() => a.documentOverlayCache.removeOverlaysForBatchId(l, c, o)).next(() => a.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(l, c)).next(() => a.localDocuments.getDocuments(l, c))
            })
        }(r.localStore, t);
        F2(r, t, n), L2(r, t), r.sharedClientState.updateMutationState(t, "rejected", n), await mp(r, s)
    } catch (s) {
        await up(s)
    }
}

function L2(e, t) {
    (e.hc.get(t) || []).forEach(n => {
        n.resolve()
    }), e.hc.delete(t)
}

function F2(e, t, n) {
    const r = Oe(e);
    let s = r.ac[r.currentUser.toKey()];
    if (s) {
        const i = s.get(t);
        i && (n ? i.reject(n) : i.resolve(), s = s.remove(t)), r.ac[r.currentUser.toKey()] = s
    }
}

function aE(e, t, n = null) {
    e.sharedClientState.removeLocalQueryTarget(t);
    for (const r of e.ic.get(t)) e.sc.delete(r), n && e.nc.wc(r, n);
    e.ic.delete(t), e.isPrimaryClient && e.cc.hs(t).forEach(r => {
        e.cc.containsKey(r) || U2(e, r)
    })
}

function U2(e, t) {
    e.rc.delete(t.path.canonicalString());
    const n = e.oc.get(t);
    n !== null && (x2(e.remoteStore, n), e.oc = e.oc.remove(t), e.uc.delete(n), RT(e))
}

function rC(e, t, n) {
    for (const r of n) r instanceof N2 ? (e.cc.addReference(r.key, t), TK(e, r)) : r instanceof P2 ? (me("SyncEngine", "Document no longer in limbo: " + r.key), e.cc.removeReference(r.key, t), e.cc.containsKey(r.key) || U2(e, r.key)) : $e()
}

function TK(e, t) {
    const n = t.key,
        r = n.path.canonicalString();
    e.oc.get(n) || e.rc.has(r) || (me("SyncEngine", "New document in limbo: " + n), e.rc.add(r), RT(e))
}

function RT(e) {
    for (; e.rc.size > 0 && e.oc.size < e.maxConcurrentLimboResolutions;) {
        const t = e.rc.values().next().value;
        e.rc.delete(t);
        const n = new ve(xt.fromString(t)),
            r = e.lc.next();
        e.uc.set(r, new mK(n)), e.oc = e.oc.insert(n, r), I2(e.remoteStore, new Ha(Ei(fv(n.path)), r, 2, dT.ct))
    }
}
async function mp(e, t, n) {
    const r = Oe(e),
        s = [],
        i = [],
        o = [];
    r.sc.isEmpty() || (r.sc.forEach((a, l) => {
        o.push(r.dc(l, t, n).then(c => {
            if ((c || n) && r.isPrimaryClient && r.sharedClientState.updateQueryState(l.targetId, c != null && c.fromCache ? "not-current" : "current"), c) {
                s.push(c);
                const u = wT.Di(l.targetId, c);
                i.push(u)
            }
        }))
    }), await Promise.all(o), r.nc.zo(s), await async function(a, l) {
        const c = Oe(a);
        try {
            await c.persistence.runTransaction("notifyLocalViewChanges", "readwrite", u => W.forEach(l, d => W.forEach(d.Vi, f => c.persistence.referenceDelegate.addReference(u, d.targetId, f)).next(() => W.forEach(d.Si, f => c.persistence.referenceDelegate.removeReference(u, d.targetId, f)))))
        } catch (u) {
            if (!dp(u)) throw u;
            me("LocalStore", "Failed to update sequence numbers: " + u)
        }
        for (const u of l) {
            const d = u.targetId;
            if (!u.fromCache) {
                const f = c.Li.get(d),
                    h = f.snapshotVersion,
                    p = f.withLastLimboFreeSnapshotVersion(h);
                c.Li = c.Li.insert(d, p)
            }
        }
    }(r.localStore, i))
}
async function $K(e, t) {
    const n = Oe(e);
    if (!n.currentUser.isEqual(t)) {
        me("SyncEngine", "User change. New user:", t.toKey());
        const r = await S2(n.localStore, t);
        n.currentUser = t,
            function(s, i) {
                s.hc.forEach(o => {
                    o.forEach(a => {
                        a.reject(new re(U.CANCELLED, i))
                    })
                }), s.hc.clear()
            }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(t, r.removedBatchIds, r.addedBatchIds), await mp(n, r.Qi)
    }
}

function kK(e, t) {
    const n = Oe(e),
        r = n.uc.get(t);
    if (r && r.ec) return je().add(r.key); {
        let s = je();
        const i = n.ic.get(t);
        if (!i) return s;
        for (const o of i) {
            const a = n.sc.get(o);
            s = s.unionWith(a.view.Qu)
        }
        return s
    }
}

function IK(e) {
    const t = Oe(e);
    return t.remoteStore.remoteSyncer.applyRemoteEvent = M2.bind(null, t), t.remoteStore.remoteSyncer.getRemoteKeysForTarget = kK.bind(null, t), t.remoteStore.remoteSyncer.rejectListen = wK.bind(null, t), t.nc.zo = dK.bind(null, t.eventManager), t.nc.wc = fK.bind(null, t.eventManager), t
}

function xK(e) {
    const t = Oe(e);
    return t.remoteStore.remoteSyncer.applySuccessfulWrite = EK.bind(null, t), t.remoteStore.remoteSyncer.rejectFailedWrite = SK.bind(null, t), t
}
class sC {
    constructor() {
        this.synchronizeTabs = !1
    }
    async initialize(t) {
        this.serializer = vv(t.databaseInfo.databaseId), this.sharedClientState = this.createSharedClientState(t), this.persistence = this.createPersistence(t), await this.persistence.start(), this.localStore = this.createLocalStore(t), this.gcScheduler = this.createGarbageCollectionScheduler(t, this.localStore), this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(t, this.localStore)
    }
    createGarbageCollectionScheduler(t, n) {
        return null
    }
    createIndexBackfillerScheduler(t, n) {
        return null
    }
    createLocalStore(t) {
        return MY(this.persistence, new NY, t.initialUser, this.serializer)
    }
    createPersistence(t) {
        return new OY(bT.Fs, this.serializer)
    }
    createSharedClientState(t) {
        return new jY
    }
    async terminate() {
        this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown()
    }
}
class CK {
    async initialize(t, n) {
        this.localStore || (this.localStore = t.localStore, this.sharedClientState = t.sharedClientState, this.datastore = this.createDatastore(n), this.remoteStore = this.createRemoteStore(n), this.eventManager = this.createEventManager(n), this.syncEngine = this.createSyncEngine(n, !t.synchronizeTabs), this.sharedClientState.onlineStateHandler = r => nC(this.syncEngine, r, 1), this.remoteStore.remoteSyncer.handleCredentialChange = $K.bind(null, this.syncEngine), await lK(this.remoteStore, this.syncEngine.isPrimaryClient))
    }
    createEventManager(t) {
        return new uK
    }
    createDatastore(t) {
        const n = vv(t.databaseInfo.databaseId),
            r = (s = t.databaseInfo, new qY(s));
        var s;
        return function(i, o, a, l) {
            return new XY(i, o, a, l)
        }(t.authCredentials, t.appCheckCredentials, r, n)
    }
    createRemoteStore(t) {
        return n = this.localStore, r = this.datastore, s = t.asyncQueue, i = a => nC(this.syncEngine, a, 0), o = Zx.D() ? new Zx : new zY, new JY(n, r, s, i, o);
        var n, r, s, i, o
    }
    createSyncEngine(t, n) {
        return function(r, s, i, o, a, l, c) {
            const u = new gK(r, s, i, o, a, l);
            return c && (u.fc = !0), u
        }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t.initialUser, t.maxConcurrentLimboResolutions, n)
    }
    terminate() {
        return async function(t) {
            const n = Oe(t);
            me("RemoteStore", "RemoteStore shutting down."), n.du.add(5), await pp(n), n._u.shutdown(), n.mu.set("Unknown")
        }(this.remoteStore)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OT {
    constructor(t) {
        this.observer = t, this.muted = !1
    }
    next(t) {
        this.observer.next && this.gc(this.observer.next, t)
    }
    error(t) {
        this.observer.error ? this.gc(this.observer.error, t) : wi("Uncaught Error in snapshot listener:", t.toString())
    }
    yc() {
        this.muted = !0
    }
    gc(t, n) {
        this.muted || setTimeout(() => {
            this.muted || t(n)
        }, 0)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AK {
    constructor(t, n, r, s) {
        this.authCredentials = t, this.appCheckCredentials = n, this.asyncQueue = r, this.databaseInfo = s, this.user = Fn.UNAUTHENTICATED, this.clientId = VL.A(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(r, async i => {
            me("FirestoreClient", "Received user=", i.uid), await this.authCredentialListener(i), this.user = i
        }), this.appCheckCredentials.start(r, i => (me("FirestoreClient", "Received new app check token=", i), this.appCheckCredentialListener(i, this.user)))
    }
    async getConfiguration() {
        return {
            asyncQueue: this.asyncQueue,
            databaseInfo: this.databaseInfo,
            clientId: this.clientId,
            authCredentials: this.authCredentials,
            appCheckCredentials: this.appCheckCredentials,
            initialUser: this.user,
            maxConcurrentLimboResolutions: 100
        }
    }
    setCredentialChangeListener(t) {
        this.authCredentialListener = t
    }
    setAppCheckTokenChangeListener(t) {
        this.appCheckCredentialListener = t
    }
    verifyNotTerminated() {
        if (this.asyncQueue.isShuttingDown) throw new re(U.FAILED_PRECONDITION, "The client has already been terminated.")
    }
    terminate() {
        this.asyncQueue.enterRestrictedMode();
        const t = new ui;
        return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
            try {
                this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t.resolve()
            } catch (n) {
                const r = kT(n, "Failed to shutdown persistence");
                t.reject(r)
            }
        }), t.promise
    }
}
async function l0(e, t) {
    e.asyncQueue.verifyOperationInProgress(), me("FirestoreClient", "Initializing OfflineComponentProvider");
    const n = await e.getConfiguration();
    await t.initialize(n);
    let r = n.initialUser;
    e.setCredentialChangeListener(async s => {
        r.isEqual(s) || (await S2(t.localStore, s), r = s)
    }), t.persistence.setDatabaseDeletedListener(() => e.terminate()), e._offlineComponents = t
}
async function iC(e, t) {
    e.asyncQueue.verifyOperationInProgress();
    const n = await OK(e);
    me("FirestoreClient", "Initializing OnlineComponentProvider");
    const r = await e.getConfiguration();
    await t.initialize(n, r), e.setCredentialChangeListener(s => eC(t.remoteStore, s)), e.setAppCheckTokenChangeListener((s, i) => eC(t.remoteStore, i)), e._onlineComponents = t
}

function RK(e) {
    return e.name === "FirebaseError" ? e.code === U.FAILED_PRECONDITION || e.code === U.UNIMPLEMENTED : !(typeof DOMException != "undefined" && e instanceof DOMException) || e.code === 22 || e.code === 20 || e.code === 11
}
async function OK(e) {
    if (!e._offlineComponents)
        if (e._uninitializedComponentsProvider) {
            me("FirestoreClient", "Using user provided OfflineComponentProvider");
            try {
                await l0(e, e._uninitializedComponentsProvider._offline)
            } catch (t) {
                const n = t;
                if (!RK(n)) throw n;
                o_("Error using user provided cache. Falling back to memory cache: " + n), await l0(e, new sC)
            }
        } else me("FirestoreClient", "Using default OfflineComponentProvider"), await l0(e, new sC);
    return e._offlineComponents
}
async function B2(e) {
    return e._onlineComponents || (e._uninitializedComponentsProvider ? (me("FirestoreClient", "Using user provided OnlineComponentProvider"), await iC(e, e._uninitializedComponentsProvider._online)) : (me("FirestoreClient", "Using default OnlineComponentProvider"), await iC(e, new CK))), e._onlineComponents
}

function DK(e) {
    return B2(e).then(t => t.syncEngine)
}
async function h_(e) {
    const t = await B2(e),
        n = t.eventManager;
    return n.onListen = _K.bind(null, t.syncEngine), n.onUnlisten = vK.bind(null, t.syncEngine), n
}

function NK(e, t, n = {}) {
    const r = new ui;
    return e.asyncQueue.enqueueAndForget(async () => function(s, i, o, a, l) {
        const c = new OT({
                next: d => {
                    i.enqueueAndForget(() => xT(s, u));
                    const f = d.docs.has(o);
                    !f && d.fromCache ? l.reject(new re(U.UNAVAILABLE, "Failed to get document because the client is offline.")) : f && d.fromCache && a && a.source === "server" ? l.reject(new re(U.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : l.resolve(d)
                },
                error: d => l.reject(d)
            }),
            u = new AT(fv(o.path), c, {
                includeMetadataChanges: !0,
                xu: !0
            });
        return IT(s, u)
    }(await h_(e), e.asyncQueue, t, n, r)), r.promise
}

function PK(e, t, n = {}) {
    const r = new ui;
    return e.asyncQueue.enqueueAndForget(async () => function(s, i, o, a, l) {
        const c = new OT({
                next: d => {
                    i.enqueueAndForget(() => xT(s, u)), d.fromCache && a.source === "server" ? l.reject(new re(U.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : l.resolve(d)
                },
                error: d => l.reject(d)
            }),
            u = new AT(o, c, {
                includeMetadataChanges: !0,
                xu: !0
            });
        return IT(s, u)
    }(await h_(e), e.asyncQueue, t, n, r)), r.promise
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oC = new Map;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function V2(e, t, n) {
    if (!n) throw new re(U.INVALID_ARGUMENT, `Function ${e}() cannot be called with an empty ${t}.`)
}

function MK(e, t, n, r) {
    if (t === !0 && r === !0) throw new re(U.INVALID_ARGUMENT, `${e} and ${n} cannot be used together.`)
}

function aC(e) {
    if (!ve.isDocumentKey(e)) throw new re(U.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`)
}

function lC(e) {
    if (ve.isDocumentKey(e)) throw new re(U.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`)
}

function Ev(e) {
    if (e === void 0) return "undefined";
    if (e === null) return "null";
    if (typeof e == "string") return e.length > 20 && (e = `${e.substring(0,20)}...`), JSON.stringify(e);
    if (typeof e == "number" || typeof e == "boolean") return "" + e;
    if (typeof e == "object") {
        if (e instanceof Array) return "an array"; {
            const t = function(n) {
                return n.constructor ? n.constructor.name : null
            }(e);
            return t ? `a custom ${t} object` : "an object"
        }
    }
    return typeof e == "function" ? "a function" : $e()
}

function fs(e, t) {
    if ("_delegate" in e && (e = e._delegate), !(e instanceof t)) {
        if (t.name === e.constructor.name) throw new re(U.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"); {
            const n = Ev(e);
            throw new re(U.INVALID_ARGUMENT, `Expected type '${t.name}', but it was: ${n}`)
        }
    }
    return e
}

function LK(e, t) {
    if (t <= 0) throw new re(U.INVALID_ARGUMENT, `Function ${e}() requires a positive number, but it was: ${t}.`)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cC {
    constructor(t) {
        var n;
        if (t.host === void 0) {
            if (t.ssl !== void 0) throw new re(U.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
            this.host = "firestore.googleapis.com", this.ssl = !0
        } else this.host = t.host, this.ssl = (n = t.ssl) === null || n === void 0 || n;
        if (this.credentials = t.credentials, this.ignoreUndefinedProperties = !!t.ignoreUndefinedProperties, this.cache = t.localCache, t.cacheSizeBytes === void 0) this.cacheSizeBytes = 41943040;
        else {
            if (t.cacheSizeBytes !== -1 && t.cacheSizeBytes < 1048576) throw new re(U.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
            this.cacheSizeBytes = t.cacheSizeBytes
        }
        this.experimentalForceLongPolling = !!t.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t.useFetchStreams, MK("experimentalForceLongPolling", t.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t.experimentalAutoDetectLongPolling)
    }
    isEqual(t) {
        return this.host === t.host && this.ssl === t.ssl && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.experimentalForceLongPolling === t.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t.ignoreUndefinedProperties && this.useFetchStreams === t.useFetchStreams
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Sv {
    constructor(t, n, r, s) {
        this._authCredentials = t, this._appCheckCredentials = n, this._databaseId = r, this._app = s, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new cC({}), this._settingsFrozen = !1
    }
    get app() {
        if (!this._app) throw new re(U.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        return this._app
    }
    get _initialized() {
        return this._settingsFrozen
    }
    get _terminated() {
        return this._terminateTask !== void 0
    }
    _setSettings(t) {
        if (this._settingsFrozen) throw new re(U.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
        this._settings = new cC(t), t.credentials !== void 0 && (this._authCredentials = function(n) {
            if (!n) return new o8;
            switch (n.type) {
                case "firstParty":
                    return new u8(n.sessionIndex || "0", n.iamToken || null, n.authTokenFactory || null);
                case "provider":
                    return n.client;
                default:
                    throw new re(U.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type")
            }
        }(t.credentials))
    }
    _getSettings() {
        return this._settings
    }
    _freezeSettings() {
        return this._settingsFrozen = !0, this._settings
    }
    _delete() {
        return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask
    }
    toJSON() {
        return {
            app: this._app,
            databaseId: this._databaseId,
            settings: this._settings
        }
    }
    _terminate() {
        return function(t) {
            const n = oC.get(t);
            n && (me("ComponentProvider", "Removing Datastore"), oC.delete(t), n.terminate())
        }(this), Promise.resolve()
    }
}

function FK(e, t, n, r = {}) {
    var s;
    const i = (e = fs(e, Sv))._getSettings();
    if (i.host !== "firestore.googleapis.com" && i.host !== t && o_("Host has been set in both settings() and useEmulator(), emulator host will be used"), e._setSettings(Object.assign(Object.assign({}, i), {
            host: `${t}:${n}`,
            ssl: !1
        })), r.mockUserToken) {
        let o, a;
        if (typeof r.mockUserToken == "string") o = r.mockUserToken, a = Fn.MOCK_USER;
        else {
            o = lP(r.mockUserToken, (s = e._app) === null || s === void 0 ? void 0 : s.options.projectId);
            const l = r.mockUserToken.sub || r.mockUserToken.user_id;
            if (!l) throw new re(U.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
            a = new Fn(l)
        }
        e._authCredentials = new a8(new BL(o, a))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lr {
    constructor(t, n, r) {
        this.converter = n, this._key = r, this.type = "document", this.firestore = t
    }
    get _path() {
        return this._key.path
    }
    get id() {
        return this._key.path.lastSegment()
    }
    get path() {
        return this._key.path.canonicalString()
    }
    get parent() {
        return new Co(this.firestore, this.converter, this._key.path.popLast())
    }
    withConverter(t) {
        return new lr(this.firestore, t, this._key)
    }
}
class Li {
    constructor(t, n, r) {
        this.converter = n, this._query = r, this.type = "query", this.firestore = t
    }
    withConverter(t) {
        return new Li(this.firestore, t, this._query)
    }
}
class Co extends Li {
    constructor(t, n, r) {
        super(t, n, fv(r)), this._path = r, this.type = "collection"
    }
    get id() {
        return this._query.path.lastSegment()
    }
    get path() {
        return this._query.path.canonicalString()
    }
    get parent() {
        const t = this._path.popLast();
        return t.isEmpty() ? null : new lr(this.firestore, null, new ve(t))
    }
    withConverter(t) {
        return new Co(this.firestore, t, this._path)
    }
}

function il(e, t, ...n) {
    if (e = st(e), V2("collection", "path", t), e instanceof Sv) {
        const r = xt.fromString(t, ...n);
        return lC(r), new Co(e, null, r)
    } {
        if (!(e instanceof lr || e instanceof Co)) throw new re(U.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        const r = e._path.child(xt.fromString(t, ...n));
        return lC(r), new Co(e.firestore, null, r)
    }
}

function ed(e, t, ...n) {
    if (e = st(e), arguments.length === 1 && (t = VL.A()), V2("doc", "path", t), e instanceof Sv) {
        const r = xt.fromString(t, ...n);
        return aC(r), new lr(e, null, new ve(r))
    } {
        if (!(e instanceof lr || e instanceof Co)) throw new re(U.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        const r = e._path.child(xt.fromString(t, ...n));
        return aC(r), new lr(e.firestore, e instanceof Co ? e.converter : null, new ve(r))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UK {
    constructor() {
        this.Nc = Promise.resolve(), this.kc = [], this.Oc = !1, this.$c = [], this.Mc = null, this.Fc = !1, this.Bc = !1, this.Lc = [], this.Co = new $2(this, "async_queue_retry"), this.qc = () => {
            const n = a0();
            n && me("AsyncQueue", "Visibility state changed to " + n.visibilityState), this.Co.vo()
        };
        const t = a0();
        t && typeof t.addEventListener == "function" && t.addEventListener("visibilitychange", this.qc)
    }
    get isShuttingDown() {
        return this.Oc
    }
    enqueueAndForget(t) {
        this.enqueue(t)
    }
    enqueueAndForgetEvenWhileRestricted(t) {
        this.Uc(), this.Kc(t)
    }
    enterRestrictedMode(t) {
        if (!this.Oc) {
            this.Oc = !0, this.Bc = t || !1;
            const n = a0();
            n && typeof n.removeEventListener == "function" && n.removeEventListener("visibilitychange", this.qc)
        }
    }
    enqueue(t) {
        if (this.Uc(), this.Oc) return new Promise(() => {});
        const n = new ui;
        return this.Kc(() => this.Oc && this.Bc ? Promise.resolve() : (t().then(n.resolve, n.reject), n.promise)).then(() => n.promise)
    }
    enqueueRetryable(t) {
        this.enqueueAndForget(() => (this.kc.push(t), this.Gc()))
    }
    async Gc() {
        if (this.kc.length !== 0) {
            try {
                await this.kc[0](), this.kc.shift(), this.Co.reset()
            } catch (t) {
                if (!dp(t)) throw t;
                me("AsyncQueue", "Operation failed with retryable error: " + t)
            }
            this.kc.length > 0 && this.Co.Ao(() => this.Gc())
        }
    }
    Kc(t) {
        const n = this.Nc.then(() => (this.Fc = !0, t().catch(r => {
            this.Mc = r, this.Fc = !1;
            const s = function(i) {
                let o = i.message || "";
                return i.stack && (o = i.stack.includes(i.message) ? i.stack : i.message + `
` + i.stack), o
            }(r);
            throw wi("INTERNAL UNHANDLED ERROR: ", s), r
        }).then(r => (this.Fc = !1, r))));
        return this.Nc = n, n
    }
    enqueueAfterDelay(t, n, r) {
        this.Uc(), this.Lc.indexOf(t) > -1 && (n = 0);
        const s = $T.createAndSchedule(this, t, n, r, i => this.Qc(i));
        return this.$c.push(s), s
    }
    Uc() {
        this.Mc && $e()
    }
    verifyOperationInProgress() {}
    async zc() {
        let t;
        do t = this.Nc, await t; while (t !== this.Nc)
    }
    jc(t) {
        for (const n of this.$c)
            if (n.timerId === t) return !0;
        return !1
    }
    Wc(t) {
        return this.zc().then(() => {
            this.$c.sort((n, r) => n.targetTimeMs - r.targetTimeMs);
            for (const n of this.$c)
                if (n.skipDelay(), t !== "all" && n.timerId === t) break;
            return this.zc()
        })
    }
    Hc(t) {
        this.Lc.push(t)
    }
    Qc(t) {
        const n = this.$c.indexOf(t);
        this.$c.splice(n, 1)
    }
}

function uC(e) {
    return function(t, n) {
        if (typeof t != "object" || t === null) return !1;
        const r = t;
        for (const s of n)
            if (s in r && typeof r[s] == "function") return !0;
        return !1
    }(e, ["next", "error", "complete"])
}
class ol extends Sv {
    constructor(t, n, r, s) {
        super(t, n, r, s), this.type = "firestore", this._queue = new UK, this._persistenceKey = (s == null ? void 0 : s.name) || "[DEFAULT]"
    }
    _terminate() {
        return this._firestoreClient || H2(this), this._firestoreClient.terminate()
    }
}

function BK(e, t) {
    const n = typeof e == "object" ? e : Il(),
        r = typeof e == "string" ? e : t || "(default)",
        s = vs(n, "firestore").getImmediate({
            identifier: r
        });
    if (!s._initialized) {
        const i = uS("firestore");
        i && FK(s, ...i)
    }
    return s
}

function Tv(e) {
    return e._firestoreClient || H2(e), e._firestoreClient.verifyNotTerminated(), e._firestoreClient
}

function H2(e) {
    var t, n, r;
    const s = e._freezeSettings(),
        i = function(o, a, l, c) {
            return new S8(o, a, l, c.host, c.ssl, c.experimentalForceLongPolling, c.experimentalAutoDetectLongPolling, c.useFetchStreams)
        }(e._databaseId, ((t = e._app) === null || t === void 0 ? void 0 : t.options.appId) || "", e._persistenceKey, s);
    e._firestoreClient = new AK(e._authCredentials, e._appCheckCredentials, e._queue, i), ((n = s.cache) === null || n === void 0 ? void 0 : n._offlineComponentProvider) && ((r = s.cache) === null || r === void 0 ? void 0 : r._onlineComponentProvider) && (e._firestoreClient._uninitializedComponentsProvider = {
        _offlineKind: s.cache.kind,
        _offline: s.cache._offlineComponentProvider,
        _online: s.cache._onlineComponentProvider
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cu {
    constructor(t) {
        this._byteString = t
    }
    static fromBase64String(t) {
        try {
            return new cu(Xn.fromBase64String(t))
        } catch (n) {
            throw new re(U.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + n)
        }
    }
    static fromUint8Array(t) {
        return new cu(Xn.fromUint8Array(t))
    }
    toBase64() {
        return this._byteString.toBase64()
    }
    toUint8Array() {
        return this._byteString.toUint8Array()
    }
    toString() {
        return "Bytes(base64: " + this.toBase64() + ")"
    }
    isEqual(t) {
        return this._byteString.isEqual(t._byteString)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $v {
    constructor(...t) {
        for (let n = 0; n < t.length; ++n)
            if (t[n].length === 0) throw new re(U.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
        this._internalPath = new Hn(t)
    }
    isEqual(t) {
        return this._internalPath.isEqual(t._internalPath)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kv {
    constructor(t) {
        this._methodName = t
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DT {
    constructor(t, n) {
        if (!isFinite(t) || t < -90 || t > 90) throw new re(U.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t);
        if (!isFinite(n) || n < -180 || n > 180) throw new re(U.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + n);
        this._lat = t, this._long = n
    }
    get latitude() {
        return this._lat
    }
    get longitude() {
        return this._long
    }
    isEqual(t) {
        return this._lat === t._lat && this._long === t._long
    }
    toJSON() {
        return {
            latitude: this._lat,
            longitude: this._long
        }
    }
    _compareTo(t) {
        return ut(this._lat, t._lat) || ut(this._long, t._long)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VK = /^__.*__$/;
class HK {
    constructor(t, n, r) {
        this.data = t, this.fieldMask = n, this.fieldTransforms = r
    }
    toMutation(t, n) {
        return this.fieldMask !== null ? new la(t, this.data, this.fieldMask, n, this.fieldTransforms) : new fp(t, this.data, n, this.fieldTransforms)
    }
}
class j2 {
    constructor(t, n, r) {
        this.data = t, this.fieldMask = n, this.fieldTransforms = r
    }
    toMutation(t, n) {
        return new la(t, this.data, this.fieldMask, n, this.fieldTransforms)
    }
}

function z2(e) {
    switch (e) {
        case 0:
        case 2:
        case 1:
            return !0;
        case 3:
        case 4:
            return !1;
        default:
            throw $e()
    }
}
class NT {
    constructor(t, n, r, s, i, o) {
        this.settings = t, this.databaseId = n, this.serializer = r, this.ignoreUndefinedProperties = s, i === void 0 && this.Jc(), this.fieldTransforms = i || [], this.fieldMask = o || []
    }
    get path() {
        return this.settings.path
    }
    get Yc() {
        return this.settings.Yc
    }
    Zc(t) {
        return new NT(Object.assign(Object.assign({}, this.settings), t), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask)
    }
    Xc(t) {
        var n;
        const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(t),
            s = this.Zc({
                path: r,
                ta: !1
            });
        return s.ea(t), s
    }
    na(t) {
        var n;
        const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(t),
            s = this.Zc({
                path: r,
                ta: !1
            });
        return s.Jc(), s
    }
    sa(t) {
        return this.Zc({
            path: void 0,
            ta: !0
        })
    }
    ia(t) {
        return p_(t, this.settings.methodName, this.settings.ra || !1, this.path, this.settings.oa)
    }
    contains(t) {
        return this.fieldMask.find(n => t.isPrefixOf(n)) !== void 0 || this.fieldTransforms.find(n => t.isPrefixOf(n.field)) !== void 0
    }
    Jc() {
        if (this.path)
            for (let t = 0; t < this.path.length; t++) this.ea(this.path.get(t))
    }
    ea(t) {
        if (t.length === 0) throw this.ia("Document fields must not be empty");
        if (z2(this.Yc) && VK.test(t)) throw this.ia('Document fields cannot begin and end with "__"')
    }
}
class jK {
    constructor(t, n, r) {
        this.databaseId = t, this.ignoreUndefinedProperties = n, this.serializer = r || vv(t)
    }
    ua(t, n, r, s = !1) {
        return new NT({
            Yc: t,
            methodName: n,
            oa: r,
            path: Hn.emptyPath(),
            ta: !1,
            ra: s
        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties)
    }
}

function PT(e) {
    const t = e._freezeSettings(),
        n = vv(e._databaseId);
    return new jK(e._databaseId, !!t.ignoreUndefinedProperties, n)
}

function zK(e, t, n, r, s, i = {}) {
    const o = e.ua(i.merge || i.mergeFields ? 2 : 0, t, n, s);
    LT("Data must be an object, but it was:", o, r);
    const a = W2(r, o);
    let l, c;
    if (i.merge) l = new Dr(o.fieldMask), c = o.fieldTransforms;
    else if (i.mergeFields) {
        const u = [];
        for (const d of i.mergeFields) {
            const f = lE(t, d, n);
            if (!o.contains(f)) throw new re(U.INVALID_ARGUMENT, `Field '${f}' is specified in your field mask but missing from your input data.`);
            q2(u, f) || u.push(f)
        }
        l = new Dr(u), c = o.fieldTransforms.filter(d => l.covers(d.field))
    } else l = null, c = o.fieldTransforms;
    return new HK(new vr(a), l, c)
}
class Iv extends kv {
    _toFieldTransform(t) {
        if (t.Yc !== 2) throw t.Yc === 1 ? t.ia(`${this._methodName}() can only appear at the top level of your update data`) : t.ia(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
        return t.fieldMask.push(t.path), null
    }
    isEqual(t) {
        return t instanceof Iv
    }
}
class MT extends kv {
    _toFieldTransform(t) {
        return new W8(t.path, new rh)
    }
    isEqual(t) {
        return t instanceof MT
    }
}

function WK(e, t, n, r) {
    const s = e.ua(1, t, n);
    LT("Data must be an object, but it was:", s, r);
    const i = [],
        o = vr.empty();
    Al(r, (l, c) => {
        const u = FT(t, l, n);
        c = st(c);
        const d = s.na(u);
        if (c instanceof Iv) i.push(u);
        else {
            const f = gp(c, d);
            f != null && (i.push(u), o.set(u, f))
        }
    });
    const a = new Dr(i);
    return new j2(o, a, s.fieldTransforms)
}

function GK(e, t, n, r, s, i) {
    const o = e.ua(1, t, n),
        a = [lE(t, r, n)],
        l = [s];
    if (i.length % 2 != 0) throw new re(U.INVALID_ARGUMENT, `Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`);
    for (let f = 0; f < i.length; f += 2) a.push(lE(t, i[f])), l.push(i[f + 1]);
    const c = [],
        u = vr.empty();
    for (let f = a.length - 1; f >= 0; --f)
        if (!q2(c, a[f])) {
            const h = a[f];
            let p = l[f];
            p = st(p);
            const m = o.na(h);
            if (p instanceof Iv) c.push(h);
            else {
                const g = gp(p, m);
                g != null && (c.push(h), u.set(h, g))
            }
        }
    const d = new Dr(c);
    return new j2(u, d, o.fieldTransforms)
}

function qK(e, t, n, r = !1) {
    return gp(n, e.ua(r ? 4 : 3, t))
}

function gp(e, t) {
    if (G2(e = st(e))) return LT("Unsupported field value:", t, e), W2(e, t);
    if (e instanceof kv) return function(n, r) {
        if (!z2(r.Yc)) throw r.ia(`${n._methodName}() can only be used with update() and set()`);
        if (!r.path) throw r.ia(`${n._methodName}() is not currently supported inside arrays`);
        const s = n._toFieldTransform(r);
        s && r.fieldTransforms.push(s)
    }(e, t), null;
    if (e === void 0 && t.ignoreUndefinedProperties) return null;
    if (t.path && t.fieldMask.push(t.path), e instanceof Array) {
        if (t.settings.ta && t.Yc !== 4) throw t.ia("Nested arrays are not supported");
        return function(n, r) {
            const s = [];
            let i = 0;
            for (const o of n) {
                let a = gp(o, r.sa(i));
                a == null && (a = {
                    nullValue: "NULL_VALUE"
                }), s.push(a), i++
            }
            return {
                arrayValue: {
                    values: s
                }
            }
        }(e, t)
    }
    return function(n, r) {
        if ((n = st(n)) === null) return {
            nullValue: "NULL_VALUE"
        };
        if (typeof n == "number") return H8(r.serializer, n);
        if (typeof n == "boolean") return {
            booleanValue: n
        };
        if (typeof n == "string") return {
            stringValue: n
        };
        if (n instanceof Date) {
            const s = un.fromDate(n);
            return {
                timestampValue: d_(r.serializer, s)
            }
        }
        if (n instanceof un) {
            const s = new un(n.seconds, 1e3 * Math.floor(n.nanoseconds / 1e3));
            return {
                timestampValue: d_(r.serializer, s)
            }
        }
        if (n instanceof DT) return {
            geoPointValue: {
                latitude: n.latitude,
                longitude: n.longitude
            }
        };
        if (n instanceof cu) return {
            bytesValue: _2(r.serializer, n._byteString)
        };
        if (n instanceof lr) {
            const s = r.databaseId,
                i = n.firestore._databaseId;
            if (!i.isEqual(s)) throw r.ia(`Document reference is for database ${i.projectId}/${i.database} but should be for database ${s.projectId}/${s.database}`);
            return {
                referenceValue: yT(n.firestore._databaseId || r.databaseId, n._key.path)
            }
        }
        throw r.ia(`Unsupported field value: ${Ev(n)}`)
    }(e, t)
}

function W2(e, t) {
    const n = {};
    return HL(e) ? t.path && t.path.length > 0 && t.fieldMask.push(t.path) : Al(e, (r, s) => {
        const i = gp(s, t.Xc(r));
        i != null && (n[r] = i)
    }), {
        mapValue: {
            fields: n
        }
    }
}

function G2(e) {
    return !(typeof e != "object" || e === null || e instanceof Array || e instanceof Date || e instanceof un || e instanceof DT || e instanceof cu || e instanceof lr || e instanceof kv)
}

function LT(e, t, n) {
    if (!G2(n) || ! function(r) {
            return typeof r == "object" && r !== null && (Object.getPrototypeOf(r) === Object.prototype || Object.getPrototypeOf(r) === null)
        }(n)) {
        const r = Ev(n);
        throw r === "an object" ? t.ia(e + " a custom object") : t.ia(e + " " + r)
    }
}

function lE(e, t, n) {
    if ((t = st(t)) instanceof $v) return t._internalPath;
    if (typeof t == "string") return FT(e, t);
    throw p_("Field path arguments must be of type string or ", e, !1, void 0, n)
}
const YK = new RegExp("[~\\*/\\[\\]]");

function FT(e, t, n) {
    if (t.search(YK) >= 0) throw p_(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, n);
    try {
        return new $v(...t.split("."))._internalPath
    } catch {
        throw p_(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, n)
    }
}

function p_(e, t, n, r, s) {
    const i = r && !r.isEmpty(),
        o = s !== void 0;
    let a = `Function ${t}() called with invalid data`;
    n && (a += " (via `toFirestore()`)"), a += ". ";
    let l = "";
    return (i || o) && (l += " (found", i && (l += ` in field ${r}`), o && (l += ` in document ${s}`), l += ")"), new re(U.INVALID_ARGUMENT, a + e + l)
}

function q2(e, t) {
    return e.some(n => n.isEqual(t))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Y2 {
    constructor(t, n, r, s, i) {
        this._firestore = t, this._userDataWriter = n, this._key = r, this._document = s, this._converter = i
    }
    get id() {
        return this._key.path.lastSegment()
    }
    get ref() {
        return new lr(this._firestore, this._converter, this._key)
    }
    exists() {
        return this._document !== null
    }
    data() {
        if (this._document) {
            if (this._converter) {
                const t = new KK(this._firestore, this._userDataWriter, this._key, this._document, null);
                return this._converter.fromFirestore(t)
            }
            return this._userDataWriter.convertValue(this._document.data.value)
        }
    }
    get(t) {
        if (this._document) {
            const n = this._document.data.field(xv("DocumentSnapshot.get", t));
            if (n !== null) return this._userDataWriter.convertValue(n)
        }
    }
}
class KK extends Y2 {
    data() {
        return super.data()
    }
}

function xv(e, t) {
    return typeof t == "string" ? FT(e, t) : t instanceof $v ? t._internalPath : t._delegate._internalPath
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function K2(e) {
    if (e.limitType === "L" && e.explicitOrderBy.length === 0) throw new re(U.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause")
}
class UT {}
class BT extends UT {}

function oh(e, t, ...n) {
    let r = [];
    t instanceof UT && r.push(t), r = r.concat(n),
        function(s) {
            const i = s.filter(a => a instanceof VT).length,
                o = s.filter(a => a instanceof Cv).length;
            if (i > 1 || i > 0 && o > 0) throw new re(U.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.")
        }(r);
    for (const s of r) e = s._apply(e);
    return e
}
class Cv extends BT {
    constructor(t, n, r) {
        super(), this._field = t, this._op = n, this._value = r, this.type = "where"
    }
    static _create(t, n, r) {
        return new Cv(t, n, r)
    }
    _apply(t) {
        const n = this._parse(t);
        return X2(t._query, n), new Li(t.firestore, t.converter, tE(t._query, n))
    }
    _parse(t) {
        const n = PT(t.firestore);
        return function(s, i, o, a, l, c, u) {
            let d;
            if (l.isKeyField()) {
                if (c === "array-contains" || c === "array-contains-any") throw new re(U.INVALID_ARGUMENT, `Invalid Query. You can't perform '${c}' queries on documentId().`);
                if (c === "in" || c === "not-in") {
                    fC(u, c);
                    const f = [];
                    for (const h of u) f.push(dC(a, s, h));
                    d = {
                        arrayValue: {
                            values: f
                        }
                    }
                } else d = dC(a, s, u)
            } else c !== "in" && c !== "not-in" && c !== "array-contains-any" || fC(u, c), d = qK(o, i, u, c === "in" || c === "not-in");
            return Jt.create(l, c, d)
        }(t._query, "where", n, t.firestore._databaseId, this._field, this._op, this._value)
    }
}

function ef(e, t, n) {
    const r = t,
        s = xv("where", e);
    return Cv._create(s, r, n)
}
class VT extends UT {
    constructor(t, n) {
        super(), this.type = t, this._queryConstraints = n
    }
    static _create(t, n) {
        return new VT(t, n)
    }
    _parse(t) {
        const n = this._queryConstraints.map(r => r._parse(t)).filter(r => r.getFilters().length > 0);
        return n.length === 1 ? n[0] : gs.create(n, this._getOperator())
    }
    _apply(t) {
        const n = this._parse(t);
        return n.getFilters().length === 0 ? t : (function(r, s) {
            let i = r;
            const o = s.getFlattenedFilters();
            for (const a of o) X2(i, a), i = tE(i, a)
        }(t._query, n), new Li(t.firestore, t.converter, tE(t._query, n)))
    }
    _getQueryConstraints() {
        return this._queryConstraints
    }
    _getOperator() {
        return this.type === "and" ? "and" : "or"
    }
}
class HT extends BT {
    constructor(t, n) {
        super(), this._field = t, this._direction = n, this.type = "orderBy"
    }
    static _create(t, n) {
        return new HT(t, n)
    }
    _apply(t) {
        const n = function(r, s, i) {
            if (r.startAt !== null) throw new re(U.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
            if (r.endAt !== null) throw new re(U.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
            const o = new kc(s, i);
            return function(a, l) {
                if (mT(a) === null) {
                    const c = hv(a);
                    c !== null && Q2(a, c, l.field)
                }
            }(r, o), o
        }(t._query, this._field, this._direction);
        return new Li(t.firestore, t.converter, function(r, s) {
            const i = r.explicitOrderBy.concat([s]);
            return new Qu(r.path, r.collectionGroup, i, r.filters.slice(), r.limit, r.limitType, r.startAt, r.endAt)
        }(t._query, n))
    }
}

function XK(e, t = "asc") {
    const n = t,
        r = xv("orderBy", e);
    return HT._create(r, n)
}
class jT extends BT {
    constructor(t, n, r) {
        super(), this.type = t, this._limit = n, this._limitType = r
    }
    static _create(t, n, r) {
        return new jT(t, n, r)
    }
    _apply(t) {
        return new Li(t.firestore, t.converter, c_(t._query, this._limit, this._limitType))
    }
}

function QK(e) {
    return LK("limit", e), jT._create("limit", e, "F")
}

function dC(e, t, n) {
    if (typeof(n = st(n)) == "string") {
        if (n === "") throw new re(U.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
        if (!JL(t) && n.indexOf("/") !== -1) throw new re(U.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
        const r = t.path.child(xt.fromString(n));
        if (!ve.isDocumentKey(r)) throw new re(U.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);
        return Mx(e, new ve(r))
    }
    if (n instanceof lr) return Mx(e, n._key);
    throw new re(U.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Ev(n)}.`)
}

function fC(e, t) {
    if (!Array.isArray(e) || e.length === 0) throw new re(U.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${t.toString()}' filters.`)
}

function X2(e, t) {
    if (t.isInequality()) {
        const r = hv(e),
            s = t.field;
        if (r !== null && !r.isEqual(s)) throw new re(U.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${r.toString()}' and '${s.toString()}'`);
        const i = mT(e);
        i !== null && Q2(e, s, i)
    }
    const n = function(r, s) {
        for (const i of r)
            for (const o of i.getFlattenedFilters())
                if (s.indexOf(o.op) >= 0) return o.op;
        return null
    }(e.filters, function(r) {
        switch (r) {
            case "!=":
                return ["!=", "not-in"];
            case "array-contains-any":
            case "in":
                return ["not-in"];
            case "not-in":
                return ["array-contains-any", "in", "not-in", "!="];
            default:
                return []
        }
    }(t.op));
    if (n !== null) throw n === t.op ? new re(U.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${t.op.toString()}' filter.`) : new re(U.INVALID_ARGUMENT, `Invalid query. You cannot use '${t.op.toString()}' filters with '${n.toString()}' filters.`)
}

function Q2(e, t, n) {
    if (!n.isEqual(t)) throw new re(U.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${t.toString()}' and so you must also use '${t.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`)
}
class JK {
    convertValue(t, n = "none") {
        switch (sl(t)) {
            case 0:
                return null;
            case 1:
                return t.booleanValue;
            case 2:
                return Qt(t.integerValue || t.doubleValue);
            case 3:
                return this.convertTimestamp(t.timestampValue);
            case 4:
                return this.convertServerTimestamp(t, n);
            case 5:
                return t.stringValue;
            case 6:
                return this.convertBytes(su(t.bytesValue));
            case 7:
                return this.convertReference(t.referenceValue);
            case 8:
                return this.convertGeoPoint(t.geoPointValue);
            case 9:
                return this.convertArray(t.arrayValue, n);
            case 10:
                return this.convertObject(t.mapValue, n);
            default:
                throw $e()
        }
    }
    convertObject(t, n) {
        const r = {};
        return Al(t.fields, (s, i) => {
            r[s] = this.convertValue(i, n)
        }), r
    }
    convertGeoPoint(t) {
        return new DT(Qt(t.latitude), Qt(t.longitude))
    }
    convertArray(t, n) {
        return (t.values || []).map(r => this.convertValue(r, n))
    }
    convertServerTimestamp(t, n) {
        switch (n) {
            case "previous":
                const r = zL(t);
                return r == null ? null : this.convertValue(r, n);
            case "estimate":
                return this.convertTimestamp(eh(t));
            default:
                return null
        }
    }
    convertTimestamp(t) {
        const n = Vo(t);
        return new un(n.seconds, n.nanos)
    }
    convertDocumentKey(t, n) {
        const r = xt.fromString(t);
        Ct(E2(r));
        const s = new th(r.get(1), r.get(3)),
            i = new ve(r.popFirst(5));
        return s.isEqual(n) || wi(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${n.projectId}/${n.database}) instead.`), i
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ZK(e, t, n) {
    let r;
    return r = e ? n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t) : t, r
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Nd {
    constructor(t, n) {
        this.hasPendingWrites = t, this.fromCache = n
    }
    isEqual(t) {
        return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache
    }
}
class J2 extends Y2 {
    constructor(t, n, r, s, i, o) {
        super(t, n, r, s, o), this._firestore = t, this._firestoreImpl = t, this.metadata = i
    }
    exists() {
        return super.exists()
    }
    data(t = {}) {
        if (this._document) {
            if (this._converter) {
                const n = new sg(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
                return this._converter.fromFirestore(n, t)
            }
            return this._userDataWriter.convertValue(this._document.data.value, t.serverTimestamps)
        }
    }
    get(t, n = {}) {
        if (this._document) {
            const r = this._document.data.field(xv("DocumentSnapshot.get", t));
            if (r !== null) return this._userDataWriter.convertValue(r, n.serverTimestamps)
        }
    }
}
class sg extends J2 {
    data(t = {}) {
        return super.data(t)
    }
}
class Z2 {
    constructor(t, n, r, s) {
        this._firestore = t, this._userDataWriter = n, this._snapshot = s, this.metadata = new Nd(s.hasPendingWrites, s.fromCache), this.query = r
    }
    get docs() {
        const t = [];
        return this.forEach(n => t.push(n)), t
    }
    get size() {
        return this._snapshot.docs.size
    }
    get empty() {
        return this.size === 0
    }
    forEach(t, n) {
        this._snapshot.docs.forEach(r => {
            t.call(n, new sg(this._firestore, this._userDataWriter, r.key, r, new Nd(this._snapshot.mutatedKeys.has(r.key), this._snapshot.fromCache), this.query.converter))
        })
    }
    docChanges(t = {}) {
        const n = !!t.includeMetadataChanges;
        if (n && this._snapshot.excludesMetadataChanges) throw new re(U.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
        return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === n || (this._cachedChanges = function(r, s) {
            if (r._snapshot.oldDocs.isEmpty()) {
                let i = 0;
                return r._snapshot.docChanges.map(o => {
                    const a = new sg(r._firestore, r._userDataWriter, o.doc.key, o.doc, new Nd(r._snapshot.mutatedKeys.has(o.doc.key), r._snapshot.fromCache), r.query.converter);
                    return o.doc, {
                        type: "added",
                        doc: a,
                        oldIndex: -1,
                        newIndex: i++
                    }
                })
            } {
                let i = r._snapshot.oldDocs;
                return r._snapshot.docChanges.filter(o => s || o.type !== 3).map(o => {
                    const a = new sg(r._firestore, r._userDataWriter, o.doc.key, o.doc, new Nd(r._snapshot.mutatedKeys.has(o.doc.key), r._snapshot.fromCache), r.query.converter);
                    let l = -1,
                        c = -1;
                    return o.type !== 0 && (l = i.indexOf(o.doc.key), i = i.delete(o.doc.key)), o.type !== 1 && (i = i.add(o.doc), c = i.indexOf(o.doc.key)), {
                        type: e9(o.type),
                        doc: a,
                        oldIndex: l,
                        newIndex: c
                    }
                })
            }
        }(this, n), this._cachedChangesIncludeMetadataChanges = n), this._cachedChanges
    }
}

function e9(e) {
    switch (e) {
        case 0:
            return "added";
        case 2:
        case 3:
            return "modified";
        case 1:
            return "removed";
        default:
            return $e()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zT(e) {
    e = fs(e, lr);
    const t = fs(e.firestore, ol);
    return NK(Tv(t), e._key).then(n => rF(t, e, n))
}
class WT extends JK {
    constructor(t) {
        super(), this.firestore = t
    }
    convertBytes(t) {
        return new cu(t)
    }
    convertReference(t) {
        const n = this.convertDocumentKey(t, this.firestore._databaseId);
        return new lr(this.firestore, null, n)
    }
}

function ah(e) {
    e = fs(e, Li);
    const t = fs(e.firestore, ol),
        n = Tv(t),
        r = new WT(t);
    return K2(e._query), PK(n, e._query).then(s => new Z2(t, r, e, s))
}

function t9(e, t, n, ...r) {
    e = fs(e, lr);
    const s = fs(e.firestore, ol),
        i = PT(s);
    let o;
    return o = typeof(t = st(t)) == "string" || t instanceof $v ? GK(i, "updateDoc", e._key, t, n, r) : WK(i, "updateDoc", e._key, t), nF(s, [o.toMutation(e._key, Cs.exists(!0))])
}

function eF(e, t) {
    const n = fs(e.firestore, ol),
        r = ed(e),
        s = ZK(e.converter, t);
    return nF(n, [zK(PT(e.firestore), "addDoc", r._key, s, e.converter !== null, {}).toMutation(r._key, Cs.exists(!1))]).then(() => r)
}

function tF(e, ...t) {
    var n, r, s;
    e = st(e);
    let i = {
            includeMetadataChanges: !1
        },
        o = 0;
    typeof t[o] != "object" || uC(t[o]) || (i = t[o], o++);
    const a = {
        includeMetadataChanges: i.includeMetadataChanges
    };
    if (uC(t[o])) {
        const d = t[o];
        t[o] = (n = d.next) === null || n === void 0 ? void 0 : n.bind(d), t[o + 1] = (r = d.error) === null || r === void 0 ? void 0 : r.bind(d), t[o + 2] = (s = d.complete) === null || s === void 0 ? void 0 : s.bind(d)
    }
    let l, c, u;
    if (e instanceof lr) c = fs(e.firestore, ol), u = fv(e._key.path), l = {
        next: d => {
            t[o] && t[o](rF(c, e, d))
        },
        error: t[o + 1],
        complete: t[o + 2]
    };
    else {
        const d = fs(e, Li);
        c = fs(d.firestore, ol), u = d._query;
        const f = new WT(c);
        l = {
            next: h => {
                t[o] && t[o](new Z2(c, f, d, h))
            },
            error: t[o + 1],
            complete: t[o + 2]
        }, K2(e._query)
    }
    return function(d, f, h, p) {
        const m = new OT(p),
            g = new AT(f, m, h);
        return d.asyncQueue.enqueueAndForget(async () => IT(await h_(d), g)), () => {
            m.yc(), d.asyncQueue.enqueueAndForget(async () => xT(await h_(d), g))
        }
    }(Tv(c), u, a, l)
}

function nF(e, t) {
    return function(n, r) {
        const s = new ui;
        return n.asyncQueue.enqueueAndForget(async () => bK(await DK(n), r, s)), s.promise
    }(Tv(e), t)
}

function rF(e, t, n) {
    const r = n.docs.get(t._key),
        s = new WT(e);
    return new J2(e, s, t._key, r, new Nd(n.hasPendingWrites, n.fromCache), t.converter)
}

function n9() {
    return new MT("serverTimestamp")
}(function(e, t = !0) {
    (function(n) {
        Xu = n
    })(ia), dr(new Kn("firestore", (n, {
        instanceIdentifier: r,
        options: s
    }) => {
        const i = n.getProvider("app").getImmediate(),
            o = new ol(new l8(n.getProvider("auth-internal")), new f8(n.getProvider("app-check-internal")), function(a, l) {
                if (!Object.prototype.hasOwnProperty.apply(a.options, ["projectId"])) throw new re(U.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
                return new th(a.options.projectId, l)
            }(i, r), i);
        return s = Object.assign({
            useFetchStreams: t
        }, s), o._setSettings(s), o
    }, "PUBLIC").setMultipleInstances(!0)), cn(Rx, "3.10.1", e), cn(Rx, "3.10.1", "esm2017")
})();
const sF = "@firebase/installations",
    GT = "0.6.4";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const iF = 1e4,
    oF = `w:${GT}`,
    aF = "FIS_v2",
    r9 = "https://firebaseinstallations.googleapis.com/v1",
    s9 = 60 * 60 * 1e3,
    i9 = "installations",
    o9 = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const a9 = {
        ["missing-app-config-values"]: 'Missing App configuration value: "{$valueName}"',
        ["not-registered"]: "Firebase Installation is not registered.",
        ["installation-not-found"]: "Firebase Installation not found.",
        ["request-failed"]: '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
        ["app-offline"]: "Could not process request. Application offline.",
        ["delete-pending-registration"]: "Can't delete installation while there is a pending registration request."
    },
    al = new sa(i9, o9, a9);

function lF(e) {
    return e instanceof zr && e.code.includes("request-failed")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function cF({
    projectId: e
}) {
    return `${r9}/projects/${e}/installations`
}

function uF(e) {
    return {
        token: e.token,
        requestStatus: 2,
        expiresIn: c9(e.expiresIn),
        creationTime: Date.now()
    }
}
async function dF(e, t) {
    const r = (await t.json()).error;
    return al.create("request-failed", {
        requestName: e,
        serverCode: r.code,
        serverMessage: r.message,
        serverStatus: r.status
    })
}

function fF({
    apiKey: e
}) {
    return new Headers({
        "Content-Type": "application/json",
        Accept: "application/json",
        "x-goog-api-key": e
    })
}

function l9(e, {
    refreshToken: t
}) {
    const n = fF(e);
    return n.append("Authorization", u9(t)), n
}
async function hF(e) {
    const t = await e();
    return t.status >= 500 && t.status < 600 ? e() : t
}

function c9(e) {
    return Number(e.replace("s", "000"))
}

function u9(e) {
    return `${aF} ${e}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function d9({
    appConfig: e,
    heartbeatServiceProvider: t
}, {
    fid: n
}) {
    const r = cF(e),
        s = fF(e),
        i = t.getImmediate({
            optional: !0
        });
    if (i) {
        const c = await i.getHeartbeatsHeader();
        c && s.append("x-firebase-client", c)
    }
    const o = {
            fid: n,
            authVersion: aF,
            appId: e.appId,
            sdkVersion: oF
        },
        a = {
            method: "POST",
            headers: s,
            body: JSON.stringify(o)
        },
        l = await hF(() => fetch(r, a));
    if (l.ok) {
        const c = await l.json();
        return {
            fid: c.fid || n,
            registrationStatus: 2,
            refreshToken: c.refreshToken,
            authToken: uF(c.authToken)
        }
    } else throw await dF("Create Installation", l)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function pF(e) {
    return new Promise(t => {
        setTimeout(t, e)
    })
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function f9(e) {
    return btoa(String.fromCharCode(...e)).replace(/\+/g, "-").replace(/\//g, "_")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const h9 = /^[cdef][\w-]{21}$/,
    cE = "";

function p9() {
    try {
        const e = new Uint8Array(17);
        (self.crypto || self.msCrypto).getRandomValues(e), e[0] = 112 + e[0] % 16;
        const n = m9(e);
        return h9.test(n) ? n : cE
    } catch {
        return cE
    }
}

function m9(e) {
    return f9(e).substr(0, 22)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Av(e) {
    return `${e.appName}!${e.appId}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mF = new Map;

function gF(e, t) {
    const n = Av(e);
    _F(n, t), g9(n, t)
}

function _F(e, t) {
    const n = mF.get(e);
    if (!!n)
        for (const r of n) r(t)
}

function g9(e, t) {
    const n = _9();
    n && n.postMessage({
        key: e,
        fid: t
    }), y9()
}
let Na = null;

function _9() {
    return !Na && "BroadcastChannel" in self && (Na = new BroadcastChannel("[Firebase] FID Change"), Na.onmessage = e => {
        _F(e.data.key, e.data.fid)
    }), Na
}

function y9() {
    mF.size === 0 && Na && (Na.close(), Na = null)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const v9 = "firebase-installations-database",
    b9 = 1,
    ll = "firebase-installations-store";
let c0 = null;

function qT() {
    return c0 || (c0 = gP(v9, b9, {
        upgrade: (e, t) => {
            switch (t) {
                case 0:
                    e.createObjectStore(ll)
            }
        }
    })), c0
}
async function m_(e, t) {
    const n = Av(e),
        s = (await qT()).transaction(ll, "readwrite"),
        i = s.objectStore(ll),
        o = await i.get(n);
    return await i.put(t, n), await s.done, (!o || o.fid !== t.fid) && gF(e, t.fid), t
}
async function yF(e) {
    const t = Av(e),
        r = (await qT()).transaction(ll, "readwrite");
    await r.objectStore(ll).delete(t), await r.done
}
async function Rv(e, t) {
    const n = Av(e),
        s = (await qT()).transaction(ll, "readwrite"),
        i = s.objectStore(ll),
        o = await i.get(n),
        a = t(o);
    return a === void 0 ? await i.delete(n) : await i.put(a, n), await s.done, a && (!o || o.fid !== a.fid) && gF(e, a.fid), a
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function YT(e) {
    let t;
    const n = await Rv(e.appConfig, r => {
        const s = w9(r),
            i = E9(e, s);
        return t = i.registrationPromise, i.installationEntry
    });
    return n.fid === cE ? {
        installationEntry: await t
    } : {
        installationEntry: n,
        registrationPromise: t
    }
}

function w9(e) {
    const t = e || {
        fid: p9(),
        registrationStatus: 0
    };
    return vF(t)
}

function E9(e, t) {
    if (t.registrationStatus === 0) {
        if (!navigator.onLine) {
            const s = Promise.reject(al.create("app-offline"));
            return {
                installationEntry: t,
                registrationPromise: s
            }
        }
        const n = {
                fid: t.fid,
                registrationStatus: 1,
                registrationTime: Date.now()
            },
            r = S9(e, n);
        return {
            installationEntry: n,
            registrationPromise: r
        }
    } else return t.registrationStatus === 1 ? {
        installationEntry: t,
        registrationPromise: T9(e)
    } : {
        installationEntry: t
    }
}
async function S9(e, t) {
    try {
        const n = await d9(e, t);
        return m_(e.appConfig, n)
    } catch (n) {
        throw lF(n) && n.customData.serverCode === 409 ? await yF(e.appConfig) : await m_(e.appConfig, {
            fid: t.fid,
            registrationStatus: 0
        }), n
    }
}
async function T9(e) {
    let t = await hC(e.appConfig);
    for (; t.registrationStatus === 1;) await pF(100), t = await hC(e.appConfig);
    if (t.registrationStatus === 0) {
        const {
            installationEntry: n,
            registrationPromise: r
        } = await YT(e);
        return r || n
    }
    return t
}

function hC(e) {
    return Rv(e, t => {
        if (!t) throw al.create("installation-not-found");
        return vF(t)
    })
}

function vF(e) {
    return $9(e) ? {
        fid: e.fid,
        registrationStatus: 0
    } : e
}

function $9(e) {
    return e.registrationStatus === 1 && e.registrationTime + iF < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function k9({
    appConfig: e,
    heartbeatServiceProvider: t
}, n) {
    const r = I9(e, n),
        s = l9(e, n),
        i = t.getImmediate({
            optional: !0
        });
    if (i) {
        const c = await i.getHeartbeatsHeader();
        c && s.append("x-firebase-client", c)
    }
    const o = {
            installation: {
                sdkVersion: oF,
                appId: e.appId
            }
        },
        a = {
            method: "POST",
            headers: s,
            body: JSON.stringify(o)
        },
        l = await hF(() => fetch(r, a));
    if (l.ok) {
        const c = await l.json();
        return uF(c)
    } else throw await dF("Generate Auth Token", l)
}

function I9(e, {
    fid: t
}) {
    return `${cF(e)}/${t}/authTokens:generate`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function KT(e, t = !1) {
    let n;
    const r = await Rv(e.appConfig, i => {
        if (!bF(i)) throw al.create("not-registered");
        const o = i.authToken;
        if (!t && A9(o)) return i;
        if (o.requestStatus === 1) return n = x9(e, t), i; {
            if (!navigator.onLine) throw al.create("app-offline");
            const a = O9(i);
            return n = C9(e, a), a
        }
    });
    return n ? await n : r.authToken
}
async function x9(e, t) {
    let n = await pC(e.appConfig);
    for (; n.authToken.requestStatus === 1;) await pF(100), n = await pC(e.appConfig);
    const r = n.authToken;
    return r.requestStatus === 0 ? KT(e, t) : r
}

function pC(e) {
    return Rv(e, t => {
        if (!bF(t)) throw al.create("not-registered");
        const n = t.authToken;
        return D9(n) ? Object.assign(Object.assign({}, t), {
            authToken: {
                requestStatus: 0
            }
        }) : t
    })
}
async function C9(e, t) {
    try {
        const n = await k9(e, t),
            r = Object.assign(Object.assign({}, t), {
                authToken: n
            });
        return await m_(e.appConfig, r), n
    } catch (n) {
        if (lF(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404)) await yF(e.appConfig);
        else {
            const r = Object.assign(Object.assign({}, t), {
                authToken: {
                    requestStatus: 0
                }
            });
            await m_(e.appConfig, r)
        }
        throw n
    }
}

function bF(e) {
    return e !== void 0 && e.registrationStatus === 2
}

function A9(e) {
    return e.requestStatus === 2 && !R9(e)
}

function R9(e) {
    const t = Date.now();
    return t < e.creationTime || e.creationTime + e.expiresIn < t + s9
}

function O9(e) {
    const t = {
        requestStatus: 1,
        requestTime: Date.now()
    };
    return Object.assign(Object.assign({}, e), {
        authToken: t
    })
}

function D9(e) {
    return e.requestStatus === 1 && e.requestTime + iF < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function N9(e) {
    const t = e,
        {
            installationEntry: n,
            registrationPromise: r
        } = await YT(t);
    return r ? r.catch(console.error) : KT(t).catch(console.error), n.fid
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function P9(e, t = !1) {
    const n = e;
    return await M9(n), (await KT(n, t)).token
}
async function M9(e) {
    const {
        registrationPromise: t
    } = await YT(e);
    t && await t
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function L9(e) {
    if (!e || !e.options) throw u0("App Configuration");
    if (!e.name) throw u0("App Name");
    const t = ["projectId", "apiKey", "appId"];
    for (const n of t)
        if (!e.options[n]) throw u0(n);
    return {
        appName: e.name,
        projectId: e.options.projectId,
        apiKey: e.options.apiKey,
        appId: e.options.appId
    }
}

function u0(e) {
    return al.create("missing-app-config-values", {
        valueName: e
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wF = "installations",
    F9 = "installations-internal",
    U9 = e => {
        const t = e.getProvider("app").getImmediate(),
            n = L9(t),
            r = vs(t, "heartbeat");
        return {
            app: t,
            appConfig: n,
            heartbeatServiceProvider: r,
            _delete: () => Promise.resolve()
        }
    },
    B9 = e => {
        const t = e.getProvider("app").getImmediate(),
            n = vs(t, wF).getImmediate();
        return {
            getId: () => N9(n),
            getToken: s => P9(n, s)
        }
    };

function V9() {
    dr(new Kn(wF, U9, "PUBLIC")), dr(new Kn(F9, B9, "PRIVATE"))
}
V9();
cn(sF, GT);
cn(sF, GT, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const g_ = "analytics",
    H9 = "firebase_id",
    j9 = "origin",
    z9 = 60 * 1e3,
    W9 = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig",
    XT = "https://www.googletagmanager.com/gtag/js";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cr = new zu("@firebase/analytics");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const G9 = {
        ["already-exists"]: "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
        ["already-initialized"]: "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.",
        ["already-initialized-settings"]: "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
        ["interop-component-reg-failed"]: "Firebase Analytics Interop Component failed to instantiate: {$reason}",
        ["invalid-analytics-context"]: "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
        ["indexeddb-unavailable"]: "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
        ["fetch-throttle"]: "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
        ["config-fetch-failed"]: "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
        ["no-api-key"]: 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
        ["no-app-id"]: 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',
        ["invalid-gtag-resource"]: "Trusted Types detected an invalid gtag resource: {$gtagURL}."
    },
    Lr = new sa("analytics", "Analytics", G9);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function q9(e) {
    if (!e.startsWith(XT)) {
        const t = Lr.create("invalid-gtag-resource", {
            gtagURL: e
        });
        return cr.warn(t.message), ""
    }
    return e
}

function EF(e) {
    return Promise.all(e.map(t => t.catch(n => n)))
}

function Y9(e, t) {
    let n;
    return window.trustedTypes && (n = window.trustedTypes.createPolicy(e, t)), n
}

function K9(e, t) {
    const n = Y9("firebase-js-sdk-policy", {
            createScriptURL: q9
        }),
        r = document.createElement("script"),
        s = `${XT}?l=${e}&id=${t}`;
    r.src = n ? n == null ? void 0 : n.createScriptURL(s) : s, r.async = !0, document.head.appendChild(r)
}

function X9(e) {
    let t = [];
    return Array.isArray(window[e]) ? t = window[e] : window[e] = t, t
}
async function Q9(e, t, n, r, s, i) {
    const o = r[s];
    try {
        if (o) await t[o];
        else {
            const l = (await EF(n)).find(c => c.measurementId === s);
            l && await t[l.appId]
        }
    } catch (a) {
        cr.error(a)
    }
    e("config", s, i)
}
async function J9(e, t, n, r, s) {
    try {
        let i = [];
        if (s && s.send_to) {
            let o = s.send_to;
            Array.isArray(o) || (o = [o]);
            const a = await EF(n);
            for (const l of o) {
                const c = a.find(d => d.measurementId === l),
                    u = c && t[c.appId];
                if (u) i.push(u);
                else {
                    i = [];
                    break
                }
            }
        }
        i.length === 0 && (i = Object.values(t)), await Promise.all(i), e("event", r, s || {})
    } catch (i) {
        cr.error(i)
    }
}

function Z9(e, t, n, r) {
    async function s(i, o, a) {
        try {
            i === "event" ? await J9(e, t, n, o, a) : i === "config" ? await Q9(e, t, n, r, o, a) : i === "consent" ? e("consent", "update", a) : e("set", o)
        } catch (l) {
            cr.error(l)
        }
    }
    return s
}

function e7(e, t, n, r, s) {
    let i = function(...o) {
        window[r].push(arguments)
    };
    return window[s] && typeof window[s] == "function" && (i = window[s]), window[s] = Z9(i, e, t, n), {
        gtagCore: i,
        wrappedGtag: window[s]
    }
}

function t7(e) {
    const t = window.document.getElementsByTagName("script");
    for (const n of Object.values(t))
        if (n.src && n.src.includes(XT) && n.src.includes(e)) return n;
    return null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const n7 = 30,
    r7 = 1e3;
class s7 {
    constructor(t = {}, n = r7) {
        this.throttleMetadata = t, this.intervalMillis = n
    }
    getThrottleMetadata(t) {
        return this.throttleMetadata[t]
    }
    setThrottleMetadata(t, n) {
        this.throttleMetadata[t] = n
    }
    deleteThrottleMetadata(t) {
        delete this.throttleMetadata[t]
    }
}
const SF = new s7;

function i7(e) {
    return new Headers({
        Accept: "application/json",
        "x-goog-api-key": e
    })
}
async function o7(e) {
    var t;
    const {
        appId: n,
        apiKey: r
    } = e, s = {
        method: "GET",
        headers: i7(r)
    }, i = W9.replace("{app-id}", n), o = await fetch(i, s);
    if (o.status !== 200 && o.status !== 304) {
        let a = "";
        try {
            const l = await o.json();
            !((t = l.error) === null || t === void 0) && t.message && (a = l.error.message)
        } catch {}
        throw Lr.create("config-fetch-failed", {
            httpStatus: o.status,
            responseMessage: a
        })
    }
    return o.json()
}
async function a7(e, t = SF, n) {
    const {
        appId: r,
        apiKey: s,
        measurementId: i
    } = e.options;
    if (!r) throw Lr.create("no-app-id");
    if (!s) {
        if (i) return {
            measurementId: i,
            appId: r
        };
        throw Lr.create("no-api-key")
    }
    const o = t.getThrottleMetadata(r) || {
            backoffCount: 0,
            throttleEndTimeMillis: Date.now()
        },
        a = new u7;
    return setTimeout(async () => {
        a.abort()
    }, n !== void 0 ? n : z9), TF({
        appId: r,
        apiKey: s,
        measurementId: i
    }, o, a, t)
}
async function TF(e, {
    throttleEndTimeMillis: t,
    backoffCount: n
}, r, s = SF) {
    var i;
    const {
        appId: o,
        measurementId: a
    } = e;
    try {
        await l7(r, t)
    } catch (l) {
        if (a) return cr.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${l==null?void 0:l.message}]`), {
            appId: o,
            measurementId: a
        };
        throw l
    }
    try {
        const l = await o7(e);
        return s.deleteThrottleMetadata(o), l
    } catch (l) {
        const c = l;
        if (!c7(c)) {
            if (s.deleteThrottleMetadata(o), a) return cr.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${c==null?void 0:c.message}]`), {
                appId: o,
                measurementId: a
            };
            throw l
        }
        const u = Number((i = c == null ? void 0 : c.customData) === null || i === void 0 ? void 0 : i.httpStatus) === 503 ? Sw(n, s.intervalMillis, n7) : Sw(n, s.intervalMillis),
            d = {
                throttleEndTimeMillis: Date.now() + u,
                backoffCount: n + 1
            };
        return s.setThrottleMetadata(o, d), cr.debug(`Calling attemptFetch again in ${u} millis`), TF(e, d, r, s)
    }
}

function l7(e, t) {
    return new Promise((n, r) => {
        const s = Math.max(t - Date.now(), 0),
            i = setTimeout(n, s);
        e.addEventListener(() => {
            clearTimeout(i), r(Lr.create("fetch-throttle", {
                throttleEndTimeMillis: t
            }))
        })
    })
}

function c7(e) {
    if (!(e instanceof zr) || !e.customData) return !1;
    const t = Number(e.customData.httpStatus);
    return t === 429 || t === 500 || t === 503 || t === 504
}
class u7 {
    constructor() {
        this.listeners = []
    }
    addEventListener(t) {
        this.listeners.push(t)
    }
    abort() {
        this.listeners.forEach(t => t())
    }
}
async function d7(e, t, n, r, s) {
    if (s && s.global) {
        e("event", n, r);
        return
    } else {
        const i = await t,
            o = Object.assign(Object.assign({}, r), {
                send_to: i
            });
        e("event", n, o)
    }
}
async function f7(e, t, n, r) {
    if (r && r.global) {
        const s = {};
        for (const i of Object.keys(n)) s[`user_properties.${i}`] = n[i];
        return e("set", s), Promise.resolve()
    } else {
        const s = await t;
        e("config", s, {
            update: !0,
            user_properties: n
        })
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function h7() {
    if (Uy()) try {
        await fP()
    } catch (e) {
        return cr.warn(Lr.create("indexeddb-unavailable", {
            errorInfo: e == null ? void 0 : e.toString()
        }).message), !1
    } else return cr.warn(Lr.create("indexeddb-unavailable", {
        errorInfo: "IndexedDB is not available in this environment."
    }).message), !1;
    return !0
}
async function p7(e, t, n, r, s, i, o) {
    var a;
    const l = a7(e);
    l.then(h => {
        n[h.measurementId] = h.appId, e.options.measurementId && h.measurementId !== e.options.measurementId && cr.warn(`The measurement ID in the local Firebase config (${e.options.measurementId}) does not match the measurement ID fetched from the server (${h.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`)
    }).catch(h => cr.error(h)), t.push(l);
    const c = h7().then(h => {
            if (h) return r.getId()
        }),
        [u, d] = await Promise.all([l, c]);
    t7(i) || K9(i, u.measurementId), s("js", new Date);
    const f = (a = o == null ? void 0 : o.config) !== null && a !== void 0 ? a : {};
    return f[j9] = "firebase", f.update = !0, d != null && (f[H9] = d), s("config", u.measurementId, f), u.measurementId
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class m7 {
    constructor(t) {
        this.app = t
    }
    _delete() {
        return delete Cc[this.app.options.appId], Promise.resolve()
    }
}
let Cc = {},
    mC = [];
const gC = {};
let d0 = "dataLayer",
    g7 = "gtag",
    _C, QT, yC = !1;

function _7() {
    const e = [];
    if (cP() && e.push("This is a browser extension environment."), Sz() || e.push("Cookies are not available."), e.length > 0) {
        const t = e.map((r, s) => `(${s+1}) ${r}`).join(" "),
            n = Lr.create("invalid-analytics-context", {
                errorInfo: t
            });
        cr.warn(n.message)
    }
}

function y7(e, t, n) {
    _7();
    const r = e.options.appId;
    if (!r) throw Lr.create("no-app-id");
    if (!e.options.apiKey)
        if (e.options.measurementId) cr.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${e.options.measurementId} provided in the "measurementId" field in the local Firebase config.`);
        else throw Lr.create("no-api-key");
    if (Cc[r] != null) throw Lr.create("already-exists", {
        id: r
    });
    if (!yC) {
        X9(d0);
        const {
            wrappedGtag: i,
            gtagCore: o
        } = e7(Cc, mC, gC, d0, g7);
        QT = i, _C = o, yC = !0
    }
    return Cc[r] = p7(e, mC, gC, t, _C, d0, n), new m7(e)
}

function v7(e = Il()) {
    e = st(e);
    const t = vs(e, g_);
    return t.isInitialized() ? t.getImmediate() : b7(e)
}

function b7(e, t = {}) {
    const n = vs(e, g_);
    if (n.isInitialized()) {
        const s = n.getImmediate();
        if (Lf(t, n.getOptions())) return s;
        throw Lr.create("already-initialized")
    }
    return n.initialize({
        options: t
    })
}

function w7(e, t, n) {
    e = st(e), f7(QT, Cc[e.app.options.appId], t, n).catch(r => cr.error(r))
}

function $F(e, t, n, r) {
    e = st(e), d7(QT, Cc[e.app.options.appId], t, n, r).catch(s => cr.error(s))
}
const vC = "@firebase/analytics",
    bC = "0.9.5";

function E7() {
    dr(new Kn(g_, (t, {
        options: n
    }) => {
        const r = t.getProvider("app").getImmediate(),
            s = t.getProvider("installations-internal").getImmediate();
        return y7(r, s, n)
    }, "PUBLIC")), dr(new Kn("analytics-internal", e, "PRIVATE")), cn(vC, bC), cn(vC, bC, "esm2017");

    function e(t) {
        try {
            const n = t.getProvider(g_).getImmediate();
            return {
                logEvent: (r, s, i) => $F(n, r, s, i)
            }
        } catch (n) {
            throw Lr.create("interop-component-reg-failed", {
                reason: n
            })
        }
    }
}
E7();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const S7 = "type.googleapis.com/google.protobuf.Int64Value",
    T7 = "type.googleapis.com/google.protobuf.UInt64Value";

function kF(e, t) {
    const n = {};
    for (const r in e) e.hasOwnProperty(r) && (n[r] = t(e[r]));
    return n
}

function uE(e) {
    if (e == null) return null;
    if (e instanceof Number && (e = e.valueOf()), typeof e == "number" && isFinite(e) || e === !0 || e === !1 || Object.prototype.toString.call(e) === "[object String]") return e;
    if (e instanceof Date) return e.toISOString();
    if (Array.isArray(e)) return e.map(t => uE(t));
    if (typeof e == "function" || typeof e == "object") return kF(e, t => uE(t));
    throw new Error("Data cannot be encoded in JSON: " + e)
}

function __(e) {
    if (e == null) return e;
    if (e["@type"]) switch (e["@type"]) {
        case S7:
        case T7:
            {
                const t = Number(e.value);
                if (isNaN(t)) throw new Error("Data cannot be decoded from JSON: " + e);
                return t
            }
        default:
            throw new Error("Data cannot be decoded from JSON: " + e)
    }
    return Array.isArray(e) ? e.map(t => __(t)) : typeof e == "function" || typeof e == "object" ? kF(e, t => __(t)) : e
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JT = "functions";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wC = {
    OK: "ok",
    CANCELLED: "cancelled",
    UNKNOWN: "unknown",
    INVALID_ARGUMENT: "invalid-argument",
    DEADLINE_EXCEEDED: "deadline-exceeded",
    NOT_FOUND: "not-found",
    ALREADY_EXISTS: "already-exists",
    PERMISSION_DENIED: "permission-denied",
    UNAUTHENTICATED: "unauthenticated",
    RESOURCE_EXHAUSTED: "resource-exhausted",
    FAILED_PRECONDITION: "failed-precondition",
    ABORTED: "aborted",
    OUT_OF_RANGE: "out-of-range",
    UNIMPLEMENTED: "unimplemented",
    INTERNAL: "internal",
    UNAVAILABLE: "unavailable",
    DATA_LOSS: "data-loss"
};
class Ac extends zr {
    constructor(t, n, r) {
        super(`${JT}/${t}`, n || ""), this.details = r
    }
}

function $7(e) {
    if (e >= 200 && e < 300) return "ok";
    switch (e) {
        case 0:
            return "internal";
        case 400:
            return "invalid-argument";
        case 401:
            return "unauthenticated";
        case 403:
            return "permission-denied";
        case 404:
            return "not-found";
        case 409:
            return "aborted";
        case 429:
            return "resource-exhausted";
        case 499:
            return "cancelled";
        case 500:
            return "internal";
        case 501:
            return "unimplemented";
        case 503:
            return "unavailable";
        case 504:
            return "deadline-exceeded"
    }
    return "unknown"
}

function k7(e, t) {
    let n = $7(e),
        r = n,
        s;
    try {
        const i = t && t.error;
        if (i) {
            const o = i.status;
            if (typeof o == "string") {
                if (!wC[o]) return new Ac("internal", "internal");
                n = wC[o], r = o
            }
            const a = i.message;
            typeof a == "string" && (r = a), s = i.details, s !== void 0 && (s = __(s))
        }
    } catch {}
    return n === "ok" ? null : new Ac(n, r, s)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class I7 {
    constructor(t, n, r) {
        this.auth = null, this.messaging = null, this.appCheck = null, this.auth = t.getImmediate({
            optional: !0
        }), this.messaging = n.getImmediate({
            optional: !0
        }), this.auth || t.get().then(s => this.auth = s, () => {}), this.messaging || n.get().then(s => this.messaging = s, () => {}), this.appCheck || r.get().then(s => this.appCheck = s, () => {})
    }
    async getAuthToken() {
        if (!!this.auth) try {
            const t = await this.auth.getToken();
            return t == null ? void 0 : t.accessToken
        } catch {
            return
        }
    }
    async getMessagingToken() {
        if (!(!this.messaging || !("Notification" in self) || Notification.permission !== "granted")) try {
            return await this.messaging.getToken()
        } catch {
            return
        }
    }
    async getAppCheckToken() {
        if (this.appCheck) {
            const t = await this.appCheck.getToken();
            return t.error ? null : t.token
        }
        return null
    }
    async getContext() {
        const t = await this.getAuthToken(),
            n = await this.getMessagingToken(),
            r = await this.getAppCheckToken();
        return {
            authToken: t,
            messagingToken: n,
            appCheckToken: r
        }
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dE = "us-central1";

function x7(e) {
    let t = null;
    return {
        promise: new Promise((n, r) => {
            t = setTimeout(() => {
                r(new Ac("deadline-exceeded", "deadline-exceeded"))
            }, e)
        }),
        cancel: () => {
            t && clearTimeout(t)
        }
    }
}
class C7 {
    constructor(t, n, r, s, i = dE, o) {
        this.app = t, this.fetchImpl = o, this.emulatorOrigin = null, this.contextProvider = new I7(n, r, s), this.cancelAllRequests = new Promise(a => {
            this.deleteService = () => Promise.resolve(a())
        });
        try {
            const a = new URL(i);
            this.customDomain = a.origin, this.region = dE
        } catch {
            this.customDomain = null, this.region = i
        }
    }
    _delete() {
        return this.deleteService()
    }
    _url(t) {
        const n = this.app.options.projectId;
        return this.emulatorOrigin !== null ? `${this.emulatorOrigin}/${n}/${this.region}/${t}` : this.customDomain !== null ? `${this.customDomain}/${t}` : `https://${this.region}-${n}.cloudfunctions.net/${t}`
    }
}

function A7(e, t, n) {
    e.emulatorOrigin = `http://${t}:${n}`
}

function R7(e, t, n) {
    return r => D7(e, t, r, n || {})
}
async function O7(e, t, n, r) {
    n["Content-Type"] = "application/json";
    let s;
    try {
        s = await r(e, {
            method: "POST",
            body: JSON.stringify(t),
            headers: n
        })
    } catch {
        return {
            status: 0,
            json: null
        }
    }
    let i = null;
    try {
        i = await s.json()
    } catch {}
    return {
        status: s.status,
        json: i
    }
}

function D7(e, t, n, r) {
    const s = e._url(t);
    return N7(e, s, n, r)
}
async function N7(e, t, n, r) {
    n = uE(n);
    const s = {
            data: n
        },
        i = {},
        o = await e.contextProvider.getContext();
    o.authToken && (i.Authorization = "Bearer " + o.authToken), o.messagingToken && (i["Firebase-Instance-ID-Token"] = o.messagingToken), o.appCheckToken !== null && (i["X-Firebase-AppCheck"] = o.appCheckToken);
    const a = r.timeout || 7e4,
        l = x7(a),
        c = await Promise.race([O7(t, s, i, e.fetchImpl), l.promise, e.cancelAllRequests]);
    if (l.cancel(), !c) throw new Ac("cancelled", "Firebase Functions instance was deleted.");
    const u = k7(c.status, c.json);
    if (u) throw u;
    if (!c.json) throw new Ac("internal", "Response is not valid JSON object.");
    let d = c.json.data;
    if (typeof d == "undefined" && (d = c.json.result), typeof d == "undefined") throw new Ac("internal", "Response is missing data field.");
    return {
        data: __(d)
    }
}
const EC = "@firebase/functions",
    SC = "0.9.4";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const P7 = "auth-internal",
    M7 = "app-check-internal",
    L7 = "messaging-internal";

function F7(e, t) {
    const n = (r, {
        instanceIdentifier: s
    }) => {
        const i = r.getProvider("app").getImmediate(),
            o = r.getProvider(P7),
            a = r.getProvider(L7),
            l = r.getProvider(M7);
        return new C7(i, o, a, l, s, e)
    };
    dr(new Kn(JT, n, "PUBLIC").setMultipleInstances(!0)), cn(EC, SC, t), cn(EC, SC, "esm2017")
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function U7(e = Il(), t = dE) {
    const r = vs(st(e), JT).getImmediate({
            identifier: t
        }),
        s = uS("functions");
    return s && B7(r, ...s), r
}

function B7(e, t, n) {
    A7(st(e), t, n)
}

function ca(e, t, n) {
    return R7(st(e), t, n)
}
F7(fetch.bind(self));
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fE = new Map,
    IF = {
        activated: !1,
        tokenObservers: []
    },
    V7 = {
        initialized: !1,
        enabled: !1
    };

function Sn(e) {
    return fE.get(e) || Object.assign({}, IF)
}

function H7(e, t) {
    return fE.set(e, t), fE.get(e)
}

function Ov() {
    return V7
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xF = "https://content-firebaseappcheck.googleapis.com/v1",
    j7 = "exchangeRecaptchaV3Token",
    z7 = "exchangeDebugToken",
    TC = {
        OFFSET_DURATION: 5 * 60 * 1e3,
        RETRIAL_MIN_WAIT: 30 * 1e3,
        RETRIAL_MAX_WAIT: 16 * 60 * 1e3
    },
    W7 = 24 * 60 * 60 * 1e3;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class G7 {
    constructor(t, n, r, s, i) {
        if (this.operation = t, this.retryPolicy = n, this.getWaitDuration = r, this.lowerBound = s, this.upperBound = i, this.pending = null, this.nextErrorWaitInterval = s, s > i) throw new Error("Proactive refresh lower bound greater than upper bound!")
    }
    start() {
        this.nextErrorWaitInterval = this.lowerBound, this.process(!0).catch(() => {})
    }
    stop() {
        this.pending && (this.pending.reject("cancelled"), this.pending = null)
    }
    isRunning() {
        return !!this.pending
    }
    async process(t) {
        this.stop();
        try {
            this.pending = new Mo, await q7(this.getNextRun(t)), this.pending.resolve(), await this.pending.promise, this.pending = new Mo, await this.operation(), this.pending.resolve(), await this.pending.promise, this.process(!0).catch(() => {})
        } catch (n) {
            this.retryPolicy(n) ? this.process(!1).catch(() => {}) : this.stop()
        }
    }
    getNextRun(t) {
        if (t) return this.nextErrorWaitInterval = this.lowerBound, this.getWaitDuration(); {
            const n = this.nextErrorWaitInterval;
            return this.nextErrorWaitInterval *= 2, this.nextErrorWaitInterval > this.upperBound && (this.nextErrorWaitInterval = this.upperBound), n
        }
    }
}

function q7(e) {
    return new Promise(t => {
        setTimeout(t, e)
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Y7 = {
        ["already-initialized"]: "You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.",
        ["use-before-activation"]: "App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Firebase services.",
        ["fetch-network-error"]: "Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.",
        ["fetch-parse-error"]: "Fetch client could not parse response. Original error: {$originalErrorMessage}.",
        ["fetch-status-error"]: "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.",
        ["storage-open"]: "Error thrown when opening storage. Original error: {$originalErrorMessage}.",
        ["storage-get"]: "Error thrown when reading from storage. Original error: {$originalErrorMessage}.",
        ["storage-set"]: "Error thrown when writing to storage. Original error: {$originalErrorMessage}.",
        ["recaptcha-error"]: "ReCAPTCHA error.",
        throttled: "Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}"
    },
    wr = new sa("appCheck", "AppCheck", Y7);
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $C(e = !1) {
    var t;
    return e ? (t = self.grecaptcha) === null || t === void 0 ? void 0 : t.enterprise : self.grecaptcha
}

function CF(e) {
    if (!Sn(e).activated) throw wr.create("use-before-activation", {
        appName: e.name
    })
}

function AF(e) {
    const t = Math.round(e / 1e3),
        n = Math.floor(t / (3600 * 24)),
        r = Math.floor((t - n * 3600 * 24) / 3600),
        s = Math.floor((t - n * 3600 * 24 - r * 3600) / 60),
        i = t - n * 3600 * 24 - r * 3600 - s * 60;
    let o = "";
    return n && (o += sm(n) + "d:"), r && (o += sm(r) + "h:"), o += sm(s) + "m:" + sm(i) + "s", o
}

function sm(e) {
    return e === 0 ? "00" : e >= 10 ? e.toString() : "0" + e
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function RF({
    url: e,
    body: t
}, n) {
    const r = {
            "Content-Type": "application/json"
        },
        s = n.getImmediate({
            optional: !0
        });
    if (s) {
        const d = await s.getHeartbeatsHeader();
        d && (r["X-Firebase-Client"] = d)
    }
    const i = {
        method: "POST",
        body: JSON.stringify(t),
        headers: r
    };
    let o;
    try {
        o = await fetch(e, i)
    } catch (d) {
        throw wr.create("fetch-network-error", {
            originalErrorMessage: d == null ? void 0 : d.message
        })
    }
    if (o.status !== 200) throw wr.create("fetch-status-error", {
        httpStatus: o.status
    });
    let a;
    try {
        a = await o.json()
    } catch (d) {
        throw wr.create("fetch-parse-error", {
            originalErrorMessage: d == null ? void 0 : d.message
        })
    }
    const l = a.ttl.match(/^([\d.]+)(s)$/);
    if (!l || !l[2] || isNaN(Number(l[1]))) throw wr.create("fetch-parse-error", {
        originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration format: ${a.ttl}`
    });
    const c = Number(l[1]) * 1e3,
        u = Date.now();
    return {
        token: a.token,
        expireTimeMillis: u + c,
        issuedAtTimeMillis: u
    }
}

function K7(e, t) {
    const {
        projectId: n,
        appId: r,
        apiKey: s
    } = e.options;
    return {
        url: `${xF}/projects/${n}/apps/${r}:${j7}?key=${s}`,
        body: {
            recaptcha_v3_token: t
        }
    }
}

function X7(e, t) {
    const {
        projectId: n,
        appId: r,
        apiKey: s
    } = e.options;
    return {
        url: `${xF}/projects/${n}/apps/${r}:${z7}?key=${s}`,
        body: {
            debug_token: t
        }
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Q7 = "firebase-app-check-database",
    J7 = 1,
    lh = "firebase-app-check-store",
    OF = "debug-token";
let im = null;

function DF() {
    return im || (im = new Promise((e, t) => {
        try {
            const n = indexedDB.open(Q7, J7);
            n.onsuccess = r => {
                e(r.target.result)
            }, n.onerror = r => {
                var s;
                t(wr.create("storage-open", {
                    originalErrorMessage: (s = r.target.error) === null || s === void 0 ? void 0 : s.message
                }))
            }, n.onupgradeneeded = r => {
                const s = r.target.result;
                switch (r.oldVersion) {
                    case 0:
                        s.createObjectStore(lh, {
                            keyPath: "compositeKey"
                        })
                }
            }
        } catch (n) {
            t(wr.create("storage-open", {
                originalErrorMessage: n == null ? void 0 : n.message
            }))
        }
    }), im)
}

function Z7(e) {
    return PF(MF(e))
}

function eX(e, t) {
    return NF(MF(e), t)
}

function tX(e) {
    return NF(OF, e)
}

function nX() {
    return PF(OF)
}
async function NF(e, t) {
    const r = (await DF()).transaction(lh, "readwrite"),
        i = r.objectStore(lh).put({
            compositeKey: e,
            value: t
        });
    return new Promise((o, a) => {
        i.onsuccess = l => {
            o()
        }, r.onerror = l => {
            var c;
            a(wr.create("storage-set", {
                originalErrorMessage: (c = l.target.error) === null || c === void 0 ? void 0 : c.message
            }))
        }
    })
}
async function PF(e) {
    const n = (await DF()).transaction(lh, "readonly"),
        s = n.objectStore(lh).get(e);
    return new Promise((i, o) => {
        s.onsuccess = a => {
            const l = a.target.result;
            i(l ? l.value : void 0)
        }, n.onerror = a => {
            var l;
            o(wr.create("storage-get", {
                originalErrorMessage: (l = a.target.error) === null || l === void 0 ? void 0 : l.message
            }))
        }
    })
}

function MF(e) {
    return `${e.options.appId}-${e.name}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ch = new zu("@firebase/app-check");
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function rX(e) {
    if (Uy()) {
        let t;
        try {
            t = await Z7(e)
        } catch (n) {
            ch.warn(`Failed to read token from IndexedDB. Error: ${n}`)
        }
        return t
    }
}

function f0(e, t) {
    return Uy() ? eX(e, t).catch(n => {
        ch.warn(`Failed to write token to IndexedDB. Error: ${n}`)
    }) : Promise.resolve()
}
async function sX() {
    let e;
    try {
        e = await nX()
    } catch {}
    if (e) return e; {
        const t = Nz();
        return tX(t).catch(n => ch.warn(`Failed to persist debug token to IndexedDB. Error: ${n}`)), t
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function LF() {
    return Ov().enabled
}
async function FF() {
    const e = Ov();
    if (e.enabled && e.token) return e.token.promise;
    throw Error(`
            Can't get debug token in production mode.
        `)
}

function iX() {
    const e = iP(),
        t = Ov();
    if (t.initialized = !0, typeof e.FIREBASE_APPCHECK_DEBUG_TOKEN != "string" && e.FIREBASE_APPCHECK_DEBUG_TOKEN !== !0) return;
    t.enabled = !0;
    const n = new Mo;
    t.token = n, typeof e.FIREBASE_APPCHECK_DEBUG_TOKEN == "string" ? n.resolve(e.FIREBASE_APPCHECK_DEBUG_TOKEN) : n.resolve(sX())
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oX = {
    error: "UNKNOWN_ERROR"
};

function aX(e) {
    return Fy.encodeString(JSON.stringify(e), !1)
}
async function hE(e, t = !1) {
    const n = e.app;
    CF(n);
    const r = Sn(n);
    let s = r.token,
        i;
    if (s && !yc(s) && (r.token = void 0, s = void 0), !s) {
        const l = await r.cachedTokenPromise;
        l && (yc(l) ? s = l : await f0(n, void 0))
    }
    if (!t && s && yc(s)) return {
        token: s.token
    };
    let o = !1;
    if (LF()) {
        r.exchangeTokenPromise || (r.exchangeTokenPromise = RF(X7(n, await FF()), e.heartbeatServiceProvider).finally(() => {
            r.exchangeTokenPromise = void 0
        }), o = !0);
        const l = await r.exchangeTokenPromise;
        return await f0(n, l), r.token = l, {
            token: l.token
        }
    }
    try {
        r.exchangeTokenPromise || (r.exchangeTokenPromise = r.provider.getToken().finally(() => {
            r.exchangeTokenPromise = void 0
        }), o = !0), s = await Sn(n).exchangeTokenPromise
    } catch (l) {
        l.code === "appCheck/throttled" ? ch.warn(l.message) : ch.error(l), i = l
    }
    let a;
    return s ? i ? yc(s) ? a = {
        token: s.token,
        internalError: i
    } : a = IC(i) : (a = {
        token: s.token
    }, r.token = s, await f0(n, s)) : a = IC(i), o && VF(n, a), a
}

function UF(e, t, n, r) {
    const {
        app: s
    } = e, i = Sn(s), o = {
        next: n,
        error: r,
        type: t
    };
    if (i.tokenObservers = [...i.tokenObservers, o], i.token && yc(i.token)) {
        const a = i.token;
        Promise.resolve().then(() => {
            n({
                token: a.token
            }), kC(e)
        }).catch(() => {})
    }
    i.cachedTokenPromise.then(() => kC(e))
}

function BF(e, t) {
    const n = Sn(e),
        r = n.tokenObservers.filter(s => s.next !== t);
    r.length === 0 && n.tokenRefresher && n.tokenRefresher.isRunning() && n.tokenRefresher.stop(), n.tokenObservers = r
}

function kC(e) {
    const {
        app: t
    } = e, n = Sn(t);
    let r = n.tokenRefresher;
    r || (r = lX(e), n.tokenRefresher = r), !r.isRunning() && n.isTokenAutoRefreshEnabled && r.start()
}

function lX(e) {
    const {
        app: t
    } = e;
    return new G7(async () => {
        const n = Sn(t);
        let r;
        if (n.token ? r = await hE(e, !0) : r = await hE(e), r.error) throw r.error;
        if (r.internalError) throw r.internalError
    }, () => !0, () => {
        const n = Sn(t);
        if (n.token) {
            let r = n.token.issuedAtTimeMillis + (n.token.expireTimeMillis - n.token.issuedAtTimeMillis) * .5 + 3e5;
            const s = n.token.expireTimeMillis - 5 * 60 * 1e3;
            return r = Math.min(r, s), Math.max(0, r - Date.now())
        } else return 0
    }, TC.RETRIAL_MIN_WAIT, TC.RETRIAL_MAX_WAIT)
}

function VF(e, t) {
    const n = Sn(e).tokenObservers;
    for (const r of n) try {
        r.type === "EXTERNAL" && t.error != null ? r.error(t.error) : r.next(t)
    } catch {}
}

function yc(e) {
    return e.expireTimeMillis - Date.now() > 0
}

function IC(e) {
    return {
        token: aX(oX),
        error: e
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cX {
    constructor(t, n) {
        this.app = t, this.heartbeatServiceProvider = n
    }
    _delete() {
        const {
            tokenObservers: t
        } = Sn(this.app);
        for (const n of t) BF(this.app, n.next);
        return Promise.resolve()
    }
}

function uX(e, t) {
    return new cX(e, t)
}

function dX(e) {
    return {
        getToken: t => hE(e, t),
        addTokenListener: t => UF(e, "INTERNAL", t),
        removeTokenListener: t => BF(e.app, t)
    }
}
const fX = "@firebase/app-check",
    hX = "0.6.5";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pX = "https://www.google.com/recaptcha/api.js";

function mX(e, t) {
    const n = new Mo,
        r = Sn(e);
    r.reCAPTCHAState = {
        initialized: n
    };
    const s = gX(e),
        i = $C(!1);
    return i ? xC(e, t, i, s, n) : vX(() => {
        const o = $C(!1);
        if (!o) throw new Error("no recaptcha");
        xC(e, t, o, s, n)
    }), n.promise
}

function xC(e, t, n, r, s) {
    n.ready(() => {
        yX(e, t, n, r), s.resolve(n)
    })
}

function gX(e) {
    const t = `fire_app_check_${e.name}`,
        n = document.createElement("div");
    return n.id = t, n.style.display = "none", document.body.appendChild(n), t
}
async function _X(e) {
    CF(e);
    const n = await Sn(e).reCAPTCHAState.initialized.promise;
    return new Promise((r, s) => {
        const i = Sn(e).reCAPTCHAState;
        n.ready(() => {
            r(n.execute(i.widgetId, {
                action: "fire_app_check"
            }))
        })
    })
}

function yX(e, t, n, r) {
    const s = n.render(r, {
            sitekey: t,
            size: "invisible",
            callback: () => {
                Sn(e).reCAPTCHAState.succeeded = !0
            },
            "error-callback": () => {
                Sn(e).reCAPTCHAState.succeeded = !1
            }
        }),
        i = Sn(e);
    i.reCAPTCHAState = Object.assign(Object.assign({}, i.reCAPTCHAState), {
        widgetId: s
    })
}

function vX(e) {
    const t = document.createElement("script");
    t.src = pX, t.onload = e, document.head.appendChild(t)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ZT {
    constructor(t) {
        this._siteKey = t, this._throttleData = null
    }
    async getToken() {
        var t, n, r;
        wX(this._throttleData);
        const s = await _X(this._app).catch(o => {
            throw wr.create("recaptcha-error")
        });
        if (!(!((t = Sn(this._app).reCAPTCHAState) === null || t === void 0) && t.succeeded)) throw wr.create("recaptcha-error");
        let i;
        try {
            i = await RF(K7(this._app, s), this._heartbeatServiceProvider)
        } catch (o) {
            throw !((n = o.code) === null || n === void 0) && n.includes("fetch-status-error") ? (this._throttleData = bX(Number((r = o.customData) === null || r === void 0 ? void 0 : r.httpStatus), this._throttleData), wr.create("throttled", {
                time: AF(this._throttleData.allowRequestsAfter - Date.now()),
                httpStatus: this._throttleData.httpStatus
            })) : o
        }
        return this._throttleData = null, i
    }
    initialize(t) {
        this._app = t, this._heartbeatServiceProvider = vs(t, "heartbeat"), mX(t, this._siteKey).catch(() => {})
    }
    isEqual(t) {
        return t instanceof ZT ? this._siteKey === t._siteKey : !1
    }
}

function bX(e, t) {
    if (e === 404 || e === 403) return {
        backoffCount: 1,
        allowRequestsAfter: Date.now() + W7,
        httpStatus: e
    }; {
        const n = t ? t.backoffCount : 0,
            r = Sw(n, 1e3, 2);
        return {
            backoffCount: n + 1,
            allowRequestsAfter: Date.now() + r,
            httpStatus: e
        }
    }
}

function wX(e) {
    if (e && Date.now() - e.allowRequestsAfter <= 0) throw wr.create("throttled", {
        time: AF(e.allowRequestsAfter - Date.now()),
        httpStatus: e.httpStatus
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function EX(e = Il(), t) {
    e = st(e);
    const n = vs(e, "app-check");
    if (Ov().initialized || iX(), LF() && FF().then(s => console.log(`App Check debug token: ${s}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`)), n.isInitialized()) {
        const s = n.getImmediate(),
            i = n.getOptions();
        if (i.isTokenAutoRefreshEnabled === t.isTokenAutoRefreshEnabled && i.provider.isEqual(t.provider)) return s;
        throw wr.create("already-initialized", {
            appName: e.name
        })
    }
    const r = n.initialize({
        options: t
    });
    return SX(e, t.provider, t.isTokenAutoRefreshEnabled), Sn(e).isTokenAutoRefreshEnabled && UF(r, "INTERNAL", () => {}), r
}

function SX(e, t, n) {
    const r = H7(e, Object.assign({}, IF));
    r.activated = !0, r.provider = t, r.cachedTokenPromise = rX(e).then(s => (s && yc(s) && (r.token = s, VF(e, {
        token: s.token
    })), s)), r.isTokenAutoRefreshEnabled = n === void 0 ? e.automaticDataCollectionEnabled : n, r.provider.initialize(e)
}
const TX = "app-check",
    CC = "app-check-internal";

function $X() {
    dr(new Kn(TX, e => {
        const t = e.getProvider("app").getImmediate(),
            n = e.getProvider("heartbeat");
        return uX(t, n)
    }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e, t, n) => {
        e.getProvider(CC).initialize()
    })), dr(new Kn(CC, e => {
        const t = e.getProvider("app-check").getImmediate();
        return dX(t)
    }, "PUBLIC").setInstantiationMode("EXPLICIT")), cn(fX, hX)
}
$X();
const HF = Object.prototype.toString;

function jF(e) {
    switch (HF.call(e)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
            return !0;
        default:
            return zo(e, Error)
    }
}

function td(e, t) {
    return HF.call(e) === `[object ${t}]`
}

function zF(e) {
    return td(e, "ErrorEvent")
}

function AC(e) {
    return td(e, "DOMError")
}

function kX(e) {
    return td(e, "DOMException")
}

function jo(e) {
    return td(e, "String")
}

function WF(e) {
    return e === null || typeof e != "object" && typeof e != "function"
}

function uu(e) {
    return td(e, "Object")
}

function e$(e) {
    return typeof Event != "undefined" && zo(e, Event)
}

function IX(e) {
    return typeof Element != "undefined" && zo(e, Element)
}

function xX(e) {
    return td(e, "RegExp")
}

function t$(e) {
    return Boolean(e && e.then && typeof e.then == "function")
}

function CX(e) {
    return uu(e) && "nativeEvent" in e && "preventDefault" in e && "stopPropagation" in e
}

function GF(e) {
    return typeof e == "number" && e !== e
}

function zo(e, t) {
    try {
        return e instanceof t
    } catch {
        return !1
    }
}

function om(e) {
    return e && e.Math == Math ? e : void 0
}
const ur = typeof globalThis == "object" && om(globalThis) || typeof window == "object" && om(window) || typeof self == "object" && om(self) || typeof global == "object" && om(global) || function() {
    return this
}() || {};

function _p() {
    return ur
}

function n$(e, t, n) {
    const r = n || ur,
        s = r.__SENTRY__ = r.__SENTRY__ || {};
    return s[e] || (s[e] = t())
}
const ig = _p(),
    AX = 80;

function cl(e, t = {}) {
    try {
        let n = e;
        const r = 5,
            s = [];
        let i = 0,
            o = 0;
        const a = " > ",
            l = a.length;
        let c;
        const u = Array.isArray(t) ? t : t.keyAttrs,
            d = !Array.isArray(t) && t.maxStringLength || AX;
        for (; n && i++ < r && (c = RX(n, u), !(c === "html" || i > 1 && o + s.length * l + c.length >= d));) s.push(c), o += c.length, n = n.parentNode;
        return s.reverse().join(a)
    } catch {
        return "<unknown>"
    }
}

function RX(e, t) {
    const n = e,
        r = [];
    let s, i, o, a, l;
    if (!n || !n.tagName) return "";
    r.push(n.tagName.toLowerCase());
    const c = t && t.length ? t.filter(d => n.getAttribute(d)).map(d => [d, n.getAttribute(d)]) : null;
    if (c && c.length) c.forEach(d => {
        r.push(`[${d[0]}="${d[1]}"]`)
    });
    else if (n.id && r.push(`#${n.id}`), s = n.className, s && jo(s))
        for (i = s.split(/\s+/), l = 0; l < i.length; l++) r.push(`.${i[l]}`);
    const u = ["aria-label", "type", "name", "title", "alt"];
    for (l = 0; l < u.length; l++) o = u[l], a = n.getAttribute(o), a && r.push(`[${o}="${a}"]`);
    return r.join("")
}

function OX() {
    try {
        return ig.document.location.href
    } catch {
        return ""
    }
}

function DX(e) {
    return ig.document && ig.document.querySelector ? ig.document.querySelector(e) : null
}
class Vn extends Error {
    constructor(t, n = "warn") {
        super(t), this.message = t, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n
    }
}
const NX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

function PX(e) {
    return e === "http" || e === "https"
}

function Dv(e, t = !1) {
    const {
        host: n,
        path: r,
        pass: s,
        port: i,
        projectId: o,
        protocol: a,
        publicKey: l
    } = e;
    return `${a}://${l}${t&&s?`:${s}`:""}@${n}${i?`:${i}`:""}/${r&&`${r}/`}${o}`
}

function MX(e) {
    const t = NX.exec(e);
    if (!t) throw new Vn(`Invalid Sentry Dsn: ${e}`);
    const [n, r, s = "", i, o = "", a] = t.slice(1);
    let l = "",
        c = a;
    const u = c.split("/");
    if (u.length > 1 && (l = u.slice(0, -1).join("/"), c = u.pop()), c) {
        const d = c.match(/^\d+/);
        d && (c = d[0])
    }
    return qF({
        host: i,
        pass: s,
        path: l,
        projectId: c,
        port: o,
        protocol: n,
        publicKey: r
    })
}

function qF(e) {
    return {
        protocol: e.protocol,
        publicKey: e.publicKey || "",
        pass: e.pass || "",
        host: e.host,
        port: e.port || "",
        path: e.path || "",
        projectId: e.projectId
    }
}

function LX(e) {
    if (!(typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__)) return;
    const {
        port: t,
        projectId: n,
        protocol: r
    } = e;
    if (["protocol", "publicKey", "host", "projectId"].forEach(i => {
            if (!e[i]) throw new Vn(`Invalid Sentry Dsn: ${i} missing`)
        }), !n.match(/^\d+$/)) throw new Vn(`Invalid Sentry Dsn: Invalid projectId ${n}`);
    if (!PX(r)) throw new Vn(`Invalid Sentry Dsn: Invalid protocol ${r}`);
    if (t && isNaN(parseInt(t, 10))) throw new Vn(`Invalid Sentry Dsn: Invalid port ${t}`);
    return !0
}

function FX(e) {
    const t = typeof e == "string" ? MX(e) : qF(e);
    return LX(t), t
}
const UX = "Sentry Logger ",
    y_ = ["debug", "info", "warn", "error", "log", "assert", "trace"];

function YF(e) {
    if (!("console" in ur)) return e();
    const t = ur.console,
        n = {};
    y_.forEach(r => {
        const s = t[r] && t[r].__sentry_original__;
        r in t && s && (n[r] = t[r], t[r] = s)
    });
    try {
        return e()
    } finally {
        Object.keys(n).forEach(r => {
            t[r] = n[r]
        })
    }
}

function RC() {
    let e = !1;
    const t = {
        enable: () => {
            e = !0
        },
        disable: () => {
            e = !1
        }
    };
    return typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__ ? y_.forEach(n => {
        t[n] = (...r) => {
            e && YF(() => {
                ur.console[n](`${UX}[${n}]:`, ...r)
            })
        }
    }) : y_.forEach(n => {
        t[n] = () => {}
    }), t
}
let M;
typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__ ? M = n$("logger", RC) : M = RC();

function tf(e, t = 0) {
    return typeof e != "string" || t === 0 || e.length <= t ? e : `${e.slice(0,t)}...`
}

function OC(e, t) {
    if (!Array.isArray(e)) return "";
    const n = [];
    for (let r = 0; r < e.length; r++) {
        const s = e[r];
        try {
            n.push(String(s))
        } catch {
            n.push("[value cannot be serialized]")
        }
    }
    return n.join(t)
}

function BX(e, t, n = !1) {
    return jo(e) ? xX(t) ? t.test(e) : jo(t) ? n ? e === t : e.includes(t) : !1 : !1
}

function nd(e, t = [], n = !1) {
    return t.some(r => BX(e, r, n))
}

function On(e, t, n) {
    if (!(t in e)) return;
    const r = e[t],
        s = n(r);
    if (typeof s == "function") try {
        KF(s, r)
    } catch {}
    e[t] = s
}

function r$(e, t, n) {
    Object.defineProperty(e, t, {
        value: n,
        writable: !0,
        configurable: !0
    })
}

function KF(e, t) {
    const n = t.prototype || {};
    e.prototype = t.prototype = n, r$(e, "__sentry_original__", t)
}

function s$(e) {
    return e.__sentry_original__
}

function VX(e) {
    return Object.keys(e).map(t => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`).join("&")
}

function XF(e) {
    if (jF(e)) return x({
        message: e.message,
        name: e.name,
        stack: e.stack
    }, NC(e));
    if (e$(e)) {
        const t = x({
            type: e.type,
            target: DC(e.target),
            currentTarget: DC(e.currentTarget)
        }, NC(e));
        return typeof CustomEvent != "undefined" && zo(e, CustomEvent) && (t.detail = e.detail), t
    } else return e
}

function DC(e) {
    try {
        return IX(e) ? cl(e) : Object.prototype.toString.call(e)
    } catch {
        return "<unknown>"
    }
}

function NC(e) {
    if (typeof e == "object" && e !== null) {
        const t = {};
        for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
        return t
    } else return {}
}

function HX(e, t = 40) {
    const n = Object.keys(XF(e));
    if (n.sort(), !n.length) return "[object has no keys]";
    if (n[0].length >= t) return tf(n[0], t);
    for (let r = n.length; r > 0; r--) {
        const s = n.slice(0, r).join(", ");
        if (!(s.length > t)) return r === n.length ? s : tf(s, t)
    }
    return ""
}

function Rs(e) {
    return pE(e, new Map)
}

function pE(e, t) {
    if (uu(e)) {
        const n = t.get(e);
        if (n !== void 0) return n;
        const r = {};
        t.set(e, r);
        for (const s of Object.keys(e)) typeof e[s] != "undefined" && (r[s] = pE(e[s], t));
        return r
    }
    if (Array.isArray(e)) {
        const n = t.get(e);
        if (n !== void 0) return n;
        const r = [];
        return t.set(e, r), e.forEach(s => {
            r.push(pE(s, t))
        }), r
    }
    return e
}
const QF = 50,
    PC = /\(error: (.*)\)/;

function JF(...e) {
    const t = e.sort((n, r) => n[0] - r[0]).map(n => n[1]);
    return (n, r = 0) => {
        const s = [],
            i = n.split(`
`);
        for (let o = r; o < i.length; o++) {
            const a = i[o];
            if (a.length > 1024) continue;
            const l = PC.test(a) ? a.replace(PC, "$1") : a;
            if (!l.match(/\S*Error: /)) {
                for (const c of t) {
                    const u = c(l);
                    if (u) {
                        s.push(u);
                        break
                    }
                }
                if (s.length >= QF) break
            }
        }
        return zX(s)
    }
}

function jX(e) {
    return Array.isArray(e) ? JF(...e) : e
}

function zX(e) {
    if (!e.length) return [];
    const t = e.slice(0, QF),
        n = t[t.length - 1].function;
    n && /sentryWrapped/.test(n) && t.pop(), t.reverse();
    const r = t[t.length - 1].function;
    return r && /captureMessage|captureException/.test(r) && t.pop(), t.map(s => G(x({}, s), {
        filename: s.filename || t[t.length - 1].filename,
        function: s.function || "?"
    }))
}
const h0 = "<anonymous>";

function Wo(e) {
    try {
        return !e || typeof e != "function" ? h0 : e.name || h0
    } catch {
        return h0
    }
}
const mE = _p();

function ZF() {
    if (!("fetch" in mE)) return !1;
    try {
        return new Headers, new Request("http://www.example.com"), new Response, !0
    } catch {
        return !1
    }
}

function gE(e) {
    return e && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString())
}

function WX() {
    if (!ZF()) return !1;
    if (gE(mE.fetch)) return !0;
    let e = !1;
    const t = mE.document;
    if (t && typeof t.createElement == "function") try {
        const n = t.createElement("iframe");
        n.hidden = !0, t.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (e = gE(n.contentWindow.fetch)), t.head.removeChild(n)
    } catch (n) {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
    }
    return e
}
const am = _p();

function GX() {
    const e = am.chrome,
        t = e && e.app && e.app.runtime,
        n = "history" in am && !!am.history.pushState && !!am.history.replaceState;
    return !t && n
}
const Nt = _p(),
    yo = "__sentry_xhr_v2__",
    nf = {},
    MC = {};

function qX(e) {
    if (!MC[e]) switch (MC[e] = !0, e) {
        case "console":
            YX();
            break;
        case "dom":
            nQ();
            break;
        case "xhr":
            QX();
            break;
        case "fetch":
            KX();
            break;
        case "history":
            JX();
            break;
        case "error":
            rQ();
            break;
        case "unhandledrejection":
            sQ();
            break;
        default:
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("unknown instrumentation type:", e);
            return
    }
}

function Rn(e, t) {
    nf[e] = nf[e] || [], nf[e].push(t), qX(e)
}

function hs(e, t) {
    if (!(!e || !nf[e]))
        for (const n of nf[e] || []) try {
            n(t)
        } catch (r) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error(`Error while triggering instrumentation handler.
Type: ${e}
Name: ${Wo(n)}
Error:`, r)
        }
}

function YX() {
    "console" in Nt && y_.forEach(function(e) {
        e in Nt.console && On(Nt.console, e, function(t) {
            return function(...n) {
                hs("console", {
                    args: n,
                    level: e
                }), t && t.apply(Nt.console, n)
            }
        })
    })
}

function KX() {
    !WX() || On(Nt, "fetch", function(e) {
        return function(...t) {
            const {
                method: n,
                url: r
            } = XX(t), s = {
                args: t,
                fetchData: {
                    method: n,
                    url: r
                },
                startTimestamp: Date.now()
            };
            return hs("fetch", x({}, s)), e.apply(Nt, t).then(i => (hs("fetch", G(x({}, s), {
                endTimestamp: Date.now(),
                response: i
            })), i), i => {
                throw hs("fetch", G(x({}, s), {
                    endTimestamp: Date.now(),
                    error: i
                })), i
            })
        }
    })
}

function _E(e, t) {
    return !!e && typeof e == "object" && !!e[t]
}

function LC(e) {
    return typeof e == "string" ? e : e ? _E(e, "url") ? e.url : e.toString ? e.toString() : "" : ""
}

function XX(e) {
    if (e.length === 0) return {
        method: "GET",
        url: ""
    };
    if (e.length === 2) {
        const [n, r] = e;
        return {
            url: LC(n),
            method: _E(r, "method") ? String(r.method).toUpperCase() : "GET"
        }
    }
    const t = e[0];
    return {
        url: LC(t),
        method: _E(t, "method") ? String(t.method).toUpperCase() : "GET"
    }
}

function QX() {
    if (!("XMLHttpRequest" in Nt)) return;
    const e = XMLHttpRequest.prototype;
    On(e, "open", function(t) {
        return function(...n) {
            const r = n[1],
                s = this[yo] = {
                    method: jo(n[0]) ? n[0].toUpperCase() : n[0],
                    url: n[1],
                    request_headers: {}
                };
            jo(r) && s.method === "POST" && r.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
            const i = () => {
                const o = this[yo];
                if (!!o && this.readyState === 4) {
                    try {
                        o.status_code = this.status
                    } catch {}
                    hs("xhr", {
                        args: n,
                        endTimestamp: Date.now(),
                        startTimestamp: Date.now(),
                        xhr: this
                    })
                }
            };
            return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? On(this, "onreadystatechange", function(o) {
                return function(...a) {
                    return i(), o.apply(this, a)
                }
            }) : this.addEventListener("readystatechange", i), On(this, "setRequestHeader", function(o) {
                return function(...a) {
                    const [l, c] = a, u = this[yo];
                    return u && (u.request_headers[l.toLowerCase()] = c), o.apply(this, a)
                }
            }), t.apply(this, n)
        }
    }), On(e, "send", function(t) {
        return function(...n) {
            const r = this[yo];
            return r && n[0] !== void 0 && (r.body = n[0]), hs("xhr", {
                args: n,
                startTimestamp: Date.now(),
                xhr: this
            }), t.apply(this, n)
        }
    })
}
let lm;

function JX() {
    if (!GX()) return;
    const e = Nt.onpopstate;
    Nt.onpopstate = function(...n) {
        const r = Nt.location.href,
            s = lm;
        if (lm = r, hs("history", {
                from: s,
                to: r
            }), e) try {
            return e.apply(this, n)
        } catch {}
    };

    function t(n) {
        return function(...r) {
            const s = r.length > 2 ? r[2] : void 0;
            if (s) {
                const i = lm,
                    o = String(s);
                lm = o, hs("history", {
                    from: i,
                    to: o
                })
            }
            return n.apply(this, r)
        }
    }
    On(Nt.history, "pushState", t), On(Nt.history, "replaceState", t)
}
const ZX = 1e3;
let cm, um;

function eQ(e, t) {
    if (!e || e.type !== t.type) return !0;
    try {
        if (e.target !== t.target) return !0
    } catch {}
    return !1
}

function tQ(e) {
    if (e.type !== "keypress") return !1;
    try {
        const t = e.target;
        if (!t || !t.tagName) return !0;
        if (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable) return !1
    } catch {}
    return !0
}

function FC(e, t = !1) {
    return n => {
        if (!n || um === n || tQ(n)) return;
        const r = n.type === "keypress" ? "input" : n.type;
        cm === void 0 ? (e({
            event: n,
            name: r,
            global: t
        }), um = n) : eQ(um, n) && (e({
            event: n,
            name: r,
            global: t
        }), um = n), clearTimeout(cm), cm = Nt.setTimeout(() => {
            cm = void 0
        }, ZX)
    }
}

function nQ() {
    if (!("document" in Nt)) return;
    const e = hs.bind(null, "dom"),
        t = FC(e, !0);
    Nt.document.addEventListener("click", t, !1), Nt.document.addEventListener("keypress", t, !1), ["EventTarget", "Node"].forEach(n => {
        const r = Nt[n] && Nt[n].prototype;
        !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (On(r, "addEventListener", function(s) {
            return function(i, o, a) {
                if (i === "click" || i == "keypress") try {
                    const l = this,
                        c = l.__sentry_instrumentation_handlers__ = l.__sentry_instrumentation_handlers__ || {},
                        u = c[i] = c[i] || {
                            refCount: 0
                        };
                    if (!u.handler) {
                        const d = FC(e);
                        u.handler = d, s.call(this, i, d, a)
                    }
                    u.refCount++
                } catch {}
                return s.call(this, i, o, a)
            }
        }), On(r, "removeEventListener", function(s) {
            return function(i, o, a) {
                if (i === "click" || i == "keypress") try {
                    const l = this,
                        c = l.__sentry_instrumentation_handlers__ || {},
                        u = c[i];
                    u && (u.refCount--, u.refCount <= 0 && (s.call(this, i, u.handler, a), u.handler = void 0, delete c[i]), Object.keys(c).length === 0 && delete l.__sentry_instrumentation_handlers__)
                } catch {}
                return s.call(this, i, o, a)
            }
        }))
    })
}
let dm = null;

function rQ() {
    dm = Nt.onerror, Nt.onerror = function(e, t, n, r, s) {
        return hs("error", {
            column: r,
            error: s,
            line: n,
            msg: e,
            url: t
        }), dm && !dm.__SENTRY_LOADER__ ? dm.apply(this, arguments) : !1
    }, Nt.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let fm = null;

function sQ() {
    fm = Nt.onunhandledrejection, Nt.onunhandledrejection = function(e) {
        return hs("unhandledrejection", e), fm && !fm.__SENTRY_LOADER__ ? fm.apply(this, arguments) : !0
    }, Nt.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}

function iQ() {
    const e = typeof WeakSet == "function",
        t = e ? new WeakSet : [];

    function n(s) {
        if (e) return t.has(s) ? !0 : (t.add(s), !1);
        for (let i = 0; i < t.length; i++)
            if (t[i] === s) return !0;
        return t.push(s), !1
    }

    function r(s) {
        if (e) t.delete(s);
        else
            for (let i = 0; i < t.length; i++)
                if (t[i] === s) {
                    t.splice(i, 1);
                    break
                }
    }
    return [n, r]
}

function di() {
    const e = ur,
        t = e.crypto || e.msCrypto;
    if (t && t.randomUUID) return t.randomUUID().replace(/-/g, "");
    const n = t && t.getRandomValues ? () => t.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;
    return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, r => (r ^ (n() & 15) >> r / 4).toString(16))
}

function eU(e) {
    return e.exception && e.exception.values ? e.exception.values[0] : void 0
}

function fo(e) {
    const {
        message: t,
        event_id: n
    } = e;
    if (t) return t;
    const r = eU(e);
    return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>"
}

function yE(e, t, n) {
    const r = e.exception = e.exception || {},
        s = r.values = r.values || [],
        i = s[0] = s[0] || {};
    i.value || (i.value = t || ""), i.type || (i.type = n || "Error")
}

function uh(e, t) {
    const n = eU(e);
    if (!n) return;
    const r = {
            type: "generic",
            handled: !0
        },
        s = n.mechanism;
    if (n.mechanism = x(x(x({}, r), s), t), t && "data" in t) {
        const i = x(x({}, s && s.data), t.data);
        n.mechanism.data = i
    }
}

function UC(e) {
    if (e && e.__sentry_captured__) return !0;
    try {
        r$(e, "__sentry_captured__", !0)
    } catch {}
    return !1
}

function i$(e) {
    return Array.isArray(e) ? e : [e]
}

function oQ() {
    return typeof __SENTRY_BROWSER_BUNDLE__ != "undefined" && !!__SENTRY_BROWSER_BUNDLE__
}

function aQ() {
    return "npm"
}

function tU() {
    return !oQ() && Object.prototype.toString.call(typeof process != "undefined" ? process : 0) === "[object process]"
}

function lQ(e, t) {
    return e.require(t)
}

function $s(e, t = 100, n = 1 / 0) {
    try {
        return vE("", e, t, n)
    } catch (r) {
        return {
            ERROR: `**non-serializable** (${r})`
        }
    }
}

function nU(e, t = 3, n = 100 * 1024) {
    const r = $s(e, t);
    return fQ(r) > n ? nU(e, t - 1, n) : r
}

function vE(e, t, n = 1 / 0, r = 1 / 0, s = iQ()) {
    const [i, o] = s;
    if (t == null || ["number", "boolean", "string"].includes(typeof t) && !GF(t)) return t;
    const a = cQ(e, t);
    if (!a.startsWith("[object ")) return a;
    if (t.__sentry_skip_normalization__) return t;
    const l = typeof t.__sentry_override_normalization_depth__ == "number" ? t.__sentry_override_normalization_depth__ : n;
    if (l === 0) return a.replace("object ", "");
    if (i(t)) return "[Circular ~]";
    const c = t;
    if (c && typeof c.toJSON == "function") try {
        const h = c.toJSON();
        return vE("", h, l - 1, r, s)
    } catch {}
    const u = Array.isArray(t) ? [] : {};
    let d = 0;
    const f = XF(t);
    for (const h in f) {
        if (!Object.prototype.hasOwnProperty.call(f, h)) continue;
        if (d >= r) {
            u[h] = "[MaxProperties ~]";
            break
        }
        const p = f[h];
        u[h] = vE(h, p, l - 1, r, s), d++
    }
    return o(t), u
}

function cQ(e, t) {
    try {
        if (e === "domain" && t && typeof t == "object" && t._events) return "[Domain]";
        if (e === "domainEmitter") return "[DomainEmitter]";
        if (typeof global != "undefined" && t === global) return "[Global]";
        if (typeof window != "undefined" && t === window) return "[Window]";
        if (typeof document != "undefined" && t === document) return "[Document]";
        if (CX(t)) return "[SyntheticEvent]";
        if (typeof t == "number" && t !== t) return "[NaN]";
        if (typeof t == "function") return `[Function: ${Wo(t)}]`;
        if (typeof t == "symbol") return `[${String(t)}]`;
        if (typeof t == "bigint") return `[BigInt: ${String(t)}]`;
        const n = uQ(t);
        return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
    } catch (n) {
        return `**non-serializable** (${n})`
    }
}

function uQ(e) {
    const t = Object.getPrototypeOf(e);
    return t ? t.constructor.name : "null prototype"
}

function dQ(e) {
    return ~-encodeURI(e).split(/%..|./).length
}

function fQ(e) {
    return dQ(JSON.stringify(e))
}
var ei;
(function(e) {
    e[e.PENDING = 0] = "PENDING";
    const n = 1;
    e[e.RESOLVED = n] = "RESOLVED";
    const r = 2;
    e[e.REJECTED = r] = "REJECTED"
})(ei || (ei = {}));

function ul(e) {
    return new rr(t => {
        t(e)
    })
}

function v_(e) {
    return new rr((t, n) => {
        n(e)
    })
}
class rr {
    __init() {
        this._state = ei.PENDING
    }
    __init2() {
        this._handlers = []
    }
    constructor(t) {
        rr.prototype.__init.call(this), rr.prototype.__init2.call(this), rr.prototype.__init3.call(this), rr.prototype.__init4.call(this), rr.prototype.__init5.call(this), rr.prototype.__init6.call(this);
        try {
            t(this._resolve, this._reject)
        } catch (n) {
            this._reject(n)
        }
    }
    then(t, n) {
        return new rr((r, s) => {
            this._handlers.push([!1, i => {
                if (!t) r(i);
                else try {
                    r(t(i))
                } catch (o) {
                    s(o)
                }
            }, i => {
                if (!n) s(i);
                else try {
                    r(n(i))
                } catch (o) {
                    s(o)
                }
            }]), this._executeHandlers()
        })
    } catch (t) {
        return this.then(n => n, t)
    } finally(t) {
        return new rr((n, r) => {
            let s, i;
            return this.then(o => {
                i = !1, s = o, t && t()
            }, o => {
                i = !0, s = o, t && t()
            }).then(() => {
                if (i) {
                    r(s);
                    return
                }
                n(s)
            })
        })
    }
    __init3() {
        this._resolve = t => {
            this._setResult(ei.RESOLVED, t)
        }
    }
    __init4() {
        this._reject = t => {
            this._setResult(ei.REJECTED, t)
        }
    }
    __init5() {
        this._setResult = (t, n) => {
            if (this._state === ei.PENDING) {
                if (t$(n)) {
                    n.then(this._resolve, this._reject);
                    return
                }
                this._state = t, this._value = n, this._executeHandlers()
            }
        }
    }
    __init6() {
        this._executeHandlers = () => {
            if (this._state === ei.PENDING) return;
            const t = this._handlers.slice();
            this._handlers = [], t.forEach(n => {
                n[0] || (this._state === ei.RESOLVED && n[1](this._value), this._state === ei.REJECTED && n[2](this._value), n[0] = !0)
            })
        }
    }
}

function hQ(e) {
    const t = [];

    function n() {
        return e === void 0 || t.length < e
    }

    function r(o) {
        return t.splice(t.indexOf(o), 1)[0]
    }

    function s(o) {
        if (!n()) return v_(new Vn("Not adding Promise because buffer limit was reached."));
        const a = o();
        return t.indexOf(a) === -1 && t.push(a), a.then(() => r(a)).then(null, () => r(a).then(null, () => {})), a
    }

    function i(o) {
        return new rr((a, l) => {
            let c = t.length;
            if (!c) return a(!0);
            const u = setTimeout(() => {
                o && o > 0 && a(!1)
            }, o);
            t.forEach(d => {
                ul(d).then(() => {
                    --c || (clearTimeout(u), a(!0))
                }, l)
            })
        })
    }
    return {
        $: t,
        add: s,
        drain: i
    }
}

function p0(e) {
    if (!e) return {};
    const t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!t) return {};
    const n = t[6] || "",
        r = t[8] || "";
    return {
        host: t[4],
        path: t[5],
        protocol: t[2],
        search: n,
        hash: r,
        relative: t[5] + n + r
    }
}
const pQ = ["fatal", "error", "warning", "log", "info", "debug"];

function mQ(e) {
    return e === "warn" ? "warning" : pQ.includes(e) ? e : "log"
}
const rU = _p(),
    bE = {
        nowSeconds: () => Date.now() / 1e3
    };

function gQ() {
    const {
        performance: e
    } = rU;
    if (!e || !e.now) return;
    const t = Date.now() - e.now();
    return {
        now: () => e.now(),
        timeOrigin: t
    }
}

function _Q() {
    try {
        return lQ(module, "perf_hooks").performance
    } catch {
        return
    }
}
const m0 = tU() ? _Q() : gQ(),
    BC = m0 === void 0 ? bE : {
        nowSeconds: () => (m0.timeOrigin + m0.now()) / 1e3
    },
    Nv = bE.nowSeconds.bind(bE),
    Go = BC.nowSeconds.bind(BC),
    Ti = (() => {
        const {
            performance: e
        } = rU;
        if (!e || !e.now) return;
        const t = 3600 * 1e3,
            n = e.now(),
            r = Date.now(),
            s = e.timeOrigin ? Math.abs(e.timeOrigin + n - r) : t,
            i = s < t,
            o = e.timing && e.timing.navigationStart,
            l = typeof o == "number" ? Math.abs(o + n - r) : t,
            c = l < t;
        return i || c ? s <= l ? e.timeOrigin : o : r
    })(),
    yQ = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");

function vQ(e) {
    const t = e.match(yQ);
    if (!e || !t) return;
    let n;
    return t[3] === "1" ? n = !0 : t[3] === "0" && (n = !1), {
        traceId: t[1],
        parentSampled: n,
        parentSpanId: t[2]
    }
}

function rd(e, t = []) {
    return [e, t]
}

function bQ(e, t) {
    const [n, r] = e;
    return [n, [...r, t]]
}

function VC(e, t) {
    const n = e[1];
    for (const r of n) {
        const s = r[0].type;
        if (t(r, s)) return !0
    }
    return !1
}

function wE(e, t) {
    return (t || new TextEncoder).encode(e)
}

function wQ(e, t) {
    const [n, r] = e;
    let s = JSON.stringify(n);

    function i(o) {
        typeof s == "string" ? s = typeof o == "string" ? s + o : [wE(s, t), o] : s.push(typeof o == "string" ? wE(o, t) : o)
    }
    for (const o of r) {
        const [a, l] = o;
        if (i(`
${JSON.stringify(a)}
`), typeof l == "string" || l instanceof Uint8Array) i(l);
        else {
            let c;
            try {
                c = JSON.stringify(l)
            } catch {
                c = JSON.stringify($s(l))
            }
            i(c)
        }
    }
    return typeof s == "string" ? s : EQ(s)
}

function EQ(e) {
    const t = e.reduce((s, i) => s + i.length, 0),
        n = new Uint8Array(t);
    let r = 0;
    for (const s of e) n.set(s, r), r += s.length;
    return n
}

function SQ(e, t) {
    const n = typeof e.data == "string" ? wE(e.data, t) : e.data;
    return [Rs({
        type: "attachment",
        length: n.length,
        filename: e.filename,
        content_type: e.contentType,
        attachment_type: e.attachmentType
    }), n]
}
const TQ = {
    session: "session",
    sessions: "session",
    attachment: "attachment",
    transaction: "transaction",
    event: "error",
    client_report: "internal",
    user_report: "default",
    profile: "profile",
    replay_event: "replay",
    replay_recording: "replay",
    check_in: "monitor"
};

function HC(e) {
    return TQ[e]
}

function o$(e) {
    if (!e || !e.sdk) return;
    const {
        name: t,
        version: n
    } = e.sdk;
    return {
        name: t,
        version: n
    }
}

function sU(e, t, n, r) {
    const s = e.sdkProcessingMetadata && e.sdkProcessingMetadata.dynamicSamplingContext;
    return x(x(x({
        event_id: e.event_id,
        sent_at: new Date().toISOString()
    }, t && {
        sdk: t
    }), !!n && {
        dsn: Dv(r)
    }), s && {
        trace: Rs(x({}, s))
    })
}

function $Q(e, t, n) {
    const r = [{
        type: "client_report"
    }, {
        timestamp: n || Nv(),
        discarded_events: e
    }];
    return rd(t ? {
        dsn: t
    } : {}, [r])
}
const kQ = 60 * 1e3;

function IQ(e, t = Date.now()) {
    const n = parseInt(`${e}`, 10);
    if (!isNaN(n)) return n * 1e3;
    const r = Date.parse(`${e}`);
    return isNaN(r) ? kQ : r - t
}

function xQ(e, t) {
    return e[t] || e.all || 0
}

function CQ(e, t, n = Date.now()) {
    return xQ(e, t) > n
}

function AQ(e, {
    statusCode: t,
    headers: n
}, r = Date.now()) {
    const s = x({}, e),
        i = n && n["x-sentry-rate-limits"],
        o = n && n["retry-after"];
    if (i)
        for (const a of i.trim().split(",")) {
            const [l, c] = a.split(":", 2), u = parseInt(l, 10), d = (isNaN(u) ? 60 : u) * 1e3;
            if (!c) s.all = r + d;
            else
                for (const f of c.split(";")) s[f] = r + d
        } else o ? s.all = r + IQ(o, r) : t === 429 && (s.all = r + 60 * 1e3);
    return s
}
const EE = "baggage",
    iU = "sentry-",
    RQ = /^sentry-/,
    OQ = 8192;

function DQ(e) {
    if (!jo(e) && !Array.isArray(e)) return;
    let t = {};
    if (Array.isArray(e)) t = e.reduce((r, s) => {
        const i = jC(s);
        return x(x({}, r), i)
    }, {});
    else {
        if (!e) return;
        t = jC(e)
    }
    const n = Object.entries(t).reduce((r, [s, i]) => {
        if (s.match(RQ)) {
            const o = s.slice(iU.length);
            r[o] = i
        }
        return r
    }, {});
    if (Object.keys(n).length > 0) return n
}

function oU(e) {
    const t = Object.entries(e).reduce((n, [r, s]) => (s && (n[`${iU}${r}`] = s), n), {});
    return NQ(t)
}

function jC(e) {
    return e.split(",").map(t => t.split("=").map(n => decodeURIComponent(n.trim()))).reduce((t, [n, r]) => (t[n] = r, t), {})
}

function NQ(e) {
    if (Object.keys(e).length !== 0) return Object.entries(e).reduce((t, [n, r], s) => {
        const i = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`,
            o = s === 0 ? i : `${t},${i}`;
        return o.length > OQ ? ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`), t) : o
    }, "")
}
const a$ = "production";

function PQ(e) {
    const t = Go(),
        n = {
            sid: di(),
            init: !0,
            timestamp: t,
            started: t,
            duration: 0,
            status: "ok",
            errors: 0,
            ignoreDuration: !1,
            toJSON: () => LQ(n)
        };
    return e && du(n, e), n
}

function du(e, t = {}) {
    if (t.user && (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address), !e.did && !t.did && (e.did = t.user.id || t.user.email || t.user.username)), e.timestamp = t.timestamp || Go(), t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration), t.sid && (e.sid = t.sid.length === 32 ? t.sid : di()), t.init !== void 0 && (e.init = t.init), !e.did && t.did && (e.did = `${t.did}`), typeof t.started == "number" && (e.started = t.started), e.ignoreDuration) e.duration = void 0;
    else if (typeof t.duration == "number") e.duration = t.duration;
    else {
        const n = e.timestamp - e.started;
        e.duration = n >= 0 ? n : 0
    }
    t.release && (e.release = t.release), t.environment && (e.environment = t.environment), !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress), !e.userAgent && t.userAgent && (e.userAgent = t.userAgent), typeof t.errors == "number" && (e.errors = t.errors), t.status && (e.status = t.status)
}

function MQ(e, t) {
    let n = {};
    t ? n = {
        status: t
    } : e.status === "ok" && (n = {
        status: "exited"
    }), du(e, n)
}

function LQ(e) {
    return Rs({
        sid: `${e.sid}`,
        init: e.init,
        started: new Date(e.started * 1e3).toISOString(),
        timestamp: new Date(e.timestamp * 1e3).toISOString(),
        status: e.status,
        errors: e.errors,
        did: typeof e.did == "number" || typeof e.did == "string" ? `${e.did}` : void 0,
        duration: e.duration,
        attrs: {
            release: e.release,
            environment: e.environment,
            ip_address: e.ipAddress,
            user_agent: e.userAgent
        }
    })
}
const FQ = 100;
class ja {
    constructor() {
        this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}
    }
    static clone(t) {
        const n = new ja;
        return t && (n._breadcrumbs = [...t._breadcrumbs], n._tags = x({}, t._tags), n._extra = x({}, t._extra), n._contexts = x({}, t._contexts), n._user = t._user, n._level = t._level, n._span = t._span, n._session = t._session, n._transactionName = t._transactionName, n._fingerprint = t._fingerprint, n._eventProcessors = [...t._eventProcessors], n._requestSession = t._requestSession, n._attachments = [...t._attachments], n._sdkProcessingMetadata = x({}, t._sdkProcessingMetadata)), n
    }
    addScopeListener(t) {
        this._scopeListeners.push(t)
    }
    addEventProcessor(t) {
        return this._eventProcessors.push(t), this
    }
    setUser(t) {
        return this._user = t || {}, this._session && du(this._session, {
            user: t
        }), this._notifyScopeListeners(), this
    }
    getUser() {
        return this._user
    }
    getRequestSession() {
        return this._requestSession
    }
    setRequestSession(t) {
        return this._requestSession = t, this
    }
    setTags(t) {
        return this._tags = x(x({}, this._tags), t), this._notifyScopeListeners(), this
    }
    setTag(t, n) {
        return this._tags = G(x({}, this._tags), {
            [t]: n
        }), this._notifyScopeListeners(), this
    }
    setExtras(t) {
        return this._extra = x(x({}, this._extra), t), this._notifyScopeListeners(), this
    }
    setExtra(t, n) {
        return this._extra = G(x({}, this._extra), {
            [t]: n
        }), this._notifyScopeListeners(), this
    }
    setFingerprint(t) {
        return this._fingerprint = t, this._notifyScopeListeners(), this
    }
    setLevel(t) {
        return this._level = t, this._notifyScopeListeners(), this
    }
    setTransactionName(t) {
        return this._transactionName = t, this._notifyScopeListeners(), this
    }
    setContext(t, n) {
        return n === null ? delete this._contexts[t] : this._contexts[t] = n, this._notifyScopeListeners(), this
    }
    setSpan(t) {
        return this._span = t, this._notifyScopeListeners(), this
    }
    getSpan() {
        return this._span
    }
    getTransaction() {
        const t = this.getSpan();
        return t && t.transaction
    }
    setSession(t) {
        return t ? this._session = t : delete this._session, this._notifyScopeListeners(), this
    }
    getSession() {
        return this._session
    }
    update(t) {
        if (!t) return this;
        if (typeof t == "function") {
            const n = t(this);
            return n instanceof ja ? n : this
        }
        return t instanceof ja ? (this._tags = x(x({}, this._tags), t._tags), this._extra = x(x({}, this._extra), t._extra), this._contexts = x(x({}, this._contexts), t._contexts), t._user && Object.keys(t._user).length && (this._user = t._user), t._level && (this._level = t._level), t._fingerprint && (this._fingerprint = t._fingerprint), t._requestSession && (this._requestSession = t._requestSession)) : uu(t) && (t = t, this._tags = x(x({}, this._tags), t.tags), this._extra = x(x({}, this._extra), t.extra), this._contexts = x(x({}, this._contexts), t.contexts), t.user && (this._user = t.user), t.level && (this._level = t.level), t.fingerprint && (this._fingerprint = t.fingerprint), t.requestSession && (this._requestSession = t.requestSession)), this
    }
    clear() {
        return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this
    }
    addBreadcrumb(t, n) {
        const r = typeof n == "number" ? n : FQ;
        if (r <= 0) return this;
        const s = x({
            timestamp: Nv()
        }, t);
        return this._breadcrumbs = [...this._breadcrumbs, s].slice(-r), this._notifyScopeListeners(), this
    }
    getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1]
    }
    clearBreadcrumbs() {
        return this._breadcrumbs = [], this._notifyScopeListeners(), this
    }
    addAttachment(t) {
        return this._attachments.push(t), this
    }
    getAttachments() {
        return this._attachments
    }
    clearAttachments() {
        return this._attachments = [], this
    }
    applyToEvent(t, n = {}) {
        if (this._extra && Object.keys(this._extra).length && (t.extra = x(x({}, this._extra), t.extra)), this._tags && Object.keys(this._tags).length && (t.tags = x(x({}, this._tags), t.tags)), this._user && Object.keys(this._user).length && (t.user = x(x({}, this._user), t.user)), this._contexts && Object.keys(this._contexts).length && (t.contexts = x(x({}, this._contexts), t.contexts)), this._level && (t.level = this._level), this._transactionName && (t.transaction = this._transactionName), this._span) {
            t.contexts = x({
                trace: this._span.getTraceContext()
            }, t.contexts);
            const r = this._span.transaction;
            if (r) {
                t.sdkProcessingMetadata = x({
                    dynamicSamplingContext: r.getDynamicSamplingContext()
                }, t.sdkProcessingMetadata);
                const s = r.name;
                s && (t.tags = x({
                    transaction: s
                }, t.tags))
            }
        }
        return this._applyFingerprint(t), t.breadcrumbs = [...t.breadcrumbs || [], ...this._breadcrumbs], t.breadcrumbs = t.breadcrumbs.length > 0 ? t.breadcrumbs : void 0, t.sdkProcessingMetadata = x(x({}, t.sdkProcessingMetadata), this._sdkProcessingMetadata), this._notifyEventProcessors([...aU(), ...this._eventProcessors], t, n)
    }
    setSDKProcessingMetadata(t) {
        return this._sdkProcessingMetadata = x(x({}, this._sdkProcessingMetadata), t), this
    }
    _notifyEventProcessors(t, n, r, s = 0) {
        return new rr((i, o) => {
            const a = t[s];
            if (n === null || typeof a != "function") i(n);
            else {
                const l = a(x({}, n), r);
                (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && a.id && l === null && M.log(`Event processor "${a.id}" dropped event`), t$(l) ? l.then(c => this._notifyEventProcessors(t, c, r, s + 1).then(i)).then(null, o) : this._notifyEventProcessors(t, l, r, s + 1).then(i).then(null, o)
            }
        })
    }
    _notifyScopeListeners() {
        this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(t => {
            t(this)
        }), this._notifyingListeners = !1)
    }
    _applyFingerprint(t) {
        t.fingerprint = t.fingerprint ? i$(t.fingerprint) : [], this._fingerprint && (t.fingerprint = t.fingerprint.concat(this._fingerprint)), t.fingerprint && !t.fingerprint.length && delete t.fingerprint
    }
}

function aU() {
    return n$("globalEventProcessors", () => [])
}

function Pv(e) {
    aU().push(e)
}
const lU = 4,
    UQ = 100;
class cU {
    constructor(t, n = new ja, r = lU) {
        this._version = r, this._stack = [{
            scope: n
        }], t && this.bindClient(t)
    }
    isOlderThan(t) {
        return this._version < t
    }
    bindClient(t) {
        const n = this.getStackTop();
        n.client = t, t && t.setupIntegrations && t.setupIntegrations()
    }
    pushScope() {
        const t = ja.clone(this.getScope());
        return this.getStack().push({
            client: this.getClient(),
            scope: t
        }), t
    }
    popScope() {
        return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
    }
    withScope(t) {
        const n = this.pushScope();
        try {
            t(n)
        } finally {
            this.popScope()
        }
    }
    getClient() {
        return this.getStackTop().client
    }
    getScope() {
        return this.getStackTop().scope
    }
    getStack() {
        return this._stack
    }
    getStackTop() {
        return this._stack[this._stack.length - 1]
    }
    captureException(t, n) {
        const r = this._lastEventId = n && n.event_id ? n.event_id : di(),
            s = new Error("Sentry syntheticException");
        return this._withClient((i, o) => {
            i.captureException(t, G(x({
                originalException: t,
                syntheticException: s
            }, n), {
                event_id: r
            }), o)
        }), r
    }
    captureMessage(t, n, r) {
        const s = this._lastEventId = r && r.event_id ? r.event_id : di(),
            i = new Error(t);
        return this._withClient((o, a) => {
            o.captureMessage(t, n, G(x({
                originalException: t,
                syntheticException: i
            }, r), {
                event_id: s
            }), a)
        }), s
    }
    captureEvent(t, n) {
        const r = n && n.event_id ? n.event_id : di();
        return t.type || (this._lastEventId = r), this._withClient((s, i) => {
            s.captureEvent(t, G(x({}, n), {
                event_id: r
            }), i)
        }), r
    }
    lastEventId() {
        return this._lastEventId
    }
    addBreadcrumb(t, n) {
        const {
            scope: r,
            client: s
        } = this.getStackTop();
        if (!s) return;
        const {
            beforeBreadcrumb: i = null,
            maxBreadcrumbs: o = UQ
        } = s.getOptions && s.getOptions() || {};
        if (o <= 0) return;
        const a = Nv(),
            l = x({
                timestamp: a
            }, t),
            c = i ? YF(() => i(l, n)) : l;
        c !== null && (s.emit && s.emit("beforeAddBreadcrumb", c, n), r.addBreadcrumb(c, o))
    }
    setUser(t) {
        this.getScope().setUser(t)
    }
    setTags(t) {
        this.getScope().setTags(t)
    }
    setExtras(t) {
        this.getScope().setExtras(t)
    }
    setTag(t, n) {
        this.getScope().setTag(t, n)
    }
    setExtra(t, n) {
        this.getScope().setExtra(t, n)
    }
    setContext(t, n) {
        this.getScope().setContext(t, n)
    }
    configureScope(t) {
        const {
            scope: n,
            client: r
        } = this.getStackTop();
        r && t(n)
    }
    run(t) {
        const n = zC(this);
        try {
            t(this)
        } finally {
            zC(n)
        }
    }
    getIntegration(t) {
        const n = this.getClient();
        if (!n) return null;
        try {
            return n.getIntegration(t)
        } catch {
            return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Cannot retrieve integration ${t.id} from the current Hub`), null
        }
    }
    startTransaction(t, n) {
        const r = this._callExtensionMethod("startTransaction", t, n);
        return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && !r && console.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`), r
    }
    traceHeaders() {
        return this._callExtensionMethod("traceHeaders")
    }
    captureSession(t = !1) {
        if (t) return this.endSession();
        this._sendSessionUpdate()
    }
    endSession() {
        const n = this.getStackTop().scope,
            r = n.getSession();
        r && MQ(r), this._sendSessionUpdate(), n.setSession()
    }
    startSession(t) {
        const {
            scope: n,
            client: r
        } = this.getStackTop(), {
            release: s,
            environment: i = a$
        } = r && r.getOptions() || {}, {
            userAgent: o
        } = ur.navigator || {}, a = PQ(x(x({
            release: s,
            environment: i,
            user: n.getUser()
        }, o && {
            userAgent: o
        }), t)), l = n.getSession && n.getSession();
        return l && l.status === "ok" && du(l, {
            status: "exited"
        }), this.endSession(), n.setSession(a), a
    }
    shouldSendDefaultPii() {
        const t = this.getClient(),
            n = t && t.getOptions();
        return Boolean(n && n.sendDefaultPii)
    }
    _sendSessionUpdate() {
        const {
            scope: t,
            client: n
        } = this.getStackTop(), r = t.getSession();
        r && n && n.captureSession && n.captureSession(r)
    }
    _withClient(t) {
        const {
            scope: n,
            client: r
        } = this.getStackTop();
        r && t(r, n)
    }
    _callExtensionMethod(t, ...n) {
        const s = yp().__SENTRY__;
        if (s && s.extensions && typeof s.extensions[t] == "function") return s.extensions[t].apply(this, n);
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Extension method ${t} couldn't be found, doing nothing.`)
    }
}

function yp() {
    return ur.__SENTRY__ = ur.__SENTRY__ || {
        extensions: {},
        hub: void 0
    }, ur
}

function zC(e) {
    const t = yp(),
        n = SE(t);
    return uU(t, e), n
}

function Ne() {
    const e = yp();
    if (e.__SENTRY__ && e.__SENTRY__.acs) {
        const t = e.__SENTRY__.acs.getCurrentHub();
        if (t) return t
    }
    return BQ(e)
}

function BQ(e = yp()) {
    return (!VQ(e) || SE(e).isOlderThan(lU)) && uU(e, new cU), SE(e)
}

function VQ(e) {
    return !!(e && e.__SENTRY__ && e.__SENTRY__.hub)
}

function SE(e) {
    return n$("hub", () => new cU, e)
}

function uU(e, t) {
    if (!e) return !1;
    const n = e.__SENTRY__ = e.__SENTRY__ || {};
    return n.hub = t, !0
}

function Mv(e) {
    if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1;
    const t = Ne().getClient(),
        n = e || t && t.getOptions();
    return !!n && (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n)
}

function vp(e) {
    return (e || Ne()).getScope().getTransaction()
}
let WC = !1;

function HQ() {
    WC || (WC = !0, Rn("error", TE), Rn("unhandledrejection", TE))
}

function TE() {
    const e = vp();
    if (e) {
        const t = "internal_error";
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] Transaction: ${t} -> Global error occured`), e.setStatus(t)
    }
}
TE.tag = "sentry_tracingErrorCallback";
class Lv {
    __init() {
        this.spans = []
    }
    constructor(t = 1e3) {
        Lv.prototype.__init.call(this), this._maxlen = t
    }
    add(t) {
        this.spans.length > this._maxlen ? t.spanRecorder = void 0 : this.spans.push(t)
    }
}
class ti {
    __init2() {
        this.traceId = di()
    }
    __init3() {
        this.spanId = di().substring(16)
    }
    __init4() {
        this.startTimestamp = Go()
    }
    __init5() {
        this.tags = {}
    }
    __init6() {
        this.data = {}
    }
    __init7() {
        this.instrumenter = "sentry"
    }
    constructor(t) {
        if (ti.prototype.__init2.call(this), ti.prototype.__init3.call(this), ti.prototype.__init4.call(this), ti.prototype.__init5.call(this), ti.prototype.__init6.call(this), ti.prototype.__init7.call(this), !t) return this;
        t.traceId && (this.traceId = t.traceId), t.spanId && (this.spanId = t.spanId), t.parentSpanId && (this.parentSpanId = t.parentSpanId), "sampled" in t && (this.sampled = t.sampled), t.op && (this.op = t.op), t.description && (this.description = t.description), t.data && (this.data = t.data), t.tags && (this.tags = t.tags), t.status && (this.status = t.status), t.startTimestamp && (this.startTimestamp = t.startTimestamp), t.endTimestamp && (this.endTimestamp = t.endTimestamp), t.instrumenter && (this.instrumenter = t.instrumenter)
    }
    startChild(t) {
        const n = new ti(G(x({}, t), {
            parentSpanId: this.spanId,
            sampled: this.sampled,
            traceId: this.traceId
        }));
        if (n.spanRecorder = this.spanRecorder, n.spanRecorder && n.spanRecorder.add(n), n.transaction = this.transaction, (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && n.transaction) {
            const r = t && t.op || "< unknown op >",
                s = n.transaction.name || "< unknown name >",
                i = n.transaction.spanId,
                o = `[Tracing] Starting '${r}' span on transaction '${s}' (${i}).`;
            n.transaction.metadata.spanMetadata[n.spanId] = {
                logMessage: o
            }, M.log(o)
        }
        return n
    }
    setTag(t, n) {
        return this.tags = G(x({}, this.tags), {
            [t]: n
        }), this
    }
    setData(t, n) {
        return this.data = G(x({}, this.data), {
            [t]: n
        }), this
    }
    setStatus(t) {
        return this.status = t, this
    }
    setHttpStatus(t) {
        this.setTag("http.status_code", String(t));
        const n = jQ(t);
        return n !== "unknown_error" && this.setStatus(n), this
    }
    isSuccess() {
        return this.status === "ok"
    }
    finish(t) {
        if ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && this.transaction && this.transaction.spanId !== this.spanId) {
            const {
                logMessage: n
            } = this.transaction.metadata.spanMetadata[this.spanId];
            n && M.log(n.replace("Starting", "Finishing"))
        }
        this.endTimestamp = typeof t == "number" ? t : Go()
    }
    toTraceparent() {
        let t = "";
        return this.sampled !== void 0 && (t = this.sampled ? "-1" : "-0"), `${this.traceId}-${this.spanId}${t}`
    }
    toContext() {
        return Rs({
            data: this.data,
            description: this.description,
            endTimestamp: this.endTimestamp,
            op: this.op,
            parentSpanId: this.parentSpanId,
            sampled: this.sampled,
            spanId: this.spanId,
            startTimestamp: this.startTimestamp,
            status: this.status,
            tags: this.tags,
            traceId: this.traceId
        })
    }
    updateWithContext(t) {
        return this.data = t.data || {}, this.description = t.description, this.endTimestamp = t.endTimestamp, this.op = t.op, this.parentSpanId = t.parentSpanId, this.sampled = t.sampled, this.spanId = t.spanId || this.spanId, this.startTimestamp = t.startTimestamp || this.startTimestamp, this.status = t.status, this.tags = t.tags || {}, this.traceId = t.traceId || this.traceId, this
    }
    getTraceContext() {
        return Rs({
            data: Object.keys(this.data).length > 0 ? this.data : void 0,
            description: this.description,
            op: this.op,
            parent_span_id: this.parentSpanId,
            span_id: this.spanId,
            status: this.status,
            tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
            trace_id: this.traceId
        })
    }
    toJSON() {
        return Rs({
            data: Object.keys(this.data).length > 0 ? this.data : void 0,
            description: this.description,
            op: this.op,
            parent_span_id: this.parentSpanId,
            span_id: this.spanId,
            start_timestamp: this.startTimestamp,
            status: this.status,
            tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
            timestamp: this.endTimestamp,
            trace_id: this.traceId
        })
    }
}

function jQ(e) {
    if (e < 400 && e >= 100) return "ok";
    if (e >= 400 && e < 500) switch (e) {
        case 401:
            return "unauthenticated";
        case 403:
            return "permission_denied";
        case 404:
            return "not_found";
        case 409:
            return "already_exists";
        case 413:
            return "failed_precondition";
        case 429:
            return "resource_exhausted";
        default:
            return "invalid_argument"
    }
    if (e >= 500 && e < 600) switch (e) {
        case 501:
            return "unimplemented";
        case 503:
            return "unavailable";
        case 504:
            return "deadline_exceeded";
        default:
            return "internal_error"
    }
    return "unknown_error"
}
class Rc extends ti {
    __init() {
        this._measurements = {}
    }
    __init2() {
        this._contexts = {}
    }
    __init3() {
        this._frozenDynamicSamplingContext = void 0
    }
    constructor(t, n) {
        super(t), Rc.prototype.__init.call(this), Rc.prototype.__init2.call(this), Rc.prototype.__init3.call(this), this._hub = n || Ne(), this._name = t.name || "", this.metadata = G(x({
            source: "custom"
        }, t.metadata), {
            spanMetadata: {}
        }), this._trimEnd = t.trimEnd, this.transaction = this;
        const r = this.metadata.dynamicSamplingContext;
        r && (this._frozenDynamicSamplingContext = x({}, r))
    }
    get name() {
        return this._name
    }
    set name(t) {
        this.setName(t)
    }
    setName(t, n = "custom") {
        this._name = t, this.metadata.source = n
    }
    initSpanRecorder(t = 1e3) {
        this.spanRecorder || (this.spanRecorder = new Lv(t)), this.spanRecorder.add(this)
    }
    setContext(t, n) {
        n === null ? delete this._contexts[t] : this._contexts[t] = n
    }
    setMeasurement(t, n, r = "") {
        this._measurements[t] = {
            value: n,
            unit: r
        }
    }
    setMetadata(t) {
        this.metadata = x(x({}, this.metadata), t)
    }
    finish(t) {
        if (this.endTimestamp !== void 0) return;
        this.name || ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this.name = "<unlabeled transaction>"), super.finish(t);
        const n = this._hub.getClient();
        if (n && n.emit && n.emit("finishTransaction", this), this.sampled !== !0) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), n && n.recordDroppedEvent("sample_rate", "transaction");
            return
        }
        const r = this.spanRecorder ? this.spanRecorder.spans.filter(a => a !== this && a.endTimestamp) : [];
        this._trimEnd && r.length > 0 && (this.endTimestamp = r.reduce((a, l) => a.endTimestamp && l.endTimestamp ? a.endTimestamp > l.endTimestamp ? a : l : a).endTimestamp);
        const s = this.metadata,
            i = x({
                contexts: G(x({}, this._contexts), {
                    trace: this.getTraceContext()
                }),
                spans: r,
                start_timestamp: this.startTimestamp,
                tags: this.tags,
                timestamp: this.endTimestamp,
                transaction: this.name,
                type: "transaction",
                sdkProcessingMetadata: G(x({}, s), {
                    dynamicSamplingContext: this.getDynamicSamplingContext()
                })
            }, s.source && {
                transaction_info: {
                    source: s.source
                }
            });
        return Object.keys(this._measurements).length > 0 && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2)), i.measurements = this._measurements), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`), this._hub.captureEvent(i)
    }
    toContext() {
        const t = super.toContext();
        return Rs(G(x({}, t), {
            name: this.name,
            trimEnd: this._trimEnd
        }))
    }
    updateWithContext(t) {
        return super.updateWithContext(t), this.name = t.name || "", this._trimEnd = t.trimEnd, this
    }
    getDynamicSamplingContext() {
        if (this._frozenDynamicSamplingContext) return this._frozenDynamicSamplingContext;
        const t = this._hub || Ne(),
            n = t && t.getClient();
        if (!n) return {};
        const {
            environment: r,
            release: s
        } = n.getOptions() || {}, {
            publicKey: i
        } = n.getDsn() || {}, o = this.metadata.sampleRate, a = o !== void 0 ? o.toString() : void 0, {
            segment: l
        } = t.getScope().getUser() || {}, c = this.metadata.source, u = c && c !== "url" ? this.name : void 0, d = Rs({
            environment: r || a$,
            release: s,
            transaction: u,
            user_segment: l,
            public_key: i,
            trace_id: this.traceId,
            sample_rate: a
        });
        return n.emit && n.emit("createDsc", d), d
    }
    setHub(t) {
        this._hub = t
    }
}
const og = {
        idleTimeout: 1e3,
        finalTimeout: 3e4,
        heartbeatInterval: 5e3
    },
    zQ = "finishReason",
    Kl = ["heartbeatFailed", "idleTimeout", "documentHidden", "finalTimeout", "externalFinish", "cancelled"];
class WQ extends Lv {
    constructor(t, n, r, s) {
        super(s), this._pushActivity = t, this._popActivity = n, this.transactionSpanId = r
    }
    add(t) {
        t.spanId !== this.transactionSpanId && (t.finish = n => {
            t.endTimestamp = typeof n == "number" ? n : Go(), this._popActivity(t.spanId)
        }, t.endTimestamp === void 0 && this._pushActivity(t.spanId)), super.add(t)
    }
}
class ao extends Rc {
    __init() {
        this.activities = {}
    }
    __init2() {
        this._heartbeatCounter = 0
    }
    __init3() {
        this._finished = !1
    }
    __init4() {
        this._idleTimeoutCanceledPermanently = !1
    }
    __init5() {
        this._beforeFinishCallbacks = []
    }
    __init6() {
        this._finishReason = Kl[4]
    }
    constructor(t, n, r = og.idleTimeout, s = og.finalTimeout, i = og.heartbeatInterval, o = !1) {
        super(t, n), this._idleHub = n, this._idleTimeout = r, this._finalTimeout = s, this._heartbeatInterval = i, this._onScope = o, ao.prototype.__init.call(this), ao.prototype.__init2.call(this), ao.prototype.__init3.call(this), ao.prototype.__init4.call(this), ao.prototype.__init5.call(this), ao.prototype.__init6.call(this), o && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`), n.configureScope(a => a.setSpan(this))), this._restartIdleTimeout(), setTimeout(() => {
            this._finished || (this.setStatus("deadline_exceeded"), this._finishReason = Kl[3], this.finish())
        }, this._finalTimeout)
    }
    finish(t = Go()) {
        if (this._finished = !0, this.activities = {}, this.op === "ui.action.click" && this.setTag(zQ, this._finishReason), this.spanRecorder) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] finishing IdleTransaction", new Date(t * 1e3).toISOString(), this.op);
            for (const n of this._beforeFinishCallbacks) n(this, t);
            this.spanRecorder.spans = this.spanRecorder.spans.filter(n => {
                if (n.spanId === this.spanId) return !0;
                n.endTimestamp || (n.endTimestamp = t, n.setStatus("cancelled"), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(n, void 0, 2)));
                const r = n.startTimestamp < t;
                return r || (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(n, void 0, 2)), r
            }), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] flushing IdleTransaction")
        } else(typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] No active IdleTransaction");
        if (this._onScope) {
            const n = this._idleHub.getScope();
            n.getTransaction() === this && n.setSpan(void 0)
        }
        return super.finish(t)
    }
    registerBeforeFinishCallback(t) {
        this._beforeFinishCallbacks.push(t)
    }
    initSpanRecorder(t) {
        if (!this.spanRecorder) {
            const n = s => {
                    this._finished || this._pushActivity(s)
                },
                r = s => {
                    this._finished || this._popActivity(s)
                };
            this.spanRecorder = new WQ(n, r, this.spanId, t), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("Starting heartbeat"), this._pingHeartbeat()
        }
        this.spanRecorder.add(this)
    }
    cancelIdleTimeout(t, {
        restartOnChildSpanChange: n
    } = {
        restartOnChildSpanChange: !0
    }) {
        this._idleTimeoutCanceledPermanently = n === !1, this._idleTimeoutID && (clearTimeout(this._idleTimeoutID), this._idleTimeoutID = void 0, Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently && (this._finishReason = Kl[5], this.finish(t)))
    }
    setFinishReason(t) {
        this._finishReason = t
    }
    _restartIdleTimeout(t) {
        this.cancelIdleTimeout(), this._idleTimeoutID = setTimeout(() => {
            !this._finished && Object.keys(this.activities).length === 0 && (this._finishReason = Kl[1], this.finish(t))
        }, this._idleTimeout)
    }
    _pushActivity(t) {
        this.cancelIdleTimeout(void 0, {
            restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently
        }), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] pushActivity: ${t}`), this.activities[t] = !0, (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] new activities count", Object.keys(this.activities).length)
    }
    _popActivity(t) {
        if (this.activities[t] && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] popActivity ${t}`), delete this.activities[t], (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] new activities count", Object.keys(this.activities).length)), Object.keys(this.activities).length === 0) {
            const n = Go();
            this._idleTimeoutCanceledPermanently ? (this._finishReason = Kl[5], this.finish(n)) : this._restartIdleTimeout(n + this._idleTimeout / 1e3)
        }
    }
    _beat() {
        if (this._finished) return;
        const t = Object.keys(this.activities).join("");
        t === this._prevHeartbeatString ? this._heartbeatCounter++ : this._heartbeatCounter = 1, this._prevHeartbeatString = t, this._heartbeatCounter >= 3 ? ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] Transaction finished because of no change for 3 heart beats"), this.setStatus("deadline_exceeded"), this._finishReason = Kl[0], this.finish()) : this._pingHeartbeat()
    }
    _pingHeartbeat() {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`), setTimeout(() => {
            this._beat()
        }, this._heartbeatInterval)
    }
}

function GQ() {
    const t = this.getScope().getSpan();
    return t ? {
        "sentry-trace": t.toTraceparent()
    } : {}
}

function dU(e, t, n) {
    if (!Mv(t)) return e.sampled = !1, e;
    if (e.sampled !== void 0) return e.setMetadata({
        sampleRate: Number(e.sampled)
    }), e;
    let r;
    return typeof t.tracesSampler == "function" ? (r = t.tracesSampler(n), e.setMetadata({
        sampleRate: Number(r)
    })) : n.parentSampled !== void 0 ? r = n.parentSampled : typeof t.tracesSampleRate != "undefined" ? (r = t.tracesSampleRate, e.setMetadata({
        sampleRate: Number(r)
    })) : (r = 1, e.setMetadata({
        sampleRate: r
    })), qQ(r) ? r ? (e.sampled = Math.random() < r, e.sampled ? ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] starting ${e.op} transaction - ${e.name}`), e) : ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(r)})`), e)) : ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] Discarding transaction because ${typeof t.tracesSampler=="function"?"tracesSampler returned 0 or false":"a negative sampling decision was inherited or tracesSampleRate is set to 0"}`), e.sampled = !1, e) : ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("[Tracing] Discarding transaction because of invalid sample rate."), e.sampled = !1, e)
}

function qQ(e) {
    return GF(e) || !(typeof e == "number" || typeof e == "boolean") ? ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(e)} of type ${JSON.stringify(typeof e)}.`), !1) : e < 0 || e > 1 ? ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${e}.`), !1) : !0
}

function YQ(e, t) {
    const n = this.getClient(),
        r = n && n.getOptions() || {},
        s = r.instrumenter || "sentry",
        i = e.instrumenter || "sentry";
    s !== i && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error(`A transaction was started with instrumenter=\`${i}\`, but the SDK is configured with the \`${s}\` instrumenter.
The transaction will not be sampled. Please use the ${s} instrumentation to start transactions.`), e.sampled = !1);
    let o = new Rc(e, this);
    return o = dU(o, r, x({
        parentSampled: e.parentSampled,
        transactionContext: e
    }, t)), o.sampled && o.initSpanRecorder(r._experiments && r._experiments.maxSpans), n && n.emit && n.emit("startTransaction", o), o
}

function GC(e, t, n, r, s, i, o) {
    const a = e.getClient(),
        l = a && a.getOptions() || {};
    let c = new ao(t, e, n, r, o, s);
    return c = dU(c, l, x({
        parentSampled: t.parentSampled,
        transactionContext: t
    }, i)), c.sampled && c.initSpanRecorder(l._experiments && l._experiments.maxSpans), a && a.emit && a.emit("startTransaction", c), c
}

function KQ() {
    const e = yp();
    !e.__SENTRY__ || (e.__SENTRY__.extensions = e.__SENTRY__.extensions || {}, e.__SENTRY__.extensions.startTransaction || (e.__SENTRY__.extensions.startTransaction = YQ), e.__SENTRY__.extensions.traceHeaders || (e.__SENTRY__.extensions.traceHeaders = GQ), HQ())
}

function dl(e, t) {
    return Ne().captureException(e, {
        captureContext: t
    })
}

function XQ(e) {
    Ne().addBreadcrumb(e)
}

function l$(e, t) {
    Ne().setContext(e, t)
}

function QQ(e) {
    Ne().setUser(e)
}

function JQ(e) {
    Ne().withScope(e)
}
const ZQ = "7";

function eJ(e) {
    const t = e.protocol ? `${e.protocol}:` : "",
        n = e.port ? `:${e.port}` : "";
    return `${t}//${e.host}${n}${e.path?`/${e.path}`:""}/api/`
}

function tJ(e) {
    return `${eJ(e)}${e.projectId}/envelope/`
}

function nJ(e, t) {
    return VX(x({
        sentry_key: e.publicKey,
        sentry_version: ZQ
    }, t && {
        sentry_client: `${t.name}/${t.version}`
    }))
}

function rJ(e, t = {}) {
    const n = typeof t == "string" ? t : t.tunnel,
        r = typeof t == "string" || !t._metadata ? void 0 : t._metadata.sdk;
    return n || `${tJ(e)}?${nJ(e,r)}`
}

function sJ(e, t) {
    return t && (e.sdk = e.sdk || {}, e.sdk.name = e.sdk.name || t.name, e.sdk.version = e.sdk.version || t.version, e.sdk.integrations = [...e.sdk.integrations || [], ...t.integrations || []], e.sdk.packages = [...e.sdk.packages || [], ...t.packages || []]), e
}

function iJ(e, t, n, r) {
    const s = o$(n),
        i = x(x({
            sent_at: new Date().toISOString()
        }, s && {
            sdk: s
        }), !!r && {
            dsn: Dv(t)
        }),
        o = "aggregates" in e ? [{
            type: "sessions"
        }, e] : [{
            type: "session"
        }, e];
    return rd(i, [o])
}

function oJ(e, t, n, r) {
    const s = o$(n),
        i = e.type && e.type !== "replay_event" ? e.type : "event";
    sJ(e, n && n.sdk);
    const o = sU(e, s, r, t);
    return delete e.sdkProcessingMetadata, rd(o, [
        [{
            type: i
        }, e]
    ])
}
const qC = [];

function aJ(e) {
    const t = {};
    return e.forEach(n => {
        const {
            name: r
        } = n, s = t[r];
        s && !s.isDefaultInstance && n.isDefaultInstance || (t[r] = n)
    }), Object.keys(t).map(n => t[n])
}

function lJ(e) {
    const t = e.defaultIntegrations || [],
        n = e.integrations;
    t.forEach(o => {
        o.isDefaultInstance = !0
    });
    let r;
    Array.isArray(n) ? r = [...t, ...n] : typeof n == "function" ? r = i$(n(t)) : r = t;
    const s = aJ(r),
        i = uJ(s, o => o.name === "Debug");
    if (i !== -1) {
        const [o] = s.splice(i, 1);
        s.push(o)
    }
    return s
}

function cJ(e) {
    const t = {};
    return e.forEach(n => {
        n && fU(n, t)
    }), t
}

function fU(e, t) {
    t[e.name] = e, qC.indexOf(e.name) === -1 && (e.setupOnce(Pv, Ne), qC.push(e.name), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`Integration installed: ${e.name}`))
}

function uJ(e, t) {
    for (let n = 0; n < e.length; n++)
        if (t(e[n]) === !0) return n;
    return -1
}

function hU(e, t, n, r) {
    const {
        normalizeDepth: s = 3,
        normalizeMaxBreadth: i = 1e3
    } = e, o = G(x({}, t), {
        event_id: t.event_id || n.event_id || di(),
        timestamp: t.timestamp || Nv()
    }), a = n.integrations || e.integrations.map(u => u.name);
    dJ(o, e), hJ(o, a), t.type === void 0 && fJ(o, e.stackParser);
    let l = r;
    n.captureContext && (l = ja.clone(l).update(n.captureContext));
    let c = ul(o);
    if (l) {
        if (l.getAttachments) {
            const u = [...n.attachments || [], ...l.getAttachments()];
            u.length && (n.attachments = u)
        }
        c = l.applyToEvent(o, n)
    }
    return c.then(u => typeof s == "number" && s > 0 ? pJ(u, s, i) : u)
}

function dJ(e, t) {
    const {
        environment: n,
        release: r,
        dist: s,
        maxValueLength: i = 250
    } = t;
    "environment" in e || (e.environment = "environment" in t ? n : a$), e.release === void 0 && r !== void 0 && (e.release = r), e.dist === void 0 && s !== void 0 && (e.dist = s), e.message && (e.message = tf(e.message, i));
    const o = e.exception && e.exception.values && e.exception.values[0];
    o && o.value && (o.value = tf(o.value, i));
    const a = e.request;
    a && a.url && (a.url = tf(a.url, i))
}
const YC = new WeakMap;

function fJ(e, t) {
    const n = ur._sentryDebugIds;
    if (!n) return;
    let r;
    const s = YC.get(t);
    s ? r = s : (r = new Map, YC.set(t, r));
    const i = Object.keys(n).reduce((l, c) => {
            let u;
            const d = r.get(c);
            d ? u = d : (u = t(c), r.set(c, u));
            for (let f = u.length - 1; f >= 0; f--) {
                const h = u[f];
                if (h.filename) {
                    l[h.filename] = n[c];
                    break
                }
            }
            return l
        }, {}),
        o = new Set;
    try {
        e.exception.values.forEach(l => {
            l.stacktrace.frames.forEach(c => {
                c.filename && o.add(c.filename)
            })
        })
    } catch {}
    e.debug_meta = e.debug_meta || {}, e.debug_meta.images = e.debug_meta.images || [];
    const a = e.debug_meta.images;
    o.forEach(l => {
        i[l] && a.push({
            type: "sourcemap",
            code_file: l,
            debug_id: i[l]
        })
    })
}

function hJ(e, t) {
    t.length > 0 && (e.sdk = e.sdk || {}, e.sdk.integrations = [...e.sdk.integrations || [], ...t])
}

function pJ(e, t, n) {
    if (!e) return null;
    const r = x(x(x(x(x({}, e), e.breadcrumbs && {
        breadcrumbs: e.breadcrumbs.map(s => x(x({}, s), s.data && {
            data: $s(s.data, t, n)
        }))
    }), e.user && {
        user: $s(e.user, t, n)
    }), e.contexts && {
        contexts: $s(e.contexts, t, n)
    }), e.extra && {
        extra: $s(e.extra, t, n)
    });
    return e.contexts && e.contexts.trace && r.contexts && (r.contexts.trace = e.contexts.trace, e.contexts.trace.data && (r.contexts.trace.data = $s(e.contexts.trace.data, t, n))), e.spans && (r.spans = e.spans.map(s => (s.data && (s.data = $s(s.data, t, n)), s))), r
}
const KC = "Not capturing exception because it's already been captured.";
class $a {
    __init() {
        this._integrations = {}
    }
    __init2() {
        this._integrationsInitialized = !1
    }
    __init3() {
        this._numProcessing = 0
    }
    __init4() {
        this._outcomes = {}
    }
    __init5() {
        this._hooks = {}
    }
    constructor(t) {
        if ($a.prototype.__init.call(this), $a.prototype.__init2.call(this), $a.prototype.__init3.call(this), $a.prototype.__init4.call(this), $a.prototype.__init5.call(this), this._options = t, t.dsn) {
            this._dsn = FX(t.dsn);
            const n = rJ(this._dsn, t);
            this._transport = t.transport(G(x({
                recordDroppedEvent: this.recordDroppedEvent.bind(this)
            }, t.transportOptions), {
                url: n
            }))
        } else(typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("No DSN provided, client will not do anything.")
    }
    captureException(t, n, r) {
        if (UC(t)) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(KC);
            return
        }
        let s = n && n.event_id;
        return this._process(this.eventFromException(t, n).then(i => this._captureEvent(i, n, r)).then(i => {
            s = i
        })), s
    }
    captureMessage(t, n, r, s) {
        let i = r && r.event_id;
        const o = WF(t) ? this.eventFromMessage(String(t), n, r) : this.eventFromException(t, r);
        return this._process(o.then(a => this._captureEvent(a, r, s)).then(a => {
            i = a
        })), i
    }
    captureEvent(t, n, r) {
        if (n && n.originalException && UC(n.originalException)) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(KC);
            return
        }
        let s = n && n.event_id;
        return this._process(this._captureEvent(t, n, r).then(i => {
            s = i
        })), s
    }
    captureSession(t) {
        if (!this._isEnabled()) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("SDK not enabled, will not capture session.");
            return
        }
        typeof t.release != "string" ? (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("Discarded session because of missing or non-string release") : (this.sendSession(t), du(t, {
            init: !1
        }))
    }
    getDsn() {
        return this._dsn
    }
    getOptions() {
        return this._options
    }
    getSdkMetadata() {
        return this._options._metadata
    }
    getTransport() {
        return this._transport
    }
    flush(t) {
        const n = this._transport;
        return n ? this._isClientDoneProcessing(t).then(r => n.flush(t).then(s => r && s)) : ul(!0)
    }
    close(t) {
        return this.flush(t).then(n => (this.getOptions().enabled = !1, n))
    }
    setupIntegrations() {
        this._isEnabled() && !this._integrationsInitialized && (this._integrations = cJ(this._options.integrations), this._integrationsInitialized = !0)
    }
    getIntegrationById(t) {
        return this._integrations[t]
    }
    getIntegration(t) {
        try {
            return this._integrations[t.id] || null
        } catch {
            return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Cannot retrieve integration ${t.id} from the current Client`), null
        }
    }
    addIntegration(t) {
        fU(t, this._integrations)
    }
    sendEvent(t, n = {}) {
        if (this._dsn) {
            let r = oJ(t, this._dsn, this._options._metadata, this._options.tunnel);
            for (const i of n.attachments || []) r = bQ(r, SQ(i, this._options.transportOptions && this._options.transportOptions.textEncoder));
            const s = this._sendEnvelope(r);
            s && s.then(i => this.emit("afterSendEvent", t, i), null)
        }
    }
    sendSession(t) {
        if (this._dsn) {
            const n = iJ(t, this._dsn, this._options._metadata, this._options.tunnel);
            this._sendEnvelope(n)
        }
    }
    recordDroppedEvent(t, n, r) {
        if (this._options.sendClientReports) {
            const s = `${t}:${n}`;
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`Adding outcome: "${s}"`), this._outcomes[s] = this._outcomes[s] + 1 || 1
        }
    }
    on(t, n) {
        this._hooks[t] || (this._hooks[t] = []), this._hooks[t].push(n)
    }
    emit(t, ...n) {
        this._hooks[t] && this._hooks[t].forEach(r => r(...n))
    }
    _updateSessionFromEvent(t, n) {
        let r = !1,
            s = !1;
        const i = n.exception && n.exception.values;
        if (i) {
            s = !0;
            for (const l of i) {
                const c = l.mechanism;
                if (c && c.handled === !1) {
                    r = !0;
                    break
                }
            }
        }
        const o = t.status === "ok";
        (o && t.errors === 0 || o && r) && (du(t, G(x({}, r && {
            status: "crashed"
        }), {
            errors: t.errors || Number(s || r)
        })), this.captureSession(t))
    }
    _isClientDoneProcessing(t) {
        return new rr(n => {
            let r = 0;
            const s = 1,
                i = setInterval(() => {
                    this._numProcessing == 0 ? (clearInterval(i), n(!0)) : (r += s, t && r >= t && (clearInterval(i), n(!1)))
                }, s)
        })
    }
    _isEnabled() {
        return this.getOptions().enabled !== !1 && this._dsn !== void 0
    }
    _prepareEvent(t, n, r) {
        const s = this.getOptions(),
            i = Object.keys(this._integrations);
        return !n.integrations && i.length > 0 && (n.integrations = i), hU(s, t, n, r)
    }
    _captureEvent(t, n = {}, r) {
        return this._processEvent(t, n, r).then(s => s.event_id, s => {
            if (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) {
                const i = s;
                i.logLevel === "log" ? M.log(i.message) : M.warn(i)
            }
        })
    }
    _processEvent(t, n, r) {
        const s = this.getOptions(),
            {
                sampleRate: i
            } = s;
        if (!this._isEnabled()) return v_(new Vn("SDK not enabled, will not capture event.", "log"));
        const o = mU(t),
            a = pU(t),
            l = t.type || "error",
            c = `before send for type \`${l}\``;
        if (a && typeof i == "number" && Math.random() > i) return this.recordDroppedEvent("sample_rate", "error", t), v_(new Vn(`Discarding event because it's not included in the random sample (sampling rate = ${i})`, "log"));
        const u = l === "replay_event" ? "replay" : l;
        return this._prepareEvent(t, n, r).then(d => {
            if (d === null) throw this.recordDroppedEvent("event_processor", u, t), new Vn("An event processor returned `null`, will not send event.", "log");
            if (n.data && n.data.__sentry__ === !0) return d;
            const h = gJ(s, d, n);
            return mJ(h, c)
        }).then(d => {
            if (d === null) throw this.recordDroppedEvent("before_send", u, t), new Vn(`${c} returned \`null\`, will not send event.`, "log");
            const f = r && r.getSession();
            !o && f && this._updateSessionFromEvent(f, d);
            const h = d.transaction_info;
            if (o && h && d.transaction !== t.transaction) {
                const p = "custom";
                d.transaction_info = G(x({}, h), {
                    source: p
                })
            }
            return this.sendEvent(d, n), d
        }).then(null, d => {
            throw d instanceof Vn ? d : (this.captureException(d, {
                data: {
                    __sentry__: !0
                },
                originalException: d
            }), new Vn(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${d}`))
        })
    }
    _process(t) {
        this._numProcessing++, t.then(n => (this._numProcessing--, n), n => (this._numProcessing--, n))
    }
    _sendEnvelope(t) {
        if (this._transport && this._dsn) return this.emit("beforeEnvelope", t), this._transport.send(t).then(null, n => {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("Error while sending event:", n)
        });
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("Transport disabled")
    }
    _clearOutcomes() {
        const t = this._outcomes;
        return this._outcomes = {}, Object.keys(t).map(n => {
            const [r, s] = n.split(":");
            return {
                reason: r,
                category: s,
                quantity: t[n]
            }
        })
    }
}

function mJ(e, t) {
    const n = `${t} must return \`null\` or a valid event.`;
    if (t$(e)) return e.then(r => {
        if (!uu(r) && r !== null) throw new Vn(n);
        return r
    }, r => {
        throw new Vn(`${t} rejected with ${r}`)
    });
    if (!uu(e) && e !== null) throw new Vn(n);
    return e
}

function gJ(e, t, n) {
    const {
        beforeSend: r,
        beforeSendTransaction: s
    } = e;
    return pU(t) && r ? r(t, n) : mU(t) && s ? s(t, n) : t
}

function pU(e) {
    return e.type === void 0
}

function mU(e) {
    return e.type === "transaction"
}

function _J(e, t) {
    t.debug === !0 && (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__ ? M.enable() : console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."));
    const n = Ne();
    n.getScope().update(t.initialScope);
    const s = new e(t);
    n.bindClient(s)
}
const yJ = 30;

function gU(e, t, n = hQ(e.bufferSize || yJ)) {
    let r = {};
    const s = o => n.drain(o);

    function i(o) {
        const a = [];
        if (VC(o, (d, f) => {
                const h = HC(f);
                if (CQ(r, h)) {
                    const p = XC(d, f);
                    e.recordDroppedEvent("ratelimit_backoff", h, p)
                } else a.push(d)
            }), a.length === 0) return ul();
        const l = rd(o[0], a),
            c = d => {
                VC(l, (f, h) => {
                    const p = XC(f, h);
                    e.recordDroppedEvent(d, HC(h), p)
                })
            },
            u = () => t({
                body: wQ(l, e.textEncoder)
            }).then(d => (d.statusCode !== void 0 && (d.statusCode < 200 || d.statusCode >= 300) && (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Sentry responded with status code ${d.statusCode} to sent event.`), r = AQ(r, d), d), d => {
                throw c("network_error"), d
            });
        return n.add(u).then(d => d, d => {
            if (d instanceof Vn) return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("Skipped sending event because buffer is full."), c("queue_overflow"), ul();
            throw d
        })
    }
    return i.__sentry__baseTransport__ = !0, {
        send: i,
        flush: s
    }
}

function XC(e, t) {
    if (!(t !== "event" && t !== "transaction")) return Array.isArray(e) ? e[1] : void 0
}
const b_ = "7.51.0";
let QC;
class dh {
    constructor() {
        dh.prototype.__init.call(this)
    }
    static __initStatic() {
        this.id = "FunctionToString"
    }
    __init() {
        this.name = dh.id
    }
    setupOnce() {
        QC = Function.prototype.toString;
        try {
            Function.prototype.toString = function(...t) {
                const n = s$(this) || this;
                return QC.apply(n, t)
            }
        } catch {}
    }
}
dh.__initStatic();
const vJ = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
class Oc {
    static __initStatic() {
        this.id = "InboundFilters"
    }
    __init() {
        this.name = Oc.id
    }
    constructor(t = {}) {
        this._options = t, Oc.prototype.__init.call(this)
    }
    setupOnce(t, n) {
        const r = s => {
            const i = n();
            if (i) {
                const o = i.getIntegration(Oc);
                if (o) {
                    const a = i.getClient(),
                        l = a ? a.getOptions() : {},
                        c = bJ(o._options, l);
                    return wJ(s, c) ? null : s
                }
            }
            return s
        };
        r.id = this.name, t(r)
    }
}
Oc.__initStatic();

function bJ(e = {}, t = {}) {
    return {
        allowUrls: [...e.allowUrls || [], ...t.allowUrls || []],
        denyUrls: [...e.denyUrls || [], ...t.denyUrls || []],
        ignoreErrors: [...e.ignoreErrors || [], ...t.ignoreErrors || [], ...vJ],
        ignoreTransactions: [...e.ignoreTransactions || [], ...t.ignoreTransactions || []],
        ignoreInternal: e.ignoreInternal !== void 0 ? e.ignoreInternal : !0
    }
}

function wJ(e, t) {
    return t.ignoreInternal && IJ(e) ? ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Event dropped due to being internal Sentry Error.
Event: ${fo(e)}`), !0) : EJ(e, t.ignoreErrors) ? ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${fo(e)}`), !0) : SJ(e, t.ignoreTransactions) ? ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${fo(e)}`), !0) : TJ(e, t.denyUrls) ? ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${fo(e)}.
Url: ${w_(e)}`), !0) : $J(e, t.allowUrls) ? !1 : ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${fo(e)}.
Url: ${w_(e)}`), !0)
}

function EJ(e, t) {
    return e.type || !t || !t.length ? !1 : kJ(e).some(n => nd(n, t))
}

function SJ(e, t) {
    if (e.type !== "transaction" || !t || !t.length) return !1;
    const n = e.transaction;
    return n ? nd(n, t) : !1
}

function TJ(e, t) {
    if (!t || !t.length) return !1;
    const n = w_(e);
    return n ? nd(n, t) : !1
}

function $J(e, t) {
    if (!t || !t.length) return !0;
    const n = w_(e);
    return n ? nd(n, t) : !0
}

function kJ(e) {
    if (e.message) return [e.message];
    if (e.exception) try {
        const {
            type: t = "",
            value: n = ""
        } = e.exception.values && e.exception.values[0] || {};
        return [`${n}`, `${t}: ${n}`]
    } catch {
        return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error(`Cannot extract message for event ${fo(e)}`), []
    }
    return []
}

function IJ(e) {
    try {
        return e.exception.values[0].type === "SentryError"
    } catch {}
    return !1
}

function xJ(e = []) {
    for (let t = e.length - 1; t >= 0; t--) {
        const n = e[t];
        if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]") return n.filename || null
    }
    return null
}

function w_(e) {
    try {
        let t;
        try {
            t = e.exception.values[0].stacktrace.frames
        } catch {}
        return t ? xJ(t) : null
    } catch {
        return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error(`Cannot extract url for event ${fo(e)}`), null
    }
}
const ft = ur;
let $E = 0;

function _U() {
    return $E > 0
}

function CJ() {
    $E++, setTimeout(() => {
        $E--
    })
}

function fu(e, t = {}, n) {
    if (typeof e != "function") return e;
    try {
        const s = e.__sentry_wrapped__;
        if (s) return s;
        if (s$(e)) return e
    } catch {
        return e
    }
    const r = function() {
        const s = Array.prototype.slice.call(arguments);
        try {
            n && typeof n == "function" && n.apply(this, arguments);
            const i = s.map(o => fu(o, t));
            return e.apply(this, i)
        } catch (i) {
            throw CJ(), JQ(o => {
                o.addEventProcessor(a => (t.mechanism && (yE(a, void 0, void 0), uh(a, t.mechanism)), a.extra = G(x({}, a.extra), {
                    arguments: s
                }), a)), dl(i)
            }), i
        }
    };
    try {
        for (const s in e) Object.prototype.hasOwnProperty.call(e, s) && (r[s] = e[s])
    } catch {}
    KF(r, e), r$(e, "__sentry_wrapped__", r);
    try {
        Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
            get() {
                return e.name
            }
        })
    } catch {}
    return r
}

function yU(e, t) {
    const n = c$(e, t),
        r = {
            type: t && t.name,
            value: DJ(t)
        };
    return n.length && (r.stacktrace = {
        frames: n
    }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r
}

function AJ(e, t, n, r) {
    const i = Ne().getClient(),
        o = i && i.getOptions().normalizeDepth,
        a = {
            exception: {
                values: [{
                    type: e$(t) ? t.constructor.name : r ? "UnhandledRejection" : "Error",
                    value: `Non-Error ${r?"promise rejection":"exception"} captured with keys: ${HX(t)}`
                }]
            },
            extra: {
                __serialized__: nU(t, o)
            }
        };
    if (n) {
        const l = c$(e, n);
        l.length && (a.exception.values[0].stacktrace = {
            frames: l
        })
    }
    return a
}

function g0(e, t) {
    return {
        exception: {
            values: [yU(e, t)]
        }
    }
}

function c$(e, t) {
    const n = t.stacktrace || t.stack || "",
        r = OJ(t);
    try {
        return e(n, r)
    } catch {}
    return []
}
const RJ = /Minified React error #\d+;/i;

function OJ(e) {
    if (e) {
        if (typeof e.framesToPop == "number") return e.framesToPop;
        if (RJ.test(e.message)) return 1
    }
    return 0
}

function DJ(e) {
    const t = e && e.message;
    return t ? t.error && typeof t.error.message == "string" ? t.error.message : t : "No error message"
}

function NJ(e, t, n, r) {
    const s = n && n.syntheticException || void 0,
        i = u$(e, t, s, r);
    return uh(i), i.level = "error", n && n.event_id && (i.event_id = n.event_id), ul(i)
}

function PJ(e, t, n = "info", r, s) {
    const i = r && r.syntheticException || void 0,
        o = kE(e, t, i, s);
    return o.level = n, r && r.event_id && (o.event_id = r.event_id), ul(o)
}

function u$(e, t, n, r, s) {
    let i;
    if (zF(t) && t.error) return g0(e, t.error);
    if (AC(t) || kX(t)) {
        const o = t;
        if ("stack" in t) i = g0(e, t);
        else {
            const a = o.name || (AC(o) ? "DOMError" : "DOMException"),
                l = o.message ? `${a}: ${o.message}` : a;
            i = kE(e, l, n, r), yE(i, l)
        }
        return "code" in o && (i.tags = G(x({}, i.tags), {
            "DOMException.code": `${o.code}`
        })), i
    }
    return jF(t) ? g0(e, t) : uu(t) || e$(t) ? (i = AJ(e, t, n, s), uh(i, {
        synthetic: !0
    }), i) : (i = kE(e, t, n, r), yE(i, `${t}`, void 0), uh(i, {
        synthetic: !0
    }), i)
}

function kE(e, t, n, r) {
    const s = {
        message: t
    };
    if (r && n) {
        const i = c$(e, n);
        i.length && (s.exception = {
            values: [{
                value: t,
                stacktrace: {
                    frames: i
                }
            }]
        })
    }
    return s
}
const hm = 1024,
    vU = "Breadcrumbs";
class fh {
    static __initStatic() {
        this.id = vU
    }
    __init() {
        this.name = fh.id
    }
    constructor(t) {
        fh.prototype.__init.call(this), this.options = x({
            console: !0,
            dom: !0,
            fetch: !0,
            history: !0,
            sentry: !0,
            xhr: !0
        }, t)
    }
    setupOnce() {
        this.options.console && Rn("console", LJ), this.options.dom && Rn("dom", MJ(this.options.dom)), this.options.xhr && Rn("xhr", FJ), this.options.fetch && Rn("fetch", UJ), this.options.history && Rn("history", BJ)
    }
    addSentryBreadcrumb(t) {
        this.options.sentry && Ne().addBreadcrumb({
            category: `sentry.${t.type==="transaction"?"transaction":"event"}`,
            event_id: t.event_id,
            level: t.level,
            message: fo(t)
        }, {
            event: t
        })
    }
}
fh.__initStatic();

function MJ(e) {
    function t(n) {
        let r, s = typeof e == "object" ? e.serializeAttribute : void 0,
            i = typeof e == "object" && typeof e.maxStringLength == "number" ? e.maxStringLength : void 0;
        i && i > hm && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`\`dom.maxStringLength\` cannot exceed ${hm}, but a value of ${i} was configured. Sentry will use ${hm} instead.`), i = hm), typeof s == "string" && (s = [s]);
        try {
            const o = n.event;
            r = VJ(o) ? cl(o.target, {
                keyAttrs: s,
                maxStringLength: i
            }) : cl(o, {
                keyAttrs: s,
                maxStringLength: i
            })
        } catch {
            r = "<unknown>"
        }
        r.length !== 0 && Ne().addBreadcrumb({
            category: `ui.${n.name}`,
            message: r
        }, {
            event: n.event,
            name: n.name,
            global: n.global
        })
    }
    return t
}

function LJ(e) {
    for (let n = 0; n < e.args.length; n++)
        if (e.args[n] === "ref=Ref<") {
            e.args[n + 1] = "viewRef";
            break
        }
    const t = {
        category: "console",
        data: {
            arguments: e.args,
            logger: "console"
        },
        level: mQ(e.level),
        message: OC(e.args, " ")
    };
    if (e.level === "assert")
        if (e.args[0] === !1) t.message = `Assertion failed: ${OC(e.args.slice(1)," ")||"console.assert"}`, t.data.arguments = e.args.slice(1);
        else return;
    Ne().addBreadcrumb(t, {
        input: e.args,
        level: e.level
    })
}

function FJ(e) {
    const {
        startTimestamp: t,
        endTimestamp: n
    } = e, r = e.xhr[yo];
    if (!t || !n || !r) return;
    const {
        method: s,
        url: i,
        status_code: o,
        body: a
    } = r, l = {
        method: s,
        url: i,
        status_code: o
    }, c = {
        xhr: e.xhr,
        input: a,
        startTimestamp: t,
        endTimestamp: n
    };
    Ne().addBreadcrumb({
        category: "xhr",
        data: l,
        type: "http"
    }, c)
}

function UJ(e) {
    const {
        startTimestamp: t,
        endTimestamp: n
    } = e;
    if (!!n && !(e.fetchData.url.match(/sentry_key/) && e.fetchData.method === "POST"))
        if (e.error) {
            const r = e.fetchData,
                s = {
                    data: e.error,
                    input: e.args,
                    startTimestamp: t,
                    endTimestamp: n
                };
            Ne().addBreadcrumb({
                category: "fetch",
                data: r,
                level: "error",
                type: "http"
            }, s)
        } else {
            const r = G(x({}, e.fetchData), {
                    status_code: e.response && e.response.status
                }),
                s = {
                    input: e.args,
                    response: e.response,
                    startTimestamp: t,
                    endTimestamp: n
                };
            Ne().addBreadcrumb({
                category: "fetch",
                data: r,
                type: "http"
            }, s)
        }
}

function BJ(e) {
    let t = e.from,
        n = e.to;
    const r = p0(ft.location.href);
    let s = p0(t);
    const i = p0(n);
    s.path || (s = r), r.protocol === i.protocol && r.host === i.host && (n = i.relative), r.protocol === s.protocol && r.host === s.host && (t = s.relative), Ne().addBreadcrumb({
        category: "navigation",
        data: {
            from: t,
            to: n
        }
    })
}

function VJ(e) {
    return e && !!e.target
}

function HJ(e, {
    metadata: t,
    tunnel: n,
    dsn: r
}) {
    const s = x(x({
            event_id: e.event_id,
            sent_at: new Date().toISOString()
        }, t && t.sdk && {
            sdk: {
                name: t.sdk.name,
                version: t.sdk.version
            }
        }), !!n && !!r && {
            dsn: Dv(r)
        }),
        i = jJ(e);
    return rd(s, [i])
}

function jJ(e) {
    return [{
        type: "user_report"
    }, e]
}
class zJ extends $a {
    constructor(t) {
        const n = ft.SENTRY_SDK_SOURCE || aQ();
        t._metadata = t._metadata || {}, t._metadata.sdk = t._metadata.sdk || {
            name: "sentry.javascript.browser",
            packages: [{
                name: `${n}:@sentry/browser`,
                version: b_
            }],
            version: b_
        }, super(t), t.sendClientReports && ft.document && ft.document.addEventListener("visibilitychange", () => {
            ft.document.visibilityState === "hidden" && this._flushOutcomes()
        })
    }
    eventFromException(t, n) {
        return NJ(this._options.stackParser, t, n, this._options.attachStacktrace)
    }
    eventFromMessage(t, n = "info", r) {
        return PJ(this._options.stackParser, t, n, r, this._options.attachStacktrace)
    }
    sendEvent(t, n) {
        const r = this.getIntegrationById(vU);
        r && r.addSentryBreadcrumb && r.addSentryBreadcrumb(t), super.sendEvent(t, n)
    }
    captureUserFeedback(t) {
        if (!this._isEnabled()) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("SDK not enabled, will not capture user feedback.");
            return
        }
        const n = HJ(t, {
            metadata: this.getSdkMetadata(),
            dsn: this.getDsn(),
            tunnel: this.getOptions().tunnel
        });
        this._sendEnvelope(n)
    }
    _prepareEvent(t, n, r) {
        return t.platform = t.platform || "javascript", super._prepareEvent(t, n, r)
    }
    _flushOutcomes() {
        const t = this._clearOutcomes();
        if (t.length === 0) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("No outcomes to send");
            return
        }
        if (!this._dsn) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("No dsn provided, will not send outcomes");
            return
        }(typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("Sending outcomes:", t);
        const n = $Q(t, this._options.tunnel && Dv(this._dsn));
        this._sendEnvelope(n)
    }
}
let Pd;

function WJ() {
    if (Pd) return Pd;
    if (gE(ft.fetch)) return Pd = ft.fetch.bind(ft);
    const e = ft.document;
    let t = ft.fetch;
    if (e && typeof e.createElement == "function") try {
        const n = e.createElement("iframe");
        n.hidden = !0, e.head.appendChild(n);
        const r = n.contentWindow;
        r && r.fetch && (t = r.fetch), e.head.removeChild(n)
    } catch (n) {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
    }
    return Pd = t.bind(ft)
}

function GJ() {
    Pd = void 0
}

function qJ(e, t = WJ()) {
    let n = 0,
        r = 0;

    function s(i) {
        const o = i.body.length;
        n += o, r++;
        const a = x({
            body: i.body,
            method: "POST",
            referrerPolicy: "origin",
            headers: e.headers,
            keepalive: n <= 6e4 && r < 15
        }, e.fetchOptions);
        try {
            return t(e.url, a).then(l => (n -= o, r--, {
                statusCode: l.status,
                headers: {
                    "x-sentry-rate-limits": l.headers.get("X-Sentry-Rate-Limits"),
                    "retry-after": l.headers.get("Retry-After")
                }
            }))
        } catch (l) {
            return GJ(), n -= o, r--, v_(l)
        }
    }
    return gU(e, s)
}
const YJ = 4;

function KJ(e) {
    function t(n) {
        return new rr((r, s) => {
            const i = new XMLHttpRequest;
            i.onerror = s, i.onreadystatechange = () => {
                i.readyState === YJ && r({
                    statusCode: i.status,
                    headers: {
                        "x-sentry-rate-limits": i.getResponseHeader("X-Sentry-Rate-Limits"),
                        "retry-after": i.getResponseHeader("Retry-After")
                    }
                })
            }, i.open("POST", e.url);
            for (const o in e.headers) Object.prototype.hasOwnProperty.call(e.headers, o) && i.setRequestHeader(o, e.headers[o]);
            i.send(n.body)
        })
    }
    return gU(e, t)
}
const Fv = "?",
    XJ = 30,
    QJ = 40,
    JJ = 50;

function d$(e, t, n, r) {
    const s = {
        filename: e,
        function: t,
        in_app: !0
    };
    return n !== void 0 && (s.lineno = n), r !== void 0 && (s.colno = r), s
}
const ZJ = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
    eZ = /\((\S*)(?::(\d+))(?::(\d+))\)/,
    tZ = e => {
        const t = ZJ.exec(e);
        if (t) {
            if (t[2] && t[2].indexOf("eval") === 0) {
                const i = eZ.exec(t[2]);
                i && (t[2] = i[1], t[3] = i[2], t[4] = i[3])
            }
            const [r, s] = bU(t[1] || Fv, t[2]);
            return d$(s, r, t[3] ? +t[3] : void 0, t[4] ? +t[4] : void 0)
        }
    },
    nZ = [XJ, tZ],
    rZ = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
    sZ = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
    iZ = e => {
        const t = rZ.exec(e);
        if (t) {
            if (t[3] && t[3].indexOf(" > eval") > -1) {
                const i = sZ.exec(t[3]);
                i && (t[1] = t[1] || "eval", t[3] = i[1], t[4] = i[2], t[5] = "")
            }
            let r = t[3],
                s = t[1] || Fv;
            return [s, r] = bU(s, r), d$(r, s, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0)
        }
    },
    oZ = [JJ, iZ],
    aZ = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
    lZ = e => {
        const t = aZ.exec(e);
        return t ? d$(t[2], t[1] || Fv, +t[3], t[4] ? +t[4] : void 0) : void 0
    },
    cZ = [QJ, lZ],
    uZ = [nZ, oZ, cZ],
    dZ = JF(...uZ),
    bU = (e, t) => {
        const n = e.indexOf("safari-extension") !== -1,
            r = e.indexOf("safari-web-extension") !== -1;
        return n || r ? [e.indexOf("@") !== -1 ? e.split("@")[0] : Fv, n ? `safari-extension:${t}` : `safari-web-extension:${t}`] : [e, t]
    };
class Ao {
    static __initStatic() {
        this.id = "GlobalHandlers"
    }
    __init() {
        this.name = Ao.id
    }
    __init2() {
        this._installFunc = {
            onerror: fZ,
            onunhandledrejection: hZ
        }
    }
    constructor(t) {
        Ao.prototype.__init.call(this), Ao.prototype.__init2.call(this), this._options = x({
            onerror: !0,
            onunhandledrejection: !0
        }, t)
    }
    setupOnce() {
        Error.stackTraceLimit = 50;
        const t = this._options;
        for (const n in t) {
            const r = this._installFunc[n];
            r && t[n] && (gZ(n), r(), this._installFunc[n] = void 0)
        }
    }
}
Ao.__initStatic();

function fZ() {
    Rn("error", e => {
        const [t, n, r] = SU();
        if (!t.getIntegration(Ao)) return;
        const {
            msg: s,
            url: i,
            line: o,
            column: a,
            error: l
        } = e;
        if (_U() || l && l.__sentry_own_request__) return;
        const c = l === void 0 && jo(s) ? mZ(s, i, o, a) : wU(u$(n, l || s, void 0, r, !1), i, o, a);
        c.level = "error", EU(t, l, c, "onerror")
    })
}

function hZ() {
    Rn("unhandledrejection", e => {
        const [t, n, r] = SU();
        if (!t.getIntegration(Ao)) return;
        let s = e;
        try {
            "reason" in e ? s = e.reason : "detail" in e && "reason" in e.detail && (s = e.detail.reason)
        } catch {}
        if (_U() || s && s.__sentry_own_request__) return !0;
        const i = WF(s) ? pZ(s) : u$(n, s, void 0, r, !0);
        i.level = "error", EU(t, s, i, "onunhandledrejection")
    })
}

function pZ(e) {
    return {
        exception: {
            values: [{
                type: "UnhandledRejection",
                value: `Non-Error promise rejection captured with value: ${String(e)}`
            }]
        }
    }
}

function mZ(e, t, n, r) {
    const s = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
    let i = zF(e) ? e.message : e,
        o = "Error";
    const a = i.match(s);
    return a && (o = a[1], i = a[2]), wU({
        exception: {
            values: [{
                type: o,
                value: i
            }]
        }
    }, t, n, r)
}

function wU(e, t, n, r) {
    const s = e.exception = e.exception || {},
        i = s.values = s.values || [],
        o = i[0] = i[0] || {},
        a = o.stacktrace = o.stacktrace || {},
        l = a.frames = a.frames || [],
        c = isNaN(parseInt(r, 10)) ? void 0 : r,
        u = isNaN(parseInt(n, 10)) ? void 0 : n,
        d = jo(t) && t.length > 0 ? t : OX();
    return l.length === 0 && l.push({
        colno: c,
        filename: d,
        function: "?",
        in_app: !0,
        lineno: u
    }), e
}

function gZ(e) {
    (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`Global Handler attached: ${e}`)
}

function EU(e, t, n, r) {
    uh(n, {
        handled: !1,
        type: r
    }), e.captureEvent(n, {
        originalException: t
    })
}

function SU() {
    const e = Ne(),
        t = e.getClient(),
        n = t && t.getOptions() || {
            stackParser: () => [],
            attachStacktrace: !1
        };
    return [e, n.stackParser, n.attachStacktrace]
}
const _Z = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
class hh {
    static __initStatic() {
        this.id = "TryCatch"
    }
    __init() {
        this.name = hh.id
    }
    constructor(t) {
        hh.prototype.__init.call(this), this._options = x({
            XMLHttpRequest: !0,
            eventTarget: !0,
            requestAnimationFrame: !0,
            setInterval: !0,
            setTimeout: !0
        }, t)
    }
    setupOnce() {
        this._options.setTimeout && On(ft, "setTimeout", JC), this._options.setInterval && On(ft, "setInterval", JC), this._options.requestAnimationFrame && On(ft, "requestAnimationFrame", yZ), this._options.XMLHttpRequest && "XMLHttpRequest" in ft && On(XMLHttpRequest.prototype, "send", vZ);
        const t = this._options.eventTarget;
        t && (Array.isArray(t) ? t : _Z).forEach(bZ)
    }
}
hh.__initStatic();

function JC(e) {
    return function(...t) {
        const n = t[0];
        return t[0] = fu(n, {
            mechanism: {
                data: {
                    function: Wo(e)
                },
                handled: !0,
                type: "instrument"
            }
        }), e.apply(this, t)
    }
}

function yZ(e) {
    return function(t) {
        return e.apply(this, [fu(t, {
            mechanism: {
                data: {
                    function: "requestAnimationFrame",
                    handler: Wo(e)
                },
                handled: !0,
                type: "instrument"
            }
        })])
    }
}

function vZ(e) {
    return function(...t) {
        const n = this;
        return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(s => {
            s in n && typeof n[s] == "function" && On(n, s, function(i) {
                const o = {
                        mechanism: {
                            data: {
                                function: s,
                                handler: Wo(i)
                            },
                            handled: !0,
                            type: "instrument"
                        }
                    },
                    a = s$(i);
                return a && (o.mechanism.data.handler = Wo(a)), fu(i, o)
            })
        }), e.apply(this, t)
    }
}

function bZ(e) {
    const t = ft,
        n = t[e] && t[e].prototype;
    !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (On(n, "addEventListener", function(r) {
        return function(s, i, o) {
            try {
                typeof i.handleEvent == "function" && (i.handleEvent = fu(i.handleEvent, {
                    mechanism: {
                        data: {
                            function: "handleEvent",
                            handler: Wo(i),
                            target: e
                        },
                        handled: !0,
                        type: "instrument"
                    }
                }))
            } catch {}
            return r.apply(this, [s, fu(i, {
                mechanism: {
                    data: {
                        function: "addEventListener",
                        handler: Wo(i),
                        target: e
                    },
                    handled: !0,
                    type: "instrument"
                }
            }), o])
        }
    }), On(n, "removeEventListener", function(r) {
        return function(s, i, o) {
            const a = i;
            try {
                const l = a && a.__sentry_wrapped__;
                l && r.call(this, s, l, o)
            } catch {}
            return r.call(this, s, a, o)
        }
    }))
}
const wZ = "cause",
    EZ = 5;
class Dc {
    static __initStatic() {
        this.id = "LinkedErrors"
    }
    __init() {
        this.name = Dc.id
    }
    constructor(t = {}) {
        Dc.prototype.__init.call(this), this._key = t.key || wZ, this._limit = t.limit || EZ
    }
    setupOnce() {
        const t = Ne().getClient();
        !t || Pv((n, r) => {
            const s = Ne().getIntegration(Dc);
            return s ? SZ(t.getOptions().stackParser, s._key, s._limit, n, r) : n
        })
    }
}
Dc.__initStatic();

function SZ(e, t, n, r, s) {
    if (!r.exception || !r.exception.values || !s || !zo(s.originalException, Error)) return r;
    const i = TU(e, n, s.originalException, t);
    return r.exception.values = [...i, ...r.exception.values], r
}

function TU(e, t, n, r, s = []) {
    if (!zo(n[r], Error) || s.length + 1 >= t) return s;
    const i = yU(e, n[r]);
    return TU(e, t, n[r], r, [i, ...s])
}
class Nc {
    constructor() {
        Nc.prototype.__init.call(this)
    }
    static __initStatic() {
        this.id = "HttpContext"
    }
    __init() {
        this.name = Nc.id
    }
    setupOnce() {
        Pv(t => {
            if (Ne().getIntegration(Nc)) {
                if (!ft.navigator && !ft.location && !ft.document) return t;
                const n = t.request && t.request.url || ft.location && ft.location.href,
                    {
                        referrer: r
                    } = ft.document || {},
                    {
                        userAgent: s
                    } = ft.navigator || {},
                    i = x(x(x({}, t.request && t.request.headers), r && {
                        Referer: r
                    }), s && {
                        "User-Agent": s
                    }),
                    o = G(x(x({}, t.request), n && {
                        url: n
                    }), {
                        headers: i
                    });
                return G(x({}, t), {
                    request: o
                })
            }
            return t
        })
    }
}
Nc.__initStatic();
class Pc {
    constructor() {
        Pc.prototype.__init.call(this)
    }
    static __initStatic() {
        this.id = "Dedupe"
    }
    __init() {
        this.name = Pc.id
    }
    setupOnce(t, n) {
        const r = s => {
            if (s.type) return s;
            const i = n().getIntegration(Pc);
            if (i) {
                try {
                    if (TZ(s, i._previousEvent)) return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("Event dropped due to being a duplicate of previously captured event."), null
                } catch {
                    return i._previousEvent = s
                }
                return i._previousEvent = s
            }
            return s
        };
        r.id = this.name, t(r)
    }
}
Pc.__initStatic();

function TZ(e, t) {
    return t ? !!($Z(e, t) || kZ(e, t)) : !1
}

function $Z(e, t) {
    const n = e.message,
        r = t.message;
    return !(!n && !r || n && !r || !n && r || n !== r || !kU(e, t) || !$U(e, t))
}

function kZ(e, t) {
    const n = ZC(t),
        r = ZC(e);
    return !(!n || !r || n.type !== r.type || n.value !== r.value || !kU(e, t) || !$U(e, t))
}

function $U(e, t) {
    let n = eA(e),
        r = eA(t);
    if (!n && !r) return !0;
    if (n && !r || !n && r || (n = n, r = r, r.length !== n.length)) return !1;
    for (let s = 0; s < r.length; s++) {
        const i = r[s],
            o = n[s];
        if (i.filename !== o.filename || i.lineno !== o.lineno || i.colno !== o.colno || i.function !== o.function) return !1
    }
    return !0
}

function kU(e, t) {
    let n = e.fingerprint,
        r = t.fingerprint;
    if (!n && !r) return !0;
    if (n && !r || !n && r) return !1;
    n = n, r = r;
    try {
        return n.join("") === r.join("")
    } catch {
        return !1
    }
}

function ZC(e) {
    return e.exception && e.exception.values && e.exception.values[0]
}

function eA(e) {
    const t = e.exception;
    if (t) try {
        return t.values[0].stacktrace.frames
    } catch {
        return
    }
}
const IZ = [new Oc, new dh, new hh, new fh, new Ao, new Dc, new Pc, new Nc];

function xZ(e = {}) {
    e.defaultIntegrations === void 0 && (e.defaultIntegrations = IZ), e.release === void 0 && (typeof __SENTRY_RELEASE__ == "string" && (e.release = __SENTRY_RELEASE__), ft.SENTRY_RELEASE && ft.SENTRY_RELEASE.id && (e.release = ft.SENTRY_RELEASE.id)), e.autoSessionTracking === void 0 && (e.autoSessionTracking = !0), e.sendClientReports === void 0 && (e.sendClientReports = !0);
    const t = G(x({}, e), {
        stackParser: jX(e.stackParser || dZ),
        integrations: lJ(e),
        transport: e.transport || (ZF() ? qJ : KJ)
    });
    _J(zJ, t), e.autoSessionTracking && CZ()
}

function tA(e) {
    e.startSession({
        ignoreDuration: !0
    }), e.captureSession()
}

function CZ() {
    if (typeof ft.document == "undefined") {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
        return
    }
    const e = Ne();
    !e.captureSession || (tA(e), Rn("history", ({
        from: t,
        to: n
    }) => {
        t === void 0 || t === n || tA(Ne())
    }))
}
const Bt = ur,
    f$ = "sentryReplaySession",
    AZ = "replay_event",
    h$ = "Unable to send Replay",
    RZ = 3e5,
    OZ = 9e5,
    DZ = 36e5,
    NZ = 5e3,
    PZ = 5500,
    MZ = 6e4,
    LZ = 5e3,
    FZ = 3,
    pm = 15e4,
    mm = 5e3;
var vn;
(function(e) {
    e[e.Document = 0] = "Document", e[e.DocumentType = 1] = "DocumentType", e[e.Element = 2] = "Element", e[e.Text = 3] = "Text", e[e.CDATA = 4] = "CDATA", e[e.Comment = 5] = "Comment"
})(vn || (vn = {}));

function UZ(e) {
    return e.nodeType === e.ELEMENT_NODE
}

function rf(e) {
    const t = e == null ? void 0 : e.host;
    return Boolean(t && t.shadowRoot && t.shadowRoot === e)
}

function IU({
    maskInputOptions: e,
    tagName: t,
    type: n
}) {
    t.toLowerCase() === "option" && (t = "select");
    const r = typeof n == "string" ? n.toLowerCase() : void 0;
    return e[t.toLowerCase()] || r && e[r] || r === "password" || t === "input" && !n && e.text
}

function BZ({
    tagName: e,
    type: t,
    maskInputOptions: n,
    maskInputSelector: r
}) {
    return r || IU({
        maskInputOptions: n,
        tagName: e,
        type: t
    })
}

function E_({
    input: e,
    maskInputSelector: t,
    unmaskInputSelector: n,
    maskInputOptions: r,
    tagName: s,
    type: i,
    value: o,
    maskInputFn: a
}) {
    let l = o || "";
    return n && e.matches(n) || (e.hasAttribute("rr_is_password") && (i = "password"), (IU({
        maskInputOptions: r,
        tagName: s,
        type: i
    }) || t && e.matches(t)) && (a ? l = a(l) : l = "*".repeat(l.length))), l
}
const nA = "__rrweb_original__";

function VZ(e) {
    const t = e.getContext("2d");
    if (!t) return !0;
    const n = 50;
    for (let r = 0; r < e.width; r += n)
        for (let s = 0; s < e.height; s += n) {
            const i = t.getImageData,
                o = nA in i ? i[nA] : i;
            if (new Uint32Array(o.call(t, r, s, Math.min(n, e.width - r), Math.min(n, e.height - s)).data.buffer).some(l => l !== 0)) return !1
        }
    return !0
}
let HZ = 1;
const jZ = new RegExp("[^a-z0-9-_:]"),
    ph = -2;

function xU(e) {
    return e ? e.replace(/[\S]/g, "*") : ""
}

function zZ() {
    return HZ++
}

function WZ(e) {
    if (e instanceof HTMLFormElement) return "form";
    const t = e.tagName.toLowerCase().trim();
    return jZ.test(t) ? "div" : t
}

function IE(e) {
    try {
        const t = e.rules || e.cssRules;
        return t ? Array.from(t).map(GZ).join("") : null
    } catch {
        return null
    }
}

function GZ(e) {
    let t = e.cssText;
    if (qZ(e)) try {
        t = IE(e.styleSheet) || t
    } catch {}
    return t
}

function qZ(e) {
    return "styleSheet" in e
}

function YZ(e) {
    return e.cssRules ? Array.from(e.cssRules).map(t => t.cssText || "").join("") : ""
}

function KZ(e) {
    let t = "";
    return e.indexOf("//") > -1 ? t = e.split("/").slice(0, 3).join("/") : t = e.split("/")[0], t = t.split("?")[0], t
}
let Xl, rA;
const XZ = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,
    QZ = /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/|#).*/,
    JZ = /^(data:)([^,]*),(.*)/i;

function ag(e, t) {
    return (e || "").replace(XZ, (n, r, s, i, o, a) => {
        const l = s || o || a,
            c = r || i || "";
        if (!l) return n;
        if (!QZ.test(l)) return `url(${c}${l}${c})`;
        if (JZ.test(l)) return `url(${c}${l}${c})`;
        if (l[0] === "/") return `url(${c}${KZ(t)+l}${c})`;
        const u = t.split("/"),
            d = l.split("/");
        u.pop();
        for (const f of d) f !== "." && (f === ".." ? u.pop() : u.push(f));
        return `url(${c}${u.join("/")}${c})`
    })
}
const ZZ = /^[^ \t\n\r\u000c]+/,
    eee = /^[, \t\n\r\u000c]+/;

function tee(e, t) {
    if (t.trim() === "") return t;
    let n = 0;

    function r(i) {
        let o, a = i.exec(t.substring(n));
        return a ? (o = a[0], n += o.length, o) : ""
    }
    let s = [];
    for (; r(eee), !(n >= t.length);) {
        let i = r(ZZ);
        if (i.slice(-1) === ",") i = vc(e, i.substring(0, i.length - 1)), s.push(i);
        else {
            let o = "";
            i = vc(e, i);
            let a = !1;
            for (;;) {
                let l = t.charAt(n);
                if (l === "") {
                    s.push((i + o).trim());
                    break
                } else if (a) l === ")" && (a = !1);
                else if (l === ",") {
                    n += 1, s.push((i + o).trim());
                    break
                } else l === "(" && (a = !0);
                o += l, n += 1
            }
        }
    }
    return s.join(", ")
}

function vc(e, t) {
    if (!t || t.trim() === "") return t;
    const n = e.createElement("a");
    return n.href = t, n.href
}

function nee(e) {
    return Boolean(e.tagName === "svg" || e.ownerSVGElement)
}

function xE() {
    const e = document.createElement("a");
    return e.href = "", e.href
}

function CU(e, t, n, r, s, i, o, a) {
    if (!s) return s;
    const l = r.toLowerCase(),
        c = n.toLowerCase();
    return l === "src" || l === "href" || l === "xlink:href" && s[0] !== "#" || l === "background" && (c === "table" || c === "td" || c === "th") ? vc(e, s) : l === "srcset" ? tee(e, s) : l === "style" ? ag(s, xE()) : c === "object" && l === "data" ? vc(e, s) : i && ree(t, l, c, o) ? a ? a(s) : xU(s) : s
}

function ree(e, t, n, r) {
    return r && e.matches(r) ? !1 : ["placeholder", "title", "aria-label"].indexOf(t) > -1 || n === "input" && t === "value" && e.hasAttribute("type") && ["submit", "button"].indexOf(e.getAttribute("type").toLowerCase()) > -1
}

function see(e, t, n, r) {
    if (r && e.matches(r)) return !1;
    if (typeof t == "string") {
        if (e.classList.contains(t)) return !0
    } else
        for (let s = 0; s < e.classList.length; s++) {
            const i = e.classList[s];
            if (t.test(i)) return !0
        }
    return n ? e.matches(n) : !1
}

function S_(e, t, n, r, s) {
    if (!e) return !1;
    if (e.nodeType !== e.ELEMENT_NODE) return S_(e.parentNode, t, n, r, s);
    if (r && (e.matches(r) || e.closest(r))) return !1;
    if (s) return !0;
    if (typeof t == "string") {
        if (e.classList.contains(t)) return !0
    } else
        for (let i = 0; i < e.classList.length; i++) {
            const o = e.classList[i];
            if (t.test(o)) return !0
        }
    return n && e.matches(n) ? !0 : S_(e.parentNode, t, n, r, s)
}

function iee(e, t, n) {
    const r = e.contentWindow;
    if (!r) return;
    let s = !1,
        i;
    try {
        i = r.document.readyState
    } catch {
        return
    }
    if (i !== "complete") {
        const a = setTimeout(() => {
            s || (t(), s = !0)
        }, n);
        e.addEventListener("load", () => {
            clearTimeout(a), s = !0, t()
        });
        return
    }
    const o = "about:blank";
    if (r.location.href !== o || e.src === o || e.src === "") {
        setTimeout(t, 0);
        return
    }
    e.addEventListener("load", t)
}

function oee(e, t) {
    var n;
    const {
        doc: r,
        blockClass: s,
        blockSelector: i,
        unblockSelector: o,
        maskTextClass: a,
        maskTextSelector: l,
        unmaskTextSelector: c,
        inlineStylesheet: u,
        maskInputSelector: d,
        unmaskInputSelector: f,
        maskAllText: h,
        maskInputOptions: p = {},
        maskTextFn: m,
        maskInputFn: g,
        dataURLOptions: y = {},
        inlineImages: _,
        recordCanvas: E,
        keepIframeSrcFn: b
    } = t;
    let w;
    if (r.__sn) {
        const T = r.__sn.id;
        w = T === 1 ? void 0 : T
    }
    switch (e.nodeType) {
        case e.DOCUMENT_NODE:
            return e.compatMode !== "CSS1Compat" ? {
                type: vn.Document,
                childNodes: [],
                compatMode: e.compatMode,
                rootId: w
            } : {
                type: vn.Document,
                childNodes: [],
                rootId: w
            };
        case e.DOCUMENT_TYPE_NODE:
            return {
                type: vn.DocumentType,
                name: e.name,
                publicId: e.publicId,
                systemId: e.systemId,
                rootId: w
            };
        case e.ELEMENT_NODE:
            const T = see(e, s, i, o),
                S = WZ(e);
            let v = {};
            for (const {
                    name: R,
                    value: N
                } of Array.from(e.attributes)) cee(S, R) || (v[R] = CU(r, e, S, R, N, h, c, m));
            if (S === "link" && u) {
                const R = Array.from(r.styleSheets).find(J => J.href === e.href);
                let N = null;
                R && (N = IE(R)), N && (delete v.rel, delete v.href, v._cssText = ag(N, R.href))
            }
            if (S === "style" && e.sheet && !(e.innerText || e.textContent || "").trim().length) {
                const R = IE(e.sheet);
                R && (v._cssText = ag(R, xE()))
            }
            if (S === "input" || S === "textarea" || S === "select" || S === "option") {
                const R = e,
                    N = uee(S, R, v),
                    J = e.checked;
                v.type !== "submit" && v.type !== "button" && N && (v.value = E_({
                    input: R,
                    type: v.type,
                    tagName: S,
                    value: N,
                    maskInputSelector: d,
                    unmaskInputSelector: f,
                    maskInputOptions: p,
                    maskInputFn: g
                })), J && (v.checked = J)
            }
            if (S === "option" && (e.selected && !p.select ? v.selected = !0 : delete v.selected), S === "canvas" && E) {
                if (e.__context === "2d") VZ(e) || (v.rr_dataURL = e.toDataURL(y.type, y.quality));
                else if (!("__context" in e)) {
                    const R = e.toDataURL(y.type, y.quality),
                        N = document.createElement("canvas");
                    N.width = e.width, N.height = e.height;
                    const J = N.toDataURL(y.type, y.quality);
                    R !== J && (v.rr_dataURL = R)
                }
            }
            if (S === "img" && _) {
                Xl || (Xl = r.createElement("canvas"), rA = Xl.getContext("2d"));
                const R = e,
                    N = R.crossOrigin;
                R.crossOrigin = "anonymous";
                const J = () => {
                    try {
                        Xl.width = R.naturalWidth, Xl.height = R.naturalHeight, rA.drawImage(R, 0, 0), v.rr_dataURL = Xl.toDataURL(y.type, y.quality)
                    } catch (Y) {
                        console.warn(`Cannot inline img src=${R.currentSrc}! Error: ${Y}`)
                    }
                    N ? v.crossOrigin = N : delete v.crossOrigin
                };
                R.complete && R.naturalWidth !== 0 ? J() : R.onload = J
            }
            if ((S === "audio" || S === "video") && (v.rr_mediaState = e.paused ? "paused" : "played", v.rr_mediaCurrentTime = e.currentTime), e.scrollLeft && (v.rr_scrollLeft = e.scrollLeft), e.scrollTop && (v.rr_scrollTop = e.scrollTop), T) {
                const {
                    width: R,
                    height: N
                } = e.getBoundingClientRect();
                v = {
                    class: v.class,
                    rr_width: `${R}px`,
                    rr_height: `${N}px`
                }
            }
            return S === "iframe" && !b(v.src) && (e.contentDocument || (v.rr_src = v.src), delete v.src), {
                type: vn.Element,
                tagName: S,
                attributes: v,
                childNodes: [],
                isSVG: nee(e) || void 0,
                needBlock: T,
                rootId: w
            };
        case e.TEXT_NODE:
            const $ = e.parentNode && e.parentNode.tagName;
            let k = e.textContent;
            const C = $ === "STYLE" ? !0 : void 0,
                O = $ === "SCRIPT" ? !0 : void 0;
            if (C && k) {
                try {
                    e.nextSibling || e.previousSibling || !((n = e.parentNode.sheet) === null || n === void 0) && n.cssRules && (k = YZ(e.parentNode.sheet))
                } catch (R) {
                    console.warn(`Cannot get CSS styles from text's parentNode. Error: ${R}`, e)
                }
                k = ag(k, xE())
            }
            if (O && (k = "SCRIPT_PLACEHOLDER"), $ === "TEXTAREA" && k) k = "";
            else if ($ === "OPTION" && k) {
                const R = e.parentNode;
                k = E_({
                    input: R,
                    type: null,
                    tagName: $,
                    value: k,
                    maskInputSelector: d,
                    unmaskInputSelector: f,
                    maskInputOptions: p,
                    maskInputFn: g
                })
            } else !C && !O && S_(e, a, l, c, h) && k && (k = m ? m(k) : xU(k));
            return {
                type: vn.Text,
                textContent: k || "",
                isStyle: C,
                rootId: w
            };
        case e.CDATA_SECTION_NODE:
            return {
                type: vn.CDATA,
                textContent: "",
                rootId: w
            };
        case e.COMMENT_NODE:
            return {
                type: vn.Comment,
                textContent: e.textContent || "",
                rootId: w
            };
        default:
            return !1
    }
}

function Et(e) {
    return e == null ? "" : e.toLowerCase()
}

function aee(e, t) {
    if (t.comment && e.type === vn.Comment) return !0;
    if (e.type === vn.Element) {
        if (t.script && (e.tagName === "script" || e.tagName === "link" && (e.attributes.rel === "preload" || e.attributes.rel === "modulepreload") && e.attributes.as === "script" || e.tagName === "link" && e.attributes.rel === "prefetch" && typeof e.attributes.href == "string" && e.attributes.href.endsWith(".js"))) return !0;
        if (t.headFavicon && (e.tagName === "link" && e.attributes.rel === "shortcut icon" || e.tagName === "meta" && (Et(e.attributes.name).match(/^msapplication-tile(image|color)$/) || Et(e.attributes.name) === "application-name" || Et(e.attributes.rel) === "icon" || Et(e.attributes.rel) === "apple-touch-icon" || Et(e.attributes.rel) === "shortcut icon"))) return !0;
        if (e.tagName === "meta") {
            if (t.headMetaDescKeywords && Et(e.attributes.name).match(/^description|keywords$/)) return !0;
            if (t.headMetaSocial && (Et(e.attributes.property).match(/^(og|twitter|fb):/) || Et(e.attributes.name).match(/^(og|twitter):/) || Et(e.attributes.name) === "pinterest")) return !0;
            if (t.headMetaRobots && (Et(e.attributes.name) === "robots" || Et(e.attributes.name) === "googlebot" || Et(e.attributes.name) === "bingbot")) return !0;
            if (t.headMetaHttpEquiv && e.attributes["http-equiv"] !== void 0) return !0;
            if (t.headMetaAuthorship && (Et(e.attributes.name) === "author" || Et(e.attributes.name) === "generator" || Et(e.attributes.name) === "framework" || Et(e.attributes.name) === "publisher" || Et(e.attributes.name) === "progid" || Et(e.attributes.property).match(/^article:/) || Et(e.attributes.property).match(/^product:/))) return !0;
            if (t.headMetaVerification && (Et(e.attributes.name) === "google-site-verification" || Et(e.attributes.name) === "yandex-verification" || Et(e.attributes.name) === "csrf-token" || Et(e.attributes.name) === "p:domain_verify" || Et(e.attributes.name) === "verify-v1" || Et(e.attributes.name) === "verification" || Et(e.attributes.name) === "shopify-checkout-api-token")) return !0
        }
    }
    return !1
}

function sf(e, t) {
    const {
        doc: n,
        map: r,
        blockClass: s,
        blockSelector: i,
        unblockSelector: o,
        maskTextClass: a,
        maskTextSelector: l,
        unmaskTextSelector: c,
        skipChild: u = !1,
        inlineStylesheet: d = !0,
        maskInputSelector: f,
        unmaskInputSelector: h,
        maskAllText: p,
        maskInputOptions: m = {},
        maskTextFn: g,
        maskInputFn: y,
        slimDOMOptions: _,
        dataURLOptions: E = {},
        inlineImages: b = !1,
        recordCanvas: w = !1,
        onSerialize: T,
        onIframeLoad: S,
        iframeLoadTimeout: v = 5e3,
        keepIframeSrcFn: $ = () => !1
    } = t;
    let {
        preserveWhiteSpace: k = !0
    } = t;
    const C = oee(e, {
        doc: n,
        blockClass: s,
        blockSelector: i,
        unblockSelector: o,
        maskTextClass: a,
        maskTextSelector: l,
        unmaskTextSelector: c,
        inlineStylesheet: d,
        maskInputSelector: f,
        unmaskInputSelector: h,
        maskAllText: p,
        maskInputOptions: m,
        maskTextFn: g,
        maskInputFn: y,
        dataURLOptions: E,
        inlineImages: b,
        recordCanvas: w,
        keepIframeSrcFn: $
    });
    if (!C) return console.warn(e, "not serialized"), null;
    let O;
    "__sn" in e ? O = e.__sn.id : aee(C, _) || !k && C.type === vn.Text && !C.isStyle && !C.textContent.replace(/^\s+|\s+$/gm, "").length ? O = ph : O = zZ();
    const R = Object.assign(C, {
        id: O
    });
    if (e.__sn = R, O === ph) return null;
    r[O] = e, T && T(e);
    let N = !u;
    if (R.type === vn.Element && (N = N && !R.needBlock, delete R.needBlock, e.shadowRoot && (R.isShadowHost = !0)), (R.type === vn.Document || R.type === vn.Element) && N) {
        _.headWhitespace && C.type === vn.Element && C.tagName === "head" && (k = !1);
        const J = {
            doc: n,
            map: r,
            blockClass: s,
            blockSelector: i,
            unblockSelector: o,
            maskTextClass: a,
            maskTextSelector: l,
            unmaskTextSelector: c,
            skipChild: u,
            inlineStylesheet: d,
            maskInputSelector: f,
            unmaskInputSelector: h,
            maskAllText: p,
            maskInputOptions: m,
            maskTextFn: g,
            maskInputFn: y,
            slimDOMOptions: _,
            dataURLOptions: E,
            inlineImages: b,
            recordCanvas: w,
            preserveWhiteSpace: k,
            onSerialize: T,
            onIframeLoad: S,
            iframeLoadTimeout: v,
            keepIframeSrcFn: $
        };
        for (const Y of Array.from(e.childNodes)) {
            const ie = sf(Y, J);
            ie && R.childNodes.push(ie)
        }
        if (UZ(e) && e.shadowRoot)
            for (const Y of Array.from(e.shadowRoot.childNodes)) {
                const ie = sf(Y, J);
                ie && (ie.isShadow = !0, R.childNodes.push(ie))
            }
    }
    return e.parentNode && rf(e.parentNode) && (R.isShadow = !0), R.type === vn.Element && R.tagName === "iframe" && iee(e, () => {
        const J = e.contentDocument;
        if (J && S) {
            const Y = sf(J, {
                doc: J,
                map: r,
                blockClass: s,
                blockSelector: i,
                unblockSelector: o,
                maskTextClass: a,
                maskTextSelector: l,
                unmaskTextSelector: c,
                skipChild: !1,
                inlineStylesheet: d,
                maskInputSelector: f,
                unmaskInputSelector: h,
                maskAllText: p,
                maskInputOptions: m,
                maskTextFn: g,
                maskInputFn: y,
                slimDOMOptions: _,
                dataURLOptions: E,
                inlineImages: b,
                recordCanvas: w,
                preserveWhiteSpace: k,
                onSerialize: T,
                onIframeLoad: S,
                iframeLoadTimeout: v,
                keepIframeSrcFn: $
            });
            Y && S(e, Y)
        }
    }, v), R
}

function lee(e, t) {
    const {
        blockClass: n = "rr-block",
        blockSelector: r = null,
        unblockSelector: s = null,
        maskTextClass: i = "rr-mask",
        maskTextSelector: o = null,
        unmaskTextSelector: a = null,
        inlineStylesheet: l = !0,
        inlineImages: c = !1,
        recordCanvas: u = !1,
        maskInputSelector: d = null,
        unmaskInputSelector: f = null,
        maskAllText: h = !1,
        maskAllInputs: p = !1,
        maskTextFn: m,
        maskInputFn: g,
        slimDOM: y = !1,
        dataURLOptions: _,
        preserveWhiteSpace: E,
        onSerialize: b,
        onIframeLoad: w,
        iframeLoadTimeout: T,
        keepIframeSrcFn: S = () => !1
    } = t || {}, v = {};
    return [sf(e, {
        doc: e,
        map: v,
        blockClass: n,
        blockSelector: r,
        unblockSelector: s,
        maskTextClass: i,
        maskTextSelector: o,
        unmaskTextSelector: a,
        skipChild: !1,
        inlineStylesheet: l,
        maskInputSelector: d,
        unmaskInputSelector: f,
        maskAllText: h,
        maskInputOptions: p === !0 ? {
            color: !0,
            date: !0,
            "datetime-local": !0,
            email: !0,
            month: !0,
            number: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0,
            textarea: !0,
            select: !0
        } : p === !1 ? {} : p,
        maskTextFn: m,
        maskInputFn: g,
        slimDOMOptions: y === !0 || y === "all" ? {
            script: !0,
            comment: !0,
            headFavicon: !0,
            headWhitespace: !0,
            headMetaDescKeywords: y === "all",
            headMetaSocial: !0,
            headMetaRobots: !0,
            headMetaHttpEquiv: !0,
            headMetaAuthorship: !0,
            headMetaVerification: !0
        } : y === !1 ? {} : y,
        dataURLOptions: _,
        inlineImages: c,
        recordCanvas: u,
        preserveWhiteSpace: E,
        onSerialize: b,
        onIframeLoad: w,
        iframeLoadTimeout: T,
        keepIframeSrcFn: S
    }), v]
}

function cee(e, t, n) {
    return (e === "video" || e === "audio") && t === "autoplay"
}

function uee(e, t, n) {
    return e === "input" && (n.type === "radio" || n.type === "checkbox") ? t.getAttribute("value") || "" : t.value
}
var St;
(function(e) {
    e[e.DomContentLoaded = 0] = "DomContentLoaded", e[e.Load = 1] = "Load", e[e.FullSnapshot = 2] = "FullSnapshot", e[e.IncrementalSnapshot = 3] = "IncrementalSnapshot", e[e.Meta = 4] = "Meta", e[e.Custom = 5] = "Custom", e[e.Plugin = 6] = "Plugin"
})(St || (St = {}));
var In;
(function(e) {
    e[e.Mutation = 0] = "Mutation", e[e.MouseMove = 1] = "MouseMove", e[e.MouseInteraction = 2] = "MouseInteraction", e[e.Scroll = 3] = "Scroll", e[e.ViewportResize = 4] = "ViewportResize", e[e.Input = 5] = "Input", e[e.TouchMove = 6] = "TouchMove", e[e.MediaInteraction = 7] = "MediaInteraction", e[e.StyleSheetRule = 8] = "StyleSheetRule", e[e.CanvasMutation = 9] = "CanvasMutation", e[e.Font = 10] = "Font", e[e.Log = 11] = "Log", e[e.Drag = 12] = "Drag", e[e.StyleDeclaration = 13] = "StyleDeclaration"
})(In || (In = {}));
var T_;
(function(e) {
    e[e.MouseUp = 0] = "MouseUp", e[e.MouseDown = 1] = "MouseDown", e[e.Click = 2] = "Click", e[e.ContextMenu = 3] = "ContextMenu", e[e.DblClick = 4] = "DblClick", e[e.Focus = 5] = "Focus", e[e.Blur = 6] = "Blur", e[e.TouchStart = 7] = "TouchStart", e[e.TouchMove_Departed = 8] = "TouchMove_Departed", e[e.TouchEnd = 9] = "TouchEnd", e[e.TouchCancel = 10] = "TouchCancel"
})(T_ || (T_ = {}));
var hu;
(function(e) {
    e[e["2D"] = 0] = "2D", e[e.WebGL = 1] = "WebGL", e[e.WebGL2 = 2] = "WebGL2"
})(hu || (hu = {}));
var sA;
(function(e) {
    e[e.Play = 0] = "Play", e[e.Pause = 1] = "Pause", e[e.Seeked = 2] = "Seeked", e[e.VolumeChange = 3] = "VolumeChange"
})(sA || (sA = {}));
var iA;
(function(e) {
    e.Start = "start", e.Pause = "pause", e.Resume = "resume", e.Resize = "resize", e.Finish = "finish", e.FullsnapshotRebuilded = "fullsnapshot-rebuilded", e.LoadStylesheetStart = "load-stylesheet-start", e.LoadStylesheetEnd = "load-stylesheet-end", e.SkipStart = "skip-start", e.SkipEnd = "skip-end", e.MouseInteraction = "mouse-interaction", e.EventCast = "event-cast", e.CustomEvent = "custom-event", e.Flush = "flush", e.StateChange = "state-change", e.PlayBack = "play-back"
})(iA || (iA = {}));

function Nr(e, t, n = document) {
    const r = {
        capture: !0,
        passive: !0
    };
    return n.addEventListener(e, t, r), () => n.removeEventListener(e, t, r)
}

function dee() {
    return {
        map: {},
        getId(e) {
            return !e || !e.__sn ? -1 : e.__sn.id
        },
        getNode(e) {
            return this.map[e] || null
        },
        removeNodeFromMap(e) {
            const t = e.__sn && e.__sn.id;
            delete this.map[t], e.childNodes && e.childNodes.forEach(n => this.removeNodeFromMap(n))
        },
        has(e) {
            return this.map.hasOwnProperty(e)
        },
        reset() {
            this.map = {}
        }
    }
}
const ac = `Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`;
let oA = {
    map: {},
    getId() {
        return console.error(ac), -1
    },
    getNode() {
        return console.error(ac), null
    },
    removeNodeFromMap() {
        console.error(ac)
    },
    has() {
        return console.error(ac), !1
    },
    reset() {
        console.error(ac)
    }
};
typeof window != "undefined" && window.Proxy && window.Reflect && (oA = new Proxy(oA, {
    get(e, t, n) {
        return t === "map" && console.error(ac), Reflect.get(e, t, n)
    }
}));

function mh(e, t, n = {}) {
    let r = null,
        s = 0;
    return function(i) {
        let o = Date.now();
        !s && n.leading === !1 && (s = o);
        let a = t - (o - s),
            l = this,
            c = arguments;
        a <= 0 || a > t ? (r && (clearTimeout(r), r = null), s = o, e.apply(l, c)) : !r && n.trailing !== !1 && (r = setTimeout(() => {
            s = n.leading === !1 ? 0 : Date.now(), r = null, e.apply(l, c)
        }, a))
    }
}

function Uv(e, t, n, r, s = window) {
    const i = s.Object.getOwnPropertyDescriptor(e, t);
    return s.Object.defineProperty(e, t, r ? n : {
        set(o) {
            setTimeout(() => {
                n.set.call(this, o)
            }, 0), i && i.set && i.set.call(this, o)
        }
    }), () => Uv(e, t, i || {}, !0)
}

function pu(e, t, n) {
    try {
        if (!(t in e)) return () => {};
        const r = e[t],
            s = n(r);
        return typeof s == "function" && (s.prototype = s.prototype || {}, Object.defineProperties(s, {
            __rrweb_original__: {
                enumerable: !1,
                value: r
            }
        })), e[t] = s, () => {
            e[t] = r
        }
    } catch {
        return () => {}
    }
}

function AU() {
    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight
}

function RU() {
    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth
}

function ir(e, t, n, r) {
    if (!e) return !1;
    if (e.nodeType === e.ELEMENT_NODE) {
        let s = !1;
        const i = r && e.matches(r);
        return typeof t == "string" ? e.closest !== void 0 ? s = !i && e.closest("." + t) !== null : s = !i && e.classList.contains(t) : !i && e.classList.forEach(o => {
            t.test(o) && (s = !0)
        }), !s && n && (s = e.matches(n)), !i && s || ir(e.parentNode, t, n, r)
    }
    return e.nodeType === e.TEXT_NODE, ir(e.parentNode, t, n, r)
}

function _0(e) {
    return "__sn" in e ? e.__sn.id === ph : !1
}

function OU(e, t) {
    if (rf(e)) return !1;
    const n = t.getId(e);
    return t.has(n) ? e.parentNode && e.parentNode.nodeType === e.DOCUMENT_NODE ? !1 : e.parentNode ? OU(e.parentNode, t) : !0 : !0
}

function DU(e) {
    return Boolean(e.changedTouches)
}

function fee(e = window) {
    "NodeList" in e && !e.NodeList.prototype.forEach && (e.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in e && !e.DOMTokenList.prototype.forEach && (e.DOMTokenList.prototype.forEach = Array.prototype.forEach), Node.prototype.contains || (Node.prototype.contains = function(n) {
        if (!(0 in arguments)) throw new TypeError("1 argument is required");
        do
            if (this === n) return !0; while (n = n && n.parentNode);
        return !1
    })
}

function NU(e) {
    return "__sn" in e ? e.__sn.type === vn.Element && e.__sn.tagName === "iframe" : !1
}

function PU(e) {
    return Boolean(e == null ? void 0 : e.shadowRoot)
}

function aA(e) {
    return "__ln" in e
}
class hee {
    constructor() {
        this.length = 0, this.head = null
    }
    get(t) {
        if (t >= this.length) throw new Error("Position outside of list range");
        let n = this.head;
        for (let r = 0; r < t; r++) n = (n == null ? void 0 : n.next) || null;
        return n
    }
    addNode(t) {
        const n = {
            value: t,
            previous: null,
            next: null
        };
        if (t.__ln = n, t.previousSibling && aA(t.previousSibling)) {
            const r = t.previousSibling.__ln.next;
            n.next = r, n.previous = t.previousSibling.__ln, t.previousSibling.__ln.next = n, r && (r.previous = n)
        } else if (t.nextSibling && aA(t.nextSibling) && t.nextSibling.__ln.previous) {
            const r = t.nextSibling.__ln.previous;
            n.previous = r, n.next = t.nextSibling.__ln, t.nextSibling.__ln.previous = n, r && (r.next = n)
        } else this.head && (this.head.previous = n), n.next = this.head, this.head = n;
        this.length++
    }
    removeNode(t) {
        const n = t.__ln;
        !this.head || (n.previous ? (n.previous.next = n.next, n.next && (n.next.previous = n.previous)) : (this.head = n.next, this.head && (this.head.previous = null)), t.__ln && delete t.__ln, this.length--)
    }
}
const lA = (e, t) => `${e}@${t}`;

function cA(e) {
    return "__sn" in e
}
class pee {
    constructor() {
        this.frozen = !1, this.locked = !1, this.texts = [], this.attributes = [], this.removes = [], this.mapRemoves = [], this.movedMap = {}, this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.processMutations = t => {
            t.forEach(this.processMutation), this.emit()
        }, this.emit = () => {
            if (this.frozen || this.locked) return;
            const t = [],
                n = new hee,
                r = a => {
                    let l = a,
                        c = ph;
                    for (; c === ph;) l = l && l.nextSibling, c = l && this.mirror.getId(l);
                    return c
                },
                s = a => {
                    var l, c, u, d, f;
                    const h = a.getRootNode ? (l = a.getRootNode()) === null || l === void 0 ? void 0 : l.host : null;
                    let p = h;
                    for (; !((u = (c = p == null ? void 0 : p.getRootNode) === null || c === void 0 ? void 0 : c.call(p)) === null || u === void 0) && u.host;) p = ((f = (d = p == null ? void 0 : p.getRootNode) === null || d === void 0 ? void 0 : d.call(p)) === null || f === void 0 ? void 0 : f.host) || null;
                    const m = !this.doc.contains(a) && (!p || !this.doc.contains(p));
                    if (!a.parentNode || m) return;
                    const g = rf(a.parentNode) ? this.mirror.getId(h) : this.mirror.getId(a.parentNode),
                        y = r(a);
                    if (g === -1 || y === -1) return n.addNode(a);
                    let _ = sf(a, {
                        doc: this.doc,
                        map: this.mirror.map,
                        blockClass: this.blockClass,
                        blockSelector: this.blockSelector,
                        unblockSelector: this.unblockSelector,
                        maskTextClass: this.maskTextClass,
                        maskTextSelector: this.maskTextSelector,
                        unmaskTextSelector: this.unmaskTextSelector,
                        maskInputSelector: this.maskInputSelector,
                        unmaskInputSelector: this.unmaskInputSelector,
                        skipChild: !0,
                        inlineStylesheet: this.inlineStylesheet,
                        maskAllText: this.maskAllText,
                        maskInputOptions: this.maskInputOptions,
                        maskTextFn: this.maskTextFn,
                        maskInputFn: this.maskInputFn,
                        slimDOMOptions: this.slimDOMOptions,
                        recordCanvas: this.recordCanvas,
                        inlineImages: this.inlineImages,
                        onSerialize: E => {
                            NU(E) && this.iframeManager.addIframe(E), PU(a) && this.shadowDomManager.addShadowRoot(a.shadowRoot, document)
                        },
                        onIframeLoad: (E, b) => {
                            this.iframeManager.attachIframe(E, b), this.shadowDomManager.observeAttachShadow(E)
                        }
                    });
                    _ && t.push({
                        parentId: g,
                        nextId: y,
                        node: _
                    })
                };
            for (; this.mapRemoves.length;) this.mirror.removeNodeFromMap(this.mapRemoves.shift());
            for (const a of this.movedSet) AE(this.removes, a, this.mirror) && !this.movedSet.has(a.parentNode) || s(a);
            for (const a of this.addedSet) !RE(this.droppedSet, a) && !AE(this.removes, a, this.mirror) || RE(this.movedSet, a) ? s(a) : this.droppedSet.add(a);
            let i = null;
            for (; n.length;) {
                let a = null;
                if (i) {
                    const l = this.mirror.getId(i.value.parentNode),
                        c = r(i.value);
                    l !== -1 && c !== -1 && (a = i)
                }
                if (!a)
                    for (let l = n.length - 1; l >= 0; l--) {
                        const c = n.get(l);
                        if (c) {
                            const u = this.mirror.getId(c.value.parentNode),
                                d = r(c.value);
                            if (u !== -1 && d !== -1) {
                                a = c;
                                break
                            }
                        }
                    }
                if (!a) {
                    for (; n.head;) n.removeNode(n.head.value);
                    break
                }
                i = a.previous, n.removeNode(a.value), s(a.value)
            }
            const o = {
                texts: this.texts.map(a => ({
                    id: this.mirror.getId(a.node),
                    value: a.value
                })).filter(a => this.mirror.has(a.id)),
                attributes: this.attributes.map(a => ({
                    id: this.mirror.getId(a.node),
                    attributes: a.attributes
                })).filter(a => this.mirror.has(a.id)),
                removes: this.removes,
                adds: t
            };
            !o.texts.length && !o.attributes.length && !o.removes.length && !o.adds.length || (this.texts = [], this.attributes = [], this.removes = [], this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.movedMap = {}, this.mutationCb(o))
        }, this.processMutation = t => {
            if (!_0(t.target)) switch (t.type) {
                case "characterData":
                    {
                        const n = t.target.textContent;!ir(t.target, this.blockClass, this.blockSelector, this.unblockSelector) && n !== t.oldValue && this.texts.push({
                            value: S_(t.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextSelector, this.maskAllText) && n ? this.maskTextFn ? this.maskTextFn(n) : n.replace(/[\S]/g, "*") : n,
                            node: t.target
                        });
                        break
                    }
                case "attributes":
                    {
                        const n = t.target;
                        let r = n.getAttribute(t.attributeName);
                        if (t.attributeName === "value" && (r = E_({
                                input: n,
                                maskInputSelector: this.maskInputSelector,
                                unmaskInputSelector: this.unmaskInputSelector,
                                maskInputOptions: this.maskInputOptions,
                                tagName: n.tagName,
                                type: n.getAttribute("type"),
                                value: r,
                                maskInputFn: this.maskInputFn
                            })), ir(t.target, this.blockClass, this.blockSelector, this.unblockSelector) || r === t.oldValue) return;
                        let s = this.attributes.find(i => i.node === t.target);
                        if (s || (s = {
                                node: t.target,
                                attributes: {}
                            }, this.attributes.push(s)), t.attributeName === "type" && t.target.tagName === "INPUT" && (t.oldValue || "").toLowerCase() === "password" && t.target.setAttribute("rr_is_password", "true"), t.attributeName === "style") {
                            const i = this.doc.createElement("span");
                            t.oldValue && i.setAttribute("style", t.oldValue), (s.attributes.style === void 0 || s.attributes.style === null) && (s.attributes.style = {});
                            try {
                                const o = s.attributes.style;
                                for (const a of Array.from(n.style)) {
                                    const l = n.style.getPropertyValue(a),
                                        c = n.style.getPropertyPriority(a);
                                    (l !== i.style.getPropertyValue(a) || c !== i.style.getPropertyPriority(a)) && (c === "" ? o[a] = l : o[a] = [l, c])
                                }
                                for (const a of Array.from(i.style)) n.style.getPropertyValue(a) === "" && (o[a] = !1)
                            } catch (o) {
                                console.warn("[rrweb] Error when parsing update to style attribute:", o)
                            }
                        } else {
                            const i = t.target;
                            s.attributes[t.attributeName] = CU(this.doc, i, i.tagName, t.attributeName, r, this.maskAllText, this.unmaskTextSelector, this.maskTextFn)
                        }
                        break
                    }
                case "childList":
                    {
                        t.addedNodes.forEach(n => this.genAdds(n, t.target)),
                        t.removedNodes.forEach(n => {
                            const r = this.mirror.getId(n),
                                s = rf(t.target) ? this.mirror.getId(t.target.host) : this.mirror.getId(t.target);
                            ir(t.target, this.blockClass, this.blockSelector, this.unblockSelector) || _0(n) || (this.addedSet.has(n) ? (CE(this.addedSet, n), this.droppedSet.add(n)) : this.addedSet.has(t.target) && r === -1 || OU(t.target, this.mirror) || (this.movedSet.has(n) && this.movedMap[lA(r, s)] ? CE(this.movedSet, n) : this.removes.push({
                                parentId: s,
                                id: r,
                                isShadow: rf(t.target) ? !0 : void 0
                            })), this.mapRemoves.push(n))
                        });
                        break
                    }
            }
        }, this.genAdds = (t, n) => {
            if (!(n && ir(n, this.blockClass, this.blockSelector, this.unblockSelector))) {
                if (cA(t)) {
                    if (_0(t)) return;
                    this.movedSet.add(t);
                    let r = null;
                    n && cA(n) && (r = n.__sn.id), r && (this.movedMap[lA(t.__sn.id, r)] = !0)
                } else this.addedSet.add(t), this.droppedSet.delete(t);
                ir(t, this.blockClass, this.blockSelector, this.unblockSelector) || t.childNodes.forEach(r => this.genAdds(r))
            }
        }
    }
    init(t) {
        ["mutationCb", "blockClass", "blockSelector", "unblockSelector", "maskTextClass", "maskTextSelector", "unmaskTextSelector", "maskInputSelector", "unmaskInputSelector", "inlineStylesheet", "maskAllText", "maskInputOptions", "maskTextFn", "maskInputFn", "recordCanvas", "inlineImages", "slimDOMOptions", "doc", "mirror", "iframeManager", "shadowDomManager", "canvasManager"].forEach(n => {
            this[n] = t[n]
        })
    }
    freeze() {
        this.frozen = !0, this.canvasManager.freeze()
    }
    unfreeze() {
        this.frozen = !1, this.canvasManager.unfreeze(), this.emit()
    }
    isFrozen() {
        return this.frozen
    }
    lock() {
        this.locked = !0, this.canvasManager.lock()
    }
    unlock() {
        this.locked = !1, this.canvasManager.unlock(), this.emit()
    }
    reset() {
        this.shadowDomManager.reset(), this.canvasManager.reset()
    }
}

function CE(e, t) {
    e.delete(t), t.childNodes.forEach(n => CE(e, n))
}

function AE(e, t, n) {
    const {
        parentNode: r
    } = t;
    if (!r) return !1;
    const s = n.getId(r);
    return e.some(i => i.id === s) ? !0 : AE(e, r, n)
}

function RE(e, t) {
    const {
        parentNode: n
    } = t;
    return n ? e.has(n) ? !0 : RE(e, n) : !1
}
const rt = e => (...n) => {
        try {
            return e(...n)
        } catch (r) {
            try {
                r.__rrweb__ = !0
            } catch {}
            throw r
        }
    },
    Pa = [];

function bp(e) {
    try {
        if ("composedPath" in e) {
            const t = e.composedPath();
            if (t.length) return t[0]
        } else if ("path" in e && e.path.length) return e.path[0]
    } catch {}
    return e && e.target
}

function MU(e, t) {
    var n, r;
    const s = new pee;
    Pa.push(s), s.init(e);
    let i = window.MutationObserver || window.__rrMutationObserver;
    const o = (r = (n = window == null ? void 0 : window.Zone) === null || n === void 0 ? void 0 : n.__symbol__) === null || r === void 0 ? void 0 : r.call(n, "MutationObserver");
    o && window[o] && (i = window[o]);
    const a = new i(rt(l => {
        e.onMutation && e.onMutation(l) === !1 || s.processMutations(l)
    }));
    return a.observe(t, {
        attributes: !0,
        attributeOldValue: !0,
        characterData: !0,
        characterDataOldValue: !0,
        childList: !0,
        subtree: !0
    }), a
}

function mee({
    mousemoveCb: e,
    sampling: t,
    doc: n,
    mirror: r
}) {
    if (t.mousemove === !1) return () => {};
    const s = typeof t.mousemove == "number" ? t.mousemove : 50,
        i = typeof t.mousemoveCallback == "number" ? t.mousemoveCallback : 500;
    let o = [],
        a;
    const l = mh(d => {
            const f = Date.now() - a;
            rt(e)(o.map(h => (h.timeOffset -= f, h)), d), o = [], a = null
        }, i),
        c = mh(d => {
            const f = bp(d),
                {
                    clientX: h,
                    clientY: p
                } = DU(d) ? d.changedTouches[0] : d;
            a || (a = Date.now()), o.push({
                x: h,
                y: p,
                id: r.getId(f),
                timeOffset: Date.now() - a
            }), l(typeof DragEvent != "undefined" && d instanceof DragEvent ? In.Drag : d instanceof MouseEvent ? In.MouseMove : In.TouchMove)
        }, s, {
            trailing: !1
        }),
        u = [Nr("mousemove", rt(c), n), Nr("touchmove", rt(c), n), Nr("drag", rt(c), n)];
    return rt(() => {
        u.forEach(d => d())
    })
}

function gee({
    mouseInteractionCb: e,
    doc: t,
    mirror: n,
    blockClass: r,
    blockSelector: s,
    unblockSelector: i,
    sampling: o
}) {
    if (o.mouseInteraction === !1) return () => {};
    const a = o.mouseInteraction === !0 || o.mouseInteraction === void 0 ? {} : o.mouseInteraction,
        l = [],
        c = u => d => {
            const f = bp(d);
            if (ir(f, r, s, i)) return;
            const h = DU(d) ? d.changedTouches[0] : d;
            if (!h) return;
            const p = n.getId(f),
                {
                    clientX: m,
                    clientY: g
                } = h;
            rt(e)({
                type: T_[u],
                id: p,
                x: m,
                y: g
            })
        };
    return Object.keys(T_).filter(u => Number.isNaN(Number(u)) && !u.endsWith("_Departed") && a[u] !== !1).forEach(u => {
        const d = u.toLowerCase(),
            f = rt(c(u));
        l.push(Nr(d, f, t))
    }), rt(() => {
        l.forEach(u => u())
    })
}

function LU({
    scrollCb: e,
    doc: t,
    mirror: n,
    blockClass: r,
    blockSelector: s,
    unblockSelector: i,
    sampling: o
}) {
    const a = mh(l => {
        const c = bp(l);
        if (!c || ir(c, r, s, i)) return;
        const u = n.getId(c);
        if (c === t) {
            const d = t.scrollingElement || t.documentElement;
            rt(e)({
                id: u,
                x: d.scrollLeft,
                y: d.scrollTop
            })
        } else rt(e)({
            id: u,
            x: c.scrollLeft,
            y: c.scrollTop
        })
    }, o.scroll || 100);
    return Nr("scroll", rt(a), t)
}

function _ee({
    viewportResizeCb: e
}) {
    let t = -1,
        n = -1;
    const r = mh(() => {
        const s = AU(),
            i = RU();
        (t !== s || n !== i) && (rt(e)({
            width: Number(i),
            height: Number(s)
        }), t = s, n = i)
    }, 200);
    return Nr("resize", rt(r), window)
}

function uA(e, t) {
    const n = Object.assign({}, e);
    return t || delete n.userTriggered, n
}
const yee = ["INPUT", "TEXTAREA", "SELECT"],
    dA = new WeakMap;

function vee({
    inputCb: e,
    doc: t,
    mirror: n,
    blockClass: r,
    blockSelector: s,
    unblockSelector: i,
    ignoreClass: o,
    ignoreSelector: a,
    maskInputSelector: l,
    unmaskInputSelector: c,
    maskInputOptions: u,
    maskInputFn: d,
    sampling: f,
    userTriggeredOnInput: h
}) {
    function p(b) {
        let w = bp(b);
        const T = w && w.tagName,
            S = b.isTrusted;
        if (T === "OPTION" && (w = w.parentElement), !w || !T || yee.indexOf(T) < 0 || ir(w, r, s, i)) return;
        let v = w.type;
        if (w.classList.contains(o) || a && w.matches(a)) return;
        let $ = w.value,
            k = !1;
        w.hasAttribute("rr_is_password") && (v = "password"), v === "radio" || v === "checkbox" ? k = w.checked : BZ({
            maskInputOptions: u,
            maskInputSelector: l,
            tagName: T,
            type: v
        }) && ($ = E_({
            input: w,
            maskInputOptions: u,
            maskInputSelector: l,
            unmaskInputSelector: c,
            tagName: T,
            type: v,
            value: $,
            maskInputFn: d
        })), m(w, rt(uA)({
            text: $,
            isChecked: k,
            userTriggered: S
        }, h));
        const C = w.name;
        v === "radio" && C && k && t.querySelectorAll(`input[type="radio"][name="${C}"]`).forEach(O => {
            O !== w && m(O, rt(uA)({
                text: O.value,
                isChecked: !k,
                userTriggered: !1
            }, h))
        })
    }

    function m(b, w) {
        const T = dA.get(b);
        if (!T || T.text !== w.text || T.isChecked !== w.isChecked) {
            dA.set(b, w);
            const S = n.getId(b);
            e(Object.assign(Object.assign({}, w), {
                id: S
            }))
        }
    }
    const y = (f.input === "last" ? ["change"] : ["input", "change"]).map(b => Nr(b, rt(p), t)),
        _ = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value"),
        E = [
            [HTMLInputElement.prototype, "value"],
            [HTMLInputElement.prototype, "checked"],
            [HTMLSelectElement.prototype, "value"],
            [HTMLTextAreaElement.prototype, "value"],
            [HTMLSelectElement.prototype, "selectedIndex"],
            [HTMLOptionElement.prototype, "selected"]
        ];
    return _ && _.set && y.push(...E.map(b => Uv(b[0], b[1], {
        set() {
            rt(p)({
                target: this
            })
        }
    }))), rt(() => {
        y.forEach(b => b())
    })
}

function $_(e) {
    const t = [];

    function n(r, s) {
        if (gm("CSSGroupingRule") && r.parentRule instanceof CSSGroupingRule || gm("CSSMediaRule") && r.parentRule instanceof CSSMediaRule || gm("CSSSupportsRule") && r.parentRule instanceof CSSSupportsRule || gm("CSSConditionRule") && r.parentRule instanceof CSSConditionRule) {
            const o = Array.from(r.parentRule.cssRules).indexOf(r);
            s.unshift(o)
        } else {
            const o = Array.from(r.parentStyleSheet.cssRules).indexOf(r);
            s.unshift(o)
        }
        return s
    }
    return n(e, t)
}

function bee({
    styleSheetRuleCb: e,
    mirror: t
}, {
    win: n
}) {
    if (!n.CSSStyleSheet || !n.CSSStyleSheet.prototype) return () => {};
    const r = n.CSSStyleSheet.prototype.insertRule;
    n.CSSStyleSheet.prototype.insertRule = new Proxy(r, {
        apply: rt((a, l, c) => {
            const [u, d] = c, f = t.getId(l.ownerNode);
            return f !== -1 && e({
                id: f,
                adds: [{
                    rule: u,
                    index: d
                }]
            }), a.apply(l, c)
        })
    });
    const s = n.CSSStyleSheet.prototype.deleteRule;
    n.CSSStyleSheet.prototype.deleteRule = new Proxy(s, {
        apply: rt((a, l, c) => {
            const [u] = c, d = t.getId(l.ownerNode);
            return d !== -1 && e({
                id: d,
                removes: [{
                    index: u
                }]
            }), a.apply(l, c)
        })
    });
    const i = {};
    _m("CSSGroupingRule") ? i.CSSGroupingRule = n.CSSGroupingRule : (_m("CSSMediaRule") && (i.CSSMediaRule = n.CSSMediaRule), _m("CSSConditionRule") && (i.CSSConditionRule = n.CSSConditionRule), _m("CSSSupportsRule") && (i.CSSSupportsRule = n.CSSSupportsRule));
    const o = {};
    return Object.entries(i).forEach(([a, l]) => {
        o[a] = {
            insertRule: l.prototype.insertRule,
            deleteRule: l.prototype.deleteRule
        }, l.prototype.insertRule = new Proxy(o[a].insertRule, {
            apply: rt((c, u, d) => {
                const [f, h] = d, p = t.getId(u.parentStyleSheet.ownerNode);
                return p !== -1 && e({
                    id: p,
                    adds: [{
                        rule: f,
                        index: [...$_(u), h || 0]
                    }]
                }), c.apply(u, d)
            })
        }), l.prototype.deleteRule = new Proxy(o[a].deleteRule, {
            apply: rt((c, u, d) => {
                const [f] = d, h = t.getId(u.parentStyleSheet.ownerNode);
                return h !== -1 && e({
                    id: h,
                    removes: [{
                        index: [...$_(u), f]
                    }]
                }), c.apply(u, d)
            })
        })
    }), rt(() => {
        n.CSSStyleSheet.prototype.insertRule = r, n.CSSStyleSheet.prototype.deleteRule = s, Object.entries(i).forEach(([a, l]) => {
            l.prototype.insertRule = o[a].insertRule, l.prototype.deleteRule = o[a].deleteRule
        })
    })
}

function wee({
    styleDeclarationCb: e,
    mirror: t
}, {
    win: n
}) {
    const r = n.CSSStyleDeclaration.prototype.setProperty;
    n.CSSStyleDeclaration.prototype.setProperty = new Proxy(r, {
        apply: rt((i, o, a) => {
            var l, c;
            const [u, d, f] = a, h = t.getId((c = (l = o.parentRule) === null || l === void 0 ? void 0 : l.parentStyleSheet) === null || c === void 0 ? void 0 : c.ownerNode);
            return h !== -1 && e({
                id: h,
                set: {
                    property: u,
                    value: d,
                    priority: f
                },
                index: $_(o.parentRule)
            }), i.apply(o, a)
        })
    });
    const s = n.CSSStyleDeclaration.prototype.removeProperty;
    return n.CSSStyleDeclaration.prototype.removeProperty = new Proxy(s, {
        apply: rt((i, o, a) => {
            var l, c;
            const [u] = a, d = t.getId((c = (l = o.parentRule) === null || l === void 0 ? void 0 : l.parentStyleSheet) === null || c === void 0 ? void 0 : c.ownerNode);
            return d !== -1 && e({
                id: d,
                remove: {
                    property: u
                },
                index: $_(o.parentRule)
            }), i.apply(o, a)
        })
    }), rt(() => {
        n.CSSStyleDeclaration.prototype.setProperty = r, n.CSSStyleDeclaration.prototype.removeProperty = s
    })
}

function Eee({
    mediaInteractionCb: e,
    blockClass: t,
    blockSelector: n,
    unblockSelector: r,
    mirror: s,
    sampling: i
}) {
    const o = l => mh(rt(c => {
            const u = bp(c);
            if (!u || ir(u, t, n, r)) return;
            const {
                currentTime: d,
                volume: f,
                muted: h
            } = u;
            e({
                type: l,
                id: s.getId(u),
                currentTime: d,
                volume: f,
                muted: h
            })
        }), i.media || 500),
        a = [Nr("play", o(0)), Nr("pause", o(1)), Nr("seeked", o(2)), Nr("volumechange", o(3))];
    return rt(() => {
        a.forEach(l => l())
    })
}

function See({
    fontCb: e,
    doc: t
}) {
    const n = t.defaultView;
    if (!n) return () => {};
    const r = [],
        s = new WeakMap,
        i = n.FontFace;
    n.FontFace = function(l, c, u) {
        const d = new i(l, c, u);
        return s.set(d, {
            family: l,
            buffer: typeof c != "string",
            descriptors: u,
            fontSource: typeof c == "string" ? c : JSON.stringify(Array.from(new Uint8Array(c)))
        }), d
    };
    const o = pu(t.fonts, "add", function(a) {
        return function(l) {
            return setTimeout(() => {
                const c = s.get(l);
                c && (e(c), s.delete(l))
            }, 0), a.apply(this, [l])
        }
    });
    return r.push(() => {
        n.FontFace = i
    }), r.push(o), rt(() => {
        r.forEach(a => a())
    })
}

function Tee(e, t) {
    const {
        mutationCb: n,
        mousemoveCb: r,
        mouseInteractionCb: s,
        scrollCb: i,
        viewportResizeCb: o,
        inputCb: a,
        mediaInteractionCb: l,
        styleSheetRuleCb: c,
        styleDeclarationCb: u,
        canvasMutationCb: d,
        fontCb: f
    } = e;
    e.mutationCb = (...h) => {
        t.mutation && t.mutation(...h), n(...h)
    }, e.mousemoveCb = (...h) => {
        t.mousemove && t.mousemove(...h), r(...h)
    }, e.mouseInteractionCb = (...h) => {
        t.mouseInteraction && t.mouseInteraction(...h), s(...h)
    }, e.scrollCb = (...h) => {
        t.scroll && t.scroll(...h), i(...h)
    }, e.viewportResizeCb = (...h) => {
        t.viewportResize && t.viewportResize(...h), o(...h)
    }, e.inputCb = (...h) => {
        t.input && t.input(...h), a(...h)
    }, e.mediaInteractionCb = (...h) => {
        t.mediaInteaction && t.mediaInteaction(...h), l(...h)
    }, e.styleSheetRuleCb = (...h) => {
        t.styleSheetRule && t.styleSheetRule(...h), c(...h)
    }, e.styleDeclarationCb = (...h) => {
        t.styleDeclaration && t.styleDeclaration(...h), u(...h)
    }, e.canvasMutationCb = (...h) => {
        t.canvasMutation && t.canvasMutation(...h), d(...h)
    }, e.fontCb = (...h) => {
        t.font && t.font(...h), f(...h)
    }
}

function $ee(e, t = {}) {
    const n = e.doc.defaultView;
    if (!n) return () => {};
    Tee(e, t);
    const r = MU(e, e.doc),
        s = mee(e),
        i = gee(e),
        o = LU(e),
        a = _ee(e),
        l = vee(e),
        c = Eee(e),
        u = bee(e, {
            win: n
        }),
        d = wee(e, {
            win: n
        }),
        f = e.collectFonts ? See(e) : () => {},
        h = [];
    for (const p of e.plugins) h.push(p.observer(p.callback, n, p.options));
    return rt(() => {
        Pa.forEach(p => p.reset()), r.disconnect(), s(), i(), o(), a(), l(), c();
        try {
            u(), d()
        } catch {}
        f(), h.forEach(p => p())
    })
}

function gm(e) {
    return typeof window[e] != "undefined"
}

function _m(e) {
    return Boolean(typeof window[e] != "undefined" && window[e].prototype && "insertRule" in window[e].prototype && "deleteRule" in window[e].prototype)
}
class kee {
    constructor(t) {
        this.iframes = new WeakMap, this.mutationCb = t.mutationCb
    }
    addIframe(t) {
        this.iframes.set(t, !0)
    }
    addLoadListener(t) {
        this.loadListener = t
    }
    attachIframe(t, n) {
        var r;
        this.mutationCb({
            adds: [{
                parentId: t.__sn.id,
                nextId: null,
                node: n
            }],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: !0
        }), (r = this.loadListener) === null || r === void 0 || r.call(this, t)
    }
}
class Iee {
    constructor(t) {
        this.restorePatches = [], this.mutationCb = t.mutationCb, this.scrollCb = t.scrollCb, this.bypassOptions = t.bypassOptions, this.mirror = t.mirror;
        const n = this;
        this.restorePatches.push(pu(HTMLElement.prototype, "attachShadow", function(r) {
            return function() {
                const s = r.apply(this, arguments);
                return this.shadowRoot && n.addShadowRoot(this.shadowRoot, this.ownerDocument), s
            }
        }))
    }
    addShadowRoot(t, n) {
        MU(Object.assign(Object.assign({}, this.bypassOptions), {
            doc: n,
            mutationCb: this.mutationCb,
            mirror: this.mirror,
            shadowDomManager: this
        }), t), LU(Object.assign(Object.assign({}, this.bypassOptions), {
            scrollCb: this.scrollCb,
            doc: t,
            mirror: this.mirror
        }))
    }
    observeAttachShadow(t) {
        if (t.contentWindow) {
            const n = this;
            this.restorePatches.push(pu(t.contentWindow.HTMLElement.prototype, "attachShadow", function(r) {
                return function() {
                    const s = r.apply(this, arguments);
                    return this.shadowRoot && n.addShadowRoot(this.shadowRoot, t.contentDocument), s
                }
            }))
        }
    }
    reset() {
        this.restorePatches.forEach(t => t())
    }
}

function xee(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]]);
    return n
}

function Cee(e, t, n, r, s, i) {
    const o = [],
        a = Object.getOwnPropertyNames(t.CanvasRenderingContext2D.prototype);
    for (const l of a) try {
        if (typeof t.CanvasRenderingContext2D.prototype[l] != "function") continue;
        const c = pu(t.CanvasRenderingContext2D.prototype, l, function(u) {
            return function(...d) {
                return ir(this.canvas, n, s, r) || setTimeout(() => {
                    const f = [...d];
                    if (l === "drawImage" && f[0] && f[0] instanceof HTMLCanvasElement) {
                        const h = f[0],
                            p = h.getContext("2d");
                        let m = p == null ? void 0 : p.getImageData(0, 0, h.width, h.height),
                            g = m == null ? void 0 : m.data;
                        f[0] = JSON.stringify(g)
                    }
                    e(this.canvas, {
                        type: hu["2D"],
                        property: l,
                        args: f
                    })
                }, 0), u.apply(this, d)
            }
        });
        o.push(c)
    } catch {
        const u = Uv(t.CanvasRenderingContext2D.prototype, l, {
            set(d) {
                e(this.canvas, {
                    type: hu["2D"],
                    property: l,
                    args: [d],
                    setter: !0
                })
            }
        });
        o.push(u)
    }
    return () => {
        o.forEach(l => l())
    }
}

function Aee(e, t, n, r) {
    const s = [];
    try {
        const i = pu(e.HTMLCanvasElement.prototype, "getContext", function(o) {
            return function(a, ...l) {
                return ir(this, t, n, r) || "__context" in this || (this.__context = a), o.apply(this, [a, ...l])
            }
        });
        s.push(i)
    } catch {
        console.error("failed to patch HTMLCanvasElement.prototype.getContext")
    }
    return () => {
        s.forEach(i => i())
    }
}
var bc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    Ree = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256);
for (var ym = 0; ym < bc.length; ym++) Ree[bc.charCodeAt(ym)] = ym;
var Oee = function(e) {
    var t = new Uint8Array(e),
        n, r = t.length,
        s = "";
    for (n = 0; n < r; n += 3) s += bc[t[n] >> 2], s += bc[(t[n] & 3) << 4 | t[n + 1] >> 4], s += bc[(t[n + 1] & 15) << 2 | t[n + 2] >> 6], s += bc[t[n + 2] & 63];
    return r % 3 === 2 ? s = s.substring(0, s.length - 1) + "=" : r % 3 === 1 && (s = s.substring(0, s.length - 2) + "=="), s
};
const fA = new Map;

function Dee(e, t) {
    let n = fA.get(e);
    return n || (n = new Map, fA.set(e, n)), n.has(t) || n.set(t, []), n.get(t)
}
const FU = (e, t, n) => {
    if (!e || !(UU(e, t) || typeof e == "object")) return;
    const r = e.constructor.name,
        s = Dee(n, r);
    let i = s.indexOf(e);
    return i === -1 && (i = s.length, s.push(e)), i
};

function lg(e, t, n) {
    if (e instanceof Array) return e.map(r => lg(r, t, n));
    if (e === null) return e;
    if (e instanceof Float32Array || e instanceof Float64Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Uint8Array || e instanceof Uint16Array || e instanceof Int16Array || e instanceof Int8Array || e instanceof Uint8ClampedArray) return {
        rr_type: e.constructor.name,
        args: [Object.values(e)]
    };
    if (e instanceof ArrayBuffer) {
        const r = e.constructor.name,
            s = Oee(e);
        return {
            rr_type: r,
            base64: s
        }
    } else {
        if (e instanceof DataView) return {
            rr_type: e.constructor.name,
            args: [lg(e.buffer, t, n), e.byteOffset, e.byteLength]
        };
        if (e instanceof HTMLImageElement) {
            const r = e.constructor.name,
                {
                    src: s
                } = e;
            return {
                rr_type: r,
                src: s
            }
        } else {
            if (e instanceof ImageData) return {
                rr_type: e.constructor.name,
                args: [lg(e.data, t, n), e.width, e.height]
            };
            if (UU(e, t) || typeof e == "object") {
                const r = e.constructor.name,
                    s = FU(e, t, n);
                return {
                    rr_type: r,
                    index: s
                }
            }
        }
    }
    return e
}
const Nee = (e, t, n) => [...e].map(r => lg(r, t, n)),
    UU = (e, t) => {
        const r = ["WebGLActiveInfo", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLShaderPrecisionFormat", "WebGLTexture", "WebGLUniformLocation", "WebGLVertexArrayObject", "WebGLVertexArrayObjectOES"].filter(s => typeof t[s] == "function");
        return Boolean(r.find(s => e instanceof t[s]))
    };

function hA(e, t, n, r, s, i, o, a) {
    const l = [],
        c = Object.getOwnPropertyNames(e);
    for (const u of c) try {
        if (typeof e[u] != "function") continue;
        const d = pu(e, u, function(f) {
            return function(...h) {
                const p = f.apply(this, h);
                if (FU(p, a, e), !ir(this.canvas, r, i, s)) {
                    const m = o.getId(this.canvas),
                        g = Nee([...h], a, e),
                        y = {
                            type: t,
                            property: u,
                            args: g
                        };
                    n(this.canvas, y)
                }
                return p
            }
        });
        l.push(d)
    } catch {
        const f = Uv(e, u, {
            set(h) {
                n(this.canvas, {
                    type: t,
                    property: u,
                    args: [h],
                    setter: !0
                })
            }
        });
        l.push(f)
    }
    return l
}

function Pee(e, t, n, r, s, i) {
    const o = [];
    return o.push(...hA(t.WebGLRenderingContext.prototype, hu.WebGL, e, n, r, s, i, t)), typeof t.WebGL2RenderingContext != "undefined" && o.push(...hA(t.WebGL2RenderingContext.prototype, hu.WebGL2, e, n, r, s, i, t)), () => {
        o.forEach(a => a())
    }
}
class Mee {
    reset() {
        this.pendingCanvasMutations.clear(), this.resetObservers && this.resetObservers()
    }
    freeze() {
        this.frozen = !0
    }
    unfreeze() {
        this.frozen = !1
    }
    lock() {
        this.locked = !0
    }
    unlock() {
        this.locked = !1
    }
    constructor(t) {
        this.pendingCanvasMutations = new Map, this.rafStamps = {
            latestId: 0,
            invokeId: null
        }, this.frozen = !1, this.locked = !1, this.processMutation = function(n, r) {
            (this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId || !this.rafStamps.invokeId) && (this.rafStamps.invokeId = this.rafStamps.latestId), this.pendingCanvasMutations.has(n) || this.pendingCanvasMutations.set(n, []), this.pendingCanvasMutations.get(n).push(r)
        }, this.mutationCb = t.mutationCb, this.mirror = t.mirror, t.recordCanvas === !0 && this.initCanvasMutationObserver(t.win, t.blockClass, t.blockSelector, t.unblockSelector)
    }
    initCanvasMutationObserver(t, n, r, s) {
        this.startRAFTimestamping(), this.startPendingCanvasMutationFlusher();
        const i = Aee(t, n, s, r),
            o = Cee(this.processMutation.bind(this), t, n, s, r, this.mirror),
            a = Pee(this.processMutation.bind(this), t, n, s, r, this.mirror);
        this.resetObservers = () => {
            i(), o(), a()
        }
    }
    startPendingCanvasMutationFlusher() {
        requestAnimationFrame(() => this.flushPendingCanvasMutations())
    }
    startRAFTimestamping() {
        const t = n => {
            this.rafStamps.latestId = n, requestAnimationFrame(t)
        };
        requestAnimationFrame(t)
    }
    flushPendingCanvasMutations() {
        this.pendingCanvasMutations.forEach((t, n) => {
            const r = this.mirror.getId(n);
            this.flushPendingCanvasMutationFor(n, r)
        }), requestAnimationFrame(() => this.flushPendingCanvasMutations())
    }
    flushPendingCanvasMutationFor(t, n) {
        if (this.frozen || this.locked) return;
        const r = this.pendingCanvasMutations.get(t);
        if (!r || n === -1) return;
        const s = r.map(o => xee(o, ["type"])),
            {
                type: i
            } = r[0];
        this.mutationCb({
            id: n,
            type: i,
            commands: s
        }), this.pendingCanvasMutations.delete(t)
    }
}

function kn(e) {
    return Object.assign(Object.assign({}, e), {
        timestamp: Date.now()
    })
}
let en, of ;
const Md = dee();

function fl(e = {}) {
    const {
        emit: t,
        checkoutEveryNms: n,
        checkoutEveryNth: r,
        blockClass: s = "rr-block",
        blockSelector: i = null,
        unblockSelector: o = null,
        ignoreClass: a = "rr-ignore",
        ignoreSelector: l = null,
        maskTextClass: c = "rr-mask",
        maskTextSelector: u = null,
        maskInputSelector: d = null,
        unmaskTextSelector: f = null,
        unmaskInputSelector: h = null,
        inlineStylesheet: p = !0,
        maskAllText: m = !1,
        maskAllInputs: g,
        maskInputOptions: y,
        slimDOMOptions: _,
        maskInputFn: E,
        maskTextFn: b,
        hooks: w,
        packFn: T,
        sampling: S = {},
        mousemoveWait: v,
        recordCanvas: $ = !1,
        userTriggeredOnInput: k = !1,
        collectFonts: C = !1,
        inlineImages: O = !1,
        plugins: R,
        keepIframeSrcFn: N = () => !1,
        onMutation: J
    } = e;
    if (!t) throw new Error("emit function is required");
    v !== void 0 && S.mousemove === void 0 && (S.mousemove = v);
    const Y = g === !0 ? {
            color: !0,
            date: !0,
            "datetime-local": !0,
            email: !0,
            month: !0,
            number: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0,
            textarea: !0,
            select: !0,
            radio: !0,
            checkbox: !0
        } : y !== void 0 ? y : {},
        ie = _ === !0 || _ === "all" ? {
            script: !0,
            comment: !0,
            headFavicon: !0,
            headWhitespace: !0,
            headMetaSocial: !0,
            headMetaRobots: !0,
            headMetaHttpEquiv: !0,
            headMetaVerification: !0,
            headMetaAuthorship: _ === "all",
            headMetaDescKeywords: _ === "all"
        } : _ || {};
    fee();
    let ce, Ue = 0;
    const Kt = D => {
        for (const V of R || []) V.eventProcessor && (D = V.eventProcessor(D));
        return T && (D = T(D)), D
    };
    en = (D, V) => {
        var oe;
        if (((oe = Pa[0]) === null || oe === void 0 ? void 0 : oe.isFrozen()) && D.type !== St.FullSnapshot && !(D.type === St.IncrementalSnapshot && D.data.source === In.Mutation) && Pa.forEach(we => we.unfreeze()), t(Kt(D), V), D.type === St.FullSnapshot) ce = D, Ue = 0;
        else if (D.type === St.IncrementalSnapshot) {
            if (D.data.source === In.Mutation && D.data.isAttachIframe) return;
            Ue++;
            const we = r && Ue >= r,
                ge = n && D.timestamp - ce.timestamp > n;
            (we || ge) && of (!0)
        }
    };
    const Yt = D => {
            en(kn({
                type: St.IncrementalSnapshot,
                data: Object.assign({
                    source: In.Mutation
                }, D)
            }))
        },
        pn = D => en(kn({
            type: St.IncrementalSnapshot,
            data: Object.assign({
                source: In.Scroll
            }, D)
        })),
        mn = D => en(kn({
            type: St.IncrementalSnapshot,
            data: Object.assign({
                source: In.CanvasMutation
            }, D)
        })),
        pr = new kee({
            mutationCb: Yt
        }),
        L = new Mee({
            recordCanvas: $,
            mutationCb: mn,
            win: window,
            blockClass: s,
            blockSelector: i,
            unblockSelector: o,
            mirror: Md
        }),
        se = new Iee({
            mutationCb: Yt,
            scrollCb: pn,
            bypassOptions: {
                onMutation: J,
                blockClass: s,
                blockSelector: i,
                unblockSelector: o,
                maskTextClass: c,
                maskTextSelector: u,
                unmaskTextSelector: f,
                maskInputSelector: d,
                unmaskInputSelector: h,
                inlineStylesheet: p,
                maskAllText: m,
                maskInputOptions: Y,
                maskTextFn: b,
                maskInputFn: E,
                recordCanvas: $,
                inlineImages: O,
                sampling: S,
                slimDOMOptions: ie,
                iframeManager: pr,
                canvasManager: L
            },
            mirror: Md
        }); of = (D = !1) => {
        var V, oe, we, ge;
        en(kn({
            type: St.Meta,
            data: {
                href: window.location.href,
                width: RU(),
                height: AU()
            }
        }), D), Pa.forEach(A => A.lock());
        const [ee, I] = lee(document, {
            blockClass: s,
            blockSelector: i,
            unblockSelector: o,
            maskTextClass: c,
            maskTextSelector: u,
            unmaskTextSelector: f,
            maskInputSelector: d,
            unmaskInputSelector: h,
            inlineStylesheet: p,
            maskAllText: m,
            maskAllInputs: Y,
            maskTextFn: b,
            slimDOM: ie,
            recordCanvas: $,
            inlineImages: O,
            onSerialize: A => {
                NU(A) && pr.addIframe(A), PU(A) && se.addShadowRoot(A.shadowRoot, document)
            },
            onIframeLoad: (A, P) => {
                pr.attachIframe(A, P), se.observeAttachShadow(A)
            },
            keepIframeSrcFn: N
        });
        if (!ee) return console.warn("Failed to snapshot the document");
        Md.map = I, en(kn({
            type: St.FullSnapshot,
            data: {
                node: ee,
                initialOffset: {
                    left: window.pageXOffset !== void 0 ? window.pageXOffset : (document == null ? void 0 : document.documentElement.scrollLeft) || ((oe = (V = document == null ? void 0 : document.body) === null || V === void 0 ? void 0 : V.parentElement) === null || oe === void 0 ? void 0 : oe.scrollLeft) || (document == null ? void 0 : document.body.scrollLeft) || 0,
                    top: window.pageYOffset !== void 0 ? window.pageYOffset : (document == null ? void 0 : document.documentElement.scrollTop) || ((ge = (we = document == null ? void 0 : document.body) === null || we === void 0 ? void 0 : we.parentElement) === null || ge === void 0 ? void 0 : ge.scrollTop) || (document == null ? void 0 : document.body.scrollTop) || 0
                }
            }
        })), Pa.forEach(A => A.unlock())
    };
    try {
        const D = [];
        D.push(Nr("DOMContentLoaded", () => {
            en(kn({
                type: St.DomContentLoaded,
                data: {}
            }))
        }));
        const V = we => {
            var ge;
            return rt($ee)({
                onMutation: J,
                mutationCb: Yt,
                mousemoveCb: (ee, I) => en(kn({
                    type: St.IncrementalSnapshot,
                    data: {
                        source: I,
                        positions: ee
                    }
                })),
                mouseInteractionCb: ee => en(kn({
                    type: St.IncrementalSnapshot,
                    data: Object.assign({
                        source: In.MouseInteraction
                    }, ee)
                })),
                scrollCb: pn,
                viewportResizeCb: ee => en(kn({
                    type: St.IncrementalSnapshot,
                    data: Object.assign({
                        source: In.ViewportResize
                    }, ee)
                })),
                inputCb: ee => en(kn({
                    type: St.IncrementalSnapshot,
                    data: Object.assign({
                        source: In.Input
                    }, ee)
                })),
                mediaInteractionCb: ee => en(kn({
                    type: St.IncrementalSnapshot,
                    data: Object.assign({
                        source: In.MediaInteraction
                    }, ee)
                })),
                styleSheetRuleCb: ee => en(kn({
                    type: St.IncrementalSnapshot,
                    data: Object.assign({
                        source: In.StyleSheetRule
                    }, ee)
                })),
                styleDeclarationCb: ee => en(kn({
                    type: St.IncrementalSnapshot,
                    data: Object.assign({
                        source: In.StyleDeclaration
                    }, ee)
                })),
                canvasMutationCb: mn,
                fontCb: ee => en(kn({
                    type: St.IncrementalSnapshot,
                    data: Object.assign({
                        source: In.Font
                    }, ee)
                })),
                blockClass: s,
                ignoreClass: a,
                ignoreSelector: l,
                maskTextClass: c,
                maskTextSelector: u,
                unmaskTextSelector: f,
                maskInputSelector: d,
                unmaskInputSelector: h,
                maskInputOptions: Y,
                inlineStylesheet: p,
                sampling: S,
                recordCanvas: $,
                inlineImages: O,
                userTriggeredOnInput: k,
                collectFonts: C,
                doc: we,
                maskAllText: m,
                maskInputFn: E,
                maskTextFn: b,
                blockSelector: i,
                unblockSelector: o,
                slimDOMOptions: ie,
                mirror: Md,
                iframeManager: pr,
                shadowDomManager: se,
                canvasManager: L,
                plugins: ((ge = R == null ? void 0 : R.filter(ee => ee.observer)) === null || ge === void 0 ? void 0 : ge.map(ee => ({
                    observer: ee.observer,
                    options: ee.options,
                    callback: I => en(kn({
                        type: St.Plugin,
                        data: {
                            plugin: ee.name,
                            payload: I
                        }
                    }))
                }))) || []
            }, w)
        };
        pr.addLoadListener(we => {
            try {
                D.push(V(we.contentDocument))
            } catch (ge) {
                console.warn(ge)
            }
        });
        const oe = () => { of (), D.push(V(document))
        };
        return document.readyState === "interactive" || document.readyState === "complete" ? oe() : D.push(Nr("load", () => {
            en(kn({
                type: St.Load,
                data: {}
            })), oe()
        }, window)), () => {
            D.forEach(we => we())
        }
    } catch (D) {
        console.warn(D)
    }
}
fl.addCustomEvent = (e, t) => {
    if (!en) throw new Error("please add custom event after start recording");
    en(kn({
        type: St.Custom,
        data: {
            tag: e,
            payload: t
        }
    }))
};
fl.freezePage = () => {
    Pa.forEach(e => e.freeze())
};
fl.takeFullSnapshot = e => {
    if (! of ) throw new Error("please take full snapshot after start recording"); of (e)
};
fl.mirror = Md;
const Lee = ["name", "type", "startTime", "transferSize", "duration"];

function pA(e) {
    return function(t) {
        return Lee.every(n => e[n] === t[n])
    }
}

function Fee(e, t) {
    const [n, r, s] = e.reduce((l, c) => (c.entryType === "navigation" ? l[0].push(c) : c.entryType === "largest-contentful-paint" ? l[1].push(c) : l[2].push(c), l), [
        [],
        [],
        []
    ]), i = [], o = [];
    let a = r.length ? r[r.length - 1] : void 0;
    return t.forEach(l => {
        if (l.entryType === "largest-contentful-paint") {
            (!a || a.startTime < l.startTime) && (a = l);
            return
        }
        if (l.entryType === "navigation") {
            const c = l;
            l.duration > 0 && !n.find(pA(c)) && !o.find(pA(c)) && o.push(c);
            return
        }
        i.push(l)
    }), [...a ? [a] : [], ...n, ...s, ...i, ...o].sort((l, c) => l.startTime - c.startTime)
}

function Uee(e) {
    const t = r => {
            const s = Fee(e.performanceEvents, r.getEntries());
            e.performanceEvents = s
        },
        n = new PerformanceObserver(t);
    return ["element", "event", "first-input", "largest-contentful-paint", "layout-shift", "longtask", "navigation", "paint", "resource"].forEach(r => {
        try {
            n.observe({
                type: r,
                buffered: !0
            })
        } catch {}
    }), n
}
const Bee = `/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
function t(t){let e=t.length;for(;--e>=0;)t[e]=0}const e=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),a=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),i=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),n=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=new Array(576);t(s);const r=new Array(60);t(r);const o=new Array(512);t(o);const l=new Array(256);t(l);const h=new Array(29);t(h);const d=new Array(30);function _(t,e,a,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}let f,c,u;function w(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}t(d);const m=t=>t<256?o[t]:o[256+(t>>>7)],b=(t,e)=>{t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},g=(t,e,a)=>{t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535,b(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)},p=(t,e,a)=>{g(t,a[2*e],a[2*e+1])},k=(t,e)=>{let a=0;do{a|=1&t,t>>>=1,a<<=1}while(--e>0);return a>>>1},v=(t,e,a)=>{const i=new Array(16);let n,s,r=0;for(n=1;n<=15;n++)r=r+a[n-1]<<1,i[n]=r;for(s=0;s<=e;s++){let e=t[2*s+1];0!==e&&(t[2*s]=k(i[e]++,e))}},y=t=>{let e;for(e=0;e<286;e++)t.dyn_ltree[2*e]=0;for(e=0;e<30;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.sym_next=t.matches=0},x=t=>{t.bi_valid>8?b(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},z=(t,e,a,i)=>{const n=2*e,s=2*a;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[a]},A=(t,e,a)=>{const i=t.heap[a];let n=a<<1;for(;n<=t.heap_len&&(n<t.heap_len&&z(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!z(e,i,t.heap[n],t.depth));)t.heap[a]=t.heap[n],a=n,n<<=1;t.heap[a]=i},E=(t,i,n)=>{let s,r,o,_,f=0;if(0!==t.sym_next)do{s=255&t.pending_buf[t.sym_buf+f++],s+=(255&t.pending_buf[t.sym_buf+f++])<<8,r=t.pending_buf[t.sym_buf+f++],0===s?p(t,r,i):(o=l[r],p(t,o+256+1,i),_=e[o],0!==_&&(r-=h[o],g(t,r,_)),s--,o=m(s),p(t,o,n),_=a[o],0!==_&&(s-=d[o],g(t,s,_)))}while(f<t.sym_next);p(t,256,i)},R=(t,e)=>{const a=e.dyn_tree,i=e.stat_desc.static_tree,n=e.stat_desc.has_stree,s=e.stat_desc.elems;let r,o,l,h=-1;for(t.heap_len=0,t.heap_max=573,r=0;r<s;r++)0!==a[2*r]?(t.heap[++t.heap_len]=h=r,t.depth[r]=0):a[2*r+1]=0;for(;t.heap_len<2;)l=t.heap[++t.heap_len]=h<2?++h:0,a[2*l]=1,t.depth[l]=0,t.opt_len--,n&&(t.static_len-=i[2*l+1]);for(e.max_code=h,r=t.heap_len>>1;r>=1;r--)A(t,a,r);l=s;do{r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],A(t,a,1),o=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=o,a[2*l]=a[2*r]+a[2*o],t.depth[l]=(t.depth[r]>=t.depth[o]?t.depth[r]:t.depth[o])+1,a[2*r+1]=a[2*o+1]=l,t.heap[1]=l++,A(t,a,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],((t,e)=>{const a=e.dyn_tree,i=e.max_code,n=e.stat_desc.static_tree,s=e.stat_desc.has_stree,r=e.stat_desc.extra_bits,o=e.stat_desc.extra_base,l=e.stat_desc.max_length;let h,d,_,f,c,u,w=0;for(f=0;f<=15;f++)t.bl_count[f]=0;for(a[2*t.heap[t.heap_max]+1]=0,h=t.heap_max+1;h<573;h++)d=t.heap[h],f=a[2*a[2*d+1]+1]+1,f>l&&(f=l,w++),a[2*d+1]=f,d>i||(t.bl_count[f]++,c=0,d>=o&&(c=r[d-o]),u=a[2*d],t.opt_len+=u*(f+c),s&&(t.static_len+=u*(n[2*d+1]+c)));if(0!==w){do{for(f=l-1;0===t.bl_count[f];)f--;t.bl_count[f]--,t.bl_count[f+1]+=2,t.bl_count[l]--,w-=2}while(w>0);for(f=l;0!==f;f--)for(d=t.bl_count[f];0!==d;)_=t.heap[--h],_>i||(a[2*_+1]!==f&&(t.opt_len+=(f-a[2*_+1])*a[2*_],a[2*_+1]=f),d--)}})(t,e),v(a,h,t.bl_count)},Z=(t,e,a)=>{let i,n,s=-1,r=e[1],o=0,l=7,h=4;for(0===r&&(l=138,h=3),e[2*(a+1)+1]=65535,i=0;i<=a;i++)n=r,r=e[2*(i+1)+1],++o<l&&n===r||(o<h?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[32]++):o<=10?t.bl_tree[34]++:t.bl_tree[36]++,o=0,s=n,0===r?(l=138,h=3):n===r?(l=6,h=3):(l=7,h=4))},U=(t,e,a)=>{let i,n,s=-1,r=e[1],o=0,l=7,h=4;for(0===r&&(l=138,h=3),i=0;i<=a;i++)if(n=r,r=e[2*(i+1)+1],!(++o<l&&n===r)){if(o<h)do{p(t,n,t.bl_tree)}while(0!=--o);else 0!==n?(n!==s&&(p(t,n,t.bl_tree),o--),p(t,16,t.bl_tree),g(t,o-3,2)):o<=10?(p(t,17,t.bl_tree),g(t,o-3,3)):(p(t,18,t.bl_tree),g(t,o-11,7));o=0,s=n,0===r?(l=138,h=3):n===r?(l=6,h=3):(l=7,h=4)}};let S=!1;const D=(t,e,a,i)=>{g(t,0+(i?1:0),3),x(t),b(t,a),b(t,~a),a&&t.pending_buf.set(t.window.subarray(e,e+a),t.pending),t.pending+=a};var T=(t,e,a,i)=>{let o,l,h=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=(t=>{let e,a=4093624447;for(e=0;e<=31;e++,a>>>=1)if(1&a&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<256;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0})(t)),R(t,t.l_desc),R(t,t.d_desc),h=(t=>{let e;for(Z(t,t.dyn_ltree,t.l_desc.max_code),Z(t,t.dyn_dtree,t.d_desc.max_code),R(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*n[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e})(t),o=t.opt_len+3+7>>>3,l=t.static_len+3+7>>>3,l<=o&&(o=l)):o=l=a+5,a+4<=o&&-1!==e?D(t,e,a,i):4===t.strategy||l===o?(g(t,2+(i?1:0),3),E(t,s,r)):(g(t,4+(i?1:0),3),((t,e,a,i)=>{let s;for(g(t,e-257,5),g(t,a-1,5),g(t,i-4,4),s=0;s<i;s++)g(t,t.bl_tree[2*n[s]+1],3);U(t,t.dyn_ltree,e-1),U(t,t.dyn_dtree,a-1)})(t,t.l_desc.max_code+1,t.d_desc.max_code+1,h+1),E(t,t.dyn_ltree,t.dyn_dtree)),y(t),i&&x(t)},O={_tr_init:t=>{S||((()=>{let t,n,w,m,b;const g=new Array(16);for(w=0,m=0;m<28;m++)for(h[m]=w,t=0;t<1<<e[m];t++)l[w++]=m;for(l[w-1]=m,b=0,m=0;m<16;m++)for(d[m]=b,t=0;t<1<<a[m];t++)o[b++]=m;for(b>>=7;m<30;m++)for(d[m]=b<<7,t=0;t<1<<a[m]-7;t++)o[256+b++]=m;for(n=0;n<=15;n++)g[n]=0;for(t=0;t<=143;)s[2*t+1]=8,t++,g[8]++;for(;t<=255;)s[2*t+1]=9,t++,g[9]++;for(;t<=279;)s[2*t+1]=7,t++,g[7]++;for(;t<=287;)s[2*t+1]=8,t++,g[8]++;for(v(s,287,g),t=0;t<30;t++)r[2*t+1]=5,r[2*t]=k(t,5);f=new _(s,e,257,286,15),c=new _(r,a,0,30,15),u=new _(new Array(0),i,0,19,7)})(),S=!0),t.l_desc=new w(t.dyn_ltree,f),t.d_desc=new w(t.dyn_dtree,c),t.bl_desc=new w(t.bl_tree,u),t.bi_buf=0,t.bi_valid=0,y(t)},_tr_stored_block:D,_tr_flush_block:T,_tr_tally:(t,e,a)=>(t.pending_buf[t.sym_buf+t.sym_next++]=e,t.pending_buf[t.sym_buf+t.sym_next++]=e>>8,t.pending_buf[t.sym_buf+t.sym_next++]=a,0===e?t.dyn_ltree[2*a]++:(t.matches++,e--,t.dyn_ltree[2*(l[a]+256+1)]++,t.dyn_dtree[2*m(e)]++),t.sym_next===t.sym_end),_tr_align:t=>{g(t,2,3),p(t,256,s),(t=>{16===t.bi_valid?(b(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)})(t)}};var F=(t,e,a,i)=>{let n=65535&t|0,s=t>>>16&65535|0,r=0;for(;0!==a;){r=a>2e3?2e3:a,a-=r;do{n=n+e[i++]|0,s=s+n|0}while(--r);n%=65521,s%=65521}return n|s<<16|0};const L=new Uint32Array((()=>{let t,e=[];for(var a=0;a<256;a++){t=a;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e})());var N=(t,e,a,i)=>{const n=L,s=i+a;t^=-1;for(let a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t},I={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},B={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:C,_tr_stored_block:H,_tr_flush_block:M,_tr_tally:j,_tr_align:K}=O,{Z_NO_FLUSH:P,Z_PARTIAL_FLUSH:Y,Z_FULL_FLUSH:G,Z_FINISH:X,Z_BLOCK:W,Z_OK:q,Z_STREAM_END:J,Z_STREAM_ERROR:Q,Z_DATA_ERROR:V,Z_BUF_ERROR:$,Z_DEFAULT_COMPRESSION:tt,Z_FILTERED:et,Z_HUFFMAN_ONLY:at,Z_RLE:it,Z_FIXED:nt,Z_DEFAULT_STRATEGY:st,Z_UNKNOWN:rt,Z_DEFLATED:ot}=B,lt=(t,e)=>(t.msg=I[e],e),ht=t=>2*t-(t>4?9:0),dt=t=>{let e=t.length;for(;--e>=0;)t[e]=0},_t=t=>{let e,a,i,n=t.w_size;e=t.hash_size,i=e;do{a=t.head[--i],t.head[i]=a>=n?a-n:0}while(--e);e=n,i=e;do{a=t.prev[--i],t.prev[i]=a>=n?a-n:0}while(--e)};let ft=(t,e,a)=>(e<<t.hash_shift^a)&t.hash_mask;const ct=t=>{const e=t.state;let a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+a),t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))},ut=(t,e)=>{M(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,ct(t.strm)},wt=(t,e)=>{t.pending_buf[t.pending++]=e},mt=(t,e)=>{t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},bt=(t,e,a,i)=>{let n=t.avail_in;return n>i&&(n=i),0===n?0:(t.avail_in-=n,e.set(t.input.subarray(t.next_in,t.next_in+n),a),1===t.state.wrap?t.adler=F(t.adler,e,n,a):2===t.state.wrap&&(t.adler=N(t.adler,e,n,a)),t.next_in+=n,t.total_in+=n,n)},gt=(t,e)=>{let a,i,n=t.max_chain_length,s=t.strstart,r=t.prev_length,o=t.nice_match;const l=t.strstart>t.w_size-262?t.strstart-(t.w_size-262):0,h=t.window,d=t.w_mask,_=t.prev,f=t.strstart+258;let c=h[s+r-1],u=h[s+r];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(a=e,h[a+r]===u&&h[a+r-1]===c&&h[a]===h[s]&&h[++a]===h[s+1]){s+=2,a++;do{}while(h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&s<f);if(i=258-(f-s),s=f-258,i>r){if(t.match_start=e,r=i,i>=o)break;c=h[s+r-1],u=h[s+r]}}}while((e=_[e&d])>l&&0!=--n);return r<=t.lookahead?r:t.lookahead},pt=t=>{const e=t.w_size;let a,i,n;do{if(i=t.window_size-t.lookahead-t.strstart,t.strstart>=e+(e-262)&&(t.window.set(t.window.subarray(e,e+e-i),0),t.match_start-=e,t.strstart-=e,t.block_start-=e,t.insert>t.strstart&&(t.insert=t.strstart),_t(t),i+=e),0===t.strm.avail_in)break;if(a=bt(t.strm,t.window,t.strstart+t.lookahead,i),t.lookahead+=a,t.lookahead+t.insert>=3)for(n=t.strstart-t.insert,t.ins_h=t.window[n],t.ins_h=ft(t,t.ins_h,t.window[n+1]);t.insert&&(t.ins_h=ft(t,t.ins_h,t.window[n+3-1]),t.prev[n&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=n,n++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<262&&0!==t.strm.avail_in)},kt=(t,e)=>{let a,i,n,s=t.pending_buf_size-5>t.w_size?t.w_size:t.pending_buf_size-5,r=0,o=t.strm.avail_in;do{if(a=65535,n=t.bi_valid+42>>3,t.strm.avail_out<n)break;if(n=t.strm.avail_out-n,i=t.strstart-t.block_start,a>i+t.strm.avail_in&&(a=i+t.strm.avail_in),a>n&&(a=n),a<s&&(0===a&&e!==X||e===P||a!==i+t.strm.avail_in))break;r=e===X&&a===i+t.strm.avail_in?1:0,H(t,0,0,r),t.pending_buf[t.pending-4]=a,t.pending_buf[t.pending-3]=a>>8,t.pending_buf[t.pending-2]=~a,t.pending_buf[t.pending-1]=~a>>8,ct(t.strm),i&&(i>a&&(i=a),t.strm.output.set(t.window.subarray(t.block_start,t.block_start+i),t.strm.next_out),t.strm.next_out+=i,t.strm.avail_out-=i,t.strm.total_out+=i,t.block_start+=i,a-=i),a&&(bt(t.strm,t.strm.output,t.strm.next_out,a),t.strm.next_out+=a,t.strm.avail_out-=a,t.strm.total_out+=a)}while(0===r);return o-=t.strm.avail_in,o&&(o>=t.w_size?(t.matches=2,t.window.set(t.strm.input.subarray(t.strm.next_in-t.w_size,t.strm.next_in),0),t.strstart=t.w_size,t.insert=t.strstart):(t.window_size-t.strstart<=o&&(t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,t.insert>t.strstart&&(t.insert=t.strstart)),t.window.set(t.strm.input.subarray(t.strm.next_in-o,t.strm.next_in),t.strstart),t.strstart+=o,t.insert+=o>t.w_size-t.insert?t.w_size-t.insert:o),t.block_start=t.strstart),t.high_water<t.strstart&&(t.high_water=t.strstart),r?4:e!==P&&e!==X&&0===t.strm.avail_in&&t.strstart===t.block_start?2:(n=t.window_size-t.strstart,t.strm.avail_in>n&&t.block_start>=t.w_size&&(t.block_start-=t.w_size,t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,n+=t.w_size,t.insert>t.strstart&&(t.insert=t.strstart)),n>t.strm.avail_in&&(n=t.strm.avail_in),n&&(bt(t.strm,t.window,t.strstart,n),t.strstart+=n,t.insert+=n>t.w_size-t.insert?t.w_size-t.insert:n),t.high_water<t.strstart&&(t.high_water=t.strstart),n=t.bi_valid+42>>3,n=t.pending_buf_size-n>65535?65535:t.pending_buf_size-n,s=n>t.w_size?t.w_size:n,i=t.strstart-t.block_start,(i>=s||(i||e===X)&&e!==P&&0===t.strm.avail_in&&i<=n)&&(a=i>n?n:i,r=e===X&&0===t.strm.avail_in&&a===i?1:0,H(t,t.block_start,a,r),t.block_start+=a,ct(t.strm)),r?3:1)},vt=(t,e)=>{let a,i;for(;;){if(t.lookahead<262){if(pt(t),t.lookahead<262&&e===P)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=ft(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-262&&(t.match_length=gt(t,a)),t.match_length>=3)if(i=j(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=ft(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=ft(t,t.ins_h,t.window[t.strstart+1]);else i=j(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(ut(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===X?(ut(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(ut(t,!1),0===t.strm.avail_out)?1:2},yt=(t,e)=>{let a,i,n;for(;;){if(t.lookahead<262){if(pt(t),t.lookahead<262&&e===P)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=ft(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-262&&(t.match_length=gt(t,a),t.match_length<=5&&(t.strategy===et||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-3,i=j(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=n&&(t.ins_h=ft(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,i&&(ut(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if(i=j(t,0,t.window[t.strstart-1]),i&&ut(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=j(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===X?(ut(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(ut(t,!1),0===t.strm.avail_out)?1:2};function xt(t,e,a,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=i,this.func=n}const zt=[new xt(0,0,0,0,kt),new xt(4,4,8,4,vt),new xt(4,5,16,8,vt),new xt(4,6,32,32,vt),new xt(4,4,16,16,yt),new xt(8,16,32,32,yt),new xt(8,16,128,128,yt),new xt(8,32,128,256,yt),new xt(32,128,258,1024,yt),new xt(32,258,258,4096,yt)];function At(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=ot,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),dt(this.dyn_ltree),dt(this.dyn_dtree),dt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),dt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),dt(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const Et=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||42!==e.status&&57!==e.status&&69!==e.status&&73!==e.status&&91!==e.status&&103!==e.status&&113!==e.status&&666!==e.status?1:0},Rt=t=>{if(Et(t))return lt(t,Q);t.total_in=t.total_out=0,t.data_type=rt;const e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=2===e.wrap?57:e.wrap?42:113,t.adler=2===e.wrap?0:1,e.last_flush=-2,C(e),q},Zt=t=>{const e=Rt(t);var a;return e===q&&((a=t.state).window_size=2*a.w_size,dt(a.head),a.max_lazy_match=zt[a.level].max_lazy,a.good_match=zt[a.level].good_length,a.nice_match=zt[a.level].nice_length,a.max_chain_length=zt[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=2,a.match_available=0,a.ins_h=0),e},Ut=(t,e,a,i,n,s)=>{if(!t)return Q;let r=1;if(e===tt&&(e=6),i<0?(r=0,i=-i):i>15&&(r=2,i-=16),n<1||n>9||a!==ot||i<8||i>15||e<0||e>9||s<0||s>nt||8===i&&1!==r)return lt(t,Q);8===i&&(i=9);const o=new At;return t.state=o,o.strm=t,o.status=42,o.wrap=r,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+3-1)/3),o.window=new Uint8Array(2*o.w_size),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new Uint8Array(o.pending_buf_size),o.sym_buf=o.lit_bufsize,o.sym_end=3*(o.lit_bufsize-1),o.level=e,o.strategy=s,o.method=a,Zt(t)};var St={deflateInit:(t,e)=>Ut(t,e,ot,15,8,st),deflateInit2:Ut,deflateReset:Zt,deflateResetKeep:Rt,deflateSetHeader:(t,e)=>Et(t)||2!==t.state.wrap?Q:(t.state.gzhead=e,q),deflate:(t,e)=>{if(Et(t)||e>W||e<0)return t?lt(t,Q):Q;const a=t.state;if(!t.output||0!==t.avail_in&&!t.input||666===a.status&&e!==X)return lt(t,0===t.avail_out?$:Q);const i=a.last_flush;if(a.last_flush=e,0!==a.pending){if(ct(t),0===t.avail_out)return a.last_flush=-1,q}else if(0===t.avail_in&&ht(e)<=ht(i)&&e!==X)return lt(t,$);if(666===a.status&&0!==t.avail_in)return lt(t,$);if(42===a.status&&0===a.wrap&&(a.status=113),42===a.status){let e=ot+(a.w_bits-8<<4)<<8,i=-1;if(i=a.strategy>=at||a.level<2?0:a.level<6?1:6===a.level?2:3,e|=i<<6,0!==a.strstart&&(e|=32),e+=31-e%31,mt(a,e),0!==a.strstart&&(mt(a,t.adler>>>16),mt(a,65535&t.adler)),t.adler=1,a.status=113,ct(t),0!==a.pending)return a.last_flush=-1,q}if(57===a.status)if(t.adler=0,wt(a,31),wt(a,139),wt(a,8),a.gzhead)wt(a,(a.gzhead.text?1:0)+(a.gzhead.hcrc?2:0)+(a.gzhead.extra?4:0)+(a.gzhead.name?8:0)+(a.gzhead.comment?16:0)),wt(a,255&a.gzhead.time),wt(a,a.gzhead.time>>8&255),wt(a,a.gzhead.time>>16&255),wt(a,a.gzhead.time>>24&255),wt(a,9===a.level?2:a.strategy>=at||a.level<2?4:0),wt(a,255&a.gzhead.os),a.gzhead.extra&&a.gzhead.extra.length&&(wt(a,255&a.gzhead.extra.length),wt(a,a.gzhead.extra.length>>8&255)),a.gzhead.hcrc&&(t.adler=N(t.adler,a.pending_buf,a.pending,0)),a.gzindex=0,a.status=69;else if(wt(a,0),wt(a,0),wt(a,0),wt(a,0),wt(a,0),wt(a,9===a.level?2:a.strategy>=at||a.level<2?4:0),wt(a,3),a.status=113,ct(t),0!==a.pending)return a.last_flush=-1,q;if(69===a.status){if(a.gzhead.extra){let e=a.pending,i=(65535&a.gzhead.extra.length)-a.gzindex;for(;a.pending+i>a.pending_buf_size;){let n=a.pending_buf_size-a.pending;if(a.pending_buf.set(a.gzhead.extra.subarray(a.gzindex,a.gzindex+n),a.pending),a.pending=a.pending_buf_size,a.gzhead.hcrc&&a.pending>e&&(t.adler=N(t.adler,a.pending_buf,a.pending-e,e)),a.gzindex+=n,ct(t),0!==a.pending)return a.last_flush=-1,q;e=0,i-=n}let n=new Uint8Array(a.gzhead.extra);a.pending_buf.set(n.subarray(a.gzindex,a.gzindex+i),a.pending),a.pending+=i,a.gzhead.hcrc&&a.pending>e&&(t.adler=N(t.adler,a.pending_buf,a.pending-e,e)),a.gzindex=0}a.status=73}if(73===a.status){if(a.gzhead.name){let e,i=a.pending;do{if(a.pending===a.pending_buf_size){if(a.gzhead.hcrc&&a.pending>i&&(t.adler=N(t.adler,a.pending_buf,a.pending-i,i)),ct(t),0!==a.pending)return a.last_flush=-1,q;i=0}e=a.gzindex<a.gzhead.name.length?255&a.gzhead.name.charCodeAt(a.gzindex++):0,wt(a,e)}while(0!==e);a.gzhead.hcrc&&a.pending>i&&(t.adler=N(t.adler,a.pending_buf,a.pending-i,i)),a.gzindex=0}a.status=91}if(91===a.status){if(a.gzhead.comment){let e,i=a.pending;do{if(a.pending===a.pending_buf_size){if(a.gzhead.hcrc&&a.pending>i&&(t.adler=N(t.adler,a.pending_buf,a.pending-i,i)),ct(t),0!==a.pending)return a.last_flush=-1,q;i=0}e=a.gzindex<a.gzhead.comment.length?255&a.gzhead.comment.charCodeAt(a.gzindex++):0,wt(a,e)}while(0!==e);a.gzhead.hcrc&&a.pending>i&&(t.adler=N(t.adler,a.pending_buf,a.pending-i,i))}a.status=103}if(103===a.status){if(a.gzhead.hcrc){if(a.pending+2>a.pending_buf_size&&(ct(t),0!==a.pending))return a.last_flush=-1,q;wt(a,255&t.adler),wt(a,t.adler>>8&255),t.adler=0}if(a.status=113,ct(t),0!==a.pending)return a.last_flush=-1,q}if(0!==t.avail_in||0!==a.lookahead||e!==P&&666!==a.status){let i=0===a.level?kt(a,e):a.strategy===at?((t,e)=>{let a;for(;;){if(0===t.lookahead&&(pt(t),0===t.lookahead)){if(e===P)return 1;break}if(t.match_length=0,a=j(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(ut(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===X?(ut(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(ut(t,!1),0===t.strm.avail_out)?1:2})(a,e):a.strategy===it?((t,e)=>{let a,i,n,s;const r=t.window;for(;;){if(t.lookahead<=258){if(pt(t),t.lookahead<=258&&e===P)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=t.strstart-1,i=r[n],i===r[++n]&&i===r[++n]&&i===r[++n])){s=t.strstart+258;do{}while(i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&n<s);t.match_length=258-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(a=j(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=j(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(ut(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===X?(ut(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(ut(t,!1),0===t.strm.avail_out)?1:2})(a,e):zt[a.level].func(a,e);if(3!==i&&4!==i||(a.status=666),1===i||3===i)return 0===t.avail_out&&(a.last_flush=-1),q;if(2===i&&(e===Y?K(a):e!==W&&(H(a,0,0,!1),e===G&&(dt(a.head),0===a.lookahead&&(a.strstart=0,a.block_start=0,a.insert=0))),ct(t),0===t.avail_out))return a.last_flush=-1,q}return e!==X?q:a.wrap<=0?J:(2===a.wrap?(wt(a,255&t.adler),wt(a,t.adler>>8&255),wt(a,t.adler>>16&255),wt(a,t.adler>>24&255),wt(a,255&t.total_in),wt(a,t.total_in>>8&255),wt(a,t.total_in>>16&255),wt(a,t.total_in>>24&255)):(mt(a,t.adler>>>16),mt(a,65535&t.adler)),ct(t),a.wrap>0&&(a.wrap=-a.wrap),0!==a.pending?q:J)},deflateEnd:t=>{if(Et(t))return Q;const e=t.state.status;return t.state=null,113===e?lt(t,V):q},deflateSetDictionary:(t,e)=>{let a=e.length;if(Et(t))return Q;const i=t.state,n=i.wrap;if(2===n||1===n&&42!==i.status||i.lookahead)return Q;if(1===n&&(t.adler=F(t.adler,e,a,0)),i.wrap=0,a>=i.w_size){0===n&&(dt(i.head),i.strstart=0,i.block_start=0,i.insert=0);let t=new Uint8Array(i.w_size);t.set(e.subarray(a-i.w_size,a),0),e=t,a=i.w_size}const s=t.avail_in,r=t.next_in,o=t.input;for(t.avail_in=a,t.next_in=0,t.input=e,pt(i);i.lookahead>=3;){let t=i.strstart,e=i.lookahead-2;do{i.ins_h=ft(i,i.ins_h,i.window[t+3-1]),i.prev[t&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=t,t++}while(--e);i.strstart=t,i.lookahead=2,pt(i)}return i.strstart+=i.lookahead,i.block_start=i.strstart,i.insert=i.lookahead,i.lookahead=0,i.match_length=i.prev_length=2,i.match_available=0,t.next_in=r,t.input=o,t.avail_in=s,i.wrap=n,q},deflateInfo:"pako deflate (from Nodeca project)"};const Dt=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var Tt=function(t){const e=Array.prototype.slice.call(arguments,1);for(;e.length;){const a=e.shift();if(a){if("object"!=typeof a)throw new TypeError(a+"must be non-object");for(const e in a)Dt(a,e)&&(t[e]=a[e])}}return t},Ot=t=>{let e=0;for(let a=0,i=t.length;a<i;a++)e+=t[a].length;const a=new Uint8Array(e);for(let e=0,i=0,n=t.length;e<n;e++){let n=t[e];a.set(n,i),i+=n.length}return a};let Ft=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){Ft=!1}const Lt=new Uint8Array(256);for(let t=0;t<256;t++)Lt[t]=t>=252?6:t>=248?5:t>=240?4:t>=224?3:t>=192?2:1;Lt[254]=Lt[254]=1;var Nt=t=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);let e,a,i,n,s,r=t.length,o=0;for(n=0;n<r;n++)a=t.charCodeAt(n),55296==(64512&a)&&n+1<r&&(i=t.charCodeAt(n+1),56320==(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),n++)),o+=a<128?1:a<2048?2:a<65536?3:4;for(e=new Uint8Array(o),s=0,n=0;s<o;n++)a=t.charCodeAt(n),55296==(64512&a)&&n+1<r&&(i=t.charCodeAt(n+1),56320==(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),n++)),a<128?e[s++]=a:a<2048?(e[s++]=192|a>>>6,e[s++]=128|63&a):a<65536?(e[s++]=224|a>>>12,e[s++]=128|a>>>6&63,e[s++]=128|63&a):(e[s++]=240|a>>>18,e[s++]=128|a>>>12&63,e[s++]=128|a>>>6&63,e[s++]=128|63&a);return e},It=(t,e)=>{const a=e||t.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(t.subarray(0,e));let i,n;const s=new Array(2*a);for(n=0,i=0;i<a;){let e=t[i++];if(e<128){s[n++]=e;continue}let r=Lt[e];if(r>4)s[n++]=65533,i+=r-1;else{for(e&=2===r?31:3===r?15:7;r>1&&i<a;)e=e<<6|63&t[i++],r--;r>1?s[n++]=65533:e<65536?s[n++]=e:(e-=65536,s[n++]=55296|e>>10&1023,s[n++]=56320|1023&e)}}return((t,e)=>{if(e<65534&&t.subarray&&Ft)return String.fromCharCode.apply(null,t.length===e?t:t.subarray(0,e));let a="";for(let i=0;i<e;i++)a+=String.fromCharCode(t[i]);return a})(s,n)},Bt=(t,e)=>{(e=e||t.length)>t.length&&(e=t.length);let a=e-1;for(;a>=0&&128==(192&t[a]);)a--;return a<0||0===a?e:a+Lt[t[a]]>e?a:e};var Ct=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const Ht=Object.prototype.toString,{Z_NO_FLUSH:Mt,Z_SYNC_FLUSH:jt,Z_FULL_FLUSH:Kt,Z_FINISH:Pt,Z_OK:Yt,Z_STREAM_END:Gt,Z_DEFAULT_COMPRESSION:Xt,Z_DEFAULT_STRATEGY:Wt,Z_DEFLATED:qt}=B;function Jt(t){this.options=Tt({level:Xt,method:qt,chunkSize:16384,windowBits:15,memLevel:8,strategy:Wt},t||{});let e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Ct,this.strm.avail_out=0;let a=St.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(a!==Yt)throw new Error(I[a]);if(e.header&&St.deflateSetHeader(this.strm,e.header),e.dictionary){let t;if(t="string"==typeof e.dictionary?Nt(e.dictionary):"[object ArrayBuffer]"===Ht.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,a=St.deflateSetDictionary(this.strm,t),a!==Yt)throw new Error(I[a]);this._dict_set=!0}}function Qt(t,e){const a=new Jt(e);if(a.push(t,!0),a.err)throw a.msg||I[a.err];return a.result}Jt.prototype.push=function(t,e){const a=this.strm,i=this.options.chunkSize;let n,s;if(this.ended)return!1;for(s=e===~~e?e:!0===e?Pt:Mt,"string"==typeof t?a.input=Nt(t):"[object ArrayBuffer]"===Ht.call(t)?a.input=new Uint8Array(t):a.input=t,a.next_in=0,a.avail_in=a.input.length;;)if(0===a.avail_out&&(a.output=new Uint8Array(i),a.next_out=0,a.avail_out=i),(s===jt||s===Kt)&&a.avail_out<=6)this.onData(a.output.subarray(0,a.next_out)),a.avail_out=0;else{if(n=St.deflate(a,s),n===Gt)return a.next_out>0&&this.onData(a.output.subarray(0,a.next_out)),n=St.deflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===Yt;if(0!==a.avail_out){if(s>0&&a.next_out>0)this.onData(a.output.subarray(0,a.next_out)),a.avail_out=0;else if(0===a.avail_in)break}else this.onData(a.output)}return!0},Jt.prototype.onData=function(t){this.chunks.push(t)},Jt.prototype.onEnd=function(t){t===Yt&&(this.result=Ot(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};var Vt={Deflate:Jt,deflate:Qt,deflateRaw:function(t,e){return(e=e||{}).raw=!0,Qt(t,e)},gzip:function(t,e){return(e=e||{}).gzip=!0,Qt(t,e)},constants:B};var $t=function(t,e){let a,i,n,s,r,o,l,h,d,_,f,c,u,w,m,b,g,p,k,v,y,x,z,A;const E=t.state;a=t.next_in,z=t.input,i=a+(t.avail_in-5),n=t.next_out,A=t.output,s=n-(e-t.avail_out),r=n+(t.avail_out-257),o=E.dmax,l=E.wsize,h=E.whave,d=E.wnext,_=E.window,f=E.hold,c=E.bits,u=E.lencode,w=E.distcode,m=(1<<E.lenbits)-1,b=(1<<E.distbits)-1;t:do{c<15&&(f+=z[a++]<<c,c+=8,f+=z[a++]<<c,c+=8),g=u[f&m];e:for(;;){if(p=g>>>24,f>>>=p,c-=p,p=g>>>16&255,0===p)A[n++]=65535&g;else{if(!(16&p)){if(0==(64&p)){g=u[(65535&g)+(f&(1<<p)-1)];continue e}if(32&p){E.mode=16191;break t}t.msg="invalid literal/length code",E.mode=16209;break t}k=65535&g,p&=15,p&&(c<p&&(f+=z[a++]<<c,c+=8),k+=f&(1<<p)-1,f>>>=p,c-=p),c<15&&(f+=z[a++]<<c,c+=8,f+=z[a++]<<c,c+=8),g=w[f&b];a:for(;;){if(p=g>>>24,f>>>=p,c-=p,p=g>>>16&255,!(16&p)){if(0==(64&p)){g=w[(65535&g)+(f&(1<<p)-1)];continue a}t.msg="invalid distance code",E.mode=16209;break t}if(v=65535&g,p&=15,c<p&&(f+=z[a++]<<c,c+=8,c<p&&(f+=z[a++]<<c,c+=8)),v+=f&(1<<p)-1,v>o){t.msg="invalid distance too far back",E.mode=16209;break t}if(f>>>=p,c-=p,p=n-s,v>p){if(p=v-p,p>h&&E.sane){t.msg="invalid distance too far back",E.mode=16209;break t}if(y=0,x=_,0===d){if(y+=l-p,p<k){k-=p;do{A[n++]=_[y++]}while(--p);y=n-v,x=A}}else if(d<p){if(y+=l+d-p,p-=d,p<k){k-=p;do{A[n++]=_[y++]}while(--p);if(y=0,d<k){p=d,k-=p;do{A[n++]=_[y++]}while(--p);y=n-v,x=A}}}else if(y+=d-p,p<k){k-=p;do{A[n++]=_[y++]}while(--p);y=n-v,x=A}for(;k>2;)A[n++]=x[y++],A[n++]=x[y++],A[n++]=x[y++],k-=3;k&&(A[n++]=x[y++],k>1&&(A[n++]=x[y++]))}else{y=n-v;do{A[n++]=A[y++],A[n++]=A[y++],A[n++]=A[y++],k-=3}while(k>2);k&&(A[n++]=A[y++],k>1&&(A[n++]=A[y++]))}break}}break}}while(a<i&&n<r);k=c>>3,a-=k,c-=k<<3,f&=(1<<c)-1,t.next_in=a,t.next_out=n,t.avail_in=a<i?i-a+5:5-(a-i),t.avail_out=n<r?r-n+257:257-(n-r),E.hold=f,E.bits=c};const te=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),ee=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),ae=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),ie=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var ne=(t,e,a,i,n,s,r,o)=>{const l=o.bits;let h,d,_,f,c,u,w=0,m=0,b=0,g=0,p=0,k=0,v=0,y=0,x=0,z=0,A=null;const E=new Uint16Array(16),R=new Uint16Array(16);let Z,U,S,D=null;for(w=0;w<=15;w++)E[w]=0;for(m=0;m<i;m++)E[e[a+m]]++;for(p=l,g=15;g>=1&&0===E[g];g--);if(p>g&&(p=g),0===g)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(b=1;b<g&&0===E[b];b++);for(p<b&&(p=b),y=1,w=1;w<=15;w++)if(y<<=1,y-=E[w],y<0)return-1;if(y>0&&(0===t||1!==g))return-1;for(R[1]=0,w=1;w<15;w++)R[w+1]=R[w]+E[w];for(m=0;m<i;m++)0!==e[a+m]&&(r[R[e[a+m]]++]=m);if(0===t?(A=D=r,u=20):1===t?(A=te,D=ee,u=257):(A=ae,D=ie,u=0),z=0,m=0,w=b,c=s,k=p,v=0,_=-1,x=1<<p,f=x-1,1===t&&x>852||2===t&&x>592)return 1;for(;;){Z=w-v,r[m]+1<u?(U=0,S=r[m]):r[m]>=u?(U=D[r[m]-u],S=A[r[m]-u]):(U=96,S=0),h=1<<w-v,d=1<<k,b=d;do{d-=h,n[c+(z>>v)+d]=Z<<24|U<<16|S|0}while(0!==d);for(h=1<<w-1;z&h;)h>>=1;if(0!==h?(z&=h-1,z+=h):z=0,m++,0==--E[w]){if(w===g)break;w=e[a+r[m]]}if(w>p&&(z&f)!==_){for(0===v&&(v=p),c+=b,k=w-v,y=1<<k;k+v<g&&(y-=E[k+v],!(y<=0));)k++,y<<=1;if(x+=1<<k,1===t&&x>852||2===t&&x>592)return 1;_=z&f,n[_]=p<<24|k<<16|c-s|0}}return 0!==z&&(n[c+z]=w-v<<24|64<<16|0),o.bits=p,0};const{Z_FINISH:se,Z_BLOCK:re,Z_TREES:oe,Z_OK:le,Z_STREAM_END:he,Z_NEED_DICT:de,Z_STREAM_ERROR:_e,Z_DATA_ERROR:fe,Z_MEM_ERROR:ce,Z_BUF_ERROR:ue,Z_DEFLATED:we}=B,me=16209,be=t=>(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24);function ge(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const pe=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||e.mode<16180||e.mode>16211?1:0},ke=t=>{if(pe(t))return _e;const e=t.state;return t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=16180,e.last=0,e.havedict=0,e.flags=-1,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,le},ve=t=>{if(pe(t))return _e;const e=t.state;return e.wsize=0,e.whave=0,e.wnext=0,ke(t)},ye=(t,e)=>{let a;if(pe(t))return _e;const i=t.state;return e<0?(a=0,e=-e):(a=5+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?_e:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=a,i.wbits=e,ve(t))},xe=(t,e)=>{if(!t)return _e;const a=new ge;t.state=a,a.strm=t,a.window=null,a.mode=16180;const i=ye(t,e);return i!==le&&(t.state=null),i};let ze,Ae,Ee=!0;const Re=t=>{if(Ee){ze=new Int32Array(512),Ae=new Int32Array(32);let e=0;for(;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(ne(1,t.lens,0,288,ze,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;ne(2,t.lens,0,32,Ae,0,t.work,{bits:5}),Ee=!1}t.lencode=ze,t.lenbits=9,t.distcode=Ae,t.distbits=5},Ze=(t,e,a,i)=>{let n;const s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new Uint8Array(s.wsize)),i>=s.wsize?(s.window.set(e.subarray(a-s.wsize,a),0),s.wnext=0,s.whave=s.wsize):(n=s.wsize-s.wnext,n>i&&(n=i),s.window.set(e.subarray(a-i,a-i+n),s.wnext),(i-=n)?(s.window.set(e.subarray(a-i,a),0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0};var Ue={inflateReset:ve,inflateReset2:ye,inflateResetKeep:ke,inflateInit:t=>xe(t,15),inflateInit2:xe,inflate:(t,e)=>{let a,i,n,s,r,o,l,h,d,_,f,c,u,w,m,b,g,p,k,v,y,x,z=0;const A=new Uint8Array(4);let E,R;const Z=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(pe(t)||!t.output||!t.input&&0!==t.avail_in)return _e;a=t.state,16191===a.mode&&(a.mode=16192),r=t.next_out,n=t.output,l=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,h=a.hold,d=a.bits,_=o,f=l,x=le;t:for(;;)switch(a.mode){case 16180:if(0===a.wrap){a.mode=16192;break}for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(2&a.wrap&&35615===h){0===a.wbits&&(a.wbits=15),a.check=0,A[0]=255&h,A[1]=h>>>8&255,a.check=N(a.check,A,2,0),h=0,d=0,a.mode=16181;break}if(a.head&&(a.head.done=!1),!(1&a.wrap)||(((255&h)<<8)+(h>>8))%31){t.msg="incorrect header check",a.mode=me;break}if((15&h)!==we){t.msg="unknown compression method",a.mode=me;break}if(h>>>=4,d-=4,y=8+(15&h),0===a.wbits&&(a.wbits=y),y>15||y>a.wbits){t.msg="invalid window size",a.mode=me;break}a.dmax=1<<a.wbits,a.flags=0,t.adler=a.check=1,a.mode=512&h?16189:16191,h=0,d=0;break;case 16181:for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(a.flags=h,(255&a.flags)!==we){t.msg="unknown compression method",a.mode=me;break}if(57344&a.flags){t.msg="unknown header flags set",a.mode=me;break}a.head&&(a.head.text=h>>8&1),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,a.check=N(a.check,A,2,0)),h=0,d=0,a.mode=16182;case 16182:for(;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.head&&(a.head.time=h),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,A[2]=h>>>16&255,A[3]=h>>>24&255,a.check=N(a.check,A,4,0)),h=0,d=0,a.mode=16183;case 16183:for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.head&&(a.head.xflags=255&h,a.head.os=h>>8),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,a.check=N(a.check,A,2,0)),h=0,d=0,a.mode=16184;case 16184:if(1024&a.flags){for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.length=h,a.head&&(a.head.extra_len=h),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,a.check=N(a.check,A,2,0)),h=0,d=0}else a.head&&(a.head.extra=null);a.mode=16185;case 16185:if(1024&a.flags&&(c=a.length,c>o&&(c=o),c&&(a.head&&(y=a.head.extra_len-a.length,a.head.extra||(a.head.extra=new Uint8Array(a.head.extra_len)),a.head.extra.set(i.subarray(s,s+c),y)),512&a.flags&&4&a.wrap&&(a.check=N(a.check,i,c,s)),o-=c,s+=c,a.length-=c),a.length))break t;a.length=0,a.mode=16186;case 16186:if(2048&a.flags){if(0===o)break t;c=0;do{y=i[s+c++],a.head&&y&&a.length<65536&&(a.head.name+=String.fromCharCode(y))}while(y&&c<o);if(512&a.flags&&4&a.wrap&&(a.check=N(a.check,i,c,s)),o-=c,s+=c,y)break t}else a.head&&(a.head.name=null);a.length=0,a.mode=16187;case 16187:if(4096&a.flags){if(0===o)break t;c=0;do{y=i[s+c++],a.head&&y&&a.length<65536&&(a.head.comment+=String.fromCharCode(y))}while(y&&c<o);if(512&a.flags&&4&a.wrap&&(a.check=N(a.check,i,c,s)),o-=c,s+=c,y)break t}else a.head&&(a.head.comment=null);a.mode=16188;case 16188:if(512&a.flags){for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(4&a.wrap&&h!==(65535&a.check)){t.msg="header crc mismatch",a.mode=me;break}h=0,d=0}a.head&&(a.head.hcrc=a.flags>>9&1,a.head.done=!0),t.adler=a.check=0,a.mode=16191;break;case 16189:for(;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}t.adler=a.check=be(h),h=0,d=0,a.mode=16190;case 16190:if(0===a.havedict)return t.next_out=r,t.avail_out=l,t.next_in=s,t.avail_in=o,a.hold=h,a.bits=d,de;t.adler=a.check=1,a.mode=16191;case 16191:if(e===re||e===oe)break t;case 16192:if(a.last){h>>>=7&d,d-=7&d,a.mode=16206;break}for(;d<3;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}switch(a.last=1&h,h>>>=1,d-=1,3&h){case 0:a.mode=16193;break;case 1:if(Re(a),a.mode=16199,e===oe){h>>>=2,d-=2;break t}break;case 2:a.mode=16196;break;case 3:t.msg="invalid block type",a.mode=me}h>>>=2,d-=2;break;case 16193:for(h>>>=7&d,d-=7&d;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if((65535&h)!=(h>>>16^65535)){t.msg="invalid stored block lengths",a.mode=me;break}if(a.length=65535&h,h=0,d=0,a.mode=16194,e===oe)break t;case 16194:a.mode=16195;case 16195:if(c=a.length,c){if(c>o&&(c=o),c>l&&(c=l),0===c)break t;n.set(i.subarray(s,s+c),r),o-=c,s+=c,l-=c,r+=c,a.length-=c;break}a.mode=16191;break;case 16196:for(;d<14;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(a.nlen=257+(31&h),h>>>=5,d-=5,a.ndist=1+(31&h),h>>>=5,d-=5,a.ncode=4+(15&h),h>>>=4,d-=4,a.nlen>286||a.ndist>30){t.msg="too many length or distance symbols",a.mode=me;break}a.have=0,a.mode=16197;case 16197:for(;a.have<a.ncode;){for(;d<3;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.lens[Z[a.have++]]=7&h,h>>>=3,d-=3}for(;a.have<19;)a.lens[Z[a.have++]]=0;if(a.lencode=a.lendyn,a.lenbits=7,E={bits:a.lenbits},x=ne(0,a.lens,0,19,a.lencode,0,a.work,E),a.lenbits=E.bits,x){t.msg="invalid code lengths set",a.mode=me;break}a.have=0,a.mode=16198;case 16198:for(;a.have<a.nlen+a.ndist;){for(;z=a.lencode[h&(1<<a.lenbits)-1],m=z>>>24,b=z>>>16&255,g=65535&z,!(m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(g<16)h>>>=m,d-=m,a.lens[a.have++]=g;else{if(16===g){for(R=m+2;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(h>>>=m,d-=m,0===a.have){t.msg="invalid bit length repeat",a.mode=me;break}y=a.lens[a.have-1],c=3+(3&h),h>>>=2,d-=2}else if(17===g){for(R=m+3;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}h>>>=m,d-=m,y=0,c=3+(7&h),h>>>=3,d-=3}else{for(R=m+7;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}h>>>=m,d-=m,y=0,c=11+(127&h),h>>>=7,d-=7}if(a.have+c>a.nlen+a.ndist){t.msg="invalid bit length repeat",a.mode=me;break}for(;c--;)a.lens[a.have++]=y}}if(a.mode===me)break;if(0===a.lens[256]){t.msg="invalid code -- missing end-of-block",a.mode=me;break}if(a.lenbits=9,E={bits:a.lenbits},x=ne(1,a.lens,0,a.nlen,a.lencode,0,a.work,E),a.lenbits=E.bits,x){t.msg="invalid literal/lengths set",a.mode=me;break}if(a.distbits=6,a.distcode=a.distdyn,E={bits:a.distbits},x=ne(2,a.lens,a.nlen,a.ndist,a.distcode,0,a.work,E),a.distbits=E.bits,x){t.msg="invalid distances set",a.mode=me;break}if(a.mode=16199,e===oe)break t;case 16199:a.mode=16200;case 16200:if(o>=6&&l>=258){t.next_out=r,t.avail_out=l,t.next_in=s,t.avail_in=o,a.hold=h,a.bits=d,$t(t,f),r=t.next_out,n=t.output,l=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,h=a.hold,d=a.bits,16191===a.mode&&(a.back=-1);break}for(a.back=0;z=a.lencode[h&(1<<a.lenbits)-1],m=z>>>24,b=z>>>16&255,g=65535&z,!(m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(b&&0==(240&b)){for(p=m,k=b,v=g;z=a.lencode[v+((h&(1<<p+k)-1)>>p)],m=z>>>24,b=z>>>16&255,g=65535&z,!(p+m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}h>>>=p,d-=p,a.back+=p}if(h>>>=m,d-=m,a.back+=m,a.length=g,0===b){a.mode=16205;break}if(32&b){a.back=-1,a.mode=16191;break}if(64&b){t.msg="invalid literal/length code",a.mode=me;break}a.extra=15&b,a.mode=16201;case 16201:if(a.extra){for(R=a.extra;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.length+=h&(1<<a.extra)-1,h>>>=a.extra,d-=a.extra,a.back+=a.extra}a.was=a.length,a.mode=16202;case 16202:for(;z=a.distcode[h&(1<<a.distbits)-1],m=z>>>24,b=z>>>16&255,g=65535&z,!(m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(0==(240&b)){for(p=m,k=b,v=g;z=a.distcode[v+((h&(1<<p+k)-1)>>p)],m=z>>>24,b=z>>>16&255,g=65535&z,!(p+m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}h>>>=p,d-=p,a.back+=p}if(h>>>=m,d-=m,a.back+=m,64&b){t.msg="invalid distance code",a.mode=me;break}a.offset=g,a.extra=15&b,a.mode=16203;case 16203:if(a.extra){for(R=a.extra;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.offset+=h&(1<<a.extra)-1,h>>>=a.extra,d-=a.extra,a.back+=a.extra}if(a.offset>a.dmax){t.msg="invalid distance too far back",a.mode=me;break}a.mode=16204;case 16204:if(0===l)break t;if(c=f-l,a.offset>c){if(c=a.offset-c,c>a.whave&&a.sane){t.msg="invalid distance too far back",a.mode=me;break}c>a.wnext?(c-=a.wnext,u=a.wsize-c):u=a.wnext-c,c>a.length&&(c=a.length),w=a.window}else w=n,u=r-a.offset,c=a.length;c>l&&(c=l),l-=c,a.length-=c;do{n[r++]=w[u++]}while(--c);0===a.length&&(a.mode=16200);break;case 16205:if(0===l)break t;n[r++]=a.length,l--,a.mode=16200;break;case 16206:if(a.wrap){for(;d<32;){if(0===o)break t;o--,h|=i[s++]<<d,d+=8}if(f-=l,t.total_out+=f,a.total+=f,4&a.wrap&&f&&(t.adler=a.check=a.flags?N(a.check,n,f,r-f):F(a.check,n,f,r-f)),f=l,4&a.wrap&&(a.flags?h:be(h))!==a.check){t.msg="incorrect data check",a.mode=me;break}h=0,d=0}a.mode=16207;case 16207:if(a.wrap&&a.flags){for(;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(4&a.wrap&&h!==(4294967295&a.total)){t.msg="incorrect length check",a.mode=me;break}h=0,d=0}a.mode=16208;case 16208:x=he;break t;case me:x=fe;break t;case 16210:return ce;default:return _e}return t.next_out=r,t.avail_out=l,t.next_in=s,t.avail_in=o,a.hold=h,a.bits=d,(a.wsize||f!==t.avail_out&&a.mode<me&&(a.mode<16206||e!==se))&&Ze(t,t.output,t.next_out,f-t.avail_out),_-=t.avail_in,f-=t.avail_out,t.total_in+=_,t.total_out+=f,a.total+=f,4&a.wrap&&f&&(t.adler=a.check=a.flags?N(a.check,n,f,t.next_out-f):F(a.check,n,f,t.next_out-f)),t.data_type=a.bits+(a.last?64:0)+(16191===a.mode?128:0)+(16199===a.mode||16194===a.mode?256:0),(0===_&&0===f||e===se)&&x===le&&(x=ue),x},inflateEnd:t=>{if(pe(t))return _e;let e=t.state;return e.window&&(e.window=null),t.state=null,le},inflateGetHeader:(t,e)=>{if(pe(t))return _e;const a=t.state;return 0==(2&a.wrap)?_e:(a.head=e,e.done=!1,le)},inflateSetDictionary:(t,e)=>{const a=e.length;let i,n,s;return pe(t)?_e:(i=t.state,0!==i.wrap&&16190!==i.mode?_e:16190===i.mode&&(n=1,n=F(n,e,a,0),n!==i.check)?fe:(s=Ze(t,e,a,a),s?(i.mode=16210,ce):(i.havedict=1,le)))},inflateInfo:"pako inflate (from Nodeca project)"};var Se=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const De=Object.prototype.toString,{Z_NO_FLUSH:Te,Z_FINISH:Oe,Z_OK:Fe,Z_STREAM_END:Le,Z_NEED_DICT:Ne,Z_STREAM_ERROR:Ie,Z_DATA_ERROR:Be,Z_MEM_ERROR:Ce}=B;function He(t){this.options=Tt({chunkSize:65536,windowBits:15,to:""},t||{});const e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Ct,this.strm.avail_out=0;let a=Ue.inflateInit2(this.strm,e.windowBits);if(a!==Fe)throw new Error(I[a]);if(this.header=new Se,Ue.inflateGetHeader(this.strm,this.header),e.dictionary&&("string"==typeof e.dictionary?e.dictionary=Nt(e.dictionary):"[object ArrayBuffer]"===De.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(a=Ue.inflateSetDictionary(this.strm,e.dictionary),a!==Fe)))throw new Error(I[a])}He.prototype.push=function(t,e){const a=this.strm,i=this.options.chunkSize,n=this.options.dictionary;let s,r,o;if(this.ended)return!1;for(r=e===~~e?e:!0===e?Oe:Te,"[object ArrayBuffer]"===De.call(t)?a.input=new Uint8Array(t):a.input=t,a.next_in=0,a.avail_in=a.input.length;;){for(0===a.avail_out&&(a.output=new Uint8Array(i),a.next_out=0,a.avail_out=i),s=Ue.inflate(a,r),s===Ne&&n&&(s=Ue.inflateSetDictionary(a,n),s===Fe?s=Ue.inflate(a,r):s===Be&&(s=Ne));a.avail_in>0&&s===Le&&a.state.wrap>0&&0!==t[a.next_in];)Ue.inflateReset(a),s=Ue.inflate(a,r);switch(s){case Ie:case Be:case Ne:case Ce:return this.onEnd(s),this.ended=!0,!1}if(o=a.avail_out,a.next_out&&(0===a.avail_out||s===Le))if("string"===this.options.to){let t=Bt(a.output,a.next_out),e=a.next_out-t,n=It(a.output,t);a.next_out=e,a.avail_out=i-e,e&&a.output.set(a.output.subarray(t,t+e),0),this.onData(n)}else this.onData(a.output.length===a.next_out?a.output:a.output.subarray(0,a.next_out));if(s!==Fe||0!==o){if(s===Le)return s=Ue.inflateEnd(this.strm),this.onEnd(s),this.ended=!0,!0;if(0===a.avail_in)break}}return!0},He.prototype.onData=function(t){this.chunks.push(t)},He.prototype.onEnd=function(t){t===Fe&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=Ot(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};const{Deflate:Me,deflate:je,deflateRaw:Ke,gzip:Pe}=Vt;var Ye=Me,Ge=je,Xe=B;const We=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const e=this._hasEvents?",":"";this.deflate.push(e+t,Xe.Z_SYNC_FLUSH),this._hasEvents=!0}finish(){if(this.deflate.push("]",Xe.Z_FINISH),this.deflate.err)throw this.deflate.err;const t=this.deflate.result;return this._init(),t}_init(){this._hasEvents=!1,this.deflate=new Ye,this.deflate.push("[",Xe.Z_NO_FLUSH)}},qe={clear:()=>{We.clear()},addEvent:t=>We.addEvent(t),finish:()=>We.finish(),compress:t=>function(t){return Ge(t)}(t)};addEventListener("message",(function(t){const e=t.data.method,a=t.data.id,i=t.data.arg;if(e in qe&&"function"==typeof qe[e])try{const t=qe[e](i);postMessage({id:a,method:e,success:!0,response:t})}catch(t){postMessage({id:a,method:e,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});`;

function Vee() {
    const e = new Blob([Bee]);
    return URL.createObjectURL(e)
}

function p$(e) {
    return e > 9999999999 ? e : e * 1e3
}
class BU {
    constructor() {
        this.events = []
    }
    get hasEvents() {
        return this.events.length > 0
    }
    destroy() {
        this.events = []
    }
    async addEvent(t) {
        this.events.push(t)
    }
    finish() {
        return new Promise(t => {
            const n = this.events;
            this.events = [], t(JSON.stringify(n))
        })
    }
    clear() {
        this.events = []
    }
    getEarliestTimestamp() {
        const t = this.events.map(n => n.timestamp).sort()[0];
        return t ? p$(t) : null
    }
}
class Hee {
    constructor(t) {
        this._worker = t, this._id = 0
    }
    ensureReady() {
        return this._ensureReadyPromise ? this._ensureReadyPromise : (this._ensureReadyPromise = new Promise((t, n) => {
            this._worker.addEventListener("message", ({
                data: r
            }) => {
                r.success ? t() : n()
            }, {
                once: !0
            }), this._worker.addEventListener("error", r => {
                n(r)
            }, {
                once: !0
            })
        }), this._ensureReadyPromise)
    }
    destroy() {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Replay] Destroying compression worker"), this._worker.terminate()
    }
    postMessage(t, n) {
        const r = this._getAndIncrementId();
        return new Promise((s, i) => {
            const o = ({
                data: a
            }) => {
                const l = a;
                if (l.method === t && l.id === r) {
                    if (this._worker.removeEventListener("message", o), !l.success) {
                        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("[Replay]", l.response), i(new Error("Error in compression worker"));
                        return
                    }
                    s(l.response)
                }
            };
            this._worker.addEventListener("message", o), this._worker.postMessage({
                id: r,
                method: t,
                arg: n
            })
        })
    }
    _getAndIncrementId() {
        return this._id++
    }
}
class jee {
    constructor(t) {
        this._worker = new Hee(t), this._earliestTimestamp = null
    }
    get hasEvents() {
        return !!this._earliestTimestamp
    }
    ensureReady() {
        return this._worker.ensureReady()
    }
    destroy() {
        this._worker.destroy()
    }
    addEvent(t) {
        const n = p$(t.timestamp);
        return (!this._earliestTimestamp || n < this._earliestTimestamp) && (this._earliestTimestamp = n), this._sendEventToWorker(t)
    }
    finish() {
        return this._finishRequest()
    }
    clear() {
        this._earliestTimestamp = null, this._worker.postMessage("clear")
    }
    getEarliestTimestamp() {
        return this._earliestTimestamp
    }
    _sendEventToWorker(t) {
        return this._worker.postMessage("addEvent", JSON.stringify(t))
    }
    async _finishRequest() {
        const t = await this._worker.postMessage("finish");
        return this._earliestTimestamp = null, t
    }
}
class zee {
    constructor(t) {
        this._fallback = new BU, this._compression = new jee(t), this._used = this._fallback, this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded()
    }
    get hasEvents() {
        return this._used.hasEvents
    }
    destroy() {
        this._fallback.destroy(), this._compression.destroy()
    }
    clear() {
        return this._used.clear()
    }
    getEarliestTimestamp() {
        return this._used.getEarliestTimestamp()
    }
    addEvent(t) {
        return this._used.addEvent(t)
    }
    async finish() {
        return await this.ensureWorkerIsLoaded(), this._used.finish()
    }
    ensureWorkerIsLoaded() {
        return this._ensureWorkerIsLoadedPromise
    }
    async _ensureWorkerIsLoaded() {
        try {
            await this._compression.ensureReady()
        } catch {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Replay] Failed to load the compression worker, falling back to simple buffer");
            return
        }
        await this._switchToCompressionWorker()
    }
    async _switchToCompressionWorker() {
        const {
            events: t
        } = this._fallback, n = [];
        for (const r of t) n.push(this._compression.addEvent(r));
        this._used = this._compression;
        try {
            await Promise.all(n)
        } catch (r) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("[Replay] Failed to add events when switching buffers.", r)
        }
    }
}

function Wee({
    useCompression: e
}) {
    if (e && window.Worker) try {
        const t = Vee();
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Replay] Using compression worker");
        const n = new Worker(t);
        return new zee(n)
    } catch {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Replay] Failed to create compression worker")
    }
    return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Replay] Using simple buffer"), new BU
}

function Gee(e) {
    qee(), e.session = void 0
}

function qee() {
    if ("sessionStorage" in Bt) try {
        Bt.sessionStorage.removeItem(f$)
    } catch {}
}

function OE(e, t, n = +new Date) {
    return e === null || t === void 0 || t < 0 ? !0 : t === 0 ? !1 : e + t <= n
}

function VU(e, t, n = +new Date) {
    return OE(e.started, t.maxSessionLife, n) || OE(e.lastActivity, t.sessionIdleExpire, n)
}

function HU(e) {
    return e === void 0 ? !1 : Math.random() < e
}

function m$(e) {
    if ("sessionStorage" in Bt) try {
        Bt.sessionStorage.setItem(f$, JSON.stringify(e))
    } catch {}
}

function g$(e) {
    const t = Date.now(),
        n = e.id || di(),
        r = e.started || t,
        s = e.lastActivity || t,
        i = e.segmentId || 0,
        o = e.sampled;
    return {
        id: n,
        started: r,
        lastActivity: s,
        segmentId: i,
        sampled: o,
        shouldRefresh: !0
    }
}

function Yee(e, t) {
    return HU(e) ? "session" : t ? "buffer" : !1
}

function Kee({
    sessionSampleRate: e,
    allowBuffering: t,
    stickySession: n = !1
}) {
    const r = Yee(e, t),
        s = g$({
            sampled: r
        });
    return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Replay] Creating new session: ${s.id}`), n && m$(s), s
}

function Xee() {
    if (!("sessionStorage" in Bt)) return null;
    try {
        const t = Bt.sessionStorage.getItem(f$);
        if (!t) return null;
        const n = JSON.parse(t);
        return g$(n)
    } catch {
        return null
    }
}

function y0({
    timeouts: e,
    currentSession: t,
    stickySession: n,
    sessionSampleRate: r,
    allowBuffering: s
}) {
    const i = t || n && Xee();
    if (i)
        if (VU(i, e))
            if (i.shouldRefresh)(typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Replay] Session has expired");
            else {
                const l = g$({
                    sampled: !1
                });
                return {
                    type: "new",
                    session: l
                }
            }
    else return {
        type: "saved",
        session: i
    };
    const o = Kee({
        stickySession: n,
        sessionSampleRate: r,
        allowBuffering: s
    });
    return {
        type: "new",
        session: o
    }
}
async function Bv(e, t, n) {
    if (!e.eventBuffer || e.isPaused() || p$(t.timestamp) + e.timeouts.sessionIdlePause < Date.now()) return null;
    try {
        return n && e.eventBuffer.clear(), await e.eventBuffer.addEvent(t)
    } catch (s) {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error(s), await e.stop("addEvent");
        const i = Ne().getClient();
        i && i.recordDroppedEvent("internal_sdk_error", "replay")
    }
}

function af(e) {
    return !e.type
}

function k_(e) {
    return e.type === "transaction"
}

function Qee(e) {
    return e.type === "replay_event"
}

function jU(e) {
    const t = Jee();
    return (n, r) => {
        if (!af(n) && !k_(n)) return;
        const s = r && r.statusCode;
        if (!(t && (!s || s < 200 || s >= 300))) {
            if (k_(n) && n.contexts && n.contexts.trace && n.contexts.trace.trace_id) {
                e.getContext().traceIds.add(n.contexts.trace.trace_id);
                return
            }
            if (!!af(n) && (n.event_id && e.getContext().errorIds.add(n.event_id), e.recordingMode === "buffer" && n.exception && n.message !== h$)) {
                if (!HU(e.getOptions().errorSampleRate)) return;
                setTimeout(() => {
                    e.sendBufferedReplayOrFlush()
                })
            }
        }
    }
}

function Jee() {
    const e = Ne().getClient();
    if (!e) return !1;
    const t = e.getTransport();
    return t && t.send.__sentry__baseTransport__ || !1
}
var I_;
(function(e) {
    e[e.Document = 0] = "Document", e[e.DocumentType = 1] = "DocumentType", e[e.Element = 2] = "Element", e[e.Text = 3] = "Text", e[e.CDATA = 4] = "CDATA", e[e.Comment = 5] = "Comment"
})(I_ || (I_ = {}));

function za(e) {
    return x({
        timestamp: Date.now() / 1e3,
        type: "default"
    }, e)
}

function zU(e, t) {
    t.category !== "sentry.transaction" && (["ui.click", "ui.input"].includes(t.category) ? e.triggerUserActivity() : e.checkAndHandleExpiredSession(), e.addUpdate(() => (Bv(e, {
        type: St.Custom,
        timestamp: (t.timestamp || 0) * 1e3,
        data: {
            tag: "breadcrumb",
            payload: $s(t, 10, 1e3)
        }
    }), t.category === "console")))
}
const Zee = new Set(["id", "class", "aria-label", "role", "name", "alt", "title", "data-test-id", "data-testid"]);

function ete(e) {
    const t = {};
    for (const n in e)
        if (Zee.has(n)) {
            let r = n;
            (n === "data-testid" || n === "data-test-id") && (r = "testId"), t[r] = e[n]
        }
    return t
}
const tte = e => t => {
    if (!e.isEnabled()) return;
    const n = nte(t);
    !n || zU(e, n)
};

function nte(e) {
    let t, n;
    try {
        n = rte(e), t = cl(n)
    } catch {
        t = "<unknown>"
    }
    const r = n && "__sn" in n && n.__sn.type === I_.Element ? n.__sn : null;
    return za({
        category: `ui.${e.name}`,
        message: t,
        data: r ? {
            nodeId: r.id,
            node: {
                id: r.id,
                tagName: r.tagName,
                textContent: n ? Array.from(n.childNodes).map(s => "__sn" in s && s.__sn.type === I_.Text && s.__sn.textContent).filter(Boolean).map(s => s.trim()).join("") : "",
                attributes: ete(r.attributes)
            }
        } : {}
    })
}

function rte(e) {
    return ste(e.event) ? e.event.target : e.event
}

function ste(e) {
    return !!e.target
}

function ite(e, t) {
    return e.type || !e.exception || !e.exception.values || !e.exception.values.length ? !1 : t.originalException && t.originalException.__rrweb__ ? !0 : e.exception.values.some(n => !n.stacktrace || !n.stacktrace.frames || !n.stacktrace.frames.length ? !1 : n.stacktrace.frames.some(r => r.filename && r.filename.includes("/rrweb/src/")))
}

function ote(e, t = !1) {
    const n = t ? jU(e) : void 0;
    return (r, s) => {
        if (Qee(r)) return delete r.breadcrumbs, r;
        if (!af(r) && !k_(r)) return r;
        if (ite(r, s) && !e.getOptions()._experiments.captureExceptions) return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Replay] Ignoring error from rrweb internals", r), null;
        if ((af(r) || k_(r) && e.recordingMode === "session") && (r.tags = G(x({}, r.tags), {
                replayId: e.getSessionId()
            })), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && e.getOptions()._experiments.traceInternals && af(r)) {
            const i = lte(r);
            ate({
                message: `Tagging event (${r.event_id}) - ${r.message} - ${i.type}: ${i.value}`
            })
        }
        return n && n(r, {
            statusCode: 200
        }), r
    }
}

function ate(e) {
    const i = e,
        {
            category: t,
            level: n,
            message: r
        } = i,
        s = Gr(i, ["category", "level", "message"]);
    XQ(x({
        category: t || "console",
        level: n || "debug",
        message: `[debug]: ${r}`
    }, s))
}

function lte(e) {
    return x({
        type: "Unknown",
        value: "n/a"
    }, e.exception && e.exception.values && e.exception.values[0])
}

function Vv(e, t) {
    return t.map(({
        type: n,
        start: r,
        end: s,
        name: i,
        data: o
    }) => Bv(e, {
        type: St.Custom,
        timestamp: r,
        data: {
            tag: "performanceSpan",
            payload: {
                op: n,
                description: i,
                startTimestamp: r,
                endTimestamp: s,
                data: o
            }
        }
    }))
}

function cte(e) {
    const {
        from: t,
        to: n
    } = e, r = Date.now() / 1e3;
    return {
        type: "navigation.push",
        start: r,
        end: r,
        name: n,
        data: {
            previous: t
        }
    }
}

function ute(e) {
    return t => {
        if (!e.isEnabled()) return;
        const n = cte(t);
        n !== null && (e.getContext().urls.push(n.name), e.triggerUserActivity(), e.addUpdate(() => (Vv(e, [n]), !1)))
    }
}

function dte(e, t) {
    return (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && e.getOptions()._experiments.traceInternals ? !1 : fte(t)
}

function fte(e) {
    const t = Ne().getClient(),
        n = t && t.getDsn();
    return n ? e.includes(n.host) : !1
}

function Hv(e, t) {
    !e.isEnabled() || t !== null && (dte(e, t.name) || e.addUpdate(() => (Vv(e, [t]), !0)))
}

function hte(e) {
    const {
        startTimestamp: t,
        endTimestamp: n,
        fetchData: r,
        response: s
    } = e;
    if (!n) return null;
    const {
        method: i,
        url: o
    } = r;
    return {
        type: "resource.fetch",
        start: t / 1e3,
        end: n / 1e3,
        name: o,
        data: {
            method: i,
            statusCode: s && s.status
        }
    }
}

function pte(e) {
    return t => {
        if (!e.isEnabled()) return;
        const n = hte(t);
        Hv(e, n)
    }
}

function mte(e) {
    const {
        startTimestamp: t,
        endTimestamp: n,
        xhr: r
    } = e, s = r[yo];
    if (!t || !n || !s) return null;
    const {
        method: i,
        url: o,
        status_code: a
    } = s;
    return o === void 0 ? null : {
        type: "resource.xhr",
        name: o,
        start: t / 1e3,
        end: n / 1e3,
        data: {
            method: i,
            statusCode: a
        }
    }
}

function gte(e) {
    return t => {
        if (!e.isEnabled()) return;
        const n = mte(t);
        Hv(e, n)
    }
}
const vo = 10,
    _$ = 11,
    DE = 12,
    $i = 13,
    NE = 14,
    mu = 15,
    ni = 20,
    Yr = 21,
    PE = 22,
    gu = 23,
    WU = ["true", "false", "null"];

function _te(e, t) {
    if (!t.length) return e;
    let n = e;
    const r = t.length - 1,
        s = t[r];
    n = yte(n, s);
    for (let i = r; i >= 0; i--) switch (t[i]) {
        case vo:
            n = `${n}}`;
            break;
        case ni:
            n = `${n}]`;
            break
    }
    return n
}

function yte(e, t) {
    switch (t) {
        case vo:
            return `${e}"~~":"~~"`;
        case _$:
            return `${e}:"~~"`;
        case DE:
            return `${e}~~":"~~"`;
        case $i:
            return wte(e);
        case NE:
            return `${e}~~"`;
        case mu:
            return `${e},"~~":"~~"`;
        case ni:
            return `${e}"~~"`;
        case Yr:
            return vte(e);
        case PE:
            return `${e}~~"`;
        case gu:
            return `${e},"~~"`
    }
    return e
}

function vte(e) {
    const t = bte(e);
    if (t > -1) {
        const n = e.slice(t + 1);
        return WU.includes(n.trim()) ? `${e},"~~"` : `${e.slice(0,t+1)}"~~"`
    }
    return e
}

function bte(e) {
    for (let t = e.length - 1; t >= 0; t--) {
        const n = e[t];
        if (n === "," || n === "[") return t
    }
    return -1
}

function wte(e) {
    const t = e.lastIndexOf(":"),
        n = e.slice(t + 1);
    return WU.includes(n.trim()) ? `${e},"~~":"~~"` : `${e.slice(0,t+1)}"~~"`
}

function Ete(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) Ste(t, e, n);
    return t
}

function Ste(e, t, n) {
    const r = e[e.length - 1],
        s = t[n];
    if (!/\s/.test(s)) {
        if (s === '"' && !GU(t, n)) {
            Tte(e, r);
            return
        }
        switch (s) {
            case "{":
                $te(e, r);
                break;
            case "[":
                kte(e, r);
                break;
            case ":":
                Ite(e, r);
                break;
            case ",":
                xte(e, r);
                break;
            case "}":
                Cte(e, r);
                break;
            case "]":
                Ate(e, r);
                break
        }
    }
}

function Tte(e, t) {
    if (t === NE) {
        e.pop(), e.push(mu);
        return
    }
    if (t === PE) {
        e.pop(), e.push(gu);
        return
    }
    if (t === $i) {
        e.push(NE);
        return
    }
    if (t === Yr) {
        e.push(PE);
        return
    }
    if (t === vo) {
        e.push(DE);
        return
    }
    if (t === DE) {
        e.pop(), e.push(_$);
        return
    }
}

function $te(e, t) {
    if (!t) {
        e.push(vo);
        return
    }
    if (t === $i) {
        e.push(vo);
        return
    }
    if (t === Yr && e.push(vo), t === ni) {
        e.push(vo);
        return
    }
}

function kte(e, t) {
    if (!t) {
        e.push(ni), e.push(Yr);
        return
    }
    if (t === $i) {
        e.push(ni), e.push(Yr);
        return
    }
    if (t === Yr && (e.push(ni), e.push(Yr)), t === ni) {
        e.push(ni), e.push(Yr);
        return
    }
}

function Ite(e, t) {
    t === _$ && (e.pop(), e.push($i))
}

function xte(e, t) {
    if (t === $i) {
        e.pop();
        return
    }
    if (t === mu) {
        e.pop(), e.pop();
        return
    }
    if (t !== Yr && t === gu) {
        e.pop();
        return
    }
}

function Cte(e, t) {
    t === vo && e.pop(), t === $i && (e.pop(), e.pop()), t === mu && (e.pop(), e.pop(), e.pop()), e[e.length - 1] === $i && e.push(mu), e[e.length - 1] === Yr && e.push(gu)
}

function Ate(e, t) {
    t === ni && e.pop(), t === Yr && (e.pop(), e.pop()), t === gu && (e.pop(), e.pop(), e.pop()), e[e.length - 1] === $i && e.push(mu), e[e.length - 1] === Yr && e.push(gu)
}

function GU(e, t) {
    return e[t - 1] === "\\" && !GU(e, t - 1)
}

function qU(e) {
    const t = Ete(e);
    return _te(e, t)
}

function x_(e, t) {
    if (!!e) try {
        if (typeof e == "string") return t.encode(e).length;
        if (e instanceof URLSearchParams) return t.encode(e.toString()).length;
        if (e instanceof FormData) {
            const n = QU(e);
            return t.encode(n).length
        }
        if (e instanceof Blob) return e.size;
        if (e instanceof ArrayBuffer) return e.byteLength
    } catch {}
}

function YU(e) {
    if (!e) return;
    const t = parseInt(e, 10);
    return isNaN(t) ? void 0 : t
}

function KU(e) {
    if (typeof e == "string") return e;
    if (e instanceof URLSearchParams) return e.toString();
    if (e instanceof FormData) return QU(e)
}

function XU(e, t) {
    if (!t) return null;
    const {
        startTimestamp: n,
        endTimestamp: r,
        url: s,
        method: i,
        statusCode: o,
        request: a,
        response: l
    } = t;
    return {
        type: e,
        start: n / 1e3,
        end: r / 1e3,
        name: s,
        data: Rs({
            method: i,
            statusCode: o,
            request: a,
            response: l
        })
    }
}

function gh(e) {
    return {
        headers: {},
        size: e,
        _meta: {
            warnings: ["URL_SKIPPED"]
        }
    }
}

function bo(e, t, n) {
    if (!t && Object.keys(e).length === 0) return;
    if (!t) return {
        headers: e
    };
    if (!n) return {
        headers: e,
        size: t
    };
    const r = {
            headers: e,
            size: t
        },
        {
            body: s,
            warnings: i
        } = Rte(n);
    return r.body = s, i.length > 0 && (r._meta = {
        warnings: i
    }), r
}

function ME(e, t) {
    return Object.keys(e).reduce((n, r) => {
        const s = r.toLowerCase();
        return t.includes(s) && e[r] && (n[s] = e[r]), n
    }, {})
}

function QU(e) {
    return new URLSearchParams(e).toString()
}

function Rte(e) {
    if (!e || typeof e != "string") return {
        body: e,
        warnings: []
    };
    const t = e.length > pm;
    if (Ote(e)) try {
        const n = t ? qU(e.slice(0, pm)) : e;
        return {
            body: JSON.parse(n),
            warnings: t ? ["JSON_TRUNCATED"] : []
        }
    } catch {
        return {
            body: t ? `${e.slice(0,pm)}\u2026` : e,
            warnings: t ? ["INVALID_JSON", "TEXT_TRUNCATED"] : ["INVALID_JSON"]
        }
    }
    return {
        body: t ? `${e.slice(0,pm)}\u2026` : e,
        warnings: t ? ["TEXT_TRUNCATED"] : []
    }
}

function Ote(e) {
    const t = e[0],
        n = e[e.length - 1];
    return t === "[" && n === "]" || t === "{" && n === "}"
}

function JU(e, t) {
    return nd(e, t)
}
async function Dte(e, t, n) {
    try {
        const r = await Pte(e, t, n),
            s = XU("resource.fetch", r);
        Hv(n.replay, s)
    } catch (r) {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("[Replay] Failed to capture fetch breadcrumb", r)
    }
}

function Nte(e, t, n) {
    const {
        input: r,
        response: s
    } = t, i = ZU(r), o = x_(i, n.textEncoder), a = s ? YU(s.headers.get("content-length")) : void 0;
    o !== void 0 && (e.data.request_body_size = o), a !== void 0 && (e.data.response_body_size = a)
}
async function Pte(e, t, n) {
    const {
        startTimestamp: r,
        endTimestamp: s
    } = t, {
        url: i,
        method: o,
        status_code: a = 0,
        request_body_size: l,
        response_body_size: c
    } = e.data, u = JU(i, n.networkDetailAllowUrls), d = u ? Mte(n, t.input, l) : gh(l), f = await Lte(u, n, t.response, c);
    return {
        startTimestamp: r,
        endTimestamp: s,
        url: i,
        method: o,
        statusCode: a,
        request: d,
        response: f
    }
}

function Mte({
    networkCaptureBodies: e,
    networkRequestHeaders: t
}, n, r) {
    const s = Ute(n, t);
    if (!e) return bo(s, r, void 0);
    const i = ZU(n),
        o = KU(i);
    return bo(s, r, o)
}
async function Lte(e, {
    networkCaptureBodies: t,
    textEncoder: n,
    networkResponseHeaders: r
}, s, i) {
    if (!e && i !== void 0) return gh(i);
    const o = eB(s.headers, r);
    if (!t && i !== void 0) return bo(o, i, void 0);
    try {
        const a = s.clone(),
            l = await Fte(a),
            c = l && l.length && i === void 0 ? x_(l, n) : i;
        return e ? t ? bo(o, c, l) : bo(o, c, void 0) : gh(c)
    } catch {
        return bo(o, i, void 0)
    }
}
async function Fte(e) {
    try {
        return await e.text()
    } catch {
        return
    }
}

function ZU(e = []) {
    if (!(e.length !== 2 || typeof e[1] != "object")) return e[1].body
}

function eB(e, t) {
    const n = {};
    return t.forEach(r => {
        e.get(r) && (n[r] = e.get(r))
    }), n
}

function Ute(e, t) {
    return e.length === 1 && typeof e[0] != "string" ? mA(e[0], t) : e.length === 2 ? mA(e[1], t) : {}
}

function mA(e, t) {
    if (!e) return {};
    const n = e.headers;
    return n ? n instanceof Headers ? eB(n, t) : Array.isArray(n) ? {} : ME(n, t) : {}
}
async function Bte(e, t, n) {
    try {
        const r = Hte(e, t, n),
            s = XU("resource.xhr", r);
        Hv(n.replay, s)
    } catch (r) {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("[Replay] Failed to capture fetch breadcrumb", r)
    }
}

function Vte(e, t, n) {
    const {
        xhr: r,
        input: s
    } = t, i = x_(s, n.textEncoder), o = r.getResponseHeader("content-length") ? YU(r.getResponseHeader("content-length")) : x_(r.response, n.textEncoder);
    i !== void 0 && (e.data.request_body_size = i), o !== void 0 && (e.data.response_body_size = o)
}

function Hte(e, t, n) {
    const {
        startTimestamp: r,
        endTimestamp: s,
        input: i,
        xhr: o
    } = t, {
        url: a,
        method: l,
        status_code: c = 0,
        request_body_size: u,
        response_body_size: d
    } = e.data;
    if (!a) return null;
    if (!JU(a, n.networkDetailAllowUrls)) {
        const y = gh(u),
            _ = gh(d);
        return {
            startTimestamp: r,
            endTimestamp: s,
            url: a,
            method: l,
            statusCode: c,
            request: y,
            response: _
        }
    }
    const f = o[yo],
        h = f ? ME(f.request_headers, n.networkRequestHeaders) : {},
        p = ME(jte(o), n.networkResponseHeaders),
        m = bo(h, u, n.networkCaptureBodies ? KU(i) : void 0),
        g = bo(p, d, n.networkCaptureBodies ? t.xhr.responseText : void 0);
    return {
        startTimestamp: r,
        endTimestamp: s,
        url: a,
        method: l,
        statusCode: c,
        request: m,
        response: g
    }
}

function jte(e) {
    const t = e.getAllResponseHeaders();
    return t ? t.split(`\r
`).reduce((n, r) => {
        const [s, i] = r.split(": ");
        return n[s.toLowerCase()] = i, n
    }, {}) : {}
}

function zte(e) {
    const t = Ne().getClient();
    try {
        const n = new TextEncoder,
            {
                networkDetailAllowUrls: r,
                networkCaptureBodies: s,
                networkRequestHeaders: i,
                networkResponseHeaders: o
            } = e.getOptions(),
            a = {
                replay: e,
                textEncoder: n,
                networkDetailAllowUrls: r,
                networkCaptureBodies: s,
                networkRequestHeaders: i,
                networkResponseHeaders: o
            };
        t && t.on ? t.on("beforeAddBreadcrumb", (l, c) => Wte(a, l, c)) : (Rn("fetch", pte(e)), Rn("xhr", gte(e)))
    } catch {}
}

function Wte(e, t, n) {
    if (!!t.data) try {
        Gte(t) && Yte(n) && (Vte(t, n, e), Bte(t, n, e)), qte(t) && Kte(n) && (Nte(t, n, e), Dte(t, n, e))
    } catch {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("Error when enriching network breadcrumb")
    }
}

function Gte(e) {
    return e.category === "xhr"
}

function qte(e) {
    return e.category === "fetch"
}

function Yte(e) {
    return e && e.xhr
}

function Kte(e) {
    return e && e.response
}
let gA = null;
const Xte = e => t => {
    if (!e.isEnabled()) return;
    const n = Qte(t);
    !n || zU(e, n)
};

function Qte(e) {
    const t = e.getLastBreadcrumb && e.getLastBreadcrumb();
    return gA === t || !t || (gA = t, t.category && (["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(t.category) || t.category.startsWith("ui."))) ? null : t.category === "console" ? Jte(t) : za(t)
}

function Jte(e) {
    const t = e.data && e.data.arguments;
    if (!Array.isArray(t) || t.length === 0) return za(e);
    let n = !1;
    const r = t.map(s => {
        if (!s) return s;
        if (typeof s == "string") return s.length > mm ? (n = !0, `${s.slice(0,mm)}\u2026`) : s;
        if (typeof s == "object") try {
            const i = $s(s, 7),
                o = JSON.stringify(i);
            if (o.length > mm) {
                const a = qU(o.slice(0, mm)),
                    l = JSON.parse(a);
                return n = !0, l
            }
            return i
        } catch {}
        return s
    });
    return za(G(x({}, e), {
        data: x(G(x({}, e.data), {
            arguments: r
        }), n ? {
            _meta: {
                warnings: ["CONSOLE_ARG_TRUNCATED"]
            }
        } : {})
    }))
}

function Zte(e) {
    const t = Ne().getScope(),
        n = Ne().getClient();
    t && t.addScopeListener(Xte(e)), Rn("dom", tte(e)), Rn("history", ute(e)), zte(e), Pv(ote(e, !_A(n))), _A(n) && (n.on("afterSendEvent", jU(e)), n.on("createDsc", r => {
        const s = e.getSessionId();
        s && e.isEnabled() && e.recordingMode === "session" && (r.replay_id = s)
    }))
}

function _A(e) {
    return !!(e && e.on)
}
async function ene(e) {
    try {
        return Promise.all(Vv(e, [tne(Bt.performance.memory)]))
    } catch {
        return []
    }
}

function tne(e) {
    const {
        jsHeapSizeLimit: t,
        totalJSHeapSize: n,
        usedJSHeapSize: r
    } = e, s = Date.now() / 1e3;
    return {
        type: "memory",
        name: "memory",
        start: s,
        end: s,
        data: {
            memory: {
                jsHeapSizeLimit: t,
                totalJSHeapSize: n,
                usedJSHeapSize: r
            }
        }
    }
}
const yA = {
    resource: one,
    paint: sne,
    navigation: ine,
    ["largest-contentful-paint"]: ane
};

function nne(e) {
    return e.map(rne).filter(Boolean)
}

function rne(e) {
    return yA[e.entryType] === void 0 ? null : yA[e.entryType](e)
}

function _u(e) {
    return ((Ti || Bt.performance.timeOrigin) + e) / 1e3
}

function sne(e) {
    const {
        duration: t,
        entryType: n,
        name: r,
        startTime: s
    } = e, i = _u(s);
    return {
        type: n,
        name: r,
        start: i,
        end: i + t,
        data: void 0
    }
}

function ine(e) {
    const {
        entryType: t,
        name: n,
        decodedBodySize: r,
        duration: s,
        domComplete: i,
        encodedBodySize: o,
        domContentLoadedEventStart: a,
        domContentLoadedEventEnd: l,
        domInteractive: c,
        loadEventStart: u,
        loadEventEnd: d,
        redirectCount: f,
        startTime: h,
        transferSize: p,
        type: m
    } = e;
    return s === 0 ? null : {
        type: `${t}.${m}`,
        start: _u(h),
        end: _u(i),
        name: n,
        data: {
            size: p,
            decodedBodySize: r,
            encodedBodySize: o,
            duration: s,
            domInteractive: c,
            domContentLoadedEventStart: a,
            domContentLoadedEventEnd: l,
            loadEventStart: u,
            loadEventEnd: d,
            domComplete: i,
            redirectCount: f
        }
    }
}

function one(e) {
    const {
        entryType: t,
        initiatorType: n,
        name: r,
        responseEnd: s,
        startTime: i,
        decodedBodySize: o,
        encodedBodySize: a,
        responseStatus: l,
        transferSize: c
    } = e;
    return ["fetch", "xmlhttprequest"].includes(n) ? null : {
        type: `${t}.${n}`,
        start: _u(i),
        end: _u(s),
        name: r,
        data: {
            size: c,
            statusCode: l,
            decodedBodySize: o,
            encodedBodySize: a
        }
    }
}

function ane(e) {
    const {
        entryType: t,
        startTime: n,
        size: r
    } = e;
    let s = 0;
    if (Bt.performance) {
        const a = Bt.performance.getEntriesByType("navigation")[0];
        s = a && a.activationStart || 0
    }
    const i = Math.max(n - s, 0),
        o = _u(s) + i / 1e3;
    return {
        type: t,
        name: t,
        start: o,
        end: o,
        data: {
            value: i,
            size: r,
            nodeId: fl.mirror.getId(e.element)
        }
    }
}

function lne(e, t, n) {
    let r, s, i;
    const o = n && n.maxWait ? Math.max(n.maxWait, t) : 0;

    function a() {
        return l(), r = e(), r
    }

    function l() {
        s !== void 0 && clearTimeout(s), i !== void 0 && clearTimeout(i), s = i = void 0
    }

    function c() {
        return s !== void 0 || i !== void 0 ? a() : r
    }

    function u() {
        return s && clearTimeout(s), s = setTimeout(a, t), o && i === void 0 && (i = setTimeout(a, o)), r
    }
    return u.cancel = l, u.flush = c, u
}

function cne(e) {
    let t = !1;
    return (n, r) => {
        if (!e.checkAndHandleExpiredSession()) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("[Replay] Received replay event after session expired.");
            return
        }
        const s = r || !t;
        t = !0, e.addUpdate(() => {
            if (e.recordingMode === "buffer" && s && e.setInitialState(), Bv(e, n, s), !s) return !1;
            if (e.session && e.session.previousSessionId) return !0;
            if (e.recordingMode === "buffer" && e.session && e.eventBuffer) {
                const i = e.eventBuffer.getEarliestTimestamp();
                i && (e.session.started = i, e.getOptions().stickySession && m$(e.session))
            }
            return e.recordingMode === "session" && e.flushImmediate(), !0
        })
    }
}

function une(e, t, n, r) {
    return rd(sU(e, o$(e), r, n), [
        [{
            type: "replay_event"
        }, e],
        [{
            type: "replay_recording",
            length: typeof t == "string" ? new TextEncoder().encode(t).length : t.length
        }, t]
    ])
}

function dne({
    recordingData: e,
    headers: t
}) {
    let n;
    const r = `${JSON.stringify(t)}
`;
    if (typeof e == "string") n = `${r}${e}`;
    else {
        const i = new TextEncoder().encode(r);
        n = new Uint8Array(i.length + e.length), n.set(i), n.set(e, i.length)
    }
    return n
}
async function fne({
    client: e,
    scope: t,
    replayId: n,
    event: r
}) {
    const s = typeof e._integrations == "object" && e._integrations !== null && !Array.isArray(e._integrations) ? Object.keys(e._integrations) : void 0,
        i = await hU(e.getOptions(), r, {
            event_id: n,
            integrations: s
        }, t);
    if (!i) return null;
    i.platform = i.platform || "javascript";
    const o = e.getSdkMetadata && e.getSdkMetadata(),
        {
            name: a,
            version: l
        } = o && o.sdk || {};
    return i.sdk = G(x({}, i.sdk), {
        name: a || "sentry.javascript.unknown",
        version: l || "0.0.0"
    }), i
}
async function hne({
    recordingData: e,
    replayId: t,
    segmentId: n,
    eventContext: r,
    timestamp: s,
    session: i,
    options: o
}) {
    const a = dne({
            recordingData: e,
            headers: {
                segment_id: n
            }
        }),
        {
            urls: l,
            errorIds: c,
            traceIds: u,
            initialTimestamp: d
        } = r,
        f = Ne(),
        h = f.getClient(),
        p = f.getScope(),
        m = h && h.getTransport(),
        g = h && h.getDsn();
    if (!h || !p || !m || !g || !i.sampled) return;
    const y = {
            type: AZ,
            replay_start_timestamp: d / 1e3,
            timestamp: s / 1e3,
            error_ids: c,
            trace_ids: u,
            urls: l,
            replay_id: t,
            segment_id: n,
            replay_type: i.sampled
        },
        _ = await fne({
            scope: p,
            client: h,
            replayId: t,
            event: y
        });
    if (!_) {
        h.recordDroppedEvent("event_processor", "replay", y), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("An event processor returned `null`, will not send event.");
        return
    }
    _.contexts = G(x({}, _.contexts), {
        replay: G(x({}, _.contexts && _.contexts.replay), {
            session_sample_rate: o.sessionSampleRate,
            error_sample_rate: o.errorSampleRate
        })
    });
    const E = une(_, a, g, h.getOptions().tunnel);
    let b;
    try {
        b = await m.send(E)
    } catch (w) {
        const T = new Error(h$);
        try {
            T.cause = w
        } catch {}
        throw T
    }
    if (!b) return b;
    if (typeof b.statusCode == "number" && (b.statusCode < 200 || b.statusCode >= 300)) throw new tB(b.statusCode);
    return b
}
class tB extends Error {
    constructor(t) {
        super(`Transport returned status code ${t}`)
    }
}
async function nB(e, t = {
    count: 0,
    interval: LZ
}) {
    const {
        recordingData: n,
        options: r
    } = e;
    if (!!n.length) try {
        return await hne(e), !0
    } catch (s) {
        if (s instanceof tB) throw s;
        if (l$("Replays", {
                _retryCount: t.count
            }), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && r._experiments && r._experiments.captureExceptions && dl(s), t.count >= FZ) {
            const i = new Error(`${h$} - max retries exceeded`);
            try {
                i.cause = s
            } catch {}
            throw i
        }
        return t.interval *= ++t.count, await new Promise((i, o) => {
            setTimeout(async () => {
                try {
                    await nB(e, t), i(!0)
                } catch (a) {
                    o(a)
                }
            }, t.interval)
        })
    }
}
class tn {
    __init() {
        this.eventBuffer = null
    }
    __init2() {
        this.performanceEvents = []
    }
    __init3() {
        this.recordingMode = "session"
    }
    __init4() {
        this.timeouts = {
            sessionIdlePause: RZ,
            sessionIdleExpire: OZ,
            maxSessionLife: DZ
        }
    }
    __init5() {
        this._performanceObserver = null
    }
    __init6() {
        this._flushLock = null
    }
    __init7() {
        this._lastActivity = Date.now()
    }
    __init8() {
        this._isEnabled = !1
    }
    __init9() {
        this._isPaused = !1
    }
    __init10() {
        this._hasInitializedCoreListeners = !1
    }
    __init11() {
        this._stopRecording = null
    }
    __init12() {
        this._context = {
            errorIds: new Set,
            traceIds: new Set,
            urls: [],
            initialTimestamp: Date.now(),
            initialUrl: ""
        }
    }
    constructor({
        options: t,
        recordingOptions: n
    }) {
        tn.prototype.__init.call(this), tn.prototype.__init2.call(this), tn.prototype.__init3.call(this), tn.prototype.__init4.call(this), tn.prototype.__init5.call(this), tn.prototype.__init6.call(this), tn.prototype.__init7.call(this), tn.prototype.__init8.call(this), tn.prototype.__init9.call(this), tn.prototype.__init10.call(this), tn.prototype.__init11.call(this), tn.prototype.__init12.call(this), tn.prototype.__init13.call(this), tn.prototype.__init14.call(this), tn.prototype.__init15.call(this), tn.prototype.__init16.call(this), tn.prototype.__init17.call(this), this._recordingOptions = n, this._options = t, this._debouncedFlush = lne(() => this._flush(), this._options.flushMinDelay, {
            maxWait: this._options.flushMaxDelay
        })
    }
    getContext() {
        return this._context
    }
    isEnabled() {
        return this._isEnabled
    }
    isPaused() {
        return this._isPaused
    }
    getOptions() {
        return this._options
    }
    initializeSampling() {
        const {
            errorSampleRate: t,
            sessionSampleRate: n
        } = this._options;
        if (!(t <= 0 && n <= 0 || !this._loadAndCheckSession())) {
            if (!this.session) {
                this._handleException(new Error("Unable to initialize and create session"));
                return
            }
            this.session.sampled && this.session.sampled !== "session" && (this.recordingMode = "buffer"), this._initializeRecording()
        }
    }
    start() {
        if (this._isEnabled && this.recordingMode === "session") throw new Error("Replay recording is already in progress");
        if (this._isEnabled && this.recordingMode === "buffer") throw new Error("Replay buffering is in progress, call `flush()` to save the replay");
        const t = this.session && this.session.id,
            {
                session: n
            } = y0({
                timeouts: this.timeouts,
                stickySession: Boolean(this._options.stickySession),
                currentSession: this.session,
                sessionSampleRate: 1,
                allowBuffering: !1
            });
        n.previousSessionId = t, this.session = n, this._initializeRecording()
    }
    startBuffering() {
        if (this._isEnabled) throw new Error("Replay recording is already in progress");
        const t = this.session && this.session.id,
            {
                session: n
            } = y0({
                timeouts: this.timeouts,
                stickySession: Boolean(this._options.stickySession),
                currentSession: this.session,
                sessionSampleRate: 0,
                allowBuffering: !0
            });
        n.previousSessionId = t, this.session = n, this.recordingMode = "buffer", this._initializeRecording()
    }
    startRecording() {
        try {
            this._stopRecording = fl(G(x(x({}, this._recordingOptions), this.recordingMode === "buffer" && {
                checkoutEveryNms: MZ
            }), {
                emit: cne(this),
                onMutation: this._onMutationHandler
            }))
        } catch (t) {
            this._handleException(t)
        }
    }
    stopRecording() {
        try {
            return this._stopRecording && (this._stopRecording(), this._stopRecording = void 0), !0
        } catch (t) {
            return this._handleException(t), !1
        }
    }
    async stop(t) {
        if (!!this._isEnabled) try {
            if (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) {
                const n = `[Replay] Stopping Replay${t?` triggered by ${t}`:""}`;
                (this.getOptions()._experiments.traceInternals ? console.warn : M.log)(n)
            }
            this._isEnabled = !1, this._removeListeners(), this.stopRecording(), this._debouncedFlush.cancel(), await this._flush({
                force: !0
            }), this.eventBuffer && this.eventBuffer.destroy(), this.eventBuffer = null, Gee(this)
        } catch (n) {
            this._handleException(n)
        }
    }
    pause() {
        this._isPaused = !0, this.stopRecording()
    }
    resume() {
        !this._loadAndCheckSession() || (this._isPaused = !1, this.startRecording())
    }
    async sendBufferedReplayOrFlush({
        continueRecording: t = !0
    } = {}) {
        if (this.recordingMode === "session") return this.flushImmediate();
        await this.flushImmediate();
        const n = this.stopRecording();
        !t || !n || (this.recordingMode = "session", this.session && (this.session.shouldRefresh = !1, this._maybeSaveSession()), this.startRecording())
    }
    addUpdate(t) {
        const n = t();
        this.recordingMode !== "buffer" && n !== !0 && this._debouncedFlush()
    }
    triggerUserActivity() {
        if (this._updateUserActivity(), !this._stopRecording) {
            if (!this._loadAndCheckSession()) return;
            this.resume();
            return
        }
        this.checkAndHandleExpiredSession(), this._updateSessionActivity()
    }
    flushImmediate() {
        return this._debouncedFlush(), this._debouncedFlush.flush()
    }
    getSessionId() {
        return this.session && this.session.id
    }
    checkAndHandleExpiredSession() {
        const t = this.getSessionId();
        if (this._lastActivity && OE(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === "session") {
            this.pause();
            return
        }
        return this._loadAndCheckSession() ? t !== this.getSessionId() ? (this._triggerFullSnapshot(), !1) : !0 : void 0
    }
    setInitialState() {
        const t = `${Bt.location.pathname}${Bt.location.hash}${Bt.location.search}`,
            n = `${Bt.location.origin}${t}`;
        this.performanceEvents = [], this._clearContext(), this._context.initialUrl = n, this._context.initialTimestamp = Date.now(), this._context.urls.push(n)
    }
    _initializeRecording() {
        this.setInitialState(), this._updateSessionActivity(), this.eventBuffer = Wee({
            useCompression: this._options.useCompression
        }), this._removeListeners(), this._addListeners(), this._isEnabled = !0, this.startRecording()
    }
    _handleException(t) {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("[Replay]", t), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && this._options._experiments && this._options._experiments.captureExceptions && dl(t)
    }
    _loadAndCheckSession() {
        const {
            type: t,
            session: n
        } = y0({
            timeouts: this.timeouts,
            stickySession: Boolean(this._options.stickySession),
            currentSession: this.session,
            sessionSampleRate: this._options.sessionSampleRate,
            allowBuffering: this._options.errorSampleRate > 0
        });
        t === "new" && this.setInitialState();
        const r = this.getSessionId();
        return n.id !== r && (n.previousSessionId = r), this.session = n, this.session.sampled ? !0 : (this.stop("session unsampled"), !1)
    }
    _addListeners() {
        try {
            Bt.document.addEventListener("visibilitychange", this._handleVisibilityChange), Bt.addEventListener("blur", this._handleWindowBlur), Bt.addEventListener("focus", this._handleWindowFocus), this._hasInitializedCoreListeners || (Zte(this), this._hasInitializedCoreListeners = !0)
        } catch (t) {
            this._handleException(t)
        }
        "PerformanceObserver" in Bt && (this._performanceObserver = Uee(this))
    }
    _removeListeners() {
        try {
            Bt.document.removeEventListener("visibilitychange", this._handleVisibilityChange), Bt.removeEventListener("blur", this._handleWindowBlur), Bt.removeEventListener("focus", this._handleWindowFocus), this._performanceObserver && (this._performanceObserver.disconnect(), this._performanceObserver = null)
        } catch (t) {
            this._handleException(t)
        }
    }
    __init13() {
        this._handleVisibilityChange = () => {
            Bt.document.visibilityState === "visible" ? this._doChangeToForegroundTasks() : this._doChangeToBackgroundTasks()
        }
    }
    __init14() {
        this._handleWindowBlur = () => {
            const t = za({
                category: "ui.blur"
            });
            this._doChangeToBackgroundTasks(t)
        }
    }
    __init15() {
        this._handleWindowFocus = () => {
            const t = za({
                category: "ui.focus"
            });
            this._doChangeToForegroundTasks(t)
        }
    }
    _doChangeToBackgroundTasks(t) {
        if (!this.session) return;
        const n = VU(this.session, this.timeouts);
        t && !n && this._createCustomBreadcrumb(t), this._conditionalFlush()
    }
    _doChangeToForegroundTasks(t) {
        if (!this.session) return;
        if (!this.checkAndHandleExpiredSession()) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Replay] Document has become active, but session has expired");
            return
        }
        t && this._createCustomBreadcrumb(t)
    }
    _triggerFullSnapshot(t = !0) {
        try {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Replay] Taking full rrweb snapshot"), fl.takeFullSnapshot(t)
        } catch (n) {
            this._handleException(n)
        }
    }
    _updateUserActivity(t = Date.now()) {
        this._lastActivity = t
    }
    _updateSessionActivity(t = Date.now()) {
        this.session && (this.session.lastActivity = t, this._maybeSaveSession())
    }
    _createCustomBreadcrumb(t) {
        this.addUpdate(() => {
            Bv(this, {
                type: St.Custom,
                timestamp: t.timestamp || 0,
                data: {
                    tag: "breadcrumb",
                    payload: t
                }
            })
        })
    }
    _addPerformanceEntries() {
        const t = [...this.performanceEvents];
        return this.performanceEvents = [], Promise.all(Vv(this, nne(t)))
    }
    _conditionalFlush() {
        this.recordingMode !== "buffer" && this.flushImmediate()
    }
    _clearContext() {
        this._context.errorIds.clear(), this._context.traceIds.clear(), this._context.urls = []
    }
    _updateInitialTimestampFromEventBuffer() {
        const {
            session: t,
            eventBuffer: n
        } = this;
        if (!t || !n || t.segmentId) return;
        const r = n.getEarliestTimestamp();
        r && r < this._context.initialTimestamp && (this._context.initialTimestamp = r)
    }
    _popEventContext() {
        const t = {
            initialTimestamp: this._context.initialTimestamp,
            initialUrl: this._context.initialUrl,
            errorIds: Array.from(this._context.errorIds),
            traceIds: Array.from(this._context.traceIds),
            urls: this._context.urls
        };
        return this._clearContext(), t
    }
    async _runFlush() {
        if (!this.session || !this.eventBuffer) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("[Replay] No session or eventBuffer found to flush.");
            return
        }
        if (await this._addPerformanceEntries(), !(!this.eventBuffer || !this.eventBuffer.hasEvents) && (await ene(this), !!this.eventBuffer)) try {
            this._updateInitialTimestampFromEventBuffer();
            const t = await this.eventBuffer.finish(),
                n = this.session.id,
                r = this._popEventContext(),
                s = this.session.segmentId++;
            this._maybeSaveSession(), await nB({
                replayId: n,
                recordingData: t,
                segmentId: s,
                eventContext: r,
                session: this.session,
                options: this.getOptions(),
                timestamp: Date.now()
            })
        } catch (t) {
            this._handleException(t), this.stop("sendReplay");
            const n = Ne().getClient();
            n && n.recordDroppedEvent("send_error", "replay")
        }
    }
    __init16() {
        this._flush = async ({
            force: t = !1
        } = {}) => {
            if (!(!this._isEnabled && !t)) {
                if (!this.checkAndHandleExpiredSession()) {
                    (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("[Replay] Attempting to finish replay event after session expired.");
                    return
                }
                if (!this.session) {
                    (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error("[Replay] No session found to flush.");
                    return
                }
                if (this._debouncedFlush.cancel(), !this._flushLock) {
                    this._flushLock = this._runFlush(), await this._flushLock, this._flushLock = null;
                    return
                }
                try {
                    await this._flushLock
                } catch (n) {
                    (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.error(n)
                } finally {
                    this._debouncedFlush()
                }
            }
        }
    }
    _maybeSaveSession() {
        this.session && this._options.stickySession && m$(this.session)
    }
    __init17() {
        this._onMutationHandler = t => {
            const n = t.length,
                r = this._options._experiments.mutationLimit || 0,
                s = this._options._experiments.mutationBreadcrumbLimit || 1e3,
                i = r && n > r;
            if (n > s || i) {
                const o = za({
                    category: "replay.mutations",
                    data: {
                        count: n
                    }
                });
                this._createCustomBreadcrumb(o)
            }
            return i ? (this._triggerFullSnapshot(!1), !1) : !0
        }
    }
}

function hd(e, t, n, r) {
    const s = typeof r == "string" ? r.split(",") : [],
        i = [...e, ...s, ...t];
    return typeof n != "undefined" && (typeof n == "string" && i.push(`.${n}`), console.warn("[Replay] You are using a deprecated configuration item for privacy. Read the documentation on how to use the new privacy configuration.")), i.join(",")
}

function pne({
    mask: e,
    unmask: t,
    block: n,
    unblock: r,
    ignore: s,
    blockClass: i,
    blockSelector: o,
    maskTextClass: a,
    maskTextSelector: l,
    ignoreClass: c
}) {
    const u = ['base[href="/"]'],
        d = hd(e, [".sentry-mask", "[data-sentry-mask]"], a, l),
        f = hd(t, [".sentry-unmask", "[data-sentry-unmask]"]),
        h = {
            maskTextSelector: d,
            unmaskTextSelector: f,
            maskInputSelector: d,
            unmaskInputSelector: f,
            blockSelector: hd(n, [".sentry-block", "[data-sentry-block]", ...u], i, o),
            unblockSelector: hd(r, [".sentry-unblock", "[data-sentry-unblock]"]),
            ignoreSelector: hd(s, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]'], c)
        };
    return i instanceof RegExp && (h.blockClass = i), a instanceof RegExp && (h.maskTextClass = a), h
}

function vA() {
    return typeof window != "undefined" && (!tU() || mne())
}

function mne() {
    return typeof process != "undefined" && process.type === "renderer"
}
const bA = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]',
    gne = ["content-length", "content-type", "accept"];
let wA = !1;
class _h {
    static __initStatic() {
        this.id = "Replay"
    }
    __init() {
        this.name = _h.id
    }
    constructor({
        flushMinDelay: t = NZ,
        flushMaxDelay: n = PZ,
        stickySession: r = !0,
        useCompression: s = !0,
        _experiments: i = {},
        sessionSampleRate: o,
        errorSampleRate: a,
        maskAllText: l = !0,
        maskAllInputs: c = !0,
        blockAllMedia: u = !0,
        networkDetailAllowUrls: d = [],
        networkCaptureBodies: f = !0,
        networkRequestHeaders: h = [],
        networkResponseHeaders: p = [],
        mask: m = [],
        unmask: g = [],
        block: y = [],
        unblock: _ = [],
        ignore: E = [],
        maskFn: b,
        blockClass: w,
        blockSelector: T,
        maskInputOptions: S,
        maskTextClass: v,
        maskTextSelector: $,
        ignoreClass: k
    } = {}) {
        if (_h.prototype.__init.call(this), this._recordingOptions = G(x({
                maskAllInputs: c,
                maskAllText: l,
                maskInputOptions: G(x({}, S || {}), {
                    password: !0
                }),
                maskTextFn: b,
                maskInputFn: b
            }, pne({
                mask: m,
                unmask: g,
                block: y,
                unblock: _,
                ignore: E,
                blockClass: w,
                blockSelector: T,
                maskTextClass: v,
                maskTextSelector: $,
                ignoreClass: k
            })), {
                slimDOMOptions: "all",
                inlineStylesheet: !0,
                inlineImages: !1,
                collectFonts: !0
            }), this._initialOptions = {
                flushMinDelay: t,
                flushMaxDelay: n,
                stickySession: r,
                sessionSampleRate: o,
                errorSampleRate: a,
                useCompression: s,
                blockAllMedia: u,
                networkDetailAllowUrls: d,
                networkCaptureBodies: f,
                networkRequestHeaders: EA(h),
                networkResponseHeaders: EA(p),
                _experiments: i
            }, typeof o == "number" && (console.warn(`[Replay] You are passing \`sessionSampleRate\` to the Replay integration.
This option is deprecated and will be removed soon.
Instead, configure \`replaysSessionSampleRate\` directly in the SDK init options, e.g.:
Sentry.init({ replaysSessionSampleRate: ${o} })`), this._initialOptions.sessionSampleRate = o), typeof a == "number" && (console.warn(`[Replay] You are passing \`errorSampleRate\` to the Replay integration.
This option is deprecated and will be removed soon.
Instead, configure \`replaysOnErrorSampleRate\` directly in the SDK init options, e.g.:
Sentry.init({ replaysOnErrorSampleRate: ${a} })`), this._initialOptions.errorSampleRate = a), this._initialOptions.blockAllMedia && (this._recordingOptions.blockSelector = this._recordingOptions.blockSelector ? `${this._recordingOptions.blockSelector},${bA}` : bA), this._isInitialized && vA()) throw new Error("Multiple Sentry Session Replay instances are not supported");
        this._isInitialized = !0
    }
    get _isInitialized() {
        return wA
    }
    set _isInitialized(t) {
        wA = t
    }
    setupOnce() {
        !vA() || (this._setup(), setTimeout(() => this._initialize()))
    }
    start() {
        !this._replay || this._replay.start()
    }
    startBuffering() {
        !this._replay || this._replay.startBuffering()
    }
    stop() {
        return this._replay ? this._replay.stop() : Promise.resolve()
    }
    flush(t) {
        return !this._replay || !this._replay.isEnabled() ? Promise.resolve() : this._replay.sendBufferedReplayOrFlush(t)
    }
    getReplayId() {
        if (!(!this._replay || !this._replay.isEnabled())) return this._replay.getSessionId()
    }
    _initialize() {
        !this._replay || this._replay.initializeSampling()
    }
    _setup() {
        const t = _ne(this._initialOptions);
        this._replay = new tn({
            options: t,
            recordingOptions: this._recordingOptions
        })
    }
}
_h.__initStatic();

function _ne(e) {
    const t = Ne().getClient(),
        n = t && t.getOptions(),
        r = x({
            sessionSampleRate: 0,
            errorSampleRate: 0
        }, Rs(e));
    return n ? (e.sessionSampleRate == null && e.errorSampleRate == null && n.replaysSessionSampleRate == null && n.replaysOnErrorSampleRate == null && console.warn("Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set."), typeof n.replaysSessionSampleRate == "number" && (r.sessionSampleRate = n.replaysSessionSampleRate), typeof n.replaysOnErrorSampleRate == "number" && (r.errorSampleRate = n.replaysOnErrorSampleRate), r) : (console.warn("SDK client is not available."), r)
}

function EA(e) {
    return [...gne, ...e.map(t => t.toLowerCase())]
}
const vt = ur;

function yne() {
    vt && vt.document ? vt.document.addEventListener("visibilitychange", () => {
        const e = vp();
        if (vt.document.hidden && e) {
            const t = "cancelled";
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] Transaction: ${t} -> since tab moved to the background, op: ${e.op}`), e.status || e.setStatus(t), e.setTag("visibilitychange", "document.hidden"), e.finish()
        }
    }) : (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("[Tracing] Could not set up background tab detection due to lack of global document")
}
const y$ = (e, t, n) => {
        let r, s;
        return i => {
            t.value >= 0 && (i || n) && (s = t.value - (r || 0), (s || r === void 0) && (r = t.value, t.delta = s, e(t)))
        }
    },
    vne = () => `v3-${Date.now()}-${Math.floor(Math.random()*(9e12-1))+1e12}`,
    bne = () => {
        const e = vt.performance.timing,
            t = vt.performance.navigation.type,
            n = {
                entryType: "navigation",
                startTime: 0,
                type: t == 2 ? "back_forward" : t === 1 ? "reload" : "navigate"
            };
        for (const r in e) r !== "navigationStart" && r !== "toJSON" && (n[r] = Math.max(e[r] - e.navigationStart, 0));
        return n
    },
    rB = () => vt.__WEB_VITALS_POLYFILL__ ? vt.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || bne()) : vt.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0],
    sB = () => {
        const e = rB();
        return e && e.activationStart || 0
    },
    v$ = (e, t) => {
        const n = rB();
        let r = "navigate";
        return n && (vt.document.prerendering || sB() > 0 ? r = "prerender" : r = n.type.replace(/_/g, "-")), {
            name: e,
            value: typeof t == "undefined" ? -1 : t,
            rating: "good",
            delta: 0,
            entries: [],
            id: vne(),
            navigationType: r
        }
    },
    wp = (e, t, n) => {
        try {
            if (PerformanceObserver.supportedEntryTypes.includes(e)) {
                const r = new PerformanceObserver(s => {
                    t(s.getEntries())
                });
                return r.observe(Object.assign({
                    type: e,
                    buffered: !0
                }, n || {})), r
            }
        } catch {}
    },
    jv = (e, t) => {
        const n = r => {
            (r.type === "pagehide" || vt.document.visibilityState === "hidden") && (e(r), t && (removeEventListener("visibilitychange", n, !0), removeEventListener("pagehide", n, !0)))
        };
        addEventListener("visibilitychange", n, !0), addEventListener("pagehide", n, !0)
    },
    wne = e => {
        const t = v$("CLS", 0);
        let n, r = 0,
            s = [];
        const i = a => {
                a.forEach(l => {
                    if (!l.hadRecentInput) {
                        const c = s[0],
                            u = s[s.length - 1];
                        r && s.length !== 0 && l.startTime - u.startTime < 1e3 && l.startTime - c.startTime < 5e3 ? (r += l.value, s.push(l)) : (r = l.value, s = [l]), r > t.value && (t.value = r, t.entries = s, n && n())
                    }
                })
            },
            o = wp("layout-shift", i);
        if (o) {
            n = y$(e, t);
            const a = () => {
                i(o.takeRecords()), n(!0)
            };
            return jv(a), a
        }
    };
let cg = -1;
const Ene = () => vt.document.visibilityState === "hidden" && !vt.document.prerendering ? 0 : 1 / 0,
    Sne = () => {
        jv(({
            timeStamp: e
        }) => {
            cg = e
        }, !0)
    },
    b$ = () => (cg < 0 && (cg = Ene(), Sne()), {
        get firstHiddenTime() {
            return cg
        }
    }),
    Tne = e => {
        const t = b$(),
            n = v$("FID");
        let r;
        const s = a => {
                a.startTime < t.firstHiddenTime && (n.value = a.processingStart - a.startTime, n.entries.push(a), r(!0))
            },
            i = a => {
                a.forEach(s)
            },
            o = wp("first-input", i);
        r = y$(e, n), o && jv(() => {
            i(o.takeRecords()), o.disconnect()
        }, !0)
    },
    SA = {},
    $ne = e => {
        const t = b$(),
            n = v$("LCP");
        let r;
        const s = o => {
                const a = o[o.length - 1];
                if (a) {
                    const l = Math.max(a.startTime - sB(), 0);
                    l < t.firstHiddenTime && (n.value = l, n.entries = [a], r())
                }
            },
            i = wp("largest-contentful-paint", s);
        if (i) {
            r = y$(e, n);
            const o = () => {
                SA[n.id] || (s(i.takeRecords()), i.disconnect(), SA[n.id] = !0, r(!0))
            };
            return ["keydown", "click"].forEach(a => {
                addEventListener(a, o, {
                    once: !0,
                    capture: !0
                })
            }), jv(o, !0), o
        }
    };

function v0(e) {
    return typeof e == "number" && isFinite(e)
}

function yu(e, r) {
    var s = r,
        {
            startTimestamp: t
        } = s,
        n = Gr(s, ["startTimestamp"]);
    return t && e.startTimestamp > t && (e.startTimestamp = t), e.startChild(x({
        startTimestamp: t
    }, n))
}

function nn(e) {
    return e / 1e3
}

function iB() {
    return vt && vt.addEventListener && vt.performance
}
let TA = 0,
    Ft = {},
    Ss, lf;

function kne() {
    const e = iB();
    if (e && Ti) {
        e.mark && vt.performance.mark("sentry-tracing-init"), Rne();
        const t = Cne(),
            n = Ane();
        return () => {
            t && t(), n && n()
        }
    }
    return () => {}
}

function Ine() {
    wp("longtask", t => {
        for (const n of t) {
            const r = vp();
            if (!r) return;
            const s = nn(Ti + n.startTime),
                i = nn(n.duration);
            r.startChild({
                description: "Main UI thread blocked",
                op: "ui.long-task",
                startTimestamp: s,
                endTimestamp: s + i
            })
        }
    })
}

function xne() {
    wp("event", t => {
        for (const n of t) {
            const r = vp();
            if (!r) return;
            if (n.name === "click") {
                const s = nn(Ti + n.startTime),
                    i = nn(n.duration);
                r.startChild({
                    description: cl(n.target),
                    op: `ui.interaction.${n.name}`,
                    startTimestamp: s,
                    endTimestamp: s + i
                })
            }
        }
    }, {
        durationThreshold: 0
    })
}

function Cne() {
    return wne(e => {
        const t = e.entries.pop();
        !t || ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Measurements] Adding CLS"), Ft.cls = {
            value: e.value,
            unit: ""
        }, lf = t)
    })
}

function Ane() {
    return $ne(e => {
        const t = e.entries.pop();
        !t || ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Measurements] Adding LCP"), Ft.lcp = {
            value: e.value,
            unit: "millisecond"
        }, Ss = t)
    })
}

function Rne() {
    Tne(e => {
        const t = e.entries.pop();
        if (!t) return;
        const n = nn(Ti),
            r = nn(t.startTime);
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Measurements] Adding FID"), Ft.fid = {
            value: e.value,
            unit: "millisecond"
        }, Ft["mark.fid"] = {
            value: n + r,
            unit: "second"
        }
    })
}

function One(e) {
    const t = iB();
    if (!t || !vt.performance.getEntries || !Ti) return;
    (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Tracing] Adding & adjusting spans using Performance API");
    const n = nn(Ti),
        r = t.getEntries();
    let s, i;
    if (r.slice(TA).forEach(o => {
            const a = nn(o.startTime),
                l = nn(o.duration);
            if (!(e.op === "navigation" && n + a < e.startTimestamp)) switch (o.entryType) {
                case "navigation":
                    {
                        Nne(e, o, n),
                        s = n + nn(o.responseStart),
                        i = n + nn(o.requestStart);
                        break
                    }
                case "mark":
                case "paint":
                case "measure":
                    {
                        Dne(e, o, a, l, n);
                        const c = b$(),
                            u = o.startTime < c.firstHiddenTime;o.name === "first-paint" && u && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Measurements] Adding FP"), Ft.fp = {
                            value: o.startTime,
                            unit: "millisecond"
                        }),
                        o.name === "first-contentful-paint" && u && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Measurements] Adding FCP"), Ft.fcp = {
                            value: o.startTime,
                            unit: "millisecond"
                        });
                        break
                    }
                case "resource":
                    {
                        const c = o.name.replace(vt.location.origin, "");Mne(e, o, c, a, l, n);
                        break
                    }
            }
        }), TA = Math.max(r.length - 1, 0), Lne(e), e.op === "pageload") {
        typeof s == "number" && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Measurements] Adding TTFB"), Ft.ttfb = {
            value: (s - e.startTimestamp) * 1e3,
            unit: "millisecond"
        }, typeof i == "number" && i <= s && (Ft["ttfb.requestTime"] = {
            value: (s - i) * 1e3,
            unit: "millisecond"
        })), ["fcp", "fp", "lcp"].forEach(a => {
            if (!Ft[a] || n >= e.startTimestamp) return;
            const l = Ft[a].value,
                c = n + nn(l),
                u = Math.abs((c - e.startTimestamp) * 1e3),
                d = u - l;
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Measurements] Normalized ${a} from ${l} to ${u} (${d})`), Ft[a].value = u
        });
        const o = Ft["mark.fid"];
        o && Ft.fid && (yu(e, {
            description: "first input delay",
            endTimestamp: o.value + nn(Ft.fid.value),
            op: "ui.action",
            startTimestamp: o.value
        }), delete Ft["mark.fid"]), "fcp" in Ft || delete Ft.cls, Object.keys(Ft).forEach(a => {
            e.setMeasurement(a, Ft[a].value, Ft[a].unit)
        }), Fne(e)
    }
    Ss = void 0, lf = void 0, Ft = {}
}

function Dne(e, t, n, r, s) {
    const i = s + n,
        o = i + r;
    return yu(e, {
        description: t.name,
        endTimestamp: o,
        op: t.entryType,
        startTimestamp: i
    }), i
}

function Nne(e, t, n) {
    ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(r => {
        vm(e, t, r, n)
    }), vm(e, t, "secureConnection", n, "TLS/SSL", "connectEnd"), vm(e, t, "fetch", n, "cache", "domainLookupStart"), vm(e, t, "domainLookup", n, "DNS"), Pne(e, t, n)
}

function vm(e, t, n, r, s, i) {
    const o = i ? t[i] : t[`${n}End`],
        a = t[`${n}Start`];
    !a || !o || yu(e, {
        op: "browser",
        description: s || n,
        startTimestamp: r + nn(a),
        endTimestamp: r + nn(o)
    })
}

function Pne(e, t, n) {
    yu(e, {
        op: "browser",
        description: "request",
        startTimestamp: n + nn(t.requestStart),
        endTimestamp: n + nn(t.responseEnd)
    }), yu(e, {
        op: "browser",
        description: "response",
        startTimestamp: n + nn(t.responseStart),
        endTimestamp: n + nn(t.responseEnd)
    })
}

function Mne(e, t, n, r, s, i) {
    if (t.initiatorType === "xmlhttprequest" || t.initiatorType === "fetch") return;
    const o = {};
    "transferSize" in t && (o["http.response_transfer_size"] = t.transferSize), "encodedBodySize" in t && (o["http.response_content_length"] = t.encodedBodySize), "decodedBodySize" in t && (o["http.decoded_response_content_length"] = t.decodedBodySize), "renderBlockingStatus" in t && (o["resource.render_blocking_status"] = t.renderBlockingStatus);
    const a = i + r,
        l = a + s;
    yu(e, {
        description: n,
        endTimestamp: l,
        op: t.initiatorType ? `resource.${t.initiatorType}` : "resource.other",
        startTimestamp: a,
        data: o
    })
}

function Lne(e) {
    const t = vt.navigator;
    if (!t) return;
    const n = t.connection;
    n && (n.effectiveType && e.setTag("effectiveConnectionType", n.effectiveType), n.type && e.setTag("connectionType", n.type), v0(n.rtt) && (Ft["connection.rtt"] = {
        value: n.rtt,
        unit: "millisecond"
    })), v0(t.deviceMemory) && e.setTag("deviceMemory", `${t.deviceMemory} GB`), v0(t.hardwareConcurrency) && e.setTag("hardwareConcurrency", String(t.hardwareConcurrency))
}

function Fne(e) {
    Ss && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Measurements] Adding LCP Data"), Ss.element && e.setTag("lcp.element", cl(Ss.element)), Ss.id && e.setTag("lcp.id", Ss.id), Ss.url && e.setTag("lcp.url", Ss.url.trim().slice(0, 200)), e.setTag("lcp.size", Ss.size)), lf && lf.sources && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log("[Measurements] Adding CLS Data"), lf.sources.forEach((t, n) => e.setTag(`cls.source.${n+1}`, cl(t.node))))
}
const LE = ["localhost", /^\//],
    FE = {
        traceFetch: !0,
        traceXHR: !0,
        tracingOrigins: LE,
        tracePropagationTargets: LE
    };

function Une(e) {
    const {
        traceFetch: t,
        traceXHR: n,
        tracePropagationTargets: r,
        tracingOrigins: s,
        shouldCreateSpanForRequest: i
    } = x({
        traceFetch: FE.traceFetch,
        traceXHR: FE.traceXHR
    }, e), o = typeof i == "function" ? i : c => !0, a = c => Bne(c, r || s), l = {};
    t && Rn("fetch", c => {
        Vne(c, o, a, l)
    }), n && Rn("xhr", c => {
        jne(c, o, a, l)
    })
}

function Bne(e, t) {
    return nd(e, t || LE)
}

function Vne(e, t, n, r) {
    if (!Mv() || !(e.fetchData && t(e.fetchData.url))) return;
    if (e.endTimestamp) {
        const l = e.fetchData.__span;
        if (!l) return;
        const c = r[l];
        c && (e.response ? c.setHttpStatus(e.response.status) : e.error && c.setStatus("internal_error"), c.finish(), delete r[l]);
        return
    }
    const s = e.response && e.response.headers && e.response.headers.get("content-length"),
        i = Ne().getScope(),
        o = i && i.getSpan(),
        a = o && o.transaction;
    if (o && a) {
        const {
            method: l,
            url: c
        } = e.fetchData, u = o.startChild({
            data: G(x({
                url: c,
                type: "fetch"
            }, s ? {
                "http.response_content_length": s
            } : {}), {
                "http.method": l
            }),
            description: `${l} ${c}`,
            op: "http.client"
        });
        e.fetchData.__span = u.spanId, r[u.spanId] = u;
        const d = e.args[0];
        e.args[1] = e.args[1] || {};
        const f = e.args[1];
        n(e.fetchData.url) && (f.headers = Hne(d, a.getDynamicSamplingContext(), u, f))
    }
}

function Hne(e, t, n, r) {
    const s = oU(t),
        i = n.toTraceparent(),
        o = typeof Request != "undefined" && zo(e, Request) ? e.headers : r.headers;
    if (o)
        if (typeof Headers != "undefined" && zo(o, Headers)) {
            const a = new Headers(o);
            return a.append("sentry-trace", i), s && a.append(EE, s), a
        } else if (Array.isArray(o)) {
        const a = [...o, ["sentry-trace", i]];
        return s && a.push([EE, s]), a
    } else {
        const a = "baggage" in o ? o.baggage : void 0,
            l = [];
        return Array.isArray(a) ? l.push(...a) : a && l.push(a), s && l.push(s), G(x({}, o), {
            "sentry-trace": i,
            baggage: l.length > 0 ? l.join(",") : void 0
        })
    } else return {
        "sentry-trace": i,
        baggage: s
    }
}

function jne(e, t, n, r) {
    const s = e.xhr,
        i = s && s[yo];
    if (!Mv() || s && s.__sentry_own_request__ || !(s && i && t(i.url))) return;
    if (e.endTimestamp) {
        const c = s.__sentry_xhr_span_id__;
        if (!c) return;
        const u = r[c];
        u && (u.setHttpStatus(i.status_code), u.finish(), delete r[c]);
        return
    }
    const o = Ne().getScope(),
        a = o && o.getSpan(),
        l = a && a.transaction;
    if (a && l) {
        const c = a.startChild({
            data: G(x({}, i.data), {
                type: "xhr",
                "http.method": i.method,
                url: i.url
            }),
            description: `${i.method} ${i.url}`,
            op: "http.client"
        });
        if (s.__sentry_xhr_span_id__ = c.spanId, r[s.__sentry_xhr_span_id__] = c, s.setRequestHeader && n(i.url)) try {
            s.setRequestHeader("sentry-trace", c.toTraceparent());
            const u = l.getDynamicSamplingContext(),
                d = oU(u);
            d && s.setRequestHeader(EE, d)
        } catch {}
    }
}

function zne(e, t = !0, n = !0) {
    if (!vt || !vt.location) {
        (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn("Could not initialize routing instrumentation due to invalid location");
        return
    }
    let r = vt.location.href,
        s;
    t && (s = e({
        name: vt.location.pathname,
        startTimestamp: Ti ? Ti / 1e3 : void 0,
        op: "pageload",
        metadata: {
            source: "url"
        }
    })), n && Rn("history", ({
        to: i,
        from: o
    }) => {
        if (o === void 0 && r && r.indexOf(i) !== -1) {
            r = void 0;
            return
        }
        o !== i && (r = void 0, s && ((typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] Finishing current transaction with op: ${s.op}`), s.finish()), s = e({
            name: vt.location.pathname,
            op: "navigation",
            metadata: {
                source: "url"
            }
        }))
    })
}
const Wne = "BrowserTracing",
    Gne = x(G(x({}, og), {
        markBackgroundTransactions: !0,
        routingInstrumentation: zne,
        startTransactionOnLocationChange: !0,
        startTransactionOnPageLoad: !0,
        enableLongTask: !0,
        _experiments: {}
    }), FE);
class w$ {
    __init() {
        this.name = Wne
    }
    constructor(t) {
        w$.prototype.__init.call(this), KQ(), this.options = x(x({}, Gne), t), this.options._experiments.enableLongTask !== void 0 && (this.options.enableLongTask = this.options._experiments.enableLongTask), t && !t.tracePropagationTargets && t.tracingOrigins && (this.options.tracePropagationTargets = t.tracingOrigins), this._collectWebVitals = kne(), this.options.enableLongTask && Ine(), this.options._experiments.enableInteractions && xne()
    }
    setupOnce(t, n) {
        this._getCurrentHub = n;
        const {
            routingInstrumentation: r,
            startTransactionOnLocationChange: s,
            startTransactionOnPageLoad: i,
            markBackgroundTransactions: o,
            traceFetch: a,
            traceXHR: l,
            tracePropagationTargets: c,
            shouldCreateSpanForRequest: u,
            _experiments: d
        } = this.options;
        r(f => {
            const h = this._createRouteTransaction(f);
            return this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(h, f, n), h
        }, i, s), o && yne(), d.enableInteractions && this._registerInteractionListener(), Une({
            traceFetch: a,
            traceXHR: l,
            tracePropagationTargets: c,
            shouldCreateSpanForRequest: u
        })
    }
    _createRouteTransaction(t) {
        if (!this._getCurrentHub) {
            (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`[Tracing] Did not create ${t.op} transaction because _getCurrentHub is invalid.`);
            return
        }
        const {
            beforeNavigate: n,
            idleTimeout: r,
            finalTimeout: s,
            heartbeatInterval: i
        } = this.options, o = t.op === "pageload", a = o ? $A("sentry-trace") : null, l = o ? $A("baggage") : null, c = a ? vQ(a) : void 0, u = l ? DQ(l) : void 0, d = G(x(x({}, t), c), {
            metadata: G(x({}, t.metadata), {
                dynamicSamplingContext: c && !u ? {} : u
            }),
            trimEnd: !0
        }), f = typeof n == "function" ? n(d) : d, h = f === void 0 ? G(x({}, d), {
            sampled: !1
        }) : f;
        h.metadata = h.name !== d.name ? G(x({}, h.metadata), {
            source: "custom"
        }) : h.metadata, this._latestRouteName = h.name, this._latestRouteSource = h.metadata && h.metadata.source, h.sampled === !1 && (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] Will not send ${h.op} transaction because of beforeNavigate.`), (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.log(`[Tracing] Starting ${h.op} transaction on scope`);
        const p = this._getCurrentHub(),
            {
                location: m
            } = vt,
            g = GC(p, h, r, s, !0, {
                location: m
            }, i);
        return g.registerBeforeFinishCallback(y => {
            this._collectWebVitals(), One(y)
        }), g
    }
    _registerInteractionListener() {
        let t;
        const n = () => {
            const {
                idleTimeout: r,
                finalTimeout: s,
                heartbeatInterval: i
            } = this.options, o = "ui.action.click", a = vp();
            if (a && a.op && ["navigation", "pageload"].includes(a.op)) {
                (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`[Tracing] Did not create ${o} transaction because a pageload or navigation transaction is in progress.`);
                return
            }
            if (t && (t.setFinishReason("interactionInterrupted"), t.finish(), t = void 0), !this._getCurrentHub) {
                (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`[Tracing] Did not create ${o} transaction because _getCurrentHub is invalid.`);
                return
            }
            if (!this._latestRouteName) {
                (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`[Tracing] Did not create ${o} transaction because _latestRouteName is missing.`);
                return
            }
            const l = this._getCurrentHub(),
                {
                    location: c
                } = vt,
                u = {
                    name: this._latestRouteName,
                    op: o,
                    trimEnd: !0,
                    metadata: {
                        source: this._latestRouteSource || "url"
                    }
                };
            t = GC(l, u, r, s, !0, {
                location: c
            }, i)
        };
        ["click"].forEach(r => {
            addEventListener(r, n, {
                once: !1,
                capture: !0
            })
        })
    }
}

function $A(e) {
    const t = DX(`meta[name=${e}]`);
    return t ? t.getAttribute("content") : null
}
const oB = ["activate", "mount", "update"],
    qne = /(?:^|[-_])(\w)/g,
    Yne = e => e.replace(qne, t => t.toUpperCase()).replace(/[-_]/g, ""),
    Kne = "<Root>",
    b0 = "<Anonymous>",
    Xne = (e, t) => e.repeat ? e.repeat(t) : e,
    cf = (e, t) => {
        if (!e) return b0;
        if (e.$root === e) return Kne;
        if (!e.$options) return b0;
        const n = e.$options;
        let r = n.name || n._componentTag;
        const s = n.__file;
        if (!r && s) {
            const i = s.match(/([^/\\]+)\.vue$/);
            i && (r = i[1])
        }
        return (r ? `<${Yne(r)}>` : b0) + (s && t !== !1 ? ` at ${s}` : "")
    },
    Qne = e => {
        if (e && (e._isVue || e.__isVue) && e.$parent) {
            const t = [];
            let n = 0;
            for (; e;) {
                if (t.length > 0) {
                    const s = t[t.length - 1];
                    if (s.constructor === e.constructor) {
                        n++, e = e.$parent;
                        continue
                    } else n > 0 && (t[t.length - 1] = [s, n], n = 0)
                }
                t.push(e), e = e.$parent
            }
            return `

found in

${t.map((s,i)=>`${(i===0?"---> ":Xne(" ",5+i*2))+(Array.isArray(s)?`${cf(s[0])}... (${s[1]} recursive calls)`:cf(s))}`).join(`
`)}`
        }
        return `

(found in ${cf(e)})`
    },
    Jne = (e, t) => {
        const {
            errorHandler: n,
            warnHandler: r,
            silent: s
        } = e.config;
        e.config.errorHandler = (i, o, a) => {
            const l = cf(o, !1),
                c = o ? Qne(o) : "",
                u = {
                    componentName: l,
                    lifecycleHook: a,
                    trace: c
                };
            if (t.attachProps && o && (o.$options && o.$options.propsData ? u.propsData = o.$options.propsData : o.$props && (u.propsData = o.$props)), setTimeout(() => {
                    Ne().withScope(d => {
                        d.setContext("vue", u), Ne().captureException(i)
                    })
                }), typeof n == "function" && n.call(e, i, o, a), t.logErrors) {
                const d = typeof console != "undefined",
                    f = `Error in ${a}: "${i&&i.toString()}"`;
                r ? r.call(null, f, o, c) : d && !s && console.error(`[Vue warn]: ${f}${c}`)
            }
        }
    },
    kA = "ui.vue",
    Zne = {
        activate: ["activated", "deactivated"],
        create: ["beforeCreate", "created"],
        destroy: ["beforeDestroy", "destroyed"],
        mount: ["beforeMount", "mounted"],
        update: ["beforeUpdate", "updated"]
    };

function UE() {
    const e = Ne().getScope();
    return e && e.getTransaction()
}

function ere(e, t, n) {
    e.$_sentryRootSpanTimer && clearTimeout(e.$_sentryRootSpanTimer), e.$_sentryRootSpanTimer = setTimeout(() => {
        e.$root && e.$root.$_sentryRootSpan && (e.$root.$_sentryRootSpan.finish(t), e.$root.$_sentryRootSpan = void 0)
    }, n)
}
const tre = e => {
        const t = (e.hooks || []).concat(oB).filter((r, s, i) => i.indexOf(r) === s),
            n = {};
        for (const r of t) {
            const s = Zne[r];
            if (!s) {
                (typeof __SENTRY_DEBUG__ == "undefined" || __SENTRY_DEBUG__) && M.warn(`Unknown hook: ${r}`);
                continue
            }
            for (const i of s) n[i] = function() {
                const o = this.$root === this;
                if (o) {
                    const c = UE();
                    c && (this.$_sentryRootSpan = this.$_sentryRootSpan || c.startChild({
                        description: "Application Render",
                        op: `${kA}.render`
                    }))
                }
                const a = cf(this, !1),
                    l = Array.isArray(e.trackComponents) ? e.trackComponents.indexOf(a) > -1 : e.trackComponents;
                if (!(!o && !l))
                    if (this.$_sentrySpans = this.$_sentrySpans || {}, i == s[0]) {
                        const c = this.$root && this.$root.$_sentryRootSpan || UE();
                        if (c) {
                            const u = this.$_sentrySpans[r];
                            u && !u.endTimestamp && u.finish(), this.$_sentrySpans[r] = c.startChild({
                                description: `Vue <${a}>`,
                                op: `${kA}.${r}`
                            })
                        }
                    } else {
                        const c = this.$_sentrySpans[r];
                        if (!c) return;
                        c.finish(), ere(this, Go(), e.timeout)
                    }
            }
        }
        return n
    },
    nre = ur,
    rre = {
        Vue: nre.Vue,
        attachProps: !0,
        logErrors: !0,
        hooks: oB,
        timeout: 2e3,
        trackComponents: !1,
        _metadata: {
            sdk: {
                name: "sentry.javascript.vue",
                packages: [{
                    name: "npm:@sentry/vue",
                    version: b_
                }],
                version: b_
            }
        }
    };

function sre(e = {}) {
    const t = x(x({}, rre), e);
    if (xZ(t), !t.Vue && !t.app) {
        console.warn("[@sentry/vue]: Misconfigured SDK. Vue specific errors will not be captured.\nUpdate your `Sentry.init` call with an appropriate config option:\n`app` (Application Instance - Vue 3) or `Vue` (Vue Constructor - Vue 2).");
        return
    }
    t.app ? i$(t.app).forEach(r => IA(r, t)) : t.Vue && IA(t.Vue, t)
}
const IA = (e, t) => {
    const n = e;
    (n._instance && n._instance.isMounted) === !0 && console.warn("[@sentry/vue]: Misconfigured SDK. Vue app is already mounted. Make sure to call `app.mount()` after `Sentry.init()`."), Jne(e, t), Mv(t) && e.mixin(tre(x(x({}, t), t.tracingOptions)))
};

function ire(e, t = {}) {
    return (n, r = !0, s = !0) => {
        const i = {
            "routing.instrumentation": "vue-router"
        };
        r && ft && ft.location && n({
            name: ft.location.pathname,
            op: "pageload",
            tags: i,
            metadata: {
                source: "url"
            }
        }), e.onError(o => dl(o)), e.beforeEach((o, a, l) => {
            const c = a.name == null && a.matched.length === 0,
                u = {
                    params: o.params,
                    query: o.query
                };
            let d = o.path,
                f = "url";
            if (o.name && t.routeLabel !== "path" ? (d = o.name.toString(), f = "custom") : o.matched[0] && o.matched[0].path && (d = o.matched[0].path, f = "route"), r && c) {
                const h = UE();
                h && (h.metadata.source !== "custom" && h.setName(d, f), h.setData("params", u.params), h.setData("query", u.query))
            }
            s && !c && n({
                name: d,
                op: "navigation",
                tags: i,
                data: u,
                metadata: {
                    source: f
                }
            }), l()
        })
    }
}

function E$(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]]);
    return n
}

function aB() {
    return {
        ["dependent-sdk-initialized-before-auth"]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
    }
}
const ore = aB,
    lB = new sa("auth", "Firebase", aB());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const C_ = new zu("@firebase/auth");

function are(e, ...t) {
    C_.logLevel <= Xe.WARN && C_.warn(`Auth (${ia}): ${e}`, ...t)
}

function ug(e, ...t) {
    C_.logLevel <= Xe.ERROR && C_.error(`Auth (${ia}): ${e}`, ...t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Qr(e, ...t) {
    throw S$(e, ...t)
}

function Os(e, ...t) {
    return S$(e, ...t)
}

function cB(e, t, n) {
    const r = Object.assign(Object.assign({}, ore()), {
        [t]: n
    });
    return new sa("auth", "Firebase", r).create(t, {
        appName: e.name
    })
}

function lre(e, t, n) {
    const r = n;
    if (!(t instanceof r)) throw r.name !== t.constructor.name && Qr(e, "argument-error"), cB(e, "argument-error", `Type of ${t.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`)
}

function S$(e, ...t) {
    if (typeof e != "string") {
        const n = t[0],
            r = [...t.slice(1)];
        return r[0] && (r[0].appName = e.name), e._errorFactory.create(n, ...r)
    }
    return lB.create(e, ...t)
}

function be(e, t, ...n) {
    if (!e) throw S$(t, ...n)
}

function ai(e) {
    const t = "INTERNAL ASSERTION FAILED: " + e;
    throw ug(t), new Error(t)
}

function ki(e, t) {
    e || ai(t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function BE() {
    var e;
    return typeof self != "undefined" && ((e = self.location) === null || e === void 0 ? void 0 : e.href) || ""
}

function cre() {
    return xA() === "http:" || xA() === "https:"
}

function xA() {
    var e;
    return typeof self != "undefined" && ((e = self.location) === null || e === void 0 ? void 0 : e.protocol) || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ure() {
    return typeof navigator != "undefined" && navigator && "onLine" in navigator && typeof navigator.onLine == "boolean" && (cre() || cP() || "connection" in navigator) ? navigator.onLine : !0
}

function dre() {
    if (typeof navigator == "undefined") return null;
    const e = navigator;
    return e.languages && e.languages[0] || e.language || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ep {
    constructor(t, n) {
        this.shortDelay = t, this.longDelay = n, ki(n > t, "Short delay should be less than long delay!"), this.isMobile = dS() || uP()
    }
    get() {
        return ure() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function T$(e, t) {
    ki(e.emulator, "Emulator should always be set here");
    const {
        url: n
    } = e.emulator;
    return t ? `${n}${t.startsWith("/")?t.slice(1):t}` : n
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uB {
    static initialize(t, n, r) {
        this.fetchImpl = t, n && (this.headersImpl = n), r && (this.responseImpl = r)
    }
    static fetch() {
        if (this.fetchImpl) return this.fetchImpl;
        if (typeof self != "undefined" && "fetch" in self) return self.fetch;
        ai("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static headers() {
        if (this.headersImpl) return this.headersImpl;
        if (typeof self != "undefined" && "Headers" in self) return self.Headers;
        ai("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static response() {
        if (this.responseImpl) return this.responseImpl;
        if (typeof self != "undefined" && "Response" in self) return self.Response;
        ai("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fre = {
    CREDENTIAL_MISMATCH: "custom-token-mismatch",
    MISSING_CUSTOM_TOKEN: "internal-error",
    INVALID_IDENTIFIER: "invalid-email",
    MISSING_CONTINUE_URI: "internal-error",
    INVALID_PASSWORD: "wrong-password",
    MISSING_PASSWORD: "missing-password",
    EMAIL_EXISTS: "email-already-in-use",
    PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
    INVALID_IDP_RESPONSE: "invalid-credential",
    INVALID_PENDING_TOKEN: "invalid-credential",
    FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
    MISSING_REQ_TYPE: "internal-error",
    EMAIL_NOT_FOUND: "user-not-found",
    RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
    EXPIRED_OOB_CODE: "expired-action-code",
    INVALID_OOB_CODE: "invalid-action-code",
    MISSING_OOB_CODE: "internal-error",
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
    INVALID_ID_TOKEN: "invalid-user-token",
    TOKEN_EXPIRED: "user-token-expired",
    USER_NOT_FOUND: "user-token-expired",
    TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
    INVALID_CODE: "invalid-verification-code",
    INVALID_SESSION_INFO: "invalid-verification-id",
    INVALID_TEMPORARY_PROOF: "invalid-credential",
    MISSING_SESSION_INFO: "missing-verification-id",
    SESSION_EXPIRED: "code-expired",
    MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
    UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
    INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
    ADMIN_ONLY_OPERATION: "admin-restricted-operation",
    INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
    MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
    MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
    MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
    SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
    SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
    BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
    RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
    MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
    INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
    INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
    MISSING_CLIENT_TYPE: "missing-client-type",
    MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
    INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
    INVALID_REQ_TYPE: "invalid-req-type"
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hre = new Ep(3e4, 6e4);

function Ol(e, t) {
    return e.tenantId && !t.tenantId ? Object.assign(Object.assign({}, t), {
        tenantId: e.tenantId
    }) : t
}
async function ua(e, t, n, r, s = {}) {
    return dB(e, s, async () => {
        let i = {},
            o = {};
        r && (t === "GET" ? o = r : i = {
            body: JSON.stringify(r)
        });
        const a = ju(Object.assign({
                key: e.config.apiKey
            }, o)).slice(1),
            l = await e._getAdditionalHeaders();
        return l["Content-Type"] = "application/json", e.languageCode && (l["X-Firebase-Locale"] = e.languageCode), uB.fetch()(fB(e, e.config.apiHost, n, a), Object.assign({
            method: t,
            headers: l,
            referrerPolicy: "no-referrer"
        }, i))
    })
}
async function dB(e, t, n) {
    e._canInitEmulator = !1;
    const r = Object.assign(Object.assign({}, fre), t);
    try {
        const s = new pre(e),
            i = await Promise.race([n(), s.promise]);
        s.clearNetworkTimeout();
        const o = await i.json();
        if ("needConfirmation" in o) throw bm(e, "account-exists-with-different-credential", o);
        if (i.ok && !("errorMessage" in o)) return o; {
            const a = i.ok ? o.errorMessage : o.error.message,
                [l, c] = a.split(" : ");
            if (l === "FEDERATED_USER_ID_ALREADY_LINKED") throw bm(e, "credential-already-in-use", o);
            if (l === "EMAIL_EXISTS") throw bm(e, "email-already-in-use", o);
            if (l === "USER_DISABLED") throw bm(e, "user-disabled", o);
            const u = r[l] || l.toLowerCase().replace(/[_\s]+/g, "-");
            if (c) throw cB(e, u, c);
            Qr(e, u)
        }
    } catch (s) {
        if (s instanceof zr) throw s;
        Qr(e, "network-request-failed", {
            message: String(s)
        })
    }
}
async function Sp(e, t, n, r, s = {}) {
    const i = await ua(e, t, n, r, s);
    return "mfaPendingCredential" in i && Qr(e, "multi-factor-auth-required", {
        _serverResponse: i
    }), i
}

function fB(e, t, n, r) {
    const s = `${t}${n}?${r}`;
    return e.config.emulator ? T$(e.config, s) : `${e.config.apiScheme}://${s}`
}
class pre {
    constructor(t) {
        this.auth = t, this.timer = null, this.promise = new Promise((n, r) => {
            this.timer = setTimeout(() => r(Os(this.auth, "network-request-failed")), hre.get())
        })
    }
    clearNetworkTimeout() {
        clearTimeout(this.timer)
    }
}

function bm(e, t, n) {
    const r = {
        appName: e.name
    };
    n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber);
    const s = Os(e, t, r);
    return s.customData._tokenResponse = n, s
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function mre(e, t) {
    return ua(e, "POST", "/v1/accounts:delete", t)
}
async function gre(e, t) {
    return ua(e, "POST", "/v1/accounts:lookup", t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function uf(e) {
    if (!!e) try {
        const t = new Date(Number(e));
        if (!isNaN(t.getTime())) return t.toUTCString()
    } catch {}
}
async function _re(e, t = !1) {
    const n = st(e),
        r = await n.getIdToken(t),
        s = $$(r);
    be(s && s.exp && s.auth_time && s.iat, n.auth, "internal-error");
    const i = typeof s.firebase == "object" ? s.firebase : void 0,
        o = i == null ? void 0 : i.sign_in_provider;
    return {
        claims: s,
        token: r,
        authTime: uf(w0(s.auth_time)),
        issuedAtTime: uf(w0(s.iat)),
        expirationTime: uf(w0(s.exp)),
        signInProvider: o || null,
        signInSecondFactor: (i == null ? void 0 : i.sign_in_second_factor) || null
    }
}

function w0(e) {
    return Number(e) * 1e3
}

function $$(e) {
    const [t, n, r] = e.split(".");
    if (t === void 0 || n === void 0 || r === void 0) return ug("JWT malformed, contained fewer than 3 sections"), null;
    try {
        const s = Lg(n);
        return s ? JSON.parse(s) : (ug("Failed to decode base64 JWT payload"), null)
    } catch (s) {
        return ug("Caught error parsing JWT payload as JSON", s == null ? void 0 : s.toString()), null
    }
}

function yre(e) {
    const t = $$(e);
    return be(t, "internal-error"), be(typeof t.exp != "undefined", "internal-error"), be(typeof t.iat != "undefined", "internal-error"), Number(t.exp) - Number(t.iat)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function vu(e, t, n = !1) {
    if (n) return t;
    try {
        return await t
    } catch (r) {
        throw r instanceof zr && vre(r) && e.auth.currentUser === e && await e.auth.signOut(), r
    }
}

function vre({
    code: e
}) {
    return e === "auth/user-disabled" || e === "auth/user-token-expired"
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bre {
    constructor(t) {
        this.user = t, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4
    }
    _start() {
        this.isRunning || (this.isRunning = !0, this.schedule())
    }
    _stop() {
        !this.isRunning || (this.isRunning = !1, this.timerId !== null && clearTimeout(this.timerId))
    }
    getInterval(t) {
        var n;
        if (t) {
            const r = this.errorBackoff;
            return this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4), r
        } else {
            this.errorBackoff = 3e4;
            const s = ((n = this.user.stsTokenManager.expirationTime) !== null && n !== void 0 ? n : 0) - Date.now() - 3e5;
            return Math.max(0, s)
        }
    }
    schedule(t = !1) {
        if (!this.isRunning) return;
        const n = this.getInterval(t);
        this.timerId = setTimeout(async () => {
            await this.iteration()
        }, n)
    }
    async iteration() {
        try {
            await this.user.getIdToken(!0)
        } catch (t) {
            (t == null ? void 0 : t.code) === "auth/network-request-failed" && this.schedule(!0);
            return
        }
        this.schedule()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hB {
    constructor(t, n) {
        this.createdAt = t, this.lastLoginAt = n, this._initializeTime()
    }
    _initializeTime() {
        this.lastSignInTime = uf(this.lastLoginAt), this.creationTime = uf(this.createdAt)
    }
    _copy(t) {
        this.createdAt = t.createdAt, this.lastLoginAt = t.lastLoginAt, this._initializeTime()
    }
    toJSON() {
        return {
            createdAt: this.createdAt,
            lastLoginAt: this.lastLoginAt
        }
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function A_(e) {
    var t;
    const n = e.auth,
        r = await e.getIdToken(),
        s = await vu(e, gre(n, {
            idToken: r
        }));
    be(s == null ? void 0 : s.users.length, n, "internal-error");
    const i = s.users[0];
    e._notifyReloadListener(i);
    const o = !((t = i.providerUserInfo) === null || t === void 0) && t.length ? Sre(i.providerUserInfo) : [],
        a = Ere(e.providerData, o),
        l = e.isAnonymous,
        c = !(e.email && i.passwordHash) && !(a != null && a.length),
        u = l ? c : !1,
        d = {
            uid: i.localId,
            displayName: i.displayName || null,
            photoURL: i.photoUrl || null,
            email: i.email || null,
            emailVerified: i.emailVerified || !1,
            phoneNumber: i.phoneNumber || null,
            tenantId: i.tenantId || null,
            providerData: a,
            metadata: new hB(i.createdAt, i.lastLoginAt),
            isAnonymous: u
        };
    Object.assign(e, d)
}
async function wre(e) {
    const t = st(e);
    await A_(t), await t.auth._persistUserIfCurrent(t), t.auth._notifyListenersIfCurrent(t)
}

function Ere(e, t) {
    return [...e.filter(r => !t.some(s => s.providerId === r.providerId)), ...t]
}

function Sre(e) {
    return e.map(t => {
        var {
            providerId: n
        } = t, r = E$(t, ["providerId"]);
        return {
            providerId: n,
            uid: r.rawId || "",
            displayName: r.displayName || null,
            email: r.email || null,
            phoneNumber: r.phoneNumber || null,
            photoURL: r.photoUrl || null
        }
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Tre(e, t) {
    const n = await dB(e, {}, async () => {
        const r = ju({
                grant_type: "refresh_token",
                refresh_token: t
            }).slice(1),
            {
                tokenApiHost: s,
                apiKey: i
            } = e.config,
            o = fB(e, s, "/v1/token", `key=${i}`),
            a = await e._getAdditionalHeaders();
        return a["Content-Type"] = "application/x-www-form-urlencoded", uB.fetch()(o, {
            method: "POST",
            headers: a,
            body: r
        })
    });
    return {
        accessToken: n.access_token,
        expiresIn: n.expires_in,
        refreshToken: n.refresh_token
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yh {
    constructor() {
        this.refreshToken = null, this.accessToken = null, this.expirationTime = null
    }
    get isExpired() {
        return !this.expirationTime || Date.now() > this.expirationTime - 3e4
    }
    updateFromServerResponse(t) {
        be(t.idToken, "internal-error"), be(typeof t.idToken != "undefined", "internal-error"), be(typeof t.refreshToken != "undefined", "internal-error");
        const n = "expiresIn" in t && typeof t.expiresIn != "undefined" ? Number(t.expiresIn) : yre(t.idToken);
        this.updateTokensAndExpiration(t.idToken, t.refreshToken, n)
    }
    async getToken(t, n = !1) {
        return be(!this.accessToken || this.refreshToken, t, "user-token-expired"), !n && this.accessToken && !this.isExpired ? this.accessToken : this.refreshToken ? (await this.refresh(t, this.refreshToken), this.accessToken) : null
    }
    clearRefreshToken() {
        this.refreshToken = null
    }
    async refresh(t, n) {
        const {
            accessToken: r,
            refreshToken: s,
            expiresIn: i
        } = await Tre(t, n);
        this.updateTokensAndExpiration(r, s, Number(i))
    }
    updateTokensAndExpiration(t, n, r) {
        this.refreshToken = n || null, this.accessToken = t || null, this.expirationTime = Date.now() + r * 1e3
    }
    static fromJSON(t, n) {
        const {
            refreshToken: r,
            accessToken: s,
            expirationTime: i
        } = n, o = new yh;
        return r && (be(typeof r == "string", "internal-error", {
            appName: t
        }), o.refreshToken = r), s && (be(typeof s == "string", "internal-error", {
            appName: t
        }), o.accessToken = s), i && (be(typeof i == "number", "internal-error", {
            appName: t
        }), o.expirationTime = i), o
    }
    toJSON() {
        return {
            refreshToken: this.refreshToken,
            accessToken: this.accessToken,
            expirationTime: this.expirationTime
        }
    }
    _assign(t) {
        this.accessToken = t.accessToken, this.refreshToken = t.refreshToken, this.expirationTime = t.expirationTime
    }
    _clone() {
        return Object.assign(new yh, this.toJSON())
    }
    _performRefresh() {
        return ai("not implemented")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Qi(e, t) {
    be(typeof e == "string" || typeof e == "undefined", "internal-error", {
        appName: t
    })
}
class Wa {
    constructor(t) {
        var {
            uid: n,
            auth: r,
            stsTokenManager: s
        } = t, i = E$(t, ["uid", "auth", "stsTokenManager"]);
        this.providerId = "firebase", this.proactiveRefresh = new bre(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = n, this.auth = r, this.stsTokenManager = s, this.accessToken = s.accessToken, this.displayName = i.displayName || null, this.email = i.email || null, this.emailVerified = i.emailVerified || !1, this.phoneNumber = i.phoneNumber || null, this.photoURL = i.photoURL || null, this.isAnonymous = i.isAnonymous || !1, this.tenantId = i.tenantId || null, this.providerData = i.providerData ? [...i.providerData] : [], this.metadata = new hB(i.createdAt || void 0, i.lastLoginAt || void 0)
    }
    async getIdToken(t) {
        const n = await vu(this, this.stsTokenManager.getToken(this.auth, t));
        return be(n, this.auth, "internal-error"), this.accessToken !== n && (this.accessToken = n, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), n
    }
    getIdTokenResult(t) {
        return _re(this, t)
    }
    reload() {
        return wre(this)
    }
    _assign(t) {
        this !== t && (be(this.uid === t.uid, this.auth, "internal-error"), this.displayName = t.displayName, this.photoURL = t.photoURL, this.email = t.email, this.emailVerified = t.emailVerified, this.phoneNumber = t.phoneNumber, this.isAnonymous = t.isAnonymous, this.tenantId = t.tenantId, this.providerData = t.providerData.map(n => Object.assign({}, n)), this.metadata._copy(t.metadata), this.stsTokenManager._assign(t.stsTokenManager))
    }
    _clone(t) {
        const n = new Wa(Object.assign(Object.assign({}, this), {
            auth: t,
            stsTokenManager: this.stsTokenManager._clone()
        }));
        return n.metadata._copy(this.metadata), n
    }
    _onReload(t) {
        be(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = t, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null)
    }
    _notifyReloadListener(t) {
        this.reloadListener ? this.reloadListener(t) : this.reloadUserInfo = t
    }
    _startProactiveRefresh() {
        this.proactiveRefresh._start()
    }
    _stopProactiveRefresh() {
        this.proactiveRefresh._stop()
    }
    async _updateTokensIfNecessary(t, n = !1) {
        let r = !1;
        t.idToken && t.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(t), r = !0), n && await A_(this), await this.auth._persistUserIfCurrent(this), r && this.auth._notifyListenersIfCurrent(this)
    }
    async delete() {
        const t = await this.getIdToken();
        return await vu(this, mre(this.auth, {
            idToken: t
        })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut()
    }
    toJSON() {
        return Object.assign(Object.assign({
            uid: this.uid,
            email: this.email || void 0,
            emailVerified: this.emailVerified,
            displayName: this.displayName || void 0,
            isAnonymous: this.isAnonymous,
            photoURL: this.photoURL || void 0,
            phoneNumber: this.phoneNumber || void 0,
            tenantId: this.tenantId || void 0,
            providerData: this.providerData.map(t => Object.assign({}, t)),
            stsTokenManager: this.stsTokenManager.toJSON(),
            _redirectEventId: this._redirectEventId
        }, this.metadata.toJSON()), {
            apiKey: this.auth.config.apiKey,
            appName: this.auth.name
        })
    }
    get refreshToken() {
        return this.stsTokenManager.refreshToken || ""
    }
    static _fromJSON(t, n) {
        var r, s, i, o, a, l, c, u;
        const d = (r = n.displayName) !== null && r !== void 0 ? r : void 0,
            f = (s = n.email) !== null && s !== void 0 ? s : void 0,
            h = (i = n.phoneNumber) !== null && i !== void 0 ? i : void 0,
            p = (o = n.photoURL) !== null && o !== void 0 ? o : void 0,
            m = (a = n.tenantId) !== null && a !== void 0 ? a : void 0,
            g = (l = n._redirectEventId) !== null && l !== void 0 ? l : void 0,
            y = (c = n.createdAt) !== null && c !== void 0 ? c : void 0,
            _ = (u = n.lastLoginAt) !== null && u !== void 0 ? u : void 0,
            {
                uid: E,
                emailVerified: b,
                isAnonymous: w,
                providerData: T,
                stsTokenManager: S
            } = n;
        be(E && S, t, "internal-error");
        const v = yh.fromJSON(this.name, S);
        be(typeof E == "string", t, "internal-error"), Qi(d, t.name), Qi(f, t.name), be(typeof b == "boolean", t, "internal-error"), be(typeof w == "boolean", t, "internal-error"), Qi(h, t.name), Qi(p, t.name), Qi(m, t.name), Qi(g, t.name), Qi(y, t.name), Qi(_, t.name);
        const $ = new Wa({
            uid: E,
            auth: t,
            email: f,
            emailVerified: b,
            displayName: d,
            isAnonymous: w,
            photoURL: p,
            phoneNumber: h,
            tenantId: m,
            stsTokenManager: v,
            createdAt: y,
            lastLoginAt: _
        });
        return T && Array.isArray(T) && ($.providerData = T.map(k => Object.assign({}, k))), g && ($._redirectEventId = g), $
    }
    static async _fromIdTokenResponse(t, n, r = !1) {
        const s = new yh;
        s.updateFromServerResponse(n);
        const i = new Wa({
            uid: n.localId,
            auth: t,
            stsTokenManager: s,
            isAnonymous: r
        });
        return await A_(i), i
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CA = new Map;

function li(e) {
    ki(e instanceof Function, "Expected a class definition");
    let t = CA.get(e);
    return t ? (ki(t instanceof e, "Instance stored in cache mismatched with class"), t) : (t = new e, CA.set(e, t), t)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pB {
    constructor() {
        this.type = "NONE", this.storage = {}
    }
    async _isAvailable() {
        return !0
    }
    async _set(t, n) {
        this.storage[t] = n
    }
    async _get(t) {
        const n = this.storage[t];
        return n === void 0 ? null : n
    }
    async _remove(t) {
        delete this.storage[t]
    }
    _addListener(t, n) {}
    _removeListener(t, n) {}
}
pB.type = "NONE";
const AA = pB;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function dg(e, t, n) {
    return `firebase:${e}:${t}:${n}`
}
class Mc {
    constructor(t, n, r) {
        this.persistence = t, this.auth = n, this.userKey = r;
        const {
            config: s,
            name: i
        } = this.auth;
        this.fullUserKey = dg(this.userKey, s.apiKey, i), this.fullPersistenceKey = dg("persistence", s.apiKey, i), this.boundEventHandler = n._onStorageEvent.bind(n), this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
    }
    setCurrentUser(t) {
        return this.persistence._set(this.fullUserKey, t.toJSON())
    }
    async getCurrentUser() {
        const t = await this.persistence._get(this.fullUserKey);
        return t ? Wa._fromJSON(this.auth, t) : null
    }
    removeCurrentUser() {
        return this.persistence._remove(this.fullUserKey)
    }
    savePersistenceForRedirect() {
        return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
    }
    async setPersistence(t) {
        if (this.persistence === t) return;
        const n = await this.getCurrentUser();
        if (await this.removeCurrentUser(), this.persistence = t, n) return this.setCurrentUser(n)
    }
    delete() {
        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
    }
    static async create(t, n, r = "authUser") {
        if (!n.length) return new Mc(li(AA), t, r);
        const s = (await Promise.all(n.map(async c => {
            if (await c._isAvailable()) return c
        }))).filter(c => c);
        let i = s[0] || li(AA);
        const o = dg(r, t.config.apiKey, t.name);
        let a = null;
        for (const c of n) try {
            const u = await c._get(o);
            if (u) {
                const d = Wa._fromJSON(t, u);
                c !== i && (a = d), i = c;
                break
            }
        } catch {}
        const l = s.filter(c => c._shouldAllowMigration);
        return !i._shouldAllowMigration || !l.length ? new Mc(i, t, r) : (i = l[0], a && await i._set(o, a.toJSON()), await Promise.all(n.map(async c => {
            if (c !== i) try {
                await c._remove(o)
            } catch {}
        })), new Mc(i, t, r))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function RA(e) {
    const t = e.toLowerCase();
    if (t.includes("opera/") || t.includes("opr/") || t.includes("opios/")) return "Opera";
    if (_B(t)) return "IEMobile";
    if (t.includes("msie") || t.includes("trident/")) return "IE";
    if (t.includes("edge/")) return "Edge";
    if (mB(t)) return "Firefox";
    if (t.includes("silk/")) return "Silk";
    if (vB(t)) return "Blackberry";
    if (bB(t)) return "Webos";
    if (k$(t)) return "Safari";
    if ((t.includes("chrome/") || gB(t)) && !t.includes("edge/")) return "Chrome";
    if (yB(t)) return "Android"; {
        const n = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,
            r = e.match(n);
        if ((r == null ? void 0 : r.length) === 2) return r[1]
    }
    return "Other"
}

function mB(e = Yn()) {
    return /firefox\//i.test(e)
}

function k$(e = Yn()) {
    const t = e.toLowerCase();
    return t.includes("safari/") && !t.includes("chrome/") && !t.includes("crios/") && !t.includes("android")
}

function gB(e = Yn()) {
    return /crios\//i.test(e)
}

function _B(e = Yn()) {
    return /iemobile/i.test(e)
}

function yB(e = Yn()) {
    return /android/i.test(e)
}

function vB(e = Yn()) {
    return /blackberry/i.test(e)
}

function bB(e = Yn()) {
    return /webos/i.test(e)
}

function zv(e = Yn()) {
    return /iphone|ipad|ipod/i.test(e) || /macintosh/i.test(e) && /mobile/i.test(e)
}

function $re(e = Yn()) {
    var t;
    return zv(e) && !!(!((t = window.navigator) === null || t === void 0) && t.standalone)
}

function kre() {
    return Ez() && document.documentMode === 10
}

function wB(e = Yn()) {
    return zv(e) || yB(e) || bB(e) || vB(e) || /windows phone/i.test(e) || _B(e)
}

function Ire() {
    try {
        return !!(window && window !== window.top)
    } catch {
        return !1
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function EB(e, t = []) {
    let n;
    switch (e) {
        case "Browser":
            n = RA(Yn());
            break;
        case "Worker":
            n = `${RA(Yn())}-${e}`;
            break;
        default:
            n = e
    }
    const r = t.length ? t.join(",") : "FirebaseCore-web";
    return `${n}/JsCore/${ia}/${r}`
}
async function SB(e, t) {
    return ua(e, "GET", "/v2/recaptchaConfig", Ol(e, t))
}

function OA(e) {
    return e !== void 0 && e.enterprise !== void 0
}
class TB {
    constructor(t) {
        if (this.siteKey = "", this.emailPasswordEnabled = !1, t.recaptchaKey === void 0) throw new Error("recaptchaKey undefined");
        this.siteKey = t.recaptchaKey.split("/")[3], this.emailPasswordEnabled = t.recaptchaEnforcementState.some(n => n.provider === "EMAIL_PASSWORD_PROVIDER" && n.enforcementState !== "OFF")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function xre() {
    var e, t;
    return (t = (e = document.getElementsByTagName("head")) === null || e === void 0 ? void 0 : e[0]) !== null && t !== void 0 ? t : document
}

function $B(e) {
    return new Promise((t, n) => {
        const r = document.createElement("script");
        r.setAttribute("src", e), r.onload = t, r.onerror = s => {
            const i = Os("internal-error");
            i.customData = s, n(i)
        }, r.type = "text/javascript", r.charset = "UTF-8", xre().appendChild(r)
    })
}

function Cre(e) {
    return `__${e}${Math.floor(Math.random()*1e6)}`
}
const Are = "https://www.google.com/recaptcha/enterprise.js?render=",
    Rre = "recaptcha-enterprise";
class kB {
    constructor(t) {
        this.type = Rre, this.auth = da(t)
    }
    async verify(t = "verify", n = !1) {
        async function r(i) {
            if (!n) {
                if (i.tenantId == null && i._agentRecaptchaConfig != null) return i._agentRecaptchaConfig.siteKey;
                if (i.tenantId != null && i._tenantRecaptchaConfigs[i.tenantId] !== void 0) return i._tenantRecaptchaConfigs[i.tenantId].siteKey
            }
            return new Promise(async (o, a) => {
                SB(i, {
                    clientType: "CLIENT_TYPE_WEB",
                    version: "RECAPTCHA_ENTERPRISE"
                }).then(l => {
                    if (l.recaptchaKey === void 0) a(new Error("recaptcha Enterprise site key undefined"));
                    else {
                        const c = new TB(l);
                        return i.tenantId == null ? i._agentRecaptchaConfig = c : i._tenantRecaptchaConfigs[i.tenantId] = c, o(c.siteKey)
                    }
                }).catch(l => {
                    a(l)
                })
            })
        }

        function s(i, o, a) {
            const l = window.grecaptcha;
            OA(l) ? l.enterprise.ready(() => {
                try {
                    l.enterprise.execute(i, {
                        action: t
                    }).then(c => {
                        o(c)
                    }).catch(c => {
                        a(c)
                    })
                } catch (c) {
                    a(c)
                }
            }) : a(Error("No reCAPTCHA enterprise script loaded."))
        }
        return new Promise((i, o) => {
            r(this.auth).then(a => {
                if (!n && OA(window.grecaptcha)) s(a, i, o);
                else {
                    if (typeof window == "undefined") {
                        o(new Error("RecaptchaVerifier is only supported in browser"));
                        return
                    }
                    $B(Are + a).then(() => {
                        s(a, i, o)
                    }).catch(l => {
                        o(l)
                    })
                }
            }).catch(a => {
                o(a)
            })
        })
    }
}
async function bu(e, t, n, r = !1) {
    const s = new kB(e);
    let i;
    try {
        i = await s.verify(n)
    } catch {
        i = await s.verify(n, !0)
    }
    const o = Object.assign({}, t);
    return r ? Object.assign(o, {
        captchaResp: i
    }) : Object.assign(o, {
        captchaResponse: i
    }), Object.assign(o, {
        clientType: "CLIENT_TYPE_WEB"
    }), Object.assign(o, {
        recaptchaVersion: "RECAPTCHA_ENTERPRISE"
    }), o
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ore {
    constructor(t) {
        this.auth = t, this.queue = []
    }
    pushCallback(t, n) {
        const r = i => new Promise((o, a) => {
            try {
                const l = t(i);
                o(l)
            } catch (l) {
                a(l)
            }
        });
        r.onAbort = n, this.queue.push(r);
        const s = this.queue.length - 1;
        return () => {
            this.queue[s] = () => Promise.resolve()
        }
    }
    async runMiddleware(t) {
        if (this.auth.currentUser === t) return;
        const n = [];
        try {
            for (const r of this.queue) await r(t), r.onAbort && n.push(r.onAbort)
        } catch (r) {
            n.reverse();
            for (const s of n) try {
                s()
            } catch {}
            throw this.auth._errorFactory.create("login-blocked", {
                originalMessage: r == null ? void 0 : r.message
            })
        }
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dre {
    constructor(t, n, r, s) {
        this.app = t, this.heartbeatServiceProvider = n, this.appCheckServiceProvider = r, this.config = s, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new DA(this), this.idTokenSubscription = new DA(this), this.beforeStateQueue = new Ore(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = lB, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = {
            appVerificationDisabledForTesting: !1
        }, this.frameworks = [], this.name = t.name, this.clientVersion = s.sdkClientVersion
    }
    _initializeWithPersistence(t, n) {
        return n && (this._popupRedirectResolver = li(n)), this._initializationPromise = this.queue(async () => {
            var r, s;
            if (!this._deleted && (this.persistenceManager = await Mc.create(this, t), !this._deleted)) {
                if (!((r = this._popupRedirectResolver) === null || r === void 0) && r._shouldInitProactively) try {
                    await this._popupRedirectResolver._initialize(this)
                } catch {}
                await this.initializeCurrentUser(n), this.lastNotifiedUid = ((s = this.currentUser) === null || s === void 0 ? void 0 : s.uid) || null, !this._deleted && (this._isInitialized = !0)
            }
        }), this._initializationPromise
    }
    async _onStorageEvent() {
        if (this._deleted) return;
        const t = await this.assertedPersistence.getCurrentUser();
        if (!(!this.currentUser && !t)) {
            if (this.currentUser && t && this.currentUser.uid === t.uid) {
                this._currentUser._assign(t), await this.currentUser.getIdToken();
                return
            }
            await this._updateCurrentUser(t, !0)
        }
    }
    async initializeCurrentUser(t) {
        var n;
        const r = await this.assertedPersistence.getCurrentUser();
        let s = r,
            i = !1;
        if (t && this.config.authDomain) {
            await this.getOrInitRedirectPersistenceManager();
            const o = (n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId,
                a = s == null ? void 0 : s._redirectEventId,
                l = await this.tryRedirectSignIn(t);
            (!o || o === a) && (l == null ? void 0 : l.user) && (s = l.user, i = !0)
        }
        if (!s) return this.directlySetCurrentUser(null);
        if (!s._redirectEventId) {
            if (i) try {
                await this.beforeStateQueue.runMiddleware(s)
            } catch (o) {
                s = r, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o))
            }
            return s ? this.reloadAndSetCurrentUserOrClear(s) : this.directlySetCurrentUser(null)
        }
        return be(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === s._redirectEventId ? this.directlySetCurrentUser(s) : this.reloadAndSetCurrentUserOrClear(s)
    }
    async tryRedirectSignIn(t) {
        let n = null;
        try {
            n = await this._popupRedirectResolver._completeRedirectFn(this, t, !0)
        } catch {
            await this._setRedirectUser(null)
        }
        return n
    }
    async reloadAndSetCurrentUserOrClear(t) {
        try {
            await A_(t)
        } catch (n) {
            if ((n == null ? void 0 : n.code) !== "auth/network-request-failed") return this.directlySetCurrentUser(null)
        }
        return this.directlySetCurrentUser(t)
    }
    useDeviceLanguage() {
        this.languageCode = dre()
    }
    async _delete() {
        this._deleted = !0
    }
    async updateCurrentUser(t) {
        const n = t ? st(t) : null;
        return n && be(n.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(n && n._clone(this))
    }
    async _updateCurrentUser(t, n = !1) {
        if (!this._deleted) return t && be(this.tenantId === t.tenantId, this, "tenant-id-mismatch"), n || await this.beforeStateQueue.runMiddleware(t), this.queue(async () => {
            await this.directlySetCurrentUser(t), this.notifyAuthListeners()
        })
    }
    async signOut() {
        return await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null, !0)
    }
    setPersistence(t) {
        return this.queue(async () => {
            await this.assertedPersistence.setPersistence(li(t))
        })
    }
    async initializeRecaptchaConfig() {
        const t = await SB(this, {
                clientType: "CLIENT_TYPE_WEB",
                version: "RECAPTCHA_ENTERPRISE"
            }),
            n = new TB(t);
        this.tenantId == null ? this._agentRecaptchaConfig = n : this._tenantRecaptchaConfigs[this.tenantId] = n, n.emailPasswordEnabled && new kB(this).verify()
    }
    _getRecaptchaConfig() {
        return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId]
    }
    _getPersistence() {
        return this.assertedPersistence.persistence.type
    }
    _updateErrorMap(t) {
        this._errorFactory = new sa("auth", "Firebase", t())
    }
    onAuthStateChanged(t, n, r) {
        return this.registerStateListener(this.authStateSubscription, t, n, r)
    }
    beforeAuthStateChanged(t, n) {
        return this.beforeStateQueue.pushCallback(t, n)
    }
    onIdTokenChanged(t, n, r) {
        return this.registerStateListener(this.idTokenSubscription, t, n, r)
    }
    toJSON() {
        var t;
        return {
            apiKey: this.config.apiKey,
            authDomain: this.config.authDomain,
            appName: this.name,
            currentUser: (t = this._currentUser) === null || t === void 0 ? void 0 : t.toJSON()
        }
    }
    async _setRedirectUser(t, n) {
        const r = await this.getOrInitRedirectPersistenceManager(n);
        return t === null ? r.removeCurrentUser() : r.setCurrentUser(t)
    }
    async getOrInitRedirectPersistenceManager(t) {
        if (!this.redirectPersistenceManager) {
            const n = t && li(t) || this._popupRedirectResolver;
            be(n, this, "argument-error"), this.redirectPersistenceManager = await Mc.create(this, [li(n._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser()
        }
        return this.redirectPersistenceManager
    }
    async _redirectUserForId(t) {
        var n, r;
        return this._isInitialized && await this.queue(async () => {}), ((n = this._currentUser) === null || n === void 0 ? void 0 : n._redirectEventId) === t ? this._currentUser : ((r = this.redirectUser) === null || r === void 0 ? void 0 : r._redirectEventId) === t ? this.redirectUser : null
    }
    async _persistUserIfCurrent(t) {
        if (t === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(t))
    }
    _notifyListenersIfCurrent(t) {
        t === this.currentUser && this.notifyAuthListeners()
    }
    _key() {
        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
    }
    _startProactiveRefresh() {
        this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh()
    }
    _stopProactiveRefresh() {
        this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh()
    }
    get _currentUser() {
        return this.currentUser
    }
    notifyAuthListeners() {
        var t, n;
        if (!this._isInitialized) return;
        this.idTokenSubscription.next(this.currentUser);
        const r = (n = (t = this.currentUser) === null || t === void 0 ? void 0 : t.uid) !== null && n !== void 0 ? n : null;
        this.lastNotifiedUid !== r && (this.lastNotifiedUid = r, this.authStateSubscription.next(this.currentUser))
    }
    registerStateListener(t, n, r, s) {
        if (this._deleted) return () => {};
        const i = typeof n == "function" ? n : n.next.bind(n),
            o = this._isInitialized ? Promise.resolve() : this._initializationPromise;
        return be(o, this, "internal-error"), o.then(() => i(this.currentUser)), typeof n == "function" ? t.addObserver(n, r, s) : t.addObserver(n)
    }
    async directlySetCurrentUser(t) {
        this.currentUser && this.currentUser !== t && this._currentUser._stopProactiveRefresh(), t && this.isProactiveRefreshEnabled && t._startProactiveRefresh(), this.currentUser = t, t ? await this.assertedPersistence.setCurrentUser(t) : await this.assertedPersistence.removeCurrentUser()
    }
    queue(t) {
        return this.operations = this.operations.then(t, t), this.operations
    }
    get assertedPersistence() {
        return be(this.persistenceManager, this, "internal-error"), this.persistenceManager
    }
    _logFramework(t) {
        !t || this.frameworks.includes(t) || (this.frameworks.push(t), this.frameworks.sort(), this.clientVersion = EB(this.config.clientPlatform, this._getFrameworks()))
    }
    _getFrameworks() {
        return this.frameworks
    }
    async _getAdditionalHeaders() {
        var t;
        const n = {
            ["X-Client-Version"]: this.clientVersion
        };
        this.app.options.appId && (n["X-Firebase-gmpid"] = this.app.options.appId);
        const r = await ((t = this.heartbeatServiceProvider.getImmediate({
            optional: !0
        })) === null || t === void 0 ? void 0 : t.getHeartbeatsHeader());
        r && (n["X-Firebase-Client"] = r);
        const s = await this._getAppCheckToken();
        return s && (n["X-Firebase-AppCheck"] = s), n
    }
    async _getAppCheckToken() {
        var t;
        const n = await ((t = this.appCheckServiceProvider.getImmediate({
            optional: !0
        })) === null || t === void 0 ? void 0 : t.getToken());
        return n != null && n.error && are(`Error while retrieving App Check token: ${n.error}`), n == null ? void 0 : n.token
    }
}

function da(e) {
    return st(e)
}
class DA {
    constructor(t) {
        this.auth = t, this.observer = null, this.addObserver = Az(n => this.observer = n)
    }
    get next() {
        return be(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Nre(e, t) {
    const n = vs(e, "auth");
    if (n.isInitialized()) {
        const s = n.getImmediate(),
            i = n.getOptions();
        if (Lf(i, t != null ? t : {})) return s;
        Qr(s, "already-initialized")
    }
    return n.initialize({
        options: t
    })
}

function Pre(e, t) {
    const n = (t == null ? void 0 : t.persistence) || [],
        r = (Array.isArray(n) ? n : [n]).map(li);
    t != null && t.errorMap && e._updateErrorMap(t.errorMap), e._initializeWithPersistence(r, t == null ? void 0 : t.popupRedirectResolver)
}

function Mre(e, t, n) {
    const r = da(e);
    be(r._canInitEmulator, r, "emulator-config-failed"), be(/^https?:\/\//.test(t), r, "invalid-emulator-scheme");
    const s = !!(n != null && n.disableWarnings),
        i = IB(t),
        {
            host: o,
            port: a
        } = Lre(t),
        l = a === null ? "" : `:${a}`;
    r.config.emulator = {
        url: `${i}//${o}${l}/`
    }, r.settings.appVerificationDisabledForTesting = !0, r.emulatorConfig = Object.freeze({
        host: o,
        port: a,
        protocol: i.replace(":", ""),
        options: Object.freeze({
            disableWarnings: s
        })
    }), s || Fre()
}

function IB(e) {
    const t = e.indexOf(":");
    return t < 0 ? "" : e.substr(0, t + 1)
}

function Lre(e) {
    const t = IB(e),
        n = /(\/\/)?([^?#/]+)/.exec(e.substr(t.length));
    if (!n) return {
        host: "",
        port: null
    };
    const r = n[2].split("@").pop() || "",
        s = /^(\[[^\]]+\])(:|$)/.exec(r);
    if (s) {
        const i = s[1];
        return {
            host: i,
            port: NA(r.substr(i.length + 1))
        }
    } else {
        const [i, o] = r.split(":");
        return {
            host: i,
            port: NA(o)
        }
    }
}

function NA(e) {
    if (!e) return null;
    const t = Number(e);
    return isNaN(t) ? null : t
}

function Fre() {
    function e() {
        const t = document.createElement("p"),
            n = t.style;
        t.innerText = "Running in emulator mode. Do not use with production credentials.", n.position = "fixed", n.width = "100%", n.backgroundColor = "#ffffff", n.border = ".1em solid #000000", n.color = "#b50000", n.bottom = "0px", n.left = "0px", n.margin = "0px", n.zIndex = "10000", n.textAlign = "center", t.classList.add("firebase-emulator-warning"), document.body.appendChild(t)
    }
    typeof console != "undefined" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), typeof window != "undefined" && typeof document != "undefined" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", e) : e())
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class I$ {
    constructor(t, n) {
        this.providerId = t, this.signInMethod = n
    }
    toJSON() {
        return ai("not implemented")
    }
    _getIdTokenResponse(t) {
        return ai("not implemented")
    }
    _linkToIdToken(t, n) {
        return ai("not implemented")
    }
    _getReauthenticationResolver(t) {
        return ai("not implemented")
    }
}
async function Ure(e, t) {
    return ua(e, "POST", "/v1/accounts:update", t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function E0(e, t) {
    return Sp(e, "POST", "/v1/accounts:signInWithPassword", Ol(e, t))
}
async function Bre(e, t) {
    return ua(e, "POST", "/v1/accounts:sendOobCode", Ol(e, t))
}
async function S0(e, t) {
    return Bre(e, t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Vre(e, t) {
    return Sp(e, "POST", "/v1/accounts:signInWithEmailLink", Ol(e, t))
}
async function Hre(e, t) {
    return Sp(e, "POST", "/v1/accounts:signInWithEmailLink", Ol(e, t))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vh extends I$ {
    constructor(t, n, r, s = null) {
        super("password", r), this._email = t, this._password = n, this._tenantId = s
    }
    static _fromEmailAndPassword(t, n) {
        return new vh(t, n, "password")
    }
    static _fromEmailAndCode(t, n, r = null) {
        return new vh(t, n, "emailLink", r)
    }
    toJSON() {
        return {
            email: this._email,
            password: this._password,
            signInMethod: this.signInMethod,
            tenantId: this._tenantId
        }
    }
    static fromJSON(t) {
        const n = typeof t == "string" ? JSON.parse(t) : t;
        if ((n == null ? void 0 : n.email) && (n == null ? void 0 : n.password)) {
            if (n.signInMethod === "password") return this._fromEmailAndPassword(n.email, n.password);
            if (n.signInMethod === "emailLink") return this._fromEmailAndCode(n.email, n.password, n.tenantId)
        }
        return null
    }
    async _getIdTokenResponse(t) {
        var n;
        switch (this.signInMethod) {
            case "password":
                const r = {
                    returnSecureToken: !0,
                    email: this._email,
                    password: this._password,
                    clientType: "CLIENT_TYPE_WEB"
                };
                if (!((n = t._getRecaptchaConfig()) === null || n === void 0) && n.emailPasswordEnabled) {
                    const s = await bu(t, r, "signInWithPassword");
                    return E0(t, s)
                } else return E0(t, r).catch(async s => {
                    if (s.code === "auth/missing-recaptcha-token") {
                        console.log("Sign-in with email address and password is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow.");
                        const i = await bu(t, r, "signInWithPassword");
                        return E0(t, i)
                    } else return Promise.reject(s)
                });
            case "emailLink":
                return Vre(t, {
                    email: this._email,
                    oobCode: this._password
                });
            default:
                Qr(t, "internal-error")
        }
    }
    async _linkToIdToken(t, n) {
        switch (this.signInMethod) {
            case "password":
                return Ure(t, {
                    idToken: n,
                    returnSecureToken: !0,
                    email: this._email,
                    password: this._password
                });
            case "emailLink":
                return Hre(t, {
                    idToken: n,
                    email: this._email,
                    oobCode: this._password
                });
            default:
                Qr(t, "internal-error")
        }
    }
    _getReauthenticationResolver(t) {
        return this._getIdTokenResponse(t)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Lc(e, t) {
    return Sp(e, "POST", "/v1/accounts:signInWithIdp", Ol(e, t))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const jre = "http://localhost";
class hl extends I$ {
    constructor() {
        super(...arguments), this.pendingToken = null
    }
    static _fromParams(t) {
        const n = new hl(t.providerId, t.signInMethod);
        return t.idToken || t.accessToken ? (t.idToken && (n.idToken = t.idToken), t.accessToken && (n.accessToken = t.accessToken), t.nonce && !t.pendingToken && (n.nonce = t.nonce), t.pendingToken && (n.pendingToken = t.pendingToken)) : t.oauthToken && t.oauthTokenSecret ? (n.accessToken = t.oauthToken, n.secret = t.oauthTokenSecret) : Qr("argument-error"), n
    }
    toJSON() {
        return {
            idToken: this.idToken,
            accessToken: this.accessToken,
            secret: this.secret,
            nonce: this.nonce,
            pendingToken: this.pendingToken,
            providerId: this.providerId,
            signInMethod: this.signInMethod
        }
    }
    static fromJSON(t) {
        const n = typeof t == "string" ? JSON.parse(t) : t,
            {
                providerId: r,
                signInMethod: s
            } = n,
            i = E$(n, ["providerId", "signInMethod"]);
        if (!r || !s) return null;
        const o = new hl(r, s);
        return o.idToken = i.idToken || void 0, o.accessToken = i.accessToken || void 0, o.secret = i.secret, o.nonce = i.nonce, o.pendingToken = i.pendingToken || null, o
    }
    _getIdTokenResponse(t) {
        const n = this.buildRequest();
        return Lc(t, n)
    }
    _linkToIdToken(t, n) {
        const r = this.buildRequest();
        return r.idToken = n, Lc(t, r)
    }
    _getReauthenticationResolver(t) {
        const n = this.buildRequest();
        return n.autoCreate = !1, Lc(t, n)
    }
    buildRequest() {
        const t = {
            requestUri: jre,
            returnSecureToken: !0
        };
        if (this.pendingToken) t.pendingToken = this.pendingToken;
        else {
            const n = {};
            this.idToken && (n.id_token = this.idToken), this.accessToken && (n.access_token = this.accessToken), this.secret && (n.oauth_token_secret = this.secret), n.providerId = this.providerId, this.nonce && !this.pendingToken && (n.nonce = this.nonce), t.postBody = ju(n)
        }
        return t
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zre(e) {
    switch (e) {
        case "recoverEmail":
            return "RECOVER_EMAIL";
        case "resetPassword":
            return "PASSWORD_RESET";
        case "signIn":
            return "EMAIL_SIGNIN";
        case "verifyEmail":
            return "VERIFY_EMAIL";
        case "verifyAndChangeEmail":
            return "VERIFY_AND_CHANGE_EMAIL";
        case "revertSecondFactorAddition":
            return "REVERT_SECOND_FACTOR_ADDITION";
        default:
            return null
    }
}

function Wre(e) {
    const t = Cd(Ad(e)).link,
        n = t ? Cd(Ad(t)).deep_link_id : null,
        r = Cd(Ad(e)).deep_link_id;
    return (r ? Cd(Ad(r)).link : null) || r || n || t || e
}
class x$ {
    constructor(t) {
        var n, r, s, i, o, a;
        const l = Cd(Ad(t)),
            c = (n = l.apiKey) !== null && n !== void 0 ? n : null,
            u = (r = l.oobCode) !== null && r !== void 0 ? r : null,
            d = zre((s = l.mode) !== null && s !== void 0 ? s : null);
        be(c && u && d, "argument-error"), this.apiKey = c, this.operation = d, this.code = u, this.continueUrl = (i = l.continueUrl) !== null && i !== void 0 ? i : null, this.languageCode = (o = l.languageCode) !== null && o !== void 0 ? o : null, this.tenantId = (a = l.tenantId) !== null && a !== void 0 ? a : null
    }
    static parseLink(t) {
        const n = Wre(t);
        try {
            return new x$(n)
        } catch {
            return null
        }
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sd {
    constructor() {
        this.providerId = sd.PROVIDER_ID
    }
    static credential(t, n) {
        return vh._fromEmailAndPassword(t, n)
    }
    static credentialWithLink(t, n) {
        const r = x$.parseLink(n);
        return be(r, "argument-error"), vh._fromEmailAndCode(t, r.code, r.tenantId)
    }
}
sd.PROVIDER_ID = "password";
sd.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
sd.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class C$ {
    constructor(t) {
        this.providerId = t, this.defaultLanguageCode = null, this.customParameters = {}
    }
    setDefaultLanguage(t) {
        this.defaultLanguageCode = t
    }
    setCustomParameters(t) {
        return this.customParameters = t, this
    }
    getCustomParameters() {
        return this.customParameters
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Tp extends C$ {
    constructor() {
        super(...arguments), this.scopes = []
    }
    addScope(t) {
        return this.scopes.includes(t) || this.scopes.push(t), this
    }
    getScopes() {
        return [...this.scopes]
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ho extends Tp {
    constructor() {
        super("facebook.com")
    }
    static credential(t) {
        return hl._fromParams({
            providerId: ho.PROVIDER_ID,
            signInMethod: ho.FACEBOOK_SIGN_IN_METHOD,
            accessToken: t
        })
    }
    static credentialFromResult(t) {
        return ho.credentialFromTaggedObject(t)
    }
    static credentialFromError(t) {
        return ho.credentialFromTaggedObject(t.customData || {})
    }
    static credentialFromTaggedObject({
        _tokenResponse: t
    }) {
        if (!t || !("oauthAccessToken" in t) || !t.oauthAccessToken) return null;
        try {
            return ho.credential(t.oauthAccessToken)
        } catch {
            return null
        }
    }
}
ho.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
ho.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class po extends Tp {
    constructor() {
        super("google.com"), this.addScope("profile")
    }
    static credential(t, n) {
        return hl._fromParams({
            providerId: po.PROVIDER_ID,
            signInMethod: po.GOOGLE_SIGN_IN_METHOD,
            idToken: t,
            accessToken: n
        })
    }
    static credentialFromResult(t) {
        return po.credentialFromTaggedObject(t)
    }
    static credentialFromError(t) {
        return po.credentialFromTaggedObject(t.customData || {})
    }
    static credentialFromTaggedObject({
        _tokenResponse: t
    }) {
        if (!t) return null;
        const {
            oauthIdToken: n,
            oauthAccessToken: r
        } = t;
        if (!n && !r) return null;
        try {
            return po.credential(n, r)
        } catch {
            return null
        }
    }
}
po.GOOGLE_SIGN_IN_METHOD = "google.com";
po.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mo extends Tp {
    constructor() {
        super("github.com")
    }
    static credential(t) {
        return hl._fromParams({
            providerId: mo.PROVIDER_ID,
            signInMethod: mo.GITHUB_SIGN_IN_METHOD,
            accessToken: t
        })
    }
    static credentialFromResult(t) {
        return mo.credentialFromTaggedObject(t)
    }
    static credentialFromError(t) {
        return mo.credentialFromTaggedObject(t.customData || {})
    }
    static credentialFromTaggedObject({
        _tokenResponse: t
    }) {
        if (!t || !("oauthAccessToken" in t) || !t.oauthAccessToken) return null;
        try {
            return mo.credential(t.oauthAccessToken)
        } catch {
            return null
        }
    }
}
mo.GITHUB_SIGN_IN_METHOD = "github.com";
mo.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class go extends Tp {
    constructor() {
        super("twitter.com")
    }
    static credential(t, n) {
        return hl._fromParams({
            providerId: go.PROVIDER_ID,
            signInMethod: go.TWITTER_SIGN_IN_METHOD,
            oauthToken: t,
            oauthTokenSecret: n
        })
    }
    static credentialFromResult(t) {
        return go.credentialFromTaggedObject(t)
    }
    static credentialFromError(t) {
        return go.credentialFromTaggedObject(t.customData || {})
    }
    static credentialFromTaggedObject({
        _tokenResponse: t
    }) {
        if (!t) return null;
        const {
            oauthAccessToken: n,
            oauthTokenSecret: r
        } = t;
        if (!n || !r) return null;
        try {
            return go.credential(n, r)
        } catch {
            return null
        }
    }
}
go.TWITTER_SIGN_IN_METHOD = "twitter.com";
go.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function T0(e, t) {
    return Sp(e, "POST", "/v1/accounts:signUp", Ol(e, t))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pl {
    constructor(t) {
        this.user = t.user, this.providerId = t.providerId, this._tokenResponse = t._tokenResponse, this.operationType = t.operationType
    }
    static async _fromIdTokenResponse(t, n, r, s = !1) {
        const i = await Wa._fromIdTokenResponse(t, r, s),
            o = PA(r);
        return new pl({
            user: i,
            providerId: o,
            _tokenResponse: r,
            operationType: n
        })
    }
    static async _forOperation(t, n, r) {
        await t._updateTokensIfNecessary(r, !0);
        const s = PA(r);
        return new pl({
            user: t,
            providerId: s,
            _tokenResponse: r,
            operationType: n
        })
    }
}

function PA(e) {
    return e.providerId ? e.providerId : "phoneNumber" in e ? "phone" : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class R_ extends zr {
    constructor(t, n, r, s) {
        var i;
        super(n.code, n.message), this.operationType = r, this.user = s, Object.setPrototypeOf(this, R_.prototype), this.customData = {
            appName: t.name,
            tenantId: (i = t.tenantId) !== null && i !== void 0 ? i : void 0,
            _serverResponse: n.customData._serverResponse,
            operationType: r
        }
    }
    static _fromErrorAndOperation(t, n, r, s) {
        return new R_(t, n, r, s)
    }
}

function xB(e, t, n, r) {
    return (t === "reauthenticate" ? n._getReauthenticationResolver(e) : n._getIdTokenResponse(e)).catch(i => {
        throw i.code === "auth/multi-factor-auth-required" ? R_._fromErrorAndOperation(e, i, t, r) : i
    })
}
async function Gre(e, t, n = !1) {
    const r = await vu(e, t._linkToIdToken(e.auth, await e.getIdToken()), n);
    return pl._forOperation(e, "link", r)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function qre(e, t, n = !1) {
    const {
        auth: r
    } = e, s = "reauthenticate";
    try {
        const i = await vu(e, xB(r, s, t, e), n);
        be(i.idToken, r, "internal-error");
        const o = $$(i.idToken);
        be(o, r, "internal-error");
        const {
            sub: a
        } = o;
        return be(e.uid === a, r, "user-mismatch"), pl._forOperation(e, s, i)
    } catch (i) {
        throw (i == null ? void 0 : i.code) === "auth/user-not-found" && Qr(r, "user-mismatch"), i
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function CB(e, t, n = !1) {
    const r = "signIn",
        s = await xB(e, r, t),
        i = await pl._fromIdTokenResponse(e, r, s);
    return n || await e._updateCurrentUser(i.user), i
}
async function Yre(e, t) {
    return CB(da(e), t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $0(e, t, n) {
    var r;
    be(((r = n.url) === null || r === void 0 ? void 0 : r.length) > 0, e, "invalid-continue-uri"), be(typeof n.dynamicLinkDomain == "undefined" || n.dynamicLinkDomain.length > 0, e, "invalid-dynamic-link-domain"), t.continueUrl = n.url, t.dynamicLinkDomain = n.dynamicLinkDomain, t.canHandleCodeInApp = n.handleCodeInApp, n.iOS && (be(n.iOS.bundleId.length > 0, e, "missing-ios-bundle-id"), t.iOSBundleId = n.iOS.bundleId), n.android && (be(n.android.packageName.length > 0, e, "missing-android-pkg-name"), t.androidInstallApp = n.android.installApp, t.androidMinimumVersionCode = n.android.minimumVersion, t.androidPackageName = n.android.packageName)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function NRe(e, t, n) {
    var r;
    const s = da(e),
        i = {
            requestType: "PASSWORD_RESET",
            email: t,
            clientType: "CLIENT_TYPE_WEB"
        };
    if (!((r = s._getRecaptchaConfig()) === null || r === void 0) && r.emailPasswordEnabled) {
        const o = await bu(s, i, "getOobCode", !0);
        n && $0(s, o, n), await S0(s, o)
    } else n && $0(s, i, n), await S0(s, i).catch(async o => {
        if (o.code === "auth/missing-recaptcha-token") {
            console.log("Password resets are protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the password reset flow.");
            const a = await bu(s, i, "getOobCode", !0);
            n && $0(s, a, n), await S0(s, a)
        } else return Promise.reject(o)
    })
}
async function PRe(e, t, n) {
    var r;
    const s = da(e),
        i = {
            returnSecureToken: !0,
            email: t,
            password: n,
            clientType: "CLIENT_TYPE_WEB"
        };
    let o;
    if (!((r = s._getRecaptchaConfig()) === null || r === void 0) && r.emailPasswordEnabled) {
        const c = await bu(s, i, "signUpPassword");
        o = T0(s, c)
    } else o = T0(s, i).catch(async c => {
        if (c.code === "auth/missing-recaptcha-token") {
            console.log("Sign-up is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-up flow.");
            const u = await bu(s, i, "signUpPassword");
            return T0(s, u)
        } else return Promise.reject(c)
    });
    const a = await o.catch(c => Promise.reject(c)),
        l = await pl._fromIdTokenResponse(s, "signIn", a);
    return await s._updateCurrentUser(l.user), l
}

function MRe(e, t, n) {
    return Yre(st(e), sd.credential(t, n))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Kre(e, t) {
    return ua(e, "POST", "/v1/accounts:update", t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function LRe(e, {
    displayName: t,
    photoURL: n
}) {
    if (t === void 0 && n === void 0) return;
    const r = st(e),
        i = {
            idToken: await r.getIdToken(),
            displayName: t,
            photoUrl: n,
            returnSecureToken: !0
        },
        o = await vu(r, Kre(r.auth, i));
    r.displayName = o.displayName || null, r.photoURL = o.photoUrl || null;
    const a = r.providerData.find(({
        providerId: l
    }) => l === "password");
    a && (a.displayName = r.displayName, a.photoURL = r.photoURL), await r._updateTokensIfNecessary(o)
}

function AB(e, t, n, r) {
    return st(e).onIdTokenChanged(t, n, r)
}

function Xre(e, t, n) {
    return st(e).beforeAuthStateChanged(t, n)
}

function Qre(e) {
    return st(e).signOut()
}
const O_ = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RB {
    constructor(t, n) {
        this.storageRetriever = t, this.type = n
    }
    _isAvailable() {
        try {
            return this.storage ? (this.storage.setItem(O_, "1"), this.storage.removeItem(O_), Promise.resolve(!0)) : Promise.resolve(!1)
        } catch {
            return Promise.resolve(!1)
        }
    }
    _set(t, n) {
        return this.storage.setItem(t, JSON.stringify(n)), Promise.resolve()
    }
    _get(t) {
        const n = this.storage.getItem(t);
        return Promise.resolve(n ? JSON.parse(n) : null)
    }
    _remove(t) {
        return this.storage.removeItem(t), Promise.resolve()
    }
    get storage() {
        return this.storageRetriever()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Jre() {
    const e = Yn();
    return k$(e) || zv(e)
}
const Zre = 1e3,
    ese = 10;
class OB extends RB {
    constructor() {
        super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (t, n) => this.onStorageEvent(t, n), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = Jre() && Ire(), this.fallbackToPolling = wB(), this._shouldAllowMigration = !0
    }
    forAllChangedKeys(t) {
        for (const n of Object.keys(this.listeners)) {
            const r = this.storage.getItem(n),
                s = this.localCache[n];
            r !== s && t(n, s, r)
        }
    }
    onStorageEvent(t, n = !1) {
        if (!t.key) {
            this.forAllChangedKeys((o, a, l) => {
                this.notifyListeners(o, l)
            });
            return
        }
        const r = t.key;
        if (n ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) {
            const o = this.storage.getItem(r);
            if (t.newValue !== o) t.newValue !== null ? this.storage.setItem(r, t.newValue) : this.storage.removeItem(r);
            else if (this.localCache[r] === t.newValue && !n) return
        }
        const s = () => {
                const o = this.storage.getItem(r);
                !n && this.localCache[r] === o || this.notifyListeners(r, o)
            },
            i = this.storage.getItem(r);
        kre() && i !== t.newValue && t.newValue !== t.oldValue ? setTimeout(s, ese) : s()
    }
    notifyListeners(t, n) {
        this.localCache[t] = n;
        const r = this.listeners[t];
        if (r)
            for (const s of Array.from(r)) s(n && JSON.parse(n))
    }
    startPolling() {
        this.stopPolling(), this.pollTimer = setInterval(() => {
            this.forAllChangedKeys((t, n, r) => {
                this.onStorageEvent(new StorageEvent("storage", {
                    key: t,
                    oldValue: n,
                    newValue: r
                }), !0)
            })
        }, Zre)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null)
    }
    attachListener() {
        window.addEventListener("storage", this.boundEventHandler)
    }
    detachListener() {
        window.removeEventListener("storage", this.boundEventHandler)
    }
    _addListener(t, n) {
        Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[t] || (this.listeners[t] = new Set, this.localCache[t] = this.storage.getItem(t)), this.listeners[t].add(n)
    }
    _removeListener(t, n) {
        this.listeners[t] && (this.listeners[t].delete(n), this.listeners[t].size === 0 && delete this.listeners[t]), Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling())
    }
    async _set(t, n) {
        await super._set(t, n), this.localCache[t] = JSON.stringify(n)
    }
    async _get(t) {
        const n = await super._get(t);
        return this.localCache[t] = JSON.stringify(n), n
    }
    async _remove(t) {
        await super._remove(t), delete this.localCache[t]
    }
}
OB.type = "LOCAL";
const tse = OB;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DB extends RB {
    constructor() {
        super(() => window.sessionStorage, "SESSION")
    }
    _addListener(t, n) {}
    _removeListener(t, n) {}
}
DB.type = "SESSION";
const NB = DB;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nse(e) {
    return Promise.all(e.map(async t => {
        try {
            const n = await t;
            return {
                fulfilled: !0,
                value: n
            }
        } catch (n) {
            return {
                fulfilled: !1,
                reason: n
            }
        }
    }))
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Wv {
    constructor(t) {
        this.eventTarget = t, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this)
    }
    static _getInstance(t) {
        const n = this.receivers.find(s => s.isListeningto(t));
        if (n) return n;
        const r = new Wv(t);
        return this.receivers.push(r), r
    }
    isListeningto(t) {
        return this.eventTarget === t
    }
    async handleEvent(t) {
        const n = t,
            {
                eventId: r,
                eventType: s,
                data: i
            } = n.data,
            o = this.handlersMap[s];
        if (!(o != null && o.size)) return;
        n.ports[0].postMessage({
            status: "ack",
            eventId: r,
            eventType: s
        });
        const a = Array.from(o).map(async c => c(n.origin, i)),
            l = await nse(a);
        n.ports[0].postMessage({
            status: "done",
            eventId: r,
            eventType: s,
            response: l
        })
    }
    _subscribe(t, n) {
        Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[t] || (this.handlersMap[t] = new Set), this.handlersMap[t].add(n)
    }
    _unsubscribe(t, n) {
        this.handlersMap[t] && n && this.handlersMap[t].delete(n), (!n || this.handlersMap[t].size === 0) && delete this.handlersMap[t], Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler)
    }
}
Wv.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function A$(e = "", t = 10) {
    let n = "";
    for (let r = 0; r < t; r++) n += Math.floor(Math.random() * 10);
    return e + n
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rse {
    constructor(t) {
        this.target = t, this.handlers = new Set
    }
    removeMessageHandler(t) {
        t.messageChannel && (t.messageChannel.port1.removeEventListener("message", t.onMessage), t.messageChannel.port1.close()), this.handlers.delete(t)
    }
    async _send(t, n, r = 50) {
        const s = typeof MessageChannel != "undefined" ? new MessageChannel : null;
        if (!s) throw new Error("connection_unavailable");
        let i, o;
        return new Promise((a, l) => {
            const c = A$("", 20);
            s.port1.start();
            const u = setTimeout(() => {
                l(new Error("unsupported_event"))
            }, r);
            o = {
                messageChannel: s,
                onMessage(d) {
                    const f = d;
                    if (f.data.eventId === c) switch (f.data.status) {
                        case "ack":
                            clearTimeout(u), i = setTimeout(() => {
                                l(new Error("timeout"))
                            }, 3e3);
                            break;
                        case "done":
                            clearTimeout(i), a(f.data.response);
                            break;
                        default:
                            clearTimeout(u), clearTimeout(i), l(new Error("invalid_response"));
                            break
                    }
                }
            }, this.handlers.add(o), s.port1.addEventListener("message", o.onMessage), this.target.postMessage({
                eventType: t,
                eventId: c,
                data: n
            }, [s.port2])
        }).finally(() => {
            o && this.removeMessageHandler(o)
        })
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ds() {
    return window
}

function sse(e) {
    Ds().location.href = e
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function PB() {
    return typeof Ds().WorkerGlobalScope != "undefined" && typeof Ds().importScripts == "function"
}
async function ise() {
    if (!(navigator != null && navigator.serviceWorker)) return null;
    try {
        return (await navigator.serviceWorker.ready).active
    } catch {
        return null
    }
}

function ose() {
    var e;
    return ((e = navigator == null ? void 0 : navigator.serviceWorker) === null || e === void 0 ? void 0 : e.controller) || null
}

function ase() {
    return PB() ? self : null
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MB = "firebaseLocalStorageDb",
    lse = 1,
    D_ = "firebaseLocalStorage",
    LB = "fbase_key";
class $p {
    constructor(t) {
        this.request = t
    }
    toPromise() {
        return new Promise((t, n) => {
            this.request.addEventListener("success", () => {
                t(this.request.result)
            }), this.request.addEventListener("error", () => {
                n(this.request.error)
            })
        })
    }
}

function Gv(e, t) {
    return e.transaction([D_], t ? "readwrite" : "readonly").objectStore(D_)
}

function cse() {
    const e = indexedDB.deleteDatabase(MB);
    return new $p(e).toPromise()
}

function VE() {
    const e = indexedDB.open(MB, lse);
    return new Promise((t, n) => {
        e.addEventListener("error", () => {
            n(e.error)
        }), e.addEventListener("upgradeneeded", () => {
            const r = e.result;
            try {
                r.createObjectStore(D_, {
                    keyPath: LB
                })
            } catch (s) {
                n(s)
            }
        }), e.addEventListener("success", async () => {
            const r = e.result;
            r.objectStoreNames.contains(D_) ? t(r) : (r.close(), await cse(), t(await VE()))
        })
    })
}
async function MA(e, t, n) {
    const r = Gv(e, !0).put({
        [LB]: t,
        value: n
    });
    return new $p(r).toPromise()
}
async function use(e, t) {
    const n = Gv(e, !1).get(t),
        r = await new $p(n).toPromise();
    return r === void 0 ? null : r.value
}

function LA(e, t) {
    const n = Gv(e, !0).delete(t);
    return new $p(n).toPromise()
}
const dse = 800,
    fse = 3;
class FB {
    constructor() {
        this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {}, () => {})
    }
    async _openDb() {
        return this.db ? this.db : (this.db = await VE(), this.db)
    }
    async _withRetries(t) {
        let n = 0;
        for (;;) try {
            const r = await this._openDb();
            return await t(r)
        } catch (r) {
            if (n++ > fse) throw r;
            this.db && (this.db.close(), this.db = void 0)
        }
    }
    async initializeServiceWorkerMessaging() {
        return PB() ? this.initializeReceiver() : this.initializeSender()
    }
    async initializeReceiver() {
        this.receiver = Wv._getInstance(ase()), this.receiver._subscribe("keyChanged", async (t, n) => ({
            keyProcessed: (await this._poll()).includes(n.key)
        })), this.receiver._subscribe("ping", async (t, n) => ["keyChanged"])
    }
    async initializeSender() {
        var t, n;
        if (this.activeServiceWorker = await ise(), !this.activeServiceWorker) return;
        this.sender = new rse(this.activeServiceWorker);
        const r = await this.sender._send("ping", {}, 800);
        !r || ((t = r[0]) === null || t === void 0 ? void 0 : t.fulfilled) && ((n = r[0]) === null || n === void 0 ? void 0 : n.value.includes("keyChanged")) && (this.serviceWorkerReceiverAvailable = !0)
    }
    async notifyServiceWorker(t) {
        if (!(!this.sender || !this.activeServiceWorker || ose() !== this.activeServiceWorker)) try {
            await this.sender._send("keyChanged", {
                key: t
            }, this.serviceWorkerReceiverAvailable ? 800 : 50)
        } catch {}
    }
    async _isAvailable() {
        try {
            if (!indexedDB) return !1;
            const t = await VE();
            return await MA(t, O_, "1"), await LA(t, O_), !0
        } catch {}
        return !1
    }
    async _withPendingWrite(t) {
        this.pendingWrites++;
        try {
            await t()
        } finally {
            this.pendingWrites--
        }
    }
    async _set(t, n) {
        return this._withPendingWrite(async () => (await this._withRetries(r => MA(r, t, n)), this.localCache[t] = n, this.notifyServiceWorker(t)))
    }
    async _get(t) {
        const n = await this._withRetries(r => use(r, t));
        return this.localCache[t] = n, n
    }
    async _remove(t) {
        return this._withPendingWrite(async () => (await this._withRetries(n => LA(n, t)), delete this.localCache[t], this.notifyServiceWorker(t)))
    }
    async _poll() {
        const t = await this._withRetries(s => {
            const i = Gv(s, !1).getAll();
            return new $p(i).toPromise()
        });
        if (!t) return [];
        if (this.pendingWrites !== 0) return [];
        const n = [],
            r = new Set;
        for (const {
                fbase_key: s,
                value: i
            } of t) r.add(s), JSON.stringify(this.localCache[s]) !== JSON.stringify(i) && (this.notifyListeners(s, i), n.push(s));
        for (const s of Object.keys(this.localCache)) this.localCache[s] && !r.has(s) && (this.notifyListeners(s, null), n.push(s));
        return n
    }
    notifyListeners(t, n) {
        this.localCache[t] = n;
        const r = this.listeners[t];
        if (r)
            for (const s of Array.from(r)) s(n)
    }
    startPolling() {
        this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), dse)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null)
    }
    _addListener(t, n) {
        Object.keys(this.listeners).length === 0 && this.startPolling(), this.listeners[t] || (this.listeners[t] = new Set, this._get(t)), this.listeners[t].add(n)
    }
    _removeListener(t, n) {
        this.listeners[t] && (this.listeners[t].delete(n), this.listeners[t].size === 0 && delete this.listeners[t]), Object.keys(this.listeners).length === 0 && this.stopPolling()
    }
}
FB.type = "LOCAL";
const hse = FB;
new Ep(3e4, 6e4);
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function UB(e, t) {
    return t ? li(t) : (be(e._popupRedirectResolver, e, "argument-error"), e._popupRedirectResolver)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class R$ extends I$ {
    constructor(t) {
        super("custom", "custom"), this.params = t
    }
    _getIdTokenResponse(t) {
        return Lc(t, this._buildIdpRequest())
    }
    _linkToIdToken(t, n) {
        return Lc(t, this._buildIdpRequest(n))
    }
    _getReauthenticationResolver(t) {
        return Lc(t, this._buildIdpRequest())
    }
    _buildIdpRequest(t) {
        const n = {
            requestUri: this.params.requestUri,
            sessionId: this.params.sessionId,
            postBody: this.params.postBody,
            tenantId: this.params.tenantId,
            pendingToken: this.params.pendingToken,
            returnSecureToken: !0,
            returnIdpCredential: !0
        };
        return t && (n.idToken = t), n
    }
}

function pse(e) {
    return CB(e.auth, new R$(e), e.bypassAuthState)
}

function mse(e) {
    const {
        auth: t,
        user: n
    } = e;
    return be(n, t, "internal-error"), qre(n, new R$(e), e.bypassAuthState)
}
async function gse(e) {
    const {
        auth: t,
        user: n
    } = e;
    return be(n, t, "internal-error"), Gre(n, new R$(e), e.bypassAuthState)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BB {
    constructor(t, n, r, s, i = !1) {
        this.auth = t, this.resolver = r, this.user = s, this.bypassAuthState = i, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(n) ? n : [n]
    }
    execute() {
        return new Promise(async (t, n) => {
            this.pendingPromise = {
                resolve: t,
                reject: n
            };
            try {
                this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this)
            } catch (r) {
                this.reject(r)
            }
        })
    }
    async onAuthEvent(t) {
        const {
            urlResponse: n,
            sessionId: r,
            postBody: s,
            tenantId: i,
            error: o,
            type: a
        } = t;
        if (o) {
            this.reject(o);
            return
        }
        const l = {
            auth: this.auth,
            requestUri: n,
            sessionId: r,
            tenantId: i || void 0,
            postBody: s || void 0,
            user: this.user,
            bypassAuthState: this.bypassAuthState
        };
        try {
            this.resolve(await this.getIdpTask(a)(l))
        } catch (c) {
            this.reject(c)
        }
    }
    onError(t) {
        this.reject(t)
    }
    getIdpTask(t) {
        switch (t) {
            case "signInViaPopup":
            case "signInViaRedirect":
                return pse;
            case "linkViaPopup":
            case "linkViaRedirect":
                return gse;
            case "reauthViaPopup":
            case "reauthViaRedirect":
                return mse;
            default:
                Qr(this.auth, "internal-error")
        }
    }
    resolve(t) {
        ki(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(t), this.unregisterAndCleanUp()
    }
    reject(t) {
        ki(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(t), this.unregisterAndCleanUp()
    }
    unregisterAndCleanUp() {
        this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _se = new Ep(2e3, 1e4);
async function FRe(e, t, n) {
    const r = da(e);
    lre(e, t, C$);
    const s = UB(r, n);
    return new Ma(r, "signInViaPopup", t, s).executeNotNull()
}
class Ma extends BB {
    constructor(t, n, r, s, i) {
        super(t, n, s, i), this.provider = r, this.authWindow = null, this.pollId = null, Ma.currentPopupAction && Ma.currentPopupAction.cancel(), Ma.currentPopupAction = this
    }
    async executeNotNull() {
        const t = await this.execute();
        return be(t, this.auth, "internal-error"), t
    }
    async onExecution() {
        ki(this.filter.length === 1, "Popup operations only handle one event");
        const t = A$();
        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], t), this.authWindow.associatedEvent = t, this.resolver._originValidation(this.auth).catch(n => {
            this.reject(n)
        }), this.resolver._isIframeWebStorageSupported(this.auth, n => {
            n || this.reject(Os(this.auth, "web-storage-unsupported"))
        }), this.pollUserCancellation()
    }
    get eventId() {
        var t;
        return ((t = this.authWindow) === null || t === void 0 ? void 0 : t.associatedEvent) || null
    }
    cancel() {
        this.reject(Os(this.auth, "cancelled-popup-request"))
    }
    cleanUp() {
        this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, Ma.currentPopupAction = null
    }
    pollUserCancellation() {
        const t = () => {
            var n, r;
            if (!((r = (n = this.authWindow) === null || n === void 0 ? void 0 : n.window) === null || r === void 0) && r.closed) {
                this.pollId = window.setTimeout(() => {
                    this.pollId = null, this.reject(Os(this.auth, "popup-closed-by-user"))
                }, 2e3);
                return
            }
            this.pollId = window.setTimeout(t, _se.get())
        };
        t()
    }
}
Ma.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yse = "pendingRedirect",
    fg = new Map;
class vse extends BB {
    constructor(t, n, r = !1) {
        super(t, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], n, void 0, r), this.eventId = null
    }
    async execute() {
        let t = fg.get(this.auth._key());
        if (!t) {
            try {
                const r = await bse(this.resolver, this.auth) ? await super.execute() : null;
                t = () => Promise.resolve(r)
            } catch (n) {
                t = () => Promise.reject(n)
            }
            fg.set(this.auth._key(), t)
        }
        return this.bypassAuthState || fg.set(this.auth._key(), () => Promise.resolve(null)), t()
    }
    async onAuthEvent(t) {
        if (t.type === "signInViaRedirect") return super.onAuthEvent(t);
        if (t.type === "unknown") {
            this.resolve(null);
            return
        }
        if (t.eventId) {
            const n = await this.auth._redirectUserForId(t.eventId);
            if (n) return this.user = n, super.onAuthEvent(t);
            this.resolve(null)
        }
    }
    async onExecution() {}
    cleanUp() {}
}
async function bse(e, t) {
    const n = Sse(t),
        r = Ese(e);
    if (!await r._isAvailable()) return !1;
    const s = await r._get(n) === "true";
    return await r._remove(n), s
}

function wse(e, t) {
    fg.set(e._key(), t)
}

function Ese(e) {
    return li(e._redirectPersistence)
}

function Sse(e) {
    return dg(yse, e.config.apiKey, e.name)
}
async function Tse(e, t, n = !1) {
    const r = da(e),
        s = UB(r, t),
        o = await new vse(r, s, n).execute();
    return o && !n && (delete o.user._redirectEventId, await r._persistUserIfCurrent(o.user), await r._setRedirectUser(null, t)), o
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $se = 10 * 60 * 1e3;
class kse {
    constructor(t) {
        this.auth = t, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now()
    }
    registerConsumer(t) {
        this.consumers.add(t), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, t) && (this.sendToConsumer(this.queuedRedirectEvent, t), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null)
    }
    unregisterConsumer(t) {
        this.consumers.delete(t)
    }
    onEvent(t) {
        if (this.hasEventBeenHandled(t)) return !1;
        let n = !1;
        return this.consumers.forEach(r => {
            this.isEventForConsumer(t, r) && (n = !0, this.sendToConsumer(t, r), this.saveEventToCache(t))
        }), this.hasHandledPotentialRedirect || !Ise(t) || (this.hasHandledPotentialRedirect = !0, n || (this.queuedRedirectEvent = t, n = !0)), n
    }
    sendToConsumer(t, n) {
        var r;
        if (t.error && !VB(t)) {
            const s = ((r = t.error.code) === null || r === void 0 ? void 0 : r.split("auth/")[1]) || "internal-error";
            n.onError(Os(this.auth, s))
        } else n.onAuthEvent(t)
    }
    isEventForConsumer(t, n) {
        const r = n.eventId === null || !!t.eventId && t.eventId === n.eventId;
        return n.filter.includes(t.type) && r
    }
    hasEventBeenHandled(t) {
        return Date.now() - this.lastProcessedEventTime >= $se && this.cachedEventUids.clear(), this.cachedEventUids.has(FA(t))
    }
    saveEventToCache(t) {
        this.cachedEventUids.add(FA(t)), this.lastProcessedEventTime = Date.now()
    }
}

function FA(e) {
    return [e.type, e.eventId, e.sessionId, e.tenantId].filter(t => t).join("-")
}

function VB({
    type: e,
    error: t
}) {
    return e === "unknown" && (t == null ? void 0 : t.code) === "auth/no-auth-event"
}

function Ise(e) {
    switch (e.type) {
        case "signInViaRedirect":
        case "linkViaRedirect":
        case "reauthViaRedirect":
            return !0;
        case "unknown":
            return VB(e);
        default:
            return !1
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function xse(e, t = {}) {
    return ua(e, "GET", "/v1/projects", t)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Cse = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
    Ase = /^https?/;
async function Rse(e) {
    if (e.config.emulator) return;
    const {
        authorizedDomains: t
    } = await xse(e);
    for (const n of t) try {
        if (Ose(n)) return
    } catch {}
    Qr(e, "unauthorized-domain")
}

function Ose(e) {
    const t = BE(),
        {
            protocol: n,
            hostname: r
        } = new URL(t);
    if (e.startsWith("chrome-extension://")) {
        const o = new URL(e);
        return o.hostname === "" && r === "" ? n === "chrome-extension:" && e.replace("chrome-extension://", "") === t.replace("chrome-extension://", "") : n === "chrome-extension:" && o.hostname === r
    }
    if (!Ase.test(n)) return !1;
    if (Cse.test(e)) return r === e;
    const s = e.replace(/\./g, "\\.");
    return new RegExp("^(.+\\." + s + "|" + s + ")$", "i").test(r)
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Dse = new Ep(3e4, 6e4);

function UA() {
    const e = Ds().___jsl;
    if (e != null && e.H) {
        for (const t of Object.keys(e.H))
            if (e.H[t].r = e.H[t].r || [], e.H[t].L = e.H[t].L || [], e.H[t].r = [...e.H[t].L], e.CP)
                for (let n = 0; n < e.CP.length; n++) e.CP[n] = null
    }
}

function Nse(e) {
    return new Promise((t, n) => {
        var r, s, i;

        function o() {
            UA(), gapi.load("gapi.iframes", {
                callback: () => {
                    t(gapi.iframes.getContext())
                },
                ontimeout: () => {
                    UA(), n(Os(e, "network-request-failed"))
                },
                timeout: Dse.get()
            })
        }
        if (!((s = (r = Ds().gapi) === null || r === void 0 ? void 0 : r.iframes) === null || s === void 0) && s.Iframe) t(gapi.iframes.getContext());
        else if (!((i = Ds().gapi) === null || i === void 0) && i.load) o();
        else {
            const a = Cre("iframefcb");
            return Ds()[a] = () => {
                gapi.load ? o() : n(Os(e, "network-request-failed"))
            }, $B(`https://apis.google.com/js/api.js?onload=${a}`).catch(l => n(l))
        }
    }).catch(t => {
        throw hg = null, t
    })
}
let hg = null;

function Pse(e) {
    return hg = hg || Nse(e), hg
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Mse = new Ep(5e3, 15e3),
    Lse = "__/auth/iframe",
    Fse = "emulator/auth/iframe",
    Use = {
        style: {
            position: "absolute",
            top: "-100px",
            width: "1px",
            height: "1px"
        },
        "aria-hidden": "true",
        tabindex: "-1"
    },
    Bse = new Map([
        ["identitytoolkit.googleapis.com", "p"],
        ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
        ["test-identitytoolkit.sandbox.googleapis.com", "t"]
    ]);

function Vse(e) {
    const t = e.config;
    be(t.authDomain, e, "auth-domain-config-required");
    const n = t.emulator ? T$(t, Fse) : `https://${e.config.authDomain}/${Lse}`,
        r = {
            apiKey: t.apiKey,
            appName: e.name,
            v: ia
        },
        s = Bse.get(e.config.apiHost);
    s && (r.eid = s);
    const i = e._getFrameworks();
    return i.length && (r.fw = i.join(",")), `${n}?${ju(r).slice(1)}`
}
async function Hse(e) {
    const t = await Pse(e),
        n = Ds().gapi;
    return be(n, e, "internal-error"), t.open({
        where: document.body,
        url: Vse(e),
        messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
        attributes: Use,
        dontclear: !0
    }, r => new Promise(async (s, i) => {
        await r.restyle({
            setHideOnLeave: !1
        });
        const o = Os(e, "network-request-failed"),
            a = Ds().setTimeout(() => {
                i(o)
            }, Mse.get());

        function l() {
            Ds().clearTimeout(a), s(r)
        }
        r.ping(l).then(l, () => {
            i(o)
        })
    }))
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const jse = {
        location: "yes",
        resizable: "yes",
        statusbar: "yes",
        toolbar: "no"
    },
    zse = 500,
    Wse = 600,
    Gse = "_blank",
    qse = "http://localhost";
class BA {
    constructor(t) {
        this.window = t, this.associatedEvent = null
    }
    close() {
        if (this.window) try {
            this.window.close()
        } catch {}
    }
}

function Yse(e, t, n, r = zse, s = Wse) {
    const i = Math.max((window.screen.availHeight - s) / 2, 0).toString(),
        o = Math.max((window.screen.availWidth - r) / 2, 0).toString();
    let a = "";
    const l = Object.assign(Object.assign({}, jse), {
            width: r.toString(),
            height: s.toString(),
            top: i,
            left: o
        }),
        c = Yn().toLowerCase();
    n && (a = gB(c) ? Gse : n), mB(c) && (t = t || qse, l.scrollbars = "yes");
    const u = Object.entries(l).reduce((f, [h, p]) => `${f}${h}=${p},`, "");
    if ($re(c) && a !== "_self") return Kse(t || "", a), new BA(null);
    const d = window.open(t || "", a, u);
    be(d, e, "popup-blocked");
    try {
        d.focus()
    } catch {}
    return new BA(d)
}

function Kse(e, t) {
    const n = document.createElement("a");
    n.href = e, n.target = t;
    const r = document.createEvent("MouseEvent");
    r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(r)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Xse = "__/auth/handler",
    Qse = "emulator/auth/handler",
    Jse = encodeURIComponent("fac");
async function VA(e, t, n, r, s, i) {
    be(e.config.authDomain, e, "auth-domain-config-required"), be(e.config.apiKey, e, "invalid-api-key");
    const o = {
        apiKey: e.config.apiKey,
        appName: e.name,
        authType: n,
        redirectUrl: r,
        v: ia,
        eventId: s
    };
    if (t instanceof C$) {
        t.setDefaultLanguage(e.languageCode), o.providerId = t.providerId || "", Ew(t.getCustomParameters()) || (o.customParameters = JSON.stringify(t.getCustomParameters()));
        for (const [u, d] of Object.entries(i || {})) o[u] = d
    }
    if (t instanceof Tp) {
        const u = t.getScopes().filter(d => d !== "");
        u.length > 0 && (o.scopes = u.join(","))
    }
    e.tenantId && (o.tid = e.tenantId);
    const a = o;
    for (const u of Object.keys(a)) a[u] === void 0 && delete a[u];
    const l = await e._getAppCheckToken(),
        c = l ? `#${Jse}=${encodeURIComponent(l)}` : "";
    return `${Zse(e)}?${ju(a).slice(1)}${c}`
}

function Zse({
    config: e
}) {
    return e.emulator ? T$(e, Qse) : `https://${e.authDomain}/${Xse}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const k0 = "webStorageSupport";
class eie {
    constructor() {
        this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = NB, this._completeRedirectFn = Tse, this._overrideRedirectResult = wse
    }
    async _openPopup(t, n, r, s) {
        var i;
        ki((i = this.eventManagers[t._key()]) === null || i === void 0 ? void 0 : i.manager, "_initialize() not called before _openPopup()");
        const o = await VA(t, n, r, BE(), s);
        return Yse(t, o, A$())
    }
    async _openRedirect(t, n, r, s) {
        await this._originValidation(t);
        const i = await VA(t, n, r, BE(), s);
        return sse(i), new Promise(() => {})
    }
    _initialize(t) {
        const n = t._key();
        if (this.eventManagers[n]) {
            const {
                manager: s,
                promise: i
            } = this.eventManagers[n];
            return s ? Promise.resolve(s) : (ki(i, "If manager is not set, promise should be"), i)
        }
        const r = this.initAndGetManager(t);
        return this.eventManagers[n] = {
            promise: r
        }, r.catch(() => {
            delete this.eventManagers[n]
        }), r
    }
    async initAndGetManager(t) {
        const n = await Hse(t),
            r = new kse(t);
        return n.register("authEvent", s => (be(s == null ? void 0 : s.authEvent, t, "invalid-auth-event"), {
            status: r.onEvent(s.authEvent) ? "ACK" : "ERROR"
        }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[t._key()] = {
            manager: r
        }, this.iframes[t._key()] = n, r
    }
    _isIframeWebStorageSupported(t, n) {
        this.iframes[t._key()].send(k0, {
            type: k0
        }, s => {
            var i;
            const o = (i = s == null ? void 0 : s[0]) === null || i === void 0 ? void 0 : i[k0];
            o !== void 0 && n(!!o), Qr(t, "internal-error")
        }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)
    }
    _originValidation(t) {
        const n = t._key();
        return this.originValidationPromises[n] || (this.originValidationPromises[n] = Rse(t)), this.originValidationPromises[n]
    }
    get _shouldInitProactively() {
        return wB() || k$() || zv()
    }
}
const tie = eie;
var HA = "@firebase/auth",
    jA = "0.23.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nie {
    constructor(t) {
        this.auth = t, this.internalListeners = new Map
    }
    getUid() {
        var t;
        return this.assertAuthConfigured(), ((t = this.auth.currentUser) === null || t === void 0 ? void 0 : t.uid) || null
    }
    async getToken(t) {
        return this.assertAuthConfigured(), await this.auth._initializationPromise, this.auth.currentUser ? {
            accessToken: await this.auth.currentUser.getIdToken(t)
        } : null
    }
    addAuthTokenListener(t) {
        if (this.assertAuthConfigured(), this.internalListeners.has(t)) return;
        const n = this.auth.onIdTokenChanged(r => {
            t((r == null ? void 0 : r.stsTokenManager.accessToken) || null)
        });
        this.internalListeners.set(t, n), this.updateProactiveRefresh()
    }
    removeAuthTokenListener(t) {
        this.assertAuthConfigured();
        const n = this.internalListeners.get(t);
        !n || (this.internalListeners.delete(t), n(), this.updateProactiveRefresh())
    }
    assertAuthConfigured() {
        be(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth")
    }
    updateProactiveRefresh() {
        this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function rie(e) {
    switch (e) {
        case "Node":
            return "node";
        case "ReactNative":
            return "rn";
        case "Worker":
            return "webworker";
        case "Cordova":
            return "cordova";
        default:
            return
    }
}

function sie(e) {
    dr(new Kn("auth", (t, {
        options: n
    }) => {
        const r = t.getProvider("app").getImmediate(),
            s = t.getProvider("heartbeat"),
            i = t.getProvider("app-check-internal"),
            {
                apiKey: o,
                authDomain: a
            } = r.options;
        be(o && !o.includes(":"), "invalid-api-key", {
            appName: r.name
        }), be(!(a != null && a.includes(":")), "argument-error", {
            appName: r.name
        });
        const l = {
                apiKey: o,
                authDomain: a,
                clientPlatform: e,
                apiHost: "identitytoolkit.googleapis.com",
                tokenApiHost: "securetoken.googleapis.com",
                apiScheme: "https",
                sdkClientVersion: EB(e)
            },
            c = new Dre(r, s, i, l);
        return Pre(c, n), c
    }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((t, n, r) => {
        t.getProvider("auth-internal").initialize()
    })), dr(new Kn("auth-internal", t => {
        const n = da(t.getProvider("auth").getImmediate());
        return (r => new nie(r))(n)
    }, "PRIVATE").setInstantiationMode("EXPLICIT")), cn(HA, jA, rie(e)), cn(HA, jA, "esm2017")
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const iie = 5 * 60,
    oie = aP("authIdTokenMaxAge") || iie;
let zA = null;
const aie = e => async t => {
    const n = t && await t.getIdTokenResult(),
        r = n && (new Date().getTime() - Date.parse(n.issuedAtTime)) / 1e3;
    if (r && r > oie) return;
    const s = n == null ? void 0 : n.token;
    zA !== s && (zA = s, await fetch(e, {
        method: s ? "POST" : "DELETE",
        headers: s ? {
            Authorization: `Bearer ${s}`
        } : {}
    }))
};

function HB(e = Il()) {
    const t = vs(e, "auth");
    if (t.isInitialized()) return t.getImmediate();
    const n = Nre(e, {
            popupRedirectResolver: tie,
            persistence: [hse, tse, NB]
        }),
        r = aP("authTokenSyncURL");
    if (r) {
        const i = aie(r);
        Xre(n, i, () => i(n.currentUser)), AB(n, o => i(o))
    }
    const s = oP("auth");
    return s && Mre(n, `http://${s}`), n
}
sie("Browser");
var N_ = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};

function lie(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function cie(e) {
    if (e.__esModule) return e;
    var t = Object.defineProperty({}, "__esModule", {
        value: !0
    });
    return Object.keys(e).forEach(function(n) {
        var r = Object.getOwnPropertyDescriptor(e, n);
        Object.defineProperty(t, n, r.get ? r : {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        })
    }), t
}
var uie = typeof window != "undefined" ? window : typeof N_ != "undefined" ? N_ : typeof self != "undefined" ? self : {};
uie.SENTRY_RELEASE = {
    id: "c2b884bd636dacf90f8c9e821e20a3fb3390e571"
};
const die = !1,
    URe = "mixo.io",
    BRe = "https://app.mixo.io",
    fie = "mixo-admin",
    hie = (e, t) => {
        window != null && window.$crisp && (window == null || window.$crisp.push(["set", "session:data", [
            [
                [e, t]
            ]
        ]]))
    },
    VRe = () => {
        window != null && window.$crisp ? window == null || window.$crisp.push(["do", "chat:open"]) : window.open("mailto:team@mixo.io?subject=Help with Mixo", "_blank").focus()
    },
    pie = {
        apiKey: "AIzaSyAVslymxdABi7BdNzjT1quXFZduuyz6EhE",
        appId: "1:725498859830:web:6421f91ef9f6e95c056397",
        authDomain: "mixo-app.firebaseapp.com",
        databaseURL: "https://mixo-app-default-rtdb.firebaseio.com",
        messagingSenderId: "725498859830",
        projectId: "mixo-app",
        storageBucket: "mixo-app.appspot.com",
        measurementId: "G-JHGL8M7FHL"
    },
    WA = N6(),
    fa = WA.length ? WA[0] : _P(pie),
    GA = () => {
        try {
            EX(fa, {
                provider: new ZT("6LdaL8EfAAAAAPAgV1G_36iCuh49y7cuNDqZpAl5"),
                isTokenAutoRefreshEnabled: !0
            })
        } catch (e) {
            console.log("initializeAppCheck error"), console.error(e)
        }
    };
var QN;
typeof window != "undefined" && ((QN = window == null ? void 0 : window.navigator) != null && QN.onLine && GA(), window == null || window.addEventListener("online", GA));
const Vt = HB(fa),
    O$ = ZG(),
    Br = BK(fa),
    Fi = U7(fa, "us-west2"),
    bh = v7(fa),
    mie = ({
        app: e
    }) => {
        e.provide("firebaseApp", fa), e.provide("firebaseAuth", Vt), Vt.onAuthStateChanged(t => {
            t && (QQ({
                email: t == null ? void 0 : t.email,
                id: t == null ? void 0 : t.uid,
                displayName: t == null ? void 0 : t.displayName
            }), hie("userId", t == null ? void 0 : t.uid), ["adam@mixo.io", "giles@fuzzylogic.ai", "adam@fuzzylogic.ai", "adam@mixvisor.com", "giles@mixvisor.com", "giles@mixo.io", "arbolino@gmail.com"].includes(t == null ? void 0 : t.email) && (window == null || window.localStorage.setItem(fie, !0)))
        })
    };
var gie = Object.freeze(Object.defineProperty({
    __proto__: null,
    firebaseApp: fa,
    firebaseAuth: Vt,
    rtdb: O$,
    firestore: Br,
    functions: Fi,
    analytics: bh,
    install: mie
}, Symbol.toStringTag, {
    value: "Module"
}));
const jB = ["__key", "__init", "__shim", "__original", "__index", "__prevKey"];

function ha() {
    return Math.random().toString(36).substring(2, 15)
}

function _ie(e, t) {
    const n = e instanceof Set ? e : new Set(e);
    return t && t.forEach(r => n.add(r)), [...n]
}

function De(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}

function Qe(e, t, n = !0, r = ["__key"]) {
    if (e === t) return !0;
    if (typeof t == "object" && typeof e == "object") {
        if (e instanceof Map || e instanceof Set || e instanceof Date || e === null || t === null || Object.keys(e).length !== Object.keys(t).length) return !1;
        for (const s of r)
            if ((s in e || s in t) && e[s] !== t[s]) return !1;
        for (const s in e)
            if (!(s in t) || e[s] !== t[s] && !n || n && !Qe(e[s], t[s], n, r)) return !1;
        return !0
    }
    return !1
}

function wh(e) {
    const t = typeof e;
    if (t === "number") return !1;
    if (e === void 0) return !0;
    if (t === "string") return e === "";
    if (t === "object") {
        if (e === null) return !0;
        for (const n in e) return !1;
        return !(e instanceof RegExp || e instanceof Date)
    }
    return !1
}

function yie(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}

function vie(e) {
    const t = `^${yie(e)}$`,
        n = {
            MM: "(0[1-9]|1[012])",
            M: "([1-9]|1[012])",
            DD: "([012][0-9]|3[01])",
            D: "([012]?[0-9]|3[01])",
            YYYY: "\\d{4}",
            YY: "\\d{2}"
        },
        r = Object.keys(n);
    return new RegExp(r.reduce((s, i) => s.replace(i, n[i]), t))
}

function Bs(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}

function ml(e) {
    return Bs(e) || Array.isArray(e)
}

function gl(e) {
    if (Bs(e) === !1 || e.__FKNode__ || e.__POJO__ === !1) return !1;
    const t = e.constructor;
    if (t === void 0) return !0;
    const n = t.prototype;
    return !(Bs(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)
}

function _l(e, t, n = !1, r = !1) {
    if (t === null) return null;
    const s = {};
    if (typeof t == "string") return t;
    for (const i in e)
        if (De(t, i) && (t[i] !== void 0 || !r)) {
            if (n && Array.isArray(e[i]) && Array.isArray(t[i])) {
                s[i] = e[i].concat(t[i]);
                continue
            }
            if (t[i] === void 0) continue;
            gl(e[i]) && gl(t[i]) ? s[i] = _l(e[i], t[i], n, r) : s[i] = t[i]
        } else s[i] = e[i];
    for (const i in t) !De(s, i) && t[i] !== void 0 && (s[i] = t[i]);
    return s
}

function bie(e) {
    if (e[0] !== '"' && e[0] !== "'" || e[0] !== e[e.length - 1]) return !1;
    const t = e[0];
    for (let n = 1; n < e.length; n++)
        if (e[n] === t && (n === 1 || e[n - 1] !== "\\") && n !== e.length - 1) return !1;
    return !0
}

function wie(e) {
    if (!e.length) return "";
    let t = "",
        n = "";
    for (let r = 0; r < e.length; r++) {
        const s = e.charAt(r);
        (s !== "\\" || n === "\\") && (t += s), n = s
    }
    return t
}

function Ql(...e) {
    return e.reduce((t, n) => {
        const c = n,
            {
                value: r,
                name: s,
                modelValue: i,
                config: o,
                plugins: a
            } = c,
            l = Gr(c, ["value", "name", "modelValue", "config", "plugins"]);
        return Object.assign(t, l)
    }, {})
}

function Eie(e) {
    const t = [];
    let n = "",
        r = 0,
        s = "",
        i = "";
    for (let o = 0; o < e.length; o++) {
        const a = e.charAt(o);
        a === s && i !== "\\" ? s = "" : (a === "'" || a === '"') && !s && i !== "\\" ? s = a : a === "(" && !s ? r++ : a === ")" && !s && r--, a === "," && !s && r === 0 ? (t.push(n), n = "") : (a !== " " || s) && (n += a), i = a
    }
    return n && t.push(n), t
}

function qA(e, t) {
    const n = {},
        r = t.filter(i => i instanceof RegExp),
        s = new Set(t);
    for (const i in e) !s.has(i) && !r.some(o => o.test(i)) && (n[i] = e[i]);
    return n
}

function YA(e, t) {
    const n = {},
        r = t.filter(s => s instanceof RegExp);
    return t.forEach(s => {
        s instanceof RegExp || (n[s] = e[s])
    }), Object.keys(e).forEach(s => {
        r.some(i => i.test(s)) && (n[s] = e[s])
    }), n
}

function Fc(e) {
    return e.replace(/-([a-z0-9])/gi, (t, n) => n.toUpperCase())
}

function zB(e) {
    return e.replace(/([a-z0-9])([A-Z])/g, (t, n, r) => n + "-" + r.toLowerCase()).replace(" ", "-").toLowerCase()
}

function KA(e, t = jB) {
    if (e !== null && typeof e == "object") {
        let n;
        if (Array.isArray(e) ? n = [...e] : gl(e) && (n = x({}, e)), n) return Tie(e, n, t), n
    }
    return e
}

function qo(e, t = jB) {
    if (e === null || e instanceof RegExp || e instanceof Date || e instanceof Map || e instanceof Set || typeof File == "function" && e instanceof File) return e;
    let n;
    Array.isArray(e) ? n = e.map(r => typeof r == "object" ? qo(r, t) : r) : n = Object.keys(e).reduce((r, s) => (r[s] = typeof e[s] == "object" ? qo(e[s], t) : e[s], r), {});
    for (const r of t) r in e && Object.defineProperty(n, r, {
        enumerable: !1,
        value: e[r]
    });
    return n
}

function Kr(e) {
    return typeof e == "object" ? qo(e) : e
}

function Sie(e, t) {
    if (!e || typeof e != "object") return null;
    const n = t.split(".");
    let r = e;
    for (const s in n) {
        const i = n[s];
        if (De(r, i) && (r = r[i]), +s === n.length - 1) return r;
        if (!r || typeof r != "object") return null
    }
    return null
}

function Ye(e) {
    return e !== void 0 && e !== "false" && e !== !1 ? !0 : void 0
}

function Eh(e) {
    return Object.isFrozen(e) ? e : Object.defineProperty(e, "__init", {
        enumerable: !1,
        value: !0
    })
}

function D$(e) {
    return e.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().replace(/[^a-z0-9]/g, " ").trim().replace(/\s+/g, "-")
}

function Tie(e, t, n) {
    for (const r of n) r in e && Object.defineProperty(t, r, {
        enumerable: !1,
        value: e[r]
    });
    return t
}

function N$() {
    const e = [];
    let t = 0;
    const n = s => e.push(s),
        r = s => {
            const i = e[t];
            return typeof i == "function" ? i(s, o => (t++, r(o === void 0 ? s : o))) : (t = 0, s)
        };
    return n.dispatch = r, n.unshift = s => e.unshift(s), n.remove = s => {
        const i = e.indexOf(s);
        i > -1 && e.splice(i, 1)
    }, n
}

function WB() {
    const e = new Map,
        t = new Map;
    let n;
    const r = (s, i) => {
        if (n) {
            n.set(i.name, [s, i]);
            return
        }
        e.has(i.name) && e.get(i.name).forEach(o => {
            (i.origin === s || o.modifiers.includes("deep")) && o.listener(i)
        }), i.bubble && s.bubble(i)
    };
    return r.on = (s, i) => {
        const [o, ...a] = s.split("."), l = i.receipt || ha(), c = {
            modifiers: a,
            event: o,
            listener: i,
            receipt: l
        };
        return e.has(o) ? e.get(o).push(c) : e.set(o, [c]), t.has(l) ? t.get(l).push(o) : t.set(l, [o]), l
    }, r.off = s => {
        var i;
        t.has(s) && ((i = t.get(s)) === null || i === void 0 || i.forEach(o => {
            const a = e.get(o);
            Array.isArray(a) && e.set(o, a.filter(l => l.receipt !== s))
        }), t.delete(s))
    }, r.pause = s => {
        n || (n = new Map), s && s.walk(i => i._e.pause())
    }, r.play = s => {
        if (!n) return;
        const i = n;
        n = void 0, i.forEach(([o, a]) => r(o, a)), s && s.walk(o => o._e.play())
    }, r
}

function $ie(e, t, n, r, s = !0) {
    return t._e(e, {
        payload: r,
        name: n,
        bubble: s,
        origin: e
    }), e
}

function kie(e, t, n) {
    return kp(e.parent) && e.parent._e(e.parent, n), e
}

function Iie(e, t, n, r) {
    return t._e.on(n, r)
}

function xie(e, t, n) {
    return t._e.off(n), e
}
const P$ = N$();
P$((e, t) => (e.message || (e.message = String(`E${e.code}`)), t(e)));
const M$ = N$();
M$((e, t) => {
    e.message || (e.message = String(`W${e.code}`));
    const n = t(e);
    return console && typeof console.warn == "function" && console.warn(n.message), n
});

function Dl(e, t = {}) {
    M$.dispatch({
        code: e,
        data: t
    })
}

function Tr(e, t = {}) {
    throw Error(P$.dispatch({
        code: e,
        data: t
    }).message)
}

function Nn(e, t) {
    const n = x({
        blocking: !1,
        key: ha(),
        meta: {},
        type: "state",
        visible: !0
    }, e);
    return t && n.value && n.meta.localize !== !1 && (n.value = t.t(n), n.meta.locale = t.config.locale), n
}
const XA = {
    apply: Nie,
    set: Aie,
    remove: GB,
    filter: Oie,
    reduce: Die,
    release: Lie,
    touch: Rie
};

function Cie(e = !1) {
    const t = {};
    let n, r = e,
        s = [];
    const i = new Map;
    let o;
    const a = new Proxy(t, {
        get(...l) {
            const [c, u] = l;
            return u === "buffer" ? r : u === "_b" ? s : u === "_m" ? i : u === "_r" ? o : De(XA, u) ? XA[u].bind(null, t, a, n) : Reflect.get(...l)
        },
        set(l, c, u) {
            return c === "_n" ? (n = u, o === "__n" && qB(n, a), !0) : c === "_b" ? (s = u, !0) : c === "buffer" ? (r = u, !0) : c === "_r" ? (o = u, !0) : (Tr(101, n), !1)
        }
    });
    return a
}

function Aie(e, t, n, r) {
    if (t.buffer) return t._b.push([
        [r]
    ]), t;
    if (e[r.key] !== r) {
        if (typeof r.value == "string" && r.meta.localize !== !1) {
            const i = r.value;
            r.value = n.t(r), r.value !== i && (r.meta.locale = n.props.locale)
        }
        const s = `message-${De(e,r.key)?"updated":"added"}`;
        e[r.key] = Object.freeze(n.hook.message.dispatch(r)), n.emit(s, r)
    }
    return t
}

function Rie(e, t) {
    for (const n in e) {
        const r = x({}, e[n]);
        t.set(r)
    }
}

function GB(e, t, n, r) {
    if (De(e, r)) {
        const s = e[r];
        delete e[r], n.emit("message-removed", s)
    }
    return t.buffer === !0 && (t._b = t._b.filter(s => (s[0] = s[0].filter(i => i.key !== r), s[1] || s[0].length))), t
}

function Oie(e, t, n, r, s) {
    for (const i in e) {
        const o = e[i];
        (!s || o.type === s) && !r(o) && GB(e, t, n, i)
    }
}

function Die(e, t, n, r, s) {
    for (const i in e) {
        const o = e[i];
        s = r(s, o)
    }
    return s
}

function Nie(e, t, n, r, s) {
    if (Array.isArray(r)) {
        if (t.buffer) {
            t._b.push([r, s]);
            return
        }
        const i = new Set(r.map(o => (t.set(o), o.key)));
        typeof s == "string" ? t.filter(o => o.type !== s || i.has(o.key)) : typeof s == "function" && t.filter(o => !s(o) || i.has(o.key))
    } else
        for (const i in r) {
            const o = n.at(i);
            o ? o.store.apply(r[i], s) : Mie(n, t, i, r[i], s)
        }
}

function Pie(e, ...t) {
    const n = `${e.name}-set`,
        r = s => Nn({
            key: D$(s),
            type: "error",
            value: s,
            meta: {
                source: n,
                autoClear: !0
            }
        });
    return t.filter(s => !!s).map(s => {
        if (typeof s == "string" && (s = [s]), Array.isArray(s)) return s.map(i => r(i)); {
            const i = {};
            for (const o in s) Array.isArray(s[o]) ? i[o] = s[o].map(a => r(a)) : i[o] = [r(s[o])];
            return i
        }
    })
}

function Mie(e, t, n, r, s) {
    var i;
    const o = t._m;
    o.has(n) || o.set(n, []), t._r || (t._r = qB(e, t)), (i = o.get(n)) === null || i === void 0 || i.push([r, s])
}

function qB(e, t) {
    return e.on("child.deep", ({
        payload: n
    }) => {
        t._m.forEach((r, s) => {
            e.at(s) === n && (r.forEach(([i, o]) => {
                n.store.apply(i, o)
            }), t._m.delete(s))
        }), t._m.size === 0 && t._r && (e.off(t._r), t._r = void 0)
    })
}

function Lie(e, t) {
    t.buffer = !1, t._b.forEach(([n, r]) => t.apply(n, r)), t._b = []
}

function Fie() {
    const e = {};
    let t;
    return {
        count: (...n) => Uie(t, e, ...n),
        init(n) {
            t = n, n.on("message-added.deep", QA(e, 1)), n.on("message-removed.deep", QA(e, -1))
        },
        merge: n => JA(t, e, n),
        settled(n) {
            return De(e, n) ? e[n].promise : Promise.resolve()
        },
        unmerge: n => JA(t, e, n, !0),
        value(n) {
            return De(e, n) ? e[n].count : 0
        }
    }
}

function Uie(e, t, n, r, s = 0) {
    if (r = Bie(r || n), !De(t, n)) {
        const i = {
            condition: r,
            count: 0,
            name: n,
            node: e,
            promise: Promise.resolve(),
            resolve: () => {}
        };
        t[n] = i, s = e.store.reduce((o, a) => o + i.condition(a) * 1, s), e.each(o => {
            o.ledger.count(i.name, i.condition), s += o.ledger.value(i.name)
        })
    }
    return YB(t[n], s).promise
}

function Bie(e) {
    return typeof e == "function" ? e : t => t.type === e
}

function YB(e, t) {
    const n = e.count,
        r = e.count + t;
    return e.count = r, n === 0 && r !== 0 ? (e.node.emit(`unsettled:${e.name}`, e.count, !1), e.promise = new Promise(s => e.resolve = s)) : n !== 0 && r === 0 && (e.node.emit(`settled:${e.name}`, e.count, !1), e.resolve()), e.node.emit(`count:${e.name}`, e.count, !1), e
}

function QA(e, t) {
    return n => {
        for (const r in e) {
            const s = e[r];
            s.condition(n.payload) && YB(s, t)
        }
    }
}

function JA(e, t, n, r = !1) {
    for (const s in t) {
        const i = t[s].condition;
        r || n.ledger.count(s, i);
        const o = n.ledger.value(s) * (r ? -1 : 1);
        if (!!e)
            do e.ledger.count(s, i, o), e = e.parent; while (e)
    }
}
const L$ = new Map,
    pg = new Map,
    F$ = WB(),
    Vie = [];

function Hie(e) {
    e.props.id && (L$.set(e.props.id, e), pg.set(e, e.props.id), F$(e, {
        payload: e,
        name: e.props.id,
        bubble: !1,
        origin: e
    }))
}

function jie(e) {
    if (pg.has(e)) {
        const t = pg.get(e);
        pg.delete(e), L$.delete(t), F$(e, {
            payload: null,
            name: t,
            bubble: !1,
            origin: e
        })
    }
}

function Ro(e) {
    return L$.get(e)
}

function zie(e, t) {
    Vie.push(F$.on(e, t))
}

function HE(e, t, n) {
    let r = !0;
    return t in e.config._t ? r = !1 : e.emit(`config:${t}`, n, !1), t in e.props || (e.emit("prop", {
        prop: t,
        value: n
    }), e.emit(`prop:${t}`, n)), r
}

function Wie(e = {}) {
    const t = new Set,
        n = G(x({}, e), {
            _add: s => t.add(s),
            _rm: s => t.delete(s)
        });
    return new Proxy(n, {
        set(s, i, o, a) {
            return typeof i == "string" && t.forEach(l => HE(l, i, o)), Reflect.set(s, i, o, a)
        }
    })
}

function KB(e) {
    const t = document.getElementById(e);
    if (t instanceof HTMLFormElement) {
        const n = new Event("submit", {
            cancelable: !0,
            bubbles: !0
        });
        t.dispatchEvent(n);
        return
    }
    Dl(151, e)
}

function Gie(e) {
    const t = n => {
        for (const r in n.store) {
            const s = n.store[r];
            s.type === "error" || s.type === "ui" && r === "incomplete" ? n.store.remove(r) : s.type === "state" && n.store.set(G(x({}, s), {
                value: !1
            }))
        }
    };
    t(e), e.walk(t)
}

function XB(e, t) {
    const n = typeof e == "string" ? Ro(e) : e;
    if (n) {
        const r = i => Kr(i.props.initial) || (i.type === "group" ? {} : i.type === "list" ? [] : void 0);
        n._e.pause(n), n.input(Kr(t) || r(n), !1), n.walk(i => i.input(r(i), !1));
        const s = r(n);
        return n.input(typeof s == "object" ? Kr(t) || Eh(s) : s, !1), n._e.play(n), Gie(n), n.emit("reset", n), n
    }
    Dl(152, e)
}
const qie = {
        delimiter: ".",
        delay: 0,
        locale: "en",
        rootClasses: e => ({
            [`formkit-${zB(e)}`]: !0
        })
    },
    QB = Symbol("index"),
    jE = Symbol("removed"),
    zE = Symbol("moved"),
    JB = Symbol("inserted");

function Yie(e) {
    return e.type === "list" && Array.isArray(e._value)
}

function kp(e) {
    return e && typeof e == "object" && e.__FKNode__ === !0
}
const mg = (e, t, n) => {
        Tr(102, [e, n])
    },
    Kie = {
        _c: Ze(goe, mg, !1),
        add: Ze(loe),
        addProps: Ze(aoe),
        address: Ze(yoe, mg, !1),
        at: Ze(voe),
        bubble: Ze(kie),
        clearErrors: Ze(Ioe),
        calm: Ze(soe),
        config: Ze(!1),
        define: Ze(ooe),
        disturb: Ze(roe),
        destroy: Ze(ioe),
        hydrate: Ze(noe),
        index: Ze(moe, poe, !1),
        input: Ze(e5),
        each: Ze(doe),
        emit: Ze($ie),
        find: Ze(woe),
        on: Ze(Iie),
        off: Ze(xie),
        parent: Ze(!1, coe),
        plugins: Ze(!1),
        remove: Ze(uoe),
        root: Ze(Soe, mg, !1),
        reset: Ze(koe),
        resetConfig: Ze(hoe),
        setErrors: Ze(r5),
        submit: Ze($oe),
        t: Ze(Toe),
        use: Ze(U$),
        name: Ze(_oe, !1, !1),
        walk: Ze(foe)
    };

function Xie() {
    return new Map(Object.entries(Kie))
}

function Ze(e, t, n = !0) {
    return {
        get: e ? (r, s) => n ? (...i) => e(r, s, ...i) : e(r, s) : !1,
        set: t !== void 0 ? t : mg.bind(null)
    }
}

function Qie() {
    const e = new Map;
    return new Proxy(e, {
        get(t, n) {
            return e.has(n) || e.set(n, N$()), e.get(n)
        }
    })
}
let Jie = 0,
    Zie = 0;

function eoe(e) {
    var t, n;
    return ((t = e.parent) === null || t === void 0 ? void 0 : t.type) === "list" ? QB : e.name || `${((n=e.props)===null||n===void 0?void 0:n.type)||"input"}_${++Jie}`
}

function ZB(e) {
    return e.type === "group" ? Eh(e.value && typeof e.value == "object" && !Array.isArray(e.value) ? e.value : {}) : e.type === "list" ? Eh(Array.isArray(e.value) ? e.value : []) : e.value
}

function e5(e, t, n, r = !0) {
    return t._value = toe(e, e.hook.input.dispatch(n)), e.emit("input", t._value), t.isSettled && e.disturb(), r ? (t._tmo && clearTimeout(t._tmo), t._tmo = setTimeout(P_, e.props.delay, e, t)) : P_(e, t), t.settled
}

function toe(e, t) {
    switch (e.type) {
        case "input":
            break;
        case "group":
            (!t || typeof t != "object") && Tr(107, [e, t]);
            break;
        case "list":
            Array.isArray(t) || Tr(108, [e, t]);
            break
    }
    return t
}

function P_(e, t, n = !0, r = !0) {
    t._value = t.value = e.hook.commit.dispatch(t._value), e.type !== "input" && r && e.hydrate(), e.emit("commit", t.value), n && e.calm()
}

function t5(e, {
    name: t,
    value: n,
    from: r
}) {
    if (!Object.isFrozen(e._value)) {
        if (Yie(e)) {
            const s = n === jE ? [] : n === zE && typeof r == "number" ? e._value.splice(r, 1) : [n];
            e._value.splice(t, n === zE || r === JB ? 0 : 1, ...s);
            return
        }
        n !== jE ? e._value[t] = n : delete e._value[t]
    }
}

function noe(e, t) {
    const n = t._value;
    return t.children.forEach(r => {
        if (typeof n == "object")
            if (r.name in n) {
                const s = r.type !== "input" || n[r.name] && typeof n[r.name] == "object" ? Eh(n[r.name]) : n[r.name];
                r.input(s, !1)
            } else(e.type !== "list" || typeof r.name == "number") && t5(t, {
                name: r.name,
                value: r.value
            }), n.__init || (r.type === "group" ? r.input({}, !1) : r.type === "list" ? r.input([], !1) : r.input(void 0, !1))
    }), e
}

function roe(e, t) {
    var n;
    return t._d <= 0 && (t.isSettled = !1, e.emit("settled", !1, !1), t.settled = new Promise(r => {
        t._resolve = r
    }), e.parent && ((n = e.parent) === null || n === void 0 || n.disturb())), t._d++, e
}

function soe(e, t, n) {
    var r;
    if (n !== void 0 && e.type !== "input") return t5(t, n), P_(e, t, !0, !1);
    t._d > 0 && t._d--, t._d === 0 && (t.isSettled = !0, e.emit("settled", !0, !1), e.parent && ((r = e.parent) === null || r === void 0 || r.calm({
        name: e.name,
        value: t.value
    })), t._resolve && t._resolve(t.value))
}

function ioe(e, t) {
    e.emit("destroying", e), e.store.filter(() => !1), e.parent && (e.parent.emit("childRemoved", e), e.parent.remove(e)), jie(e), t._value = t.value = void 0, e.emit("destroyed", e)
}

function ooe(e, t, n) {
    t.type = n.type, t.props.definition = qo(n), t.value = t._value = ZB({
        type: e.type,
        value: t.value
    }), n.forceTypeProp && (e.props.type && (e.props.originalType = e.props.type), t.props.type = n.forceTypeProp), n.family && (t.props.family = n.family), n.features && n.features.forEach(r => r(e)), n.props && e.addProps(n.props), e.emit("defined", n)
}

function aoe(e, t, n) {
    var r;
    if (e.props.attrs) {
        const s = x({}, e.props.attrs);
        e.props._emit = !1;
        for (const o in s) {
            const a = Fc(o);
            n.includes(a) && (e.props[a] = s[o], delete s[o])
        }
        const i = Kr(t._value);
        e.props.initial = e.type !== "input" ? Eh(i) : i, e.props._emit = !0, e.props.attrs = s, e.props.definition && (e.props.definition.props = [...((r = e.props.definition) === null || r === void 0 ? void 0 : r.props) || [], ...n])
    }
    return e.emit("added-props", n), e
}

function loe(e, t, n, r) {
    if (e.type === "input" && Tr(100, e), n.parent && n.parent !== e && n.parent.remove(n), t.children.includes(n) || (r !== void 0 && e.type === "list" ? (t.children.splice(r, 0, n), Array.isArray(e.value) && e.value.length < t.children.length && e.disturb().calm({
            name: r,
            value: n.value,
            from: JB
        })) : t.children.push(n), n.isSettled || e.disturb()), n.parent !== e) {
        if (n.parent = e, n.parent !== e) return e.remove(n), n.parent.add(n), e
    } else n.use(e.plugins);
    return P_(e, t, !1), e.ledger.merge(n), e.emit("child", n), e
}

function coe(e, t, n, r) {
    return kp(r) ? (e.parent && e.parent !== r && e.parent.remove(e), t.parent = r, e.resetConfig(), r.children.includes(e) ? e.use(r.plugins) : r.add(e), !0) : r === null ? (t.parent = null, !0) : !1
}

function uoe(e, t, n) {
    const r = t.children.indexOf(n);
    if (r !== -1) {
        n.isSettled && e.disturb(), t.children.splice(r, 1);
        let s = Ye(n.props.preserve),
            i = n.parent;
        for (; s === void 0 && i;) s = Ye(i.props.preserve), i = i.parent;
        s ? e.calm() : e.calm({
            name: e.type === "list" ? r : n.name,
            value: jE
        }), n.parent = null, n.config._rmn = n
    }
    return e.ledger.unmerge(n), e
}

function doe(e, t, n) {
    t.children.forEach(r => n(r))
}

function foe(e, t, n, r = !1) {
    t.children.forEach(s => {
        (n(s) !== !1 || !r) && s.walk(n, r)
    })
}

function hoe(e, t) {
    const n = e.parent || void 0;
    t.config = n5(e.config._t, n), e.walk(r => r.resetConfig())
}

function U$(e, t, n, r = !0, s = !0) {
    return Array.isArray(n) || n instanceof Set ? (n.forEach(i => U$(e, t, i)), e) : (t.plugins.has(n) || (s && typeof n.library == "function" && n.library(e), r && n(e) !== !1 && (t.plugins.add(n), e.children.forEach(i => i.use(n)))), e)
}

function poe(e, t, n, r) {
    if (kp(e.parent)) {
        const s = e.parent.children,
            i = r >= s.length ? s.length - 1 : r < 0 ? 0 : r,
            o = s.indexOf(e);
        return o === -1 ? !1 : (s.splice(o, 1), s.splice(i, 0, e), e.parent.children = s, e.parent.type === "list" && e.parent.disturb().calm({
            name: i,
            value: zE,
            from: o
        }), !0)
    }
    return !1
}

function moe(e) {
    if (e.parent) {
        const t = [...e.parent.children].indexOf(e);
        return t === -1 ? e.parent.children.length : t
    }
    return -1
}

function goe(e, t) {
    return t
}

function _oe(e, t) {
    var n;
    return ((n = e.parent) === null || n === void 0 ? void 0 : n.type) === "list" ? e.index : t.name !== QB ? t.name : e.index
}

function yoe(e, t) {
    return t.parent ? t.parent.address.concat([e.name]) : [e.name]
}

function voe(e, t, n) {
    const r = typeof n == "string" ? n.split(e.config.delimiter) : n;
    if (!r.length) return;
    const s = r[0];
    let i = e.parent;
    for (i || (String(r[0]) === String(e.name) && r.shift(), i = e), s === "$parent" && r.shift(); i && r.length;) {
        const o = r.shift();
        switch (o) {
            case "$root":
                i = e.root;
                break;
            case "$parent":
                i = i.parent;
                break;
            case "$self":
                i = e;
                break;
            default:
                i = i.children.find(a => String(a.name) === String(o)) || boe(i, o)
        }
    }
    return i || void 0
}

function boe(e, t) {
    const n = String(t).match(/^(find)\((.*)\)$/);
    if (n) {
        const [, r, s] = n, i = s.split(",").map(o => o.trim());
        switch (r) {
            case "find":
                return e.find(i[0], i[1]);
            default:
                return
        }
    }
}

function woe(e, t, n, r) {
    return Eoe(e, n, r)
}

function Eoe(e, t, n = "name") {
    const r = typeof n == "string" ? i => i[n] == t : n,
        s = [e];
    for (; s.length;) {
        const i = s.shift();
        if (r(i, t)) return i;
        s.push(...i.children)
    }
}

function Soe(e) {
    let t = e;
    for (; t.parent;) t = t.parent;
    return t
}

function n5(e = {}, t) {
    let n;
    return new Proxy(e, {
        get(...r) {
            const s = r[1];
            if (s === "_t") return e;
            const i = Reflect.get(...r);
            if (i !== void 0) return i;
            if (t) {
                const o = t.config[s];
                if (o !== void 0) return o
            }
            if (e.rootConfig && typeof s == "string") {
                const o = e.rootConfig[s];
                if (o !== void 0) return o
            }
            return s === "delay" && (n == null ? void 0 : n.type) === "input" ? 20 : qie[s]
        },
        set(...r) {
            const s = r[1],
                i = r[2];
            if (s === "_n") return n = i, e.rootConfig && e.rootConfig._add(n), !0;
            if (s === "_rmn") return e.rootConfig && e.rootConfig._rm(n), n = void 0, !0;
            if (!Qe(e[s], i, !1)) {
                const o = Reflect.set(...r);
                return n && (n.emit(`config:${s}`, i, !1), HE(n, s, i), n.walk(a => HE(a, s, i), !0)), o
            }
            return !0
        }
    })
}

function Toe(e, t, n, r = "ui") {
    const s = typeof n == "string" ? {
            key: n,
            value: n,
            type: r
        } : n,
        i = e.hook.text.dispatch(s);
    return e.emit("text", i, !1), i.value
}

function $oe(e) {
    const t = e.name;
    do {
        if (e.props.isForm === !0) break;
        e.parent || Tr(106, t), e = e.parent
    } while (e);
    e.props.id && KB(e.props.id)
}

function koe(e, t, n) {
    return XB(e, n)
}

function r5(e, t, n, r) {
    const s = `${e.name}-set`,
        i = e.hook.setErrors.dispatch({
            localErrors: n,
            childErrors: r
        });
    return Pie(e, i.localErrors, i.childErrors).forEach(o => {
        e.store.apply(o, a => a.meta.source === s)
    }), e
}

function Ioe(e, t, n = !0, r) {
    return r5(e, t, []), n && (r = r || `${e.name}-set`, e.walk(s => {
        s.store.filter(i => !(i.type === "error" && i.meta && i.meta.source === r))
    })), e
}

function xoe(e) {
    return De(e.props, "id") || (e.props.id = `input_${Zie++}`), e
}

function Coe(e) {
    const t = {
        initial: typeof e == "object" ? Kr(e) : e
    };
    let n, r = !0;
    return new Proxy(t, {
        get(...s) {
            const [i, o] = s;
            if (De(t, o)) return Reflect.get(...s);
            if (n && typeof o == "string" && n.config[o] !== void 0) return n.config[o]
        },
        set(s, i, o, a) {
            if (i === "_n") return n = o, !0;
            if (i === "_emit") return r = o, !0;
            const {
                prop: l,
                value: c
            } = n.hook.prop.dispatch({
                prop: i,
                value: o
            });
            if (!Qe(t[l], c, !1) || typeof c == "object") {
                const u = Reflect.set(s, l, c, a);
                return r && (n.emit("prop", {
                    prop: l,
                    value: c
                }), typeof l == "string" && n.emit(`prop:${l}`, c)), u
            }
            return !0
        }
    })
}

function Aoe(e, t) {
    if (e.props.definition) return e.define(e.props.definition);
    for (const n of t) {
        if (e.props.definition) return;
        typeof n.library == "function" && n.library(e)
    }
}

function Roe(e) {
    const t = ZB(e),
        n = n5(e.config || {}, e.parent);
    return {
        _d: 0,
        _e: WB(),
        _resolve: !1,
        _tmo: !1,
        _value: t,
        children: _ie(e.children || []),
        config: n,
        hook: Qie(),
        isCreated: !1,
        isSettled: !0,
        ledger: Fie(),
        name: eoe(e),
        parent: e.parent || null,
        plugins: new Set,
        props: Coe(t),
        settled: Promise.resolve(t),
        store: Cie(!0),
        traps: Xie(),
        type: e.type || "input",
        value: t
    }
}

function Ooe(e, t) {
    var n;
    if (e.ledger.init(e.store._n = e.props._n = e.config._n = e), e.props._emit = !1, t.props && Object.assign(e.props, t.props), e.props._emit = !0, Aoe(e, new Set([...t.plugins || [], ...e.parent ? e.parent.plugins : []])), t.plugins)
        for (const r of t.plugins) U$(e, e._c, r, !0, !1);
    return xoe(e), e.each(r => e.add(r)), e.parent && e.parent.add(e, t.index), e.type === "input" && e.children.length && Tr(100, e), e5(e, e._c, e._value, !1), e.store.release(), !((n = t.props) === null || n === void 0) && n.id && Hie(e), e.emit("created", e), e.isCreated = !0, e
}

function Doe(e) {
    const t = e || {},
        n = Roe(t),
        r = new Proxy(n, {
            get(...s) {
                const [, i] = s;
                if (i === "__FKNode__") return !0;
                const o = n.traps.get(i);
                return o && o.get ? o.get(r, n) : Reflect.get(...s)
            },
            set(...s) {
                const [, i, o] = s, a = n.traps.get(i);
                return a && a.set ? a.set(r, n, i, o) : Reflect.set(...s)
            }
        });
    return Ooe(r, t)
}

function Sh(e) {
    return typeof e != "string" && De(e, "$el")
}

function Th(e) {
    return typeof e != "string" && De(e, "$cmp")
}

function lc(e) {
    return !e || typeof e == "string" ? !1 : De(e, "if") && De(e, "then")
}

function Noe(e) {
    return typeof e != "string" && "$formkit" in e
}

function Poe(e) {
    if (typeof e == "string") return {
        $el: "text",
        children: e
    };
    if (Noe(e)) {
        const t = e,
            {
                $formkit: n,
                for: r,
                if: s,
                children: i,
                bind: o
            } = t,
            a = Gr(t, ["$formkit", "for", "if", "children", "bind"]);
        return Object.assign({
            $cmp: "FormKit",
            props: G(x({}, a), {
                type: n
            })
        }, s ? {
            if: s
        } : {}, r ? {
            for: r
        } : {}, i ? {
            children: i
        } : {}, o ? {
            bind: o
        } : {})
    }
    return e
}

function Zr(e) {
    let t;
    const n = new Set,
        r = function(g, y) {
            return typeof g == "function" ? g(y) : g
        },
        s = [{
            "&&": (m, g, y) => r(m, y) && r(g, y),
            "||": (m, g, y) => r(m, y) || r(g, y)
        }, {
            "===": (m, g, y) => r(m, y) === r(g, y),
            "!==": (m, g, y) => r(m, y) !== r(g, y),
            "==": (m, g, y) => r(m, y) == r(g, y),
            "!=": (m, g, y) => r(m, y) != r(g, y),
            ">=": (m, g, y) => r(m, y) >= r(g, y),
            "<=": (m, g, y) => r(m, y) <= r(g, y),
            ">": (m, g, y) => r(m, y) > r(g, y),
            "<": (m, g, y) => r(m, y) < r(g, y)
        }, {
            "+": (m, g, y) => r(m, y) + r(g, y),
            "-": (m, g, y) => r(m, y) - r(g, y)
        }, {
            "*": (m, g, y) => r(m, y) * r(g, y),
            "/": (m, g, y) => r(m, y) / r(g, y),
            "%": (m, g, y) => r(m, y) % r(g, y)
        }],
        i = s.reduce((m, g) => m.concat(Object.keys(g)), []),
        o = new Set(i.map(m => m.charAt(0)));

    function a(m, g, y, _) {
        const E = m.filter(b => b.startsWith(g));
        return E.length ? E.find(b => _.length >= y + b.length && _.substring(y, y + b.length) === b ? b : !1) : !1
    }

    function l(m, g, y = 1) {
        let _ = y ? g.substring(m + 1).trim() : g.substring(0, m).trim();
        if (!_.length) return -1;
        if (!y) {
            const b = _.split("").reverse(),
                w = b.findIndex(T => o.has(T));
            _ = b.slice(w).join("")
        }
        const E = _[0];
        return s.findIndex(b => {
            const w = Object.keys(b);
            return !!a(w, E, 0, _)
        })
    }

    function c(m, g) {
        let y = "";
        const _ = g.length;
        let E = 0;
        for (let b = m; b < _; b++) {
            const w = g.charAt(b);
            if (w === "(") E++;
            else if (w === ")") E--;
            else if (E === 0 && w === " ") continue;
            if (E === 0 && a(i, w, b, g)) return [y, b - 1];
            y += w
        }
        return [y, g.length - 1]
    }

    function u(m, g = 0) {
        const y = s[g],
            _ = m.length,
            E = Object.keys(y);
        let b = 0,
            w = !1,
            T = null,
            S = "",
            v = null,
            $, k = "",
            C = "",
            O = "",
            R = "",
            N = 0;
        const J = (Y, ie) => {
            Y ? O += ie : S += ie
        };
        for (let Y = 0; Y < _; Y++)
            if (k = C, C = m.charAt(Y), (C === "'" || C === '"') && k !== "\\" && (b === 0 && !w || b && !R)) {
                b ? R = C : w = C, J(b, C);
                continue
            } else if (w && (C !== w || k === "\\") || R && (C !== R || k === "\\")) {
            J(b, C);
            continue
        } else if (w === C) {
            w = !1, J(b, C);
            continue
        } else if (R === C) {
            R = !1, J(b, C);
            continue
        } else {
            if (C === " ") continue;
            if (C === "(") b === 0 ? N = Y : O += C, b++;
            else if (C === ")")
                if (b--, b === 0) {
                    const ie = typeof S == "string" && S.startsWith("$") ? S : void 0,
                        ce = ie && m.charAt(Y + 1) === ".";
                    let Ue = "";
                    ce && ([Ue, Y] = c(Y + 2, m));
                    const Kt = T ? g : l(N, m, 0),
                        Yt = l(Y, m);
                    Kt === -1 && Yt === -1 ? S = d(O, -1, ie, Ue) : T && (Kt >= Yt || Yt === -1) && g === Kt ? (v = T.bind(null, d(O, -1, ie, Ue)), T = null, S = "") : Yt > Kt && g === Yt ? S = d(O, -1, ie, Ue) : S += `(${O})${ce?`.${Ue}`:""}`, O = ""
                } else O += C;
            else if (b === 0 && ($ = a(E, C, Y, m))) {
                Y === 0 && Tr(103, [$, m]), Y += $.length - 1, Y === m.length - 1 && Tr(104, [$, m]), T ? S && (v = T.bind(null, d(S, g)), T = y[$].bind(null, v), S = "") : v ? (T = y[$].bind(null, d(v, g)), v = null) : (T = y[$].bind(null, d(S, g)), S = "");
                continue
            } else J(b, C)
        }
        return S && T && (T = T.bind(null, d(S, g))), T = !T && v ? v : T, !T && S && (T = (Y, ie) => typeof Y == "function" ? Y(ie) : Y, T = T.bind(null, d(S, g))), !T && !S && Tr(105, m), T
    }

    function d(m, g, y, _) {
        if (y) {
            const E = d(y, s.length);
            let b, w = _ ? Zr(`$${_}`) : !1;
            if (typeof E == "function") {
                const T = Eie(String(m)).map(S => d(S, -1));
                return S => {
                    const v = E(S);
                    return typeof v != "function" ? (Dl(150, y), v) : (b = v(...T.map($ => typeof $ == "function" ? $(S) : $)), w && (w = w.provide($ => {
                        const k = t($);
                        return $.reduce((O, R) => {
                            if (R === _ || (_ == null ? void 0 : _.startsWith(`${R}(`))) {
                                const J = Sie(b, R);
                                O[R] = () => J
                            } else O[R] = k[R];
                            return O
                        }, {})
                    })), w ? w() : b)
                }
            }
        } else if (typeof m == "string") {
            if (m === "true") return !0;
            if (m === "false") return !1;
            if (m === "undefined") return;
            if (bie(m)) return wie(m.substring(1, m.length - 1));
            if (!isNaN(+m)) return Number(m);
            if (g < s.length - 1) return u(m, g + 1);
            if (m.startsWith("$")) {
                const E = m.substring(1);
                return n.add(E),
                    function(w) {
                        return E in w ? w[E]() : void 0
                    }
            }
            return m
        }
        return m
    }
    const f = u(e.startsWith("$:") ? e.substring(2) : e),
        h = Array.from(n);

    function p(m) {
        return t = m, Object.assign(f.bind(null, m(h)), {
            provide: p
        })
    }
    return Object.assign(f, {
        provide: p
    })
}

function gg(e, t, n) {
    return n ? typeof n == "string" ? n.split(" ").reduce((s, i) => Object.assign(s, {
        [i]: !0
    }), {}) : typeof n == "function" ? gg(e, t, n(t, e)) : n : {}
}

function Moe(e, t, ...n) {
    const r = n.reduce((s, i) => {
        if (!i) return I0(s);
        const l = i,
            {
                $reset: o
            } = l,
            a = Gr(l, ["$reset"]);
        return I0(o ? a : Object.assign(s, a))
    }, {});
    return Object.keys(e.hook.classes.dispatch({
        property: t,
        classes: r
    }).classes).filter(s => r[s]).join(" ") || null
}

function I0(e) {
    const t = "$remove:";
    let n = !1;
    const r = Object.keys(e).filter(s => (e[s] && s.startsWith(t) && (n = !0), e[s]));
    return r.length > 1 && n && r.filter(i => i.startsWith(t)).map(i => {
        const o = i.substring(t.length);
        e[o] = !1, e[i] = !1
    }), e
}

function Loe(e, t, n) {
    const r = Ro(e);
    r ? r.setErrors(t, n) : Dl(651, e)
}

function Foe(e, t = !0) {
    const n = Ro(e);
    n ? n.clearErrors(t) : Dl(652, e)
}
const M_ = "0.16.4";

function qv(e, t) {
    const n = Object.create(null),
        r = e.split(",");
    for (let s = 0; s < r.length; s++) n[r[s]] = !0;
    return t ? s => !!n[s.toLowerCase()] : s => !!n[s]
}
const Uoe = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt",
    Boe = qv(Uoe),
    Voe = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    Hoe = qv(Voe);

function s5(e) {
    return !!e || e === ""
}

function Ip(e) {
    if (he(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n],
                s = Lt(r) ? Woe(r) : Ip(r);
            if (s)
                for (const i in s) t[i] = s[i]
        }
        return t
    } else {
        if (Lt(e)) return e;
        if (qt(e)) return e
    }
}
const joe = /;(?![^(]*\))/g,
    zoe = /:(.+)/;

function Woe(e) {
    const t = {};
    return e.split(joe).forEach(n => {
        if (n) {
            const r = n.split(zoe);
            r.length > 1 && (t[r[0].trim()] = r[1].trim())
        }
    }), t
}

function wn(e) {
    let t = "";
    if (Lt(e)) t = e;
    else if (he(e))
        for (let n = 0; n < e.length; n++) {
            const r = wn(e[n]);
            r && (t += r + " ")
        } else if (qt(e))
            for (const n in e) e[n] && (t += n + " ");
    return t.trim()
}

function Goe(e) {
    if (!e) return null;
    let {
        class: t,
        style: n
    } = e;
    return t && !Lt(t) && (e.class = wn(t)), n && (e.style = Ip(n)), e
}

function qoe(e, t) {
    if (e.length !== t.length) return !1;
    let n = !0;
    for (let r = 0; n && r < e.length; r++) n = Yo(e[r], t[r]);
    return n
}

function Yo(e, t) {
    if (e === t) return !0;
    let n = ZA(e),
        r = ZA(t);
    if (n || r) return n && r ? e.getTime() === t.getTime() : !1;
    if (n = $h(e), r = $h(t), n || r) return e === t;
    if (n = he(e), r = he(t), n || r) return n && r ? qoe(e, t) : !1;
    if (n = qt(e), r = qt(t), n || r) {
        if (!n || !r) return !1;
        const s = Object.keys(e).length,
            i = Object.keys(t).length;
        if (s !== i) return !1;
        for (const o in e) {
            const a = e.hasOwnProperty(o),
                l = t.hasOwnProperty(o);
            if (a && !l || !a && l || !Yo(e[o], t[o])) return !1
        }
    }
    return String(e) === String(t)
}

function Yv(e, t) {
    return e.findIndex(n => Yo(n, t))
}
const xs = e => Lt(e) ? e : e == null ? "" : he(e) || qt(e) && (e.toString === o5 || !Te(e.toString)) ? JSON.stringify(e, i5, 2) : String(e),
    i5 = (e, t) => t && t.__v_isRef ? i5(e, t.value) : Bc(t) ? {
        [`Map(${t.size})`]: [...t.entries()].reduce((n, [r, s]) => (n[`${r} =>`] = s, n), {})
    } : Nl(t) ? {
        [`Set(${t.size})`]: [...t.values()]
    } : qt(t) && !he(t) && !a5(t) ? String(t) : t,
    dt = {},
    Uc = [],
    ps = () => {},
    Yoe = () => !1,
    Koe = /^on[^a-z]/,
    xp = e => Koe.test(e),
    B$ = e => e.startsWith("onUpdate:"),
    Gt = Object.assign,
    V$ = (e, t) => {
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1)
    },
    Xoe = Object.prototype.hasOwnProperty,
    qe = (e, t) => Xoe.call(e, t),
    he = Array.isArray,
    Bc = e => Cp(e) === "[object Map]",
    Nl = e => Cp(e) === "[object Set]",
    ZA = e => Cp(e) === "[object Date]",
    Te = e => typeof e == "function",
    Lt = e => typeof e == "string",
    $h = e => typeof e == "symbol",
    qt = e => e !== null && typeof e == "object",
    H$ = e => qt(e) && Te(e.then) && Te(e.catch),
    o5 = Object.prototype.toString,
    Cp = e => o5.call(e),
    Qoe = e => Cp(e).slice(8, -1),
    a5 = e => Cp(e) === "[object Object]",
    j$ = e => Lt(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
    df = qv(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    Kv = e => {
        const t = Object.create(null);
        return n => t[n] || (t[n] = e(n))
    },
    Joe = /-(\w)/g,
    Vr = Kv(e => e.replace(Joe, (t, n) => n ? n.toUpperCase() : "")),
    Zoe = /\B([A-Z])/g,
    Ns = Kv(e => e.replace(Zoe, "-$1").toLowerCase()),
    Ap = Kv(e => e.charAt(0).toUpperCase() + e.slice(1)),
    ff = Kv(e => e ? `on${Ap(e)}` : ""),
    wu = (e, t) => !Object.is(e, t),
    Vc = (e, t) => {
        for (let n = 0; n < e.length; n++) e[n](t)
    },
    L_ = (e, t, n) => {
        Object.defineProperty(e, t, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    },
    Ko = e => {
        const t = parseFloat(e);
        return isNaN(t) ? e : t
    };
let eR;
const eae = () => eR || (eR = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : typeof global != "undefined" ? global : {});
let Cr;
class z$ {
    constructor(t = !1) {
        this.active = !0, this.effects = [], this.cleanups = [], !t && Cr && (this.parent = Cr, this.index = (Cr.scopes || (Cr.scopes = [])).push(this) - 1)
    }
    run(t) {
        if (this.active) {
            const n = Cr;
            try {
                return Cr = this, t()
            } finally {
                Cr = n
            }
        }
    }
    on() {
        Cr = this
    }
    off() {
        Cr = this.parent
    }
    stop(t) {
        if (this.active) {
            let n, r;
            for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
            for (n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
            if (this.scopes)
                for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0);
            if (this.parent && !t) {
                const s = this.parent.scopes.pop();
                s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index)
            }
            this.active = !1
        }
    }
}

function l5(e) {
    return new z$(e)
}

function c5(e, t = Cr) {
    t && t.active && t.effects.push(e)
}

function u5() {
    return Cr
}

function d5(e) {
    Cr && Cr.cleanups.push(e)
}
const W$ = e => {
        const t = new Set(e);
        return t.w = 0, t.n = 0, t
    },
    f5 = e => (e.w & Xo) > 0,
    h5 = e => (e.n & Xo) > 0,
    tae = ({
        deps: e
    }) => {
        if (e.length)
            for (let t = 0; t < e.length; t++) e[t].w |= Xo
    },
    nae = e => {
        const {
            deps: t
        } = e;
        if (t.length) {
            let n = 0;
            for (let r = 0; r < t.length; r++) {
                const s = t[r];
                f5(s) && !h5(s) ? s.delete(e) : t[n++] = s, s.w &= ~Xo, s.n &= ~Xo
            }
            t.length = n
        }
    },
    WE = new WeakMap;
let Ld = 0,
    Xo = 1;
const GE = 30;
let rs;
const Ga = Symbol(""),
    qE = Symbol("");
class Rp {
    constructor(t, n = null, r) {
        this.fn = t, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, c5(this, r)
    }
    run() {
        if (!this.active) return this.fn();
        let t = rs,
            n = Oo;
        for (; t;) {
            if (t === this) return;
            t = t.parent
        }
        try {
            return this.parent = rs, rs = this, Oo = !0, Xo = 1 << ++Ld, Ld <= GE ? tae(this) : tR(this), this.fn()
        } finally {
            Ld <= GE && nae(this), Xo = 1 << --Ld, rs = this.parent, Oo = n, this.parent = void 0, this.deferStop && this.stop()
        }
    }
    stop() {
        rs === this ? this.deferStop = !0 : this.active && (tR(this), this.onStop && this.onStop(), this.active = !1)
    }
}

function tR(e) {
    const {
        deps: t
    } = e;
    if (t.length) {
        for (let n = 0; n < t.length; n++) t[n].delete(e);
        t.length = 0
    }
}

function rae(e, t) {
    e.effect && (e = e.effect.fn);
    const n = new Rp(e);
    t && (Gt(n, t), t.scope && c5(n, t.scope)), (!t || !t.lazy) && n.run();
    const r = n.run.bind(n);
    return r.effect = n, r
}

function sae(e) {
    e.effect.stop()
}
let Oo = !0;
const p5 = [];

function Pl() {
    p5.push(Oo), Oo = !1
}

function Ml() {
    const e = p5.pop();
    Oo = e === void 0 ? !0 : e
}

function Hr(e, t, n) {
    if (Oo && rs) {
        let r = WE.get(e);
        r || WE.set(e, r = new Map);
        let s = r.get(n);
        s || r.set(n, s = W$()), m5(s)
    }
}

function m5(e, t) {
    let n = !1;
    Ld <= GE ? h5(e) || (e.n |= Xo, n = !f5(e)) : n = !e.has(rs), n && (e.add(rs), rs.deps.push(e))
}

function Ii(e, t, n, r, s, i) {
    const o = WE.get(e);
    if (!o) return;
    let a = [];
    if (t === "clear") a = [...o.values()];
    else if (n === "length" && he(e)) o.forEach((l, c) => {
        (c === "length" || c >= r) && a.push(l)
    });
    else switch (n !== void 0 && a.push(o.get(n)), t) {
        case "add":
            he(e) ? j$(n) && a.push(o.get("length")) : (a.push(o.get(Ga)), Bc(e) && a.push(o.get(qE)));
            break;
        case "delete":
            he(e) || (a.push(o.get(Ga)), Bc(e) && a.push(o.get(qE)));
            break;
        case "set":
            Bc(e) && a.push(o.get(Ga));
            break
    }
    if (a.length === 1) a[0] && YE(a[0]);
    else {
        const l = [];
        for (const c of a) c && l.push(...c);
        YE(W$(l))
    }
}

function YE(e, t) {
    const n = he(e) ? e : [...e];
    for (const r of n) r.computed && nR(r);
    for (const r of n) r.computed || nR(r)
}

function nR(e, t) {
    (e !== rs || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run())
}
const iae = qv("__proto__,__v_isRef,__isVue"),
    g5 = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter($h)),
    oae = Xv(),
    aae = Xv(!1, !0),
    lae = Xv(!0),
    cae = Xv(!0, !0),
    rR = uae();

function uae() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t => {
        e[t] = function(...n) {
            const r = ze(this);
            for (let i = 0, o = this.length; i < o; i++) Hr(r, "get", i + "");
            const s = r[t](...n);
            return s === -1 || s === !1 ? r[t](...n.map(ze)) : s
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => {
        e[t] = function(...n) {
            Pl();
            const r = ze(this)[t].apply(this, n);
            return Ml(), r
        }
    }), e
}

function Xv(e = !1, t = !1) {
    return function(r, s, i) {
        if (s === "__v_isReactive") return !e;
        if (s === "__v_isReadonly") return e;
        if (s === "__v_isShallow") return t;
        if (s === "__v_raw" && i === (e ? t ? S5 : E5 : t ? w5 : b5).get(r)) return r;
        const o = he(r);
        if (!e && o && qe(rR, s)) return Reflect.get(rR, s, i);
        const a = Reflect.get(r, s, i);
        return ($h(s) ? g5.has(s) : iae(s)) || (e || Hr(r, "get", s), t) ? a : gt(a) ? o && j$(s) ? a : a.value : qt(a) ? e ? Zv(a) : Pr(a) : a
    }
}
const dae = _5(),
    fae = _5(!0);

function _5(e = !1) {
    return function(n, r, s, i) {
        let o = n[r];
        if (Eu(o) && gt(o) && !gt(s)) return !1;
        if (!e && !Eu(s) && (U_(s) || (s = ze(s), o = ze(o)), !he(n) && gt(o) && !gt(s))) return o.value = s, !0;
        const a = he(n) && j$(r) ? Number(r) < n.length : qe(n, r),
            l = Reflect.set(n, r, s, i);
        return n === ze(i) && (a ? wu(s, o) && Ii(n, "set", r, s) : Ii(n, "add", r, s)), l
    }
}

function hae(e, t) {
    const n = qe(e, t);
    e[t];
    const r = Reflect.deleteProperty(e, t);
    return r && n && Ii(e, "delete", t, void 0), r
}

function pae(e, t) {
    const n = Reflect.has(e, t);
    return (!$h(t) || !g5.has(t)) && Hr(e, "has", t), n
}

function mae(e) {
    return Hr(e, "iterate", he(e) ? "length" : Ga), Reflect.ownKeys(e)
}
const y5 = {
        get: oae,
        set: dae,
        deleteProperty: hae,
        has: pae,
        ownKeys: mae
    },
    v5 = {
        get: lae,
        set(e, t) {
            return !0
        },
        deleteProperty(e, t) {
            return !0
        }
    },
    gae = Gt({}, y5, {
        get: aae,
        set: fae
    }),
    _ae = Gt({}, v5, {
        get: cae
    }),
    G$ = e => e,
    Qv = e => Reflect.getPrototypeOf(e);

function wm(e, t, n = !1, r = !1) {
    e = e.__v_raw;
    const s = ze(e),
        i = ze(t);
    n || (t !== i && Hr(s, "get", t), Hr(s, "get", i));
    const {
        has: o
    } = Qv(s), a = r ? G$ : n ? Y$ : kh;
    if (o.call(s, t)) return a(e.get(t));
    if (o.call(s, i)) return a(e.get(i));
    e !== s && e.get(t)
}

function Em(e, t = !1) {
    const n = this.__v_raw,
        r = ze(n),
        s = ze(e);
    return t || (e !== s && Hr(r, "has", e), Hr(r, "has", s)), e === s ? n.has(e) : n.has(e) || n.has(s)
}

function Sm(e, t = !1) {
    return e = e.__v_raw, !t && Hr(ze(e), "iterate", Ga), Reflect.get(e, "size", e)
}

function sR(e) {
    e = ze(e);
    const t = ze(this);
    return Qv(t).has.call(t, e) || (t.add(e), Ii(t, "add", e, e)), this
}

function iR(e, t) {
    t = ze(t);
    const n = ze(this),
        {
            has: r,
            get: s
        } = Qv(n);
    let i = r.call(n, e);
    i || (e = ze(e), i = r.call(n, e));
    const o = s.call(n, e);
    return n.set(e, t), i ? wu(t, o) && Ii(n, "set", e, t) : Ii(n, "add", e, t), this
}

function oR(e) {
    const t = ze(this),
        {
            has: n,
            get: r
        } = Qv(t);
    let s = n.call(t, e);
    s || (e = ze(e), s = n.call(t, e)), r && r.call(t, e);
    const i = t.delete(e);
    return s && Ii(t, "delete", e, void 0), i
}

function aR() {
    const e = ze(this),
        t = e.size !== 0,
        n = e.clear();
    return t && Ii(e, "clear", void 0, void 0), n
}

function Tm(e, t) {
    return function(r, s) {
        const i = this,
            o = i.__v_raw,
            a = ze(o),
            l = t ? G$ : e ? Y$ : kh;
        return !e && Hr(a, "iterate", Ga), o.forEach((c, u) => r.call(s, l(c), l(u), i))
    }
}

function $m(e, t, n) {
    return function(...r) {
        const s = this.__v_raw,
            i = ze(s),
            o = Bc(i),
            a = e === "entries" || e === Symbol.iterator && o,
            l = e === "keys" && o,
            c = s[e](...r),
            u = n ? G$ : t ? Y$ : kh;
        return !t && Hr(i, "iterate", l ? qE : Ga), {
            next() {
                const {
                    value: d,
                    done: f
                } = c.next();
                return f ? {
                    value: d,
                    done: f
                } : {
                    value: a ? [u(d[0]), u(d[1])] : u(d),
                    done: f
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function Ji(e) {
    return function(...t) {
        return e === "delete" ? !1 : this
    }
}

function yae() {
    const e = {
            get(i) {
                return wm(this, i)
            },
            get size() {
                return Sm(this)
            },
            has: Em,
            add: sR,
            set: iR,
            delete: oR,
            clear: aR,
            forEach: Tm(!1, !1)
        },
        t = {
            get(i) {
                return wm(this, i, !1, !0)
            },
            get size() {
                return Sm(this)
            },
            has: Em,
            add: sR,
            set: iR,
            delete: oR,
            clear: aR,
            forEach: Tm(!1, !0)
        },
        n = {
            get(i) {
                return wm(this, i, !0)
            },
            get size() {
                return Sm(this, !0)
            },
            has(i) {
                return Em.call(this, i, !0)
            },
            add: Ji("add"),
            set: Ji("set"),
            delete: Ji("delete"),
            clear: Ji("clear"),
            forEach: Tm(!0, !1)
        },
        r = {
            get(i) {
                return wm(this, i, !0, !0)
            },
            get size() {
                return Sm(this, !0)
            },
            has(i) {
                return Em.call(this, i, !0)
            },
            add: Ji("add"),
            set: Ji("set"),
            delete: Ji("delete"),
            clear: Ji("clear"),
            forEach: Tm(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(i => {
        e[i] = $m(i, !1, !1), n[i] = $m(i, !0, !1), t[i] = $m(i, !1, !0), r[i] = $m(i, !0, !0)
    }), [e, n, t, r]
}
const [vae, bae, wae, Eae] = yae();

function Jv(e, t) {
    const n = t ? e ? Eae : wae : e ? bae : vae;
    return (r, s, i) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? r : Reflect.get(qe(n, s) && s in r ? n : r, s, i)
}
const Sae = {
        get: Jv(!1, !1)
    },
    Tae = {
        get: Jv(!1, !0)
    },
    $ae = {
        get: Jv(!0, !1)
    },
    kae = {
        get: Jv(!0, !0)
    },
    b5 = new WeakMap,
    w5 = new WeakMap,
    E5 = new WeakMap,
    S5 = new WeakMap;

function Iae(e) {
    switch (e) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function xae(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : Iae(Qoe(e))
}

function Pr(e) {
    return Eu(e) ? e : eb(e, !1, y5, Sae, b5)
}

function F_(e) {
    return eb(e, !1, gae, Tae, w5)
}

function Zv(e) {
    return eb(e, !0, v5, $ae, E5)
}

function Cae(e) {
    return eb(e, !0, _ae, kae, S5)
}

function eb(e, t, n, r, s) {
    if (!qt(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
    const i = s.get(e);
    if (i) return i;
    const o = xae(e);
    if (o === 0) return e;
    const a = new Proxy(e, o === 2 ? r : n);
    return s.set(e, a), a
}

function ms(e) {
    return Eu(e) ? ms(e.__v_raw) : !!(e && e.__v_isReactive)
}

function Eu(e) {
    return !!(e && e.__v_isReadonly)
}

function U_(e) {
    return !!(e && e.__v_isShallow)
}

function q$(e) {
    return ms(e) || Eu(e)
}

function ze(e) {
    const t = e && e.__v_raw;
    return t ? ze(t) : e
}

function Op(e) {
    return L_(e, "__v_skip", !0), e
}
const kh = e => qt(e) ? Pr(e) : e,
    Y$ = e => qt(e) ? Zv(e) : e;

function K$(e) {
    Oo && rs && (e = ze(e), m5(e.dep || (e.dep = W$())))
}

function tb(e, t) {
    e = ze(e), e.dep && YE(e.dep)
}

function gt(e) {
    return !!(e && e.__v_isRef === !0)
}

function ae(e) {
    return T5(e, !1)
}

function yl(e) {
    return T5(e, !0)
}

function T5(e, t) {
    return gt(e) ? e : new Aae(e, t)
}
class Aae {
    constructor(t, n) {
        this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? t : ze(t), this._value = n ? t : kh(t)
    }
    get value() {
        return K$(this), this._value
    }
    set value(t) {
        t = this.__v_isShallow ? t : ze(t), wu(t, this._rawValue) && (this._rawValue = t, this._value = this.__v_isShallow ? t : kh(t), tb(this))
    }
}

function Fd(e) {
    tb(e)
}

function fe(e) {
    return gt(e) ? e.value : e
}
const Rae = {
    get: (e, t, n) => fe(Reflect.get(e, t, n)),
    set: (e, t, n, r) => {
        const s = e[t];
        return gt(s) && !gt(n) ? (s.value = n, !0) : Reflect.set(e, t, n, r)
    }
};

function X$(e) {
    return ms(e) ? e : new Proxy(e, Rae)
}
class Oae {
    constructor(t) {
        this.dep = void 0, this.__v_isRef = !0;
        const {
            get: n,
            set: r
        } = t(() => K$(this), () => tb(this));
        this._get = n, this._set = r
    }
    get value() {
        return this._get()
    }
    set value(t) {
        this._set(t)
    }
}

function Dae(e) {
    return new Oae(e)
}

function Nae(e) {
    const t = he(e) ? new Array(e.length) : {};
    for (const n in e) t[n] = Q$(e, n);
    return t
}
class Pae {
    constructor(t, n, r) {
        this._object = t, this._key = n, this._defaultValue = r, this.__v_isRef = !0
    }
    get value() {
        const t = this._object[this._key];
        return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
}

function Q$(e, t, n) {
    const r = e[t];
    return gt(r) ? r : new Pae(e, t, n)
}
class Mae {
    constructor(t, n, r, s) {
        this._setter = n, this.dep = void 0, this.__v_isRef = !0, this._dirty = !0, this.effect = new Rp(t, () => {
            this._dirty || (this._dirty = !0, tb(this))
        }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = r
    }
    get value() {
        const t = ze(this);
        return K$(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value
    }
    set value(t) {
        this._setter(t)
    }
}

function Lae(e, t, n = !1) {
    let r, s;
    const i = Te(e);
    return i ? (r = e, s = ps) : (r = e.get, s = e.set), new Mae(r, s, i || !s, n)
}
const hf = [];

function $5(e, ...t) {
    Pl();
    const n = hf.length ? hf[hf.length - 1].component : null,
        r = n && n.appContext.config.warnHandler,
        s = Fae();
    if (r) Ps(r, n, 11, [e + t.join(""), n && n.proxy, s.map(({
        vnode: i
    }) => `at <${mV(n,i.type)}>`).join(`
`), s]);
    else {
        const i = [`[Vue warn]: ${e}`, ...t];
        s.length && i.push(`
`, ...Uae(s)), console.warn(...i)
    }
    Ml()
}

function Fae() {
    let e = hf[hf.length - 1];
    if (!e) return [];
    const t = [];
    for (; e;) {
        const n = t[0];
        n && n.vnode === e ? n.recurseCount++ : t.push({
            vnode: e,
            recurseCount: 0
        });
        const r = e.component && e.component.parent;
        e = r && r.vnode
    }
    return t
}

function Uae(e) {
    const t = [];
    return e.forEach((n, r) => {
        t.push(...r === 0 ? [] : [`
`], ...Bae(n))
    }), t
}

function Bae({
    vnode: e,
    recurseCount: t
}) {
    const n = t > 0 ? `... (${t} recursive calls)` : "",
        r = e.component ? e.component.parent == null : !1,
        s = ` at <${mV(e.component,e.type,r)}`,
        i = ">" + n;
    return e.props ? [s, ...Vae(e.props), i] : [s + i]
}

function Vae(e) {
    const t = [],
        n = Object.keys(e);
    return n.slice(0, 3).forEach(r => {
        t.push(...k5(r, e[r]))
    }), n.length > 3 && t.push(" ..."), t
}

function k5(e, t, n) {
    return Lt(t) ? (t = JSON.stringify(t), n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : gt(t) ? (t = k5(e, ze(t.value), !0), n ? t : [`${e}=Ref<`, t, ">"]) : Te(t) ? [`${e}=fn${t.name?`<${t.name}>`:""}`] : (t = ze(t), n ? t : [`${e}=`, t])
}

function Ps(e, t, n, r) {
    let s;
    try {
        s = r ? e(...r) : e()
    } catch (i) {
        Ll(i, t, n)
    }
    return s
}

function Fr(e, t, n, r) {
    if (Te(e)) {
        const i = Ps(e, t, n, r);
        return i && H$(i) && i.catch(o => {
            Ll(o, t, n)
        }), i
    }
    const s = [];
    for (let i = 0; i < e.length; i++) s.push(Fr(e[i], t, n, r));
    return s
}

function Ll(e, t, n, r = !0) {
    const s = t ? t.vnode : null;
    if (t) {
        let i = t.parent;
        const o = t.proxy,
            a = n;
        for (; i;) {
            const c = i.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](e, o, a) === !1) return
            }
            i = i.parent
        }
        const l = t.appContext.config.errorHandler;
        if (l) {
            Ps(l, null, 10, [e, o, a]);
            return
        }
    }
    Hae(e, n, s, r)
}

function Hae(e, t, n, r = !0) {
    console.error(e)
}
let B_ = !1,
    KE = !1;
const Or = [];
let ri = 0;
const pf = [];
let Ud = null,
    cc = 0;
const mf = [];
let so = null,
    uc = 0;
const I5 = Promise.resolve();
let J$ = null,
    XE = null;

function ln(e) {
    const t = J$ || I5;
    return e ? t.then(this ? e.bind(this) : e) : t
}

function jae(e) {
    let t = ri + 1,
        n = Or.length;
    for (; t < n;) {
        const r = t + n >>> 1;
        Ih(Or[r]) < e ? t = r + 1 : n = r
    }
    return t
}

function Z$(e) {
    (!Or.length || !Or.includes(e, B_ && e.allowRecurse ? ri + 1 : ri)) && e !== XE && (e.id == null ? Or.push(e) : Or.splice(jae(e.id), 0, e), x5())
}

function x5() {
    !B_ && !KE && (KE = !0, J$ = I5.then(A5))
}

function zae(e) {
    const t = Or.indexOf(e);
    t > ri && Or.splice(t, 1)
}

function C5(e, t, n, r) {
    he(e) ? n.push(...e) : (!t || !t.includes(e, e.allowRecurse ? r + 1 : r)) && n.push(e), x5()
}

function Wae(e) {
    C5(e, Ud, pf, cc)
}

function ek(e) {
    C5(e, so, mf, uc)
}

function nb(e, t = null) {
    if (pf.length) {
        for (XE = t, Ud = [...new Set(pf)], pf.length = 0, cc = 0; cc < Ud.length; cc++) Ud[cc]();
        Ud = null, cc = 0, XE = null, nb(e, t)
    }
}

function V_(e) {
    if (nb(), mf.length) {
        const t = [...new Set(mf)];
        if (mf.length = 0, so) {
            so.push(...t);
            return
        }
        for (so = t, so.sort((n, r) => Ih(n) - Ih(r)), uc = 0; uc < so.length; uc++) so[uc]();
        so = null, uc = 0
    }
}
const Ih = e => e.id == null ? 1 / 0 : e.id;

function A5(e) {
    KE = !1, B_ = !0, nb(e), Or.sort((n, r) => Ih(n) - Ih(r));
    const t = ps;
    try {
        for (ri = 0; ri < Or.length; ri++) {
            const n = Or[ri];
            n && n.active !== !1 && Ps(n, null, 14)
        }
    } finally {
        ri = 0, Or.length = 0, V_(), B_ = !1, J$ = null, (Or.length || pf.length || mf.length) && A5(e)
    }
}
let dc, km = [];

function R5(e, t) {
    var n, r;
    dc = e, dc ? (dc.enabled = !0, km.forEach(({
        event: s,
        args: i
    }) => dc.emit(s, ...i)), km = []) : typeof window != "undefined" && window.HTMLElement && !(!((r = (n = window.navigator) === null || n === void 0 ? void 0 : n.userAgent) === null || r === void 0) && r.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(i => {
        R5(i, t)
    }), setTimeout(() => {
        dc || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, km = [])
    }, 3e3)) : km = []
}

function Gae(e, t, ...n) {
    if (e.isUnmounted) return;
    const r = e.vnode.props || dt;
    let s = n;
    const i = t.startsWith("update:"),
        o = i && t.slice(7);
    if (o && o in r) {
        const u = `${o==="modelValue"?"model":o}Modifiers`,
            {
                number: d,
                trim: f
            } = r[u] || dt;
        f && (s = n.map(h => h.trim())), d && (s = n.map(Ko))
    }
    let a, l = r[a = ff(t)] || r[a = ff(Vr(t))];
    !l && i && (l = r[a = ff(Ns(t))]), l && Fr(l, e, 6, s);
    const c = r[a + "Once"];
    if (c) {
        if (!e.emitted) e.emitted = {};
        else if (e.emitted[a]) return;
        e.emitted[a] = !0, Fr(c, e, 6, s)
    }
}

function O5(e, t, n = !1) {
    const r = t.emitsCache,
        s = r.get(e);
    if (s !== void 0) return s;
    const i = e.emits;
    let o = {},
        a = !1;
    if (!Te(e)) {
        const l = c => {
            const u = O5(c, t, !0);
            u && (a = !0, Gt(o, u))
        };
        !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l)
    }
    return !i && !a ? (r.set(e, null), null) : (he(i) ? i.forEach(l => o[l] = null) : Gt(o, i), r.set(e, o), o)
}

function rb(e, t) {
    return !e || !xp(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), qe(e, t[0].toLowerCase() + t.slice(1)) || qe(e, Ns(t)) || qe(e, t))
}
let jn = null,
    sb = null;

function xh(e) {
    const t = jn;
    return jn = e, sb = e && e.type.__scopeId || null, t
}

function tk(e) {
    sb = e
}

function nk() {
    sb = null
}
const D5 = e => Re;

function Re(e, t = jn, n) {
    if (!t || e._n) return e;
    const r = (...s) => {
        r._d && s1(-1);
        const i = xh(t),
            o = e(...s);
        return xh(i), r._d && s1(1), o
    };
    return r._n = !0, r._c = !0, r._d = !0, r
}

function _g(e) {
    const {
        type: t,
        vnode: n,
        proxy: r,
        withProxy: s,
        props: i,
        propsOptions: [o],
        slots: a,
        attrs: l,
        emit: c,
        render: u,
        renderCache: d,
        data: f,
        setupState: h,
        ctx: p,
        inheritAttrs: m
    } = e;
    let g, y;
    const _ = xh(e);
    try {
        if (n.shapeFlag & 4) {
            const b = s || r;
            g = Ar(u.call(b, b, d, i, h, f, p)), y = l
        } else {
            const b = t;
            g = Ar(b.length > 1 ? b(i, {
                attrs: l,
                slots: a,
                emit: c
            }) : b(i, null)), y = t.props ? l : Yae(l)
        }
    } catch (b) {
        _f.length = 0, Ll(b, e, 1), g = ne(qn)
    }
    let E = g;
    if (y && m !== !1) {
        const b = Object.keys(y),
            {
                shapeFlag: w
            } = E;
        b.length && w & 7 && (o && b.some(B$) && (y = Kae(y, o)), E = _s(E, y))
    }
    return n.dirs && (E = _s(E), E.dirs = E.dirs ? E.dirs.concat(n.dirs) : n.dirs), n.transition && (E.transition = n.transition), g = E, xh(_), g
}

function qae(e) {
    let t;
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (Qo(r)) {
            if (r.type !== qn || r.children === "v-if") {
                if (t) return;
                t = r
            }
        } else return
    }
    return t
}
const Yae = e => {
        let t;
        for (const n in e)(n === "class" || n === "style" || xp(n)) && ((t || (t = {}))[n] = e[n]);
        return t
    },
    Kae = (e, t) => {
        const n = {};
        for (const r in e)(!B$(r) || !(r.slice(9) in t)) && (n[r] = e[r]);
        return n
    };

function Xae(e, t, n) {
    const {
        props: r,
        children: s,
        component: i
    } = e, {
        props: o,
        children: a,
        patchFlag: l
    } = t, c = i.emitsOptions;
    if (t.dirs || t.transition) return !0;
    if (n && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return r ? lR(r, o, c) : !!o;
        if (l & 8) {
            const u = t.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                const f = u[d];
                if (o[f] !== r[f] && !rb(c, f)) return !0
            }
        }
    } else return (s || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? o ? lR(r, o, c) : !0 : !!o;
    return !1
}

function lR(e, t, n) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(e).length) return !0;
    for (let s = 0; s < r.length; s++) {
        const i = r[s];
        if (t[i] !== e[i] && !rb(n, i)) return !0
    }
    return !1
}

function rk({
    vnode: e,
    parent: t
}, n) {
    for (; t && t.subTree === e;)(e = t.vnode).el = n, t = t.parent
}
const N5 = e => e.__isSuspense,
    Qae = {
        name: "Suspense",
        __isSuspense: !0,
        process(e, t, n, r, s, i, o, a, l, c) {
            e == null ? Jae(t, n, r, s, i, o, a, l, c) : Zae(e, t, n, r, s, o, a, l, c)
        },
        hydrate: ele,
        create: sk,
        normalize: tle
    },
    P5 = Qae;

function Ch(e, t) {
    const n = e.props && e.props[t];
    Te(n) && n()
}

function Jae(e, t, n, r, s, i, o, a, l) {
    const {
        p: c,
        o: {
            createElement: u
        }
    } = l, d = u("div"), f = e.suspense = sk(e, s, r, t, d, n, i, o, a, l);
    c(null, f.pendingBranch = e.ssContent, d, null, r, f, i, o), f.deps > 0 ? (Ch(e, "onPending"), Ch(e, "onFallback"), c(null, e.ssFallback, t, n, r, null, i, o), Hc(f, e.ssFallback)) : f.resolve()
}

function Zae(e, t, n, r, s, i, o, a, {
    p: l,
    um: c,
    o: {
        createElement: u
    }
}) {
    const d = t.suspense = e.suspense;
    d.vnode = t, t.el = e.el;
    const f = t.ssContent,
        h = t.ssFallback,
        {
            activeBranch: p,
            pendingBranch: m,
            isInFallback: g,
            isHydrating: y
        } = d;
    if (m) d.pendingBranch = f, Is(f, m) ? (l(m, f, d.hiddenContainer, null, s, d, i, o, a), d.deps <= 0 ? d.resolve() : g && (l(p, h, n, r, s, null, i, o, a), Hc(d, h))) : (d.pendingId++, y ? (d.isHydrating = !1, d.activeBranch = m) : c(m, s, d), d.deps = 0, d.effects.length = 0, d.hiddenContainer = u("div"), g ? (l(null, f, d.hiddenContainer, null, s, d, i, o, a), d.deps <= 0 ? d.resolve() : (l(p, h, n, r, s, null, i, o, a), Hc(d, h))) : p && Is(f, p) ? (l(p, f, n, r, s, d, i, o, a), d.resolve(!0)) : (l(null, f, d.hiddenContainer, null, s, d, i, o, a), d.deps <= 0 && d.resolve()));
    else if (p && Is(f, p)) l(p, f, n, r, s, d, i, o, a), Hc(d, f);
    else if (Ch(t, "onPending"), d.pendingBranch = f, d.pendingId++, l(null, f, d.hiddenContainer, null, s, d, i, o, a), d.deps <= 0) d.resolve();
    else {
        const {
            timeout: _,
            pendingId: E
        } = d;
        _ > 0 ? setTimeout(() => {
            d.pendingId === E && d.fallback(h)
        }, _) : _ === 0 && d.fallback(h)
    }
}

function sk(e, t, n, r, s, i, o, a, l, c, u = !1) {
    const {
        p: d,
        m: f,
        um: h,
        n: p,
        o: {
            parentNode: m,
            remove: g
        }
    } = c, y = Ko(e.props && e.props.timeout), _ = {
        vnode: e,
        parent: t,
        parentComponent: n,
        isSVG: o,
        container: r,
        hiddenContainer: s,
        anchor: i,
        deps: 0,
        pendingId: 0,
        timeout: typeof y == "number" ? y : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !0,
        isHydrating: u,
        isUnmounted: !1,
        effects: [],
        resolve(E = !1) {
            const {
                vnode: b,
                activeBranch: w,
                pendingBranch: T,
                pendingId: S,
                effects: v,
                parentComponent: $,
                container: k
            } = _;
            if (_.isHydrating) _.isHydrating = !1;
            else if (!E) {
                const R = w && T.transition && T.transition.mode === "out-in";
                R && (w.transition.afterLeave = () => {
                    S === _.pendingId && f(T, k, N, 0)
                });
                let {
                    anchor: N
                } = _;
                w && (N = p(w), h(w, $, _, !0)), R || f(T, k, N, 0)
            }
            Hc(_, T), _.pendingBranch = null, _.isInFallback = !1;
            let C = _.parent,
                O = !1;
            for (; C;) {
                if (C.pendingBranch) {
                    C.effects.push(...v), O = !0;
                    break
                }
                C = C.parent
            }
            O || ek(v), _.effects = [], Ch(b, "onResolve")
        },
        fallback(E) {
            if (!_.pendingBranch) return;
            const {
                vnode: b,
                activeBranch: w,
                parentComponent: T,
                container: S,
                isSVG: v
            } = _;
            Ch(b, "onFallback");
            const $ = p(w),
                k = () => {
                    !_.isInFallback || (d(null, E, S, $, T, null, v, a, l), Hc(_, E))
                },
                C = E.transition && E.transition.mode === "out-in";
            C && (w.transition.afterLeave = k), _.isInFallback = !0, h(w, T, null, !0), C || k()
        },
        move(E, b, w) {
            _.activeBranch && f(_.activeBranch, E, b, w), _.container = E
        },
        next() {
            return _.activeBranch && p(_.activeBranch)
        },
        registerDep(E, b) {
            const w = !!_.pendingBranch;
            w && _.deps++;
            const T = E.vnode.el;
            E.asyncDep.catch(S => {
                Ll(S, E, 0)
            }).then(S => {
                if (E.isUnmounted || _.isUnmounted || _.pendingId !== E.suspenseId) return;
                E.asyncResolved = !0;
                const {
                    vnode: v
                } = E;
                i1(E, S, !1), T && (v.el = T);
                const $ = !T && E.subTree.el;
                b(E, v, m(T || E.subTree.el), T ? null : p(E.subTree), _, o, l), $ && g($), rk(E, v.el), w && --_.deps === 0 && _.resolve()
            })
        },
        unmount(E, b) {
            _.isUnmounted = !0, _.activeBranch && h(_.activeBranch, n, E, b), _.pendingBranch && h(_.pendingBranch, n, E, b)
        }
    };
    return _
}

function ele(e, t, n, r, s, i, o, a, l) {
    const c = t.suspense = sk(t, r, n, e.parentNode, document.createElement("div"), null, s, i, o, a, !0),
        u = l(e, c.pendingBranch = t.ssContent, n, c, i, o);
    return c.deps === 0 && c.resolve(), u
}

function tle(e) {
    const {
        shapeFlag: t,
        children: n
    } = e, r = t & 32;
    e.ssContent = cR(r ? n.default : n), e.ssFallback = r ? cR(n.fallback) : ne(qn)
}

function cR(e) {
    let t;
    if (Te(e)) {
        const n = bl && e._c;
        n && (e._d = !1, z()), e = e(), n && (e._d = !0, t = Er, oV())
    }
    return he(e) && (e = qae(e)), e = Ar(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n => n !== e)), e
}

function M5(e, t) {
    t && t.pendingBranch ? he(e) ? t.effects.push(...e) : t.effects.push(e) : ek(e)
}

function Hc(e, t) {
    e.activeBranch = t;
    const {
        vnode: n,
        parentComponent: r
    } = e, s = n.el = t.el;
    r && r.subTree === n && (r.vnode.el = s, rk(r, s))
}

function fi(e, t) {
    if (on) {
        let n = on.provides;
        const r = on.parent && on.parent.provides;
        r === n && (n = on.provides = Object.create(r)), n[e] = t
    }
}

function bt(e, t, n = !1) {
    const r = on || jn;
    if (r) {
        const s = r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides;
        if (s && e in s) return s[e];
        if (arguments.length > 1) return n && Te(t) ? t.call(r.proxy) : t
    }
}

function sr(e, t) {
    return Dp(e, null, t)
}

function L5(e, t) {
    return Dp(e, null, {
        flush: "post"
    })
}

function nle(e, t) {
    return Dp(e, null, {
        flush: "sync"
    })
}
const uR = {};

function $t(e, t, n) {
    return Dp(e, t, n)
}

function Dp(e, t, {
    immediate: n,
    deep: r,
    flush: s,
    onTrack: i,
    onTrigger: o
} = dt) {
    const a = on;
    let l, c = !1,
        u = !1;
    if (gt(e) ? (l = () => e.value, c = U_(e)) : ms(e) ? (l = () => e, r = !0) : he(e) ? (u = !0, c = e.some(y => ms(y) || U_(y)), l = () => e.map(y => {
            if (gt(y)) return y.value;
            if (ms(y)) return La(y);
            if (Te(y)) return Ps(y, a, 2)
        })) : Te(e) ? t ? l = () => Ps(e, a, 2) : l = () => {
            if (!(a && a.isUnmounted)) return d && d(), Fr(e, a, 3, [f])
        } : l = ps, t && r) {
        const y = l;
        l = () => La(y())
    }
    let d, f = y => {
        d = g.onStop = () => {
            Ps(y, a, 4)
        }
    };
    if (Iu) return f = ps, t ? n && Fr(t, a, 3, [l(), u ? [] : void 0, f]) : l(), ps;
    let h = u ? [] : uR;
    const p = () => {
        if (!!g.active)
            if (t) {
                const y = g.run();
                (r || c || (u ? y.some((_, E) => wu(_, h[E])) : wu(y, h))) && (d && d(), Fr(t, a, 3, [y, h === uR ? void 0 : h, f]), h = y)
            } else g.run()
    };
    p.allowRecurse = !!t;
    let m;
    s === "sync" ? m = p : s === "post" ? m = () => xn(p, a && a.suspense) : m = () => Wae(p);
    const g = new Rp(l, m);
    return t ? n ? p() : h = g.run() : s === "post" ? xn(g.run.bind(g), a && a.suspense) : g.run(), () => {
        g.stop(), a && a.scope && V$(a.scope.effects, g)
    }
}

function rle(e, t, n) {
    const r = this.proxy,
        s = Lt(e) ? e.includes(".") ? F5(r, e) : () => r[e] : e.bind(r, r);
    let i;
    Te(t) ? i = t : (i = t.handler, n = t);
    const o = on;
    Jo(this);
    const a = Dp(s, i.bind(r), n);
    return o ? Jo(o) : No(), a
}

function F5(e, t) {
    const n = t.split(".");
    return () => {
        let r = e;
        for (let s = 0; s < n.length && r; s++) r = r[n[s]];
        return r
    }
}

function La(e, t) {
    if (!qt(e) || e.__v_skip || (t = t || new Set, t.has(e))) return e;
    if (t.add(e), gt(e)) La(e.value, t);
    else if (he(e))
        for (let n = 0; n < e.length; n++) La(e[n], t);
    else if (Nl(e) || Bc(e)) e.forEach(n => {
        La(n, t)
    });
    else if (a5(e))
        for (const n in e) La(e[n], t);
    return e
}

function ik() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return jr(() => {
        e.isMounted = !0
    }), pa(() => {
        e.isUnmounting = !0
    }), e
}
const qr = [Function, Array],
    sle = {
        name: "BaseTransition",
        props: {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: qr,
            onEnter: qr,
            onAfterEnter: qr,
            onEnterCancelled: qr,
            onBeforeLeave: qr,
            onLeave: qr,
            onAfterLeave: qr,
            onLeaveCancelled: qr,
            onBeforeAppear: qr,
            onAppear: qr,
            onAfterAppear: qr,
            onAppearCancelled: qr
        },
        setup(e, {
            slots: t
        }) {
            const n = Qn(),
                r = ik();
            let s;
            return () => {
                const i = t.default && ib(t.default(), !0);
                if (!i || !i.length) return;
                let o = i[0];
                if (i.length > 1) {
                    for (const m of i)
                        if (m.type !== qn) {
                            o = m;
                            break
                        }
                }
                const a = ze(e),
                    {
                        mode: l
                    } = a;
                if (r.isLeaving) return x0(o);
                const c = dR(o);
                if (!c) return x0(o);
                const u = Su(c, a, r, n);
                vl(c, u);
                const d = n.subTree,
                    f = d && dR(d);
                let h = !1;
                const {
                    getTransitionKey: p
                } = c.type;
                if (p) {
                    const m = p();
                    s === void 0 ? s = m : m !== s && (s = m, h = !0)
                }
                if (f && f.type !== qn && (!Is(c, f) || h)) {
                    const m = Su(f, a, r, n);
                    if (vl(f, m), l === "out-in") return r.isLeaving = !0, m.afterLeave = () => {
                        r.isLeaving = !1, n.update()
                    }, x0(o);
                    l === "in-out" && c.type !== qn && (m.delayLeave = (g, y, _) => {
                        const E = U5(r, f);
                        E[String(f.key)] = f, g._leaveCb = () => {
                            y(), g._leaveCb = void 0, delete u.delayedLeave
                        }, u.delayedLeave = _
                    })
                }
                return o
            }
        }
    },
    ok = sle;

function U5(e, t) {
    const {
        leavingVNodes: n
    } = e;
    let r = n.get(t.type);
    return r || (r = Object.create(null), n.set(t.type, r)), r
}

function Su(e, t, n, r) {
    const {
        appear: s,
        mode: i,
        persisted: o = !1,
        onBeforeEnter: a,
        onEnter: l,
        onAfterEnter: c,
        onEnterCancelled: u,
        onBeforeLeave: d,
        onLeave: f,
        onAfterLeave: h,
        onLeaveCancelled: p,
        onBeforeAppear: m,
        onAppear: g,
        onAfterAppear: y,
        onAppearCancelled: _
    } = t, E = String(e.key), b = U5(n, e), w = (v, $) => {
        v && Fr(v, r, 9, $)
    }, T = (v, $) => {
        const k = $[1];
        w(v, $), he(v) ? v.every(C => C.length <= 1) && k() : v.length <= 1 && k()
    }, S = {
        mode: i,
        persisted: o,
        beforeEnter(v) {
            let $ = a;
            if (!n.isMounted)
                if (s) $ = m || a;
                else return;
            v._leaveCb && v._leaveCb(!0);
            const k = b[E];
            k && Is(e, k) && k.el._leaveCb && k.el._leaveCb(), w($, [v])
        },
        enter(v) {
            let $ = l,
                k = c,
                C = u;
            if (!n.isMounted)
                if (s) $ = g || l, k = y || c, C = _ || u;
                else return;
            let O = !1;
            const R = v._enterCb = N => {
                O || (O = !0, N ? w(C, [v]) : w(k, [v]), S.delayedLeave && S.delayedLeave(), v._enterCb = void 0)
            };
            $ ? T($, [v, R]) : R()
        },
        leave(v, $) {
            const k = String(e.key);
            if (v._enterCb && v._enterCb(!0), n.isUnmounting) return $();
            w(d, [v]);
            let C = !1;
            const O = v._leaveCb = R => {
                C || (C = !0, $(), R ? w(p, [v]) : w(h, [v]), v._leaveCb = void 0, b[k] === e && delete b[k])
            };
            b[k] = e, f ? T(f, [v, O]) : O()
        },
        clone(v) {
            return Su(v, t, n, r)
        }
    };
    return S
}

function x0(e) {
    if (Np(e)) return e = _s(e), e.children = null, e
}

function dR(e) {
    return Np(e) ? e.children ? e.children[0] : void 0 : e
}

function vl(e, t) {
    e.shapeFlag & 6 && e.component ? vl(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}

function ib(e, t = !1, n) {
    let r = [],
        s = 0;
    for (let i = 0; i < e.length; i++) {
        let o = e[i];
        const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : i);
        o.type === Ht ? (o.patchFlag & 128 && s++, r = r.concat(ib(o.children, t, a))) : (t || o.type !== qn) && r.push(a != null ? _s(o, {
            key: a
        }) : o)
    }
    if (s > 1)
        for (let i = 0; i < r.length; i++) r[i].patchFlag = -2;
    return r
}

function Ir(e) {
    return Te(e) ? {
        setup: e,
        name: e.name
    } : e
}
const qa = e => !!e.type.__asyncLoader;

function Tu(e) {
    Te(e) && (e = {
        loader: e
    });
    const {
        loader: t,
        loadingComponent: n,
        errorComponent: r,
        delay: s = 200,
        timeout: i,
        suspensible: o = !0,
        onError: a
    } = e;
    let l = null,
        c, u = 0;
    const d = () => (u++, l = null, f()),
        f = () => {
            let h;
            return l || (h = l = t().catch(p => {
                if (p = p instanceof Error ? p : new Error(String(p)), a) return new Promise((m, g) => {
                    a(p, () => m(d()), () => g(p), u + 1)
                });
                throw p
            }).then(p => h !== l && l ? l : (p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), c = p, p)))
        };
    return Ir({
        name: "AsyncComponentWrapper",
        __asyncLoader: f,
        get __asyncResolved() {
            return c
        },
        setup() {
            const h = on;
            if (c) return () => C0(c, h);
            const p = _ => {
                l = null, Ll(_, h, 13, !r)
            };
            if (o && h.suspense || Iu) return f().then(_ => () => C0(_, h)).catch(_ => (p(_), () => r ? ne(r, {
                error: _
            }) : null));
            const m = ae(!1),
                g = ae(),
                y = ae(!!s);
            return s && setTimeout(() => {
                y.value = !1
            }, s), i != null && setTimeout(() => {
                if (!m.value && !g.value) {
                    const _ = new Error(`Async component timed out after ${i}ms.`);
                    p(_), g.value = _
                }
            }, i), f().then(() => {
                m.value = !0, h.parent && Np(h.parent.vnode) && Z$(h.parent.update)
            }).catch(_ => {
                p(_), g.value = _
            }), () => {
                if (m.value && c) return C0(c, h);
                if (g.value && r) return ne(r, {
                    error: g.value
                });
                if (n && !y.value) return ne(n)
            }
        }
    })
}

function C0(e, {
    vnode: {
        ref: t,
        props: n,
        children: r,
        shapeFlag: s
    },
    parent: i
}) {
    const o = ne(e, n, r);
    return o.ref = t, o
}
const Np = e => e.type.__isKeepAlive,
    ile = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: {
            include: [String, RegExp, Array],
            exclude: [String, RegExp, Array],
            max: [String, Number]
        },
        setup(e, {
            slots: t
        }) {
            const n = Qn(),
                r = n.ctx;
            if (!r.renderer) return () => {
                const _ = t.default && t.default();
                return _ && _.length === 1 ? _[0] : _
            };
            const s = new Map,
                i = new Set;
            let o = null;
            const a = n.suspense,
                {
                    renderer: {
                        p: l,
                        m: c,
                        um: u,
                        o: {
                            createElement: d
                        }
                    }
                } = r,
                f = d("div");
            r.activate = (_, E, b, w, T) => {
                const S = _.component;
                c(_, E, b, 0, a), l(S.vnode, _, E, b, S, a, w, _.slotScopeIds, T), xn(() => {
                    S.isDeactivated = !1, S.a && Vc(S.a);
                    const v = _.props && _.props.onVnodeMounted;
                    v && yr(v, S.parent, _)
                }, a)
            }, r.deactivate = _ => {
                const E = _.component;
                c(_, f, null, 1, a), xn(() => {
                    E.da && Vc(E.da);
                    const b = _.props && _.props.onVnodeUnmounted;
                    b && yr(b, E.parent, _), E.isDeactivated = !0
                }, a)
            };

            function h(_) {
                A0(_), u(_, n, a, !0)
            }

            function p(_) {
                s.forEach((E, b) => {
                    const w = q_(E.type);
                    w && (!_ || !_(w)) && m(b)
                })
            }

            function m(_) {
                const E = s.get(_);
                !o || E.type !== o.type ? h(E) : o && A0(o), s.delete(_), i.delete(_)
            }
            $t(() => [e.include, e.exclude], ([_, E]) => {
                _ && p(b => Bd(_, b)), E && p(b => !Bd(E, b))
            }, {
                flush: "post",
                deep: !0
            });
            let g = null;
            const y = () => {
                g != null && s.set(g, R0(n.subTree))
            };
            return jr(y), cb(y), pa(() => {
                s.forEach(_ => {
                    const {
                        subTree: E,
                        suspense: b
                    } = n, w = R0(E);
                    if (_.type === w.type) {
                        A0(w);
                        const T = w.component.da;
                        T && xn(T, b);
                        return
                    }
                    h(_)
                })
            }), () => {
                if (g = null, !t.default) return null;
                const _ = t.default(),
                    E = _[0];
                if (_.length > 1) return o = null, _;
                if (!Qo(E) || !(E.shapeFlag & 4) && !(E.shapeFlag & 128)) return o = null, E;
                let b = R0(E);
                const w = b.type,
                    T = q_(qa(b) ? b.type.__asyncResolved || {} : w),
                    {
                        include: S,
                        exclude: v,
                        max: $
                    } = e;
                if (S && (!T || !Bd(S, T)) || v && T && Bd(v, T)) return o = b, E;
                const k = b.key == null ? w : b.key,
                    C = s.get(k);
                return b.el && (b = _s(b), E.shapeFlag & 128 && (E.ssContent = b)), g = k, C ? (b.el = C.el, b.component = C.component, b.transition && vl(b, b.transition), b.shapeFlag |= 512, i.delete(k), i.add(k)) : (i.add(k), $ && i.size > parseInt($, 10) && m(i.values().next().value)), b.shapeFlag |= 256, o = b, N5(E.type) ? E : b
            }
        }
    },
    ole = ile;

function Bd(e, t) {
    return he(e) ? e.some(n => Bd(n, t)) : Lt(e) ? e.split(",").includes(t) : e.test ? e.test(t) : !1
}

function ob(e, t) {
    B5(e, "a", t)
}

function ab(e, t) {
    B5(e, "da", t)
}

function B5(e, t, n = on) {
    const r = e.__wdc || (e.__wdc = () => {
        let s = n;
        for (; s;) {
            if (s.isDeactivated) return;
            s = s.parent
        }
        return e()
    });
    if (lb(t, r, n), n) {
        let s = n.parent;
        for (; s && s.parent;) Np(s.parent.vnode) && ale(r, t, n, s), s = s.parent
    }
}

function ale(e, t, n, r) {
    const s = lb(t, e, r, !0);
    Fl(() => {
        V$(r[t], s)
    }, n)
}

function A0(e) {
    let t = e.shapeFlag;
    t & 256 && (t -= 256), t & 512 && (t -= 512), e.shapeFlag = t
}

function R0(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}

function lb(e, t, n = on, r = !1) {
    if (n) {
        const s = n[e] || (n[e] = []),
            i = t.__weh || (t.__weh = (...o) => {
                if (n.isUnmounted) return;
                Pl(), Jo(n);
                const a = Fr(t, n, e, o);
                return No(), Ml(), a
            });
        return r ? s.unshift(i) : s.push(i), i
    }
}
const Ui = e => (t, n = on) => (!Iu || e === "sp") && lb(e, t, n),
    ak = Ui("bm"),
    jr = Ui("m"),
    V5 = Ui("bu"),
    cb = Ui("u"),
    pa = Ui("bum"),
    Fl = Ui("um"),
    H5 = Ui("sp"),
    j5 = Ui("rtg"),
    z5 = Ui("rtc");

function W5(e, t = on) {
    lb("ec", e, t)
}

function H_(e, t) {
    const n = jn;
    if (n === null) return e;
    const r = db(n) || n.proxy,
        s = e.dirs || (e.dirs = []);
    for (let i = 0; i < t.length; i++) {
        let [o, a, l, c = dt] = t[i];
        Te(o) && (o = {
            mounted: o,
            updated: o
        }), o.deep && La(a), s.push({
            dir: o,
            instance: r,
            value: a,
            oldValue: void 0,
            arg: l,
            modifiers: c
        })
    }
    return e
}

function Ts(e, t, n, r) {
    const s = e.dirs,
        i = t && t.dirs;
    for (let o = 0; o < s.length; o++) {
        const a = s[o];
        i && (a.oldValue = i[o].value);
        let l = a.dir[r];
        l && (Pl(), Fr(l, n, 8, [e.el, a, e, t]), Ml())
    }
}
const lk = "components",
    lle = "directives";

function Do(e, t) {
    return ck(lk, e, !0, t) || e
}
const G5 = Symbol();

function Ah(e) {
    return Lt(e) ? ck(lk, e, !1) || e : e || G5
}

function cle(e) {
    return ck(lle, e)
}

function ck(e, t, n = !0, r = !1) {
    const s = jn || on;
    if (s) {
        const i = s.type;
        if (e === lk) {
            const a = q_(i);
            if (a && (a === t || a === Vr(t) || a === Ap(Vr(t)))) return i
        }
        const o = fR(s[e] || i[e], t) || fR(s.appContext[e], t);
        return !o && r ? i : o
    }
}

function fR(e, t) {
    return e && (e[t] || e[Vr(t)] || e[Ap(Vr(t))])
}

function $u(e, t, n, r) {
    let s;
    const i = n && n[r];
    if (he(e) || Lt(e)) {
        s = new Array(e.length);
        for (let o = 0, a = e.length; o < a; o++) s[o] = t(e[o], o, void 0, i && i[o])
    } else if (typeof e == "number") {
        s = new Array(e);
        for (let o = 0; o < e; o++) s[o] = t(o + 1, o, void 0, i && i[o])
    } else if (qt(e))
        if (e[Symbol.iterator]) s = Array.from(e, (o, a) => t(o, a, void 0, i && i[a]));
        else {
            const o = Object.keys(e);
            s = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a];
                s[a] = t(e[c], c, a, i && i[a])
            }
        }
    else s = [];
    return n && (n[r] = s), s
}

function q5(e, t) {
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (he(r))
            for (let s = 0; s < r.length; s++) e[r[s].name] = r[s].fn;
        else r && (e[r.name] = r.fn)
    }
    return e
}

function Gn(e, t, n = {}, r, s) {
    if (jn.isCE || jn.parent && qa(jn.parent) && jn.parent.isCE) return ne("slot", t === "default" ? null : {
        name: t
    }, r && r());
    let i = e[t];
    i && i._c && (i._d = !1), z();
    const o = i && Y5(i(n)),
        a = ke(Ht, {
            key: n.key || `_${t}`
        }, o || (r ? r() : []), o && e._ === 1 ? 64 : -2);
    return !s && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), i && i._c && (i._d = !0), a
}

function Y5(e) {
    return e.some(t => Qo(t) ? !(t.type === qn || t.type === Ht && !Y5(t.children)) : !0) ? e : null
}

function QE(e) {
    const t = {};
    for (const n in e) t[ff(n)] = e[n];
    return t
}
const JE = e => e ? dV(e) ? db(e) || e.proxy : JE(e.parent) : null,
    j_ = Gt(Object.create(null), {
        $: e => e,
        $el: e => e.vnode.el,
        $data: e => e.data,
        $props: e => e.props,
        $attrs: e => e.attrs,
        $slots: e => e.slots,
        $refs: e => e.refs,
        $parent: e => JE(e.parent),
        $root: e => JE(e.root),
        $emit: e => e.emit,
        $options: e => X5(e),
        $forceUpdate: e => e.f || (e.f = () => Z$(e.update)),
        $nextTick: e => e.n || (e.n = ln.bind(e.proxy)),
        $watch: e => rle.bind(e)
    }),
    ZE = {
        get({
            _: e
        }, t) {
            const {
                ctx: n,
                setupState: r,
                data: s,
                props: i,
                accessCache: o,
                type: a,
                appContext: l
            } = e;
            let c;
            if (t[0] !== "$") {
                const h = o[t];
                if (h !== void 0) switch (h) {
                    case 1:
                        return r[t];
                    case 2:
                        return s[t];
                    case 4:
                        return n[t];
                    case 3:
                        return i[t]
                } else {
                    if (r !== dt && qe(r, t)) return o[t] = 1, r[t];
                    if (s !== dt && qe(s, t)) return o[t] = 2, s[t];
                    if ((c = e.propsOptions[0]) && qe(c, t)) return o[t] = 3, i[t];
                    if (n !== dt && qe(n, t)) return o[t] = 4, n[t];
                    e1 && (o[t] = 0)
                }
            }
            const u = j_[t];
            let d, f;
            if (u) return t === "$attrs" && Hr(e, "get", t), u(e);
            if ((d = a.__cssModules) && (d = d[t])) return d;
            if (n !== dt && qe(n, t)) return o[t] = 4, n[t];
            if (f = l.config.globalProperties, qe(f, t)) return f[t]
        },
        set({
            _: e
        }, t, n) {
            const {
                data: r,
                setupState: s,
                ctx: i
            } = e;
            return s !== dt && qe(s, t) ? (s[t] = n, !0) : r !== dt && qe(r, t) ? (r[t] = n, !0) : qe(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (i[t] = n, !0)
        },
        has({
            _: {
                data: e,
                setupState: t,
                accessCache: n,
                ctx: r,
                appContext: s,
                propsOptions: i
            }
        }, o) {
            let a;
            return !!n[o] || e !== dt && qe(e, o) || t !== dt && qe(t, o) || (a = i[0]) && qe(a, o) || qe(r, o) || qe(j_, o) || qe(s.config.globalProperties, o)
        },
        defineProperty(e, t, n) {
            return n.get != null ? e._.accessCache[t] = 0 : qe(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n)
        }
    },
    ule = Gt({}, ZE, {
        get(e, t) {
            if (t !== Symbol.unscopables) return ZE.get(e, t, e)
        },
        has(e, t) {
            return t[0] !== "_" && !Boe(t)
        }
    });
let e1 = !0;

function dle(e) {
    const t = X5(e),
        n = e.proxy,
        r = e.ctx;
    e1 = !1, t.beforeCreate && hR(t.beforeCreate, e, "bc");
    const {
        data: s,
        computed: i,
        methods: o,
        watch: a,
        provide: l,
        inject: c,
        created: u,
        beforeMount: d,
        mounted: f,
        beforeUpdate: h,
        updated: p,
        activated: m,
        deactivated: g,
        beforeDestroy: y,
        beforeUnmount: _,
        destroyed: E,
        unmounted: b,
        render: w,
        renderTracked: T,
        renderTriggered: S,
        errorCaptured: v,
        serverPrefetch: $,
        expose: k,
        inheritAttrs: C,
        components: O,
        directives: R,
        filters: N
    } = t;
    if (c && fle(c, r, null, e.appContext.config.unwrapInjectedRef), o)
        for (const ie in o) {
            const ce = o[ie];
            Te(ce) && (r[ie] = ce.bind(n))
        }
    if (s) {
        const ie = s.call(n, n);
        qt(ie) && (e.data = Pr(ie))
    }
    if (e1 = !0, i)
        for (const ie in i) {
            const ce = i[ie],
                Ue = Te(ce) ? ce.bind(n, n) : Te(ce.get) ? ce.get.bind(n, n) : ps,
                Kt = !Te(ce) && Te(ce.set) ? ce.set.bind(n) : ps,
                Yt = Fe({
                    get: Ue,
                    set: Kt
                });
            Object.defineProperty(r, ie, {
                enumerable: !0,
                configurable: !0,
                get: () => Yt.value,
                set: pn => Yt.value = pn
            })
        }
    if (a)
        for (const ie in a) K5(a[ie], r, n, ie);
    if (l) {
        const ie = Te(l) ? l.call(n) : l;
        Reflect.ownKeys(ie).forEach(ce => {
            fi(ce, ie[ce])
        })
    }
    u && hR(u, e, "c");

    function Y(ie, ce) {
        he(ce) ? ce.forEach(Ue => ie(Ue.bind(n))) : ce && ie(ce.bind(n))
    }
    if (Y(ak, d), Y(jr, f), Y(V5, h), Y(cb, p), Y(ob, m), Y(ab, g), Y(W5, v), Y(z5, T), Y(j5, S), Y(pa, _), Y(Fl, b), Y(H5, $), he(k))
        if (k.length) {
            const ie = e.exposed || (e.exposed = {});
            k.forEach(ce => {
                Object.defineProperty(ie, ce, {
                    get: () => n[ce],
                    set: Ue => n[ce] = Ue
                })
            })
        } else e.exposed || (e.exposed = {});
    w && e.render === ps && (e.render = w), C != null && (e.inheritAttrs = C), O && (e.components = O), R && (e.directives = R)
}

function fle(e, t, n = ps, r = !1) {
    he(e) && (e = t1(e));
    for (const s in e) {
        const i = e[s];
        let o;
        qt(i) ? "default" in i ? o = bt(i.from || s, i.default, !0) : o = bt(i.from || s) : o = bt(i), gt(o) && r ? Object.defineProperty(t, s, {
            enumerable: !0,
            configurable: !0,
            get: () => o.value,
            set: a => o.value = a
        }) : t[s] = o
    }
}

function hR(e, t, n) {
    Fr(he(e) ? e.map(r => r.bind(t.proxy)) : e.bind(t.proxy), t, n)
}

function K5(e, t, n, r) {
    const s = r.includes(".") ? F5(n, r) : () => n[r];
    if (Lt(e)) {
        const i = t[e];
        Te(i) && $t(s, i)
    } else if (Te(e)) $t(s, e.bind(n));
    else if (qt(e))
        if (he(e)) e.forEach(i => K5(i, t, n, r));
        else {
            const i = Te(e.handler) ? e.handler.bind(n) : t[e.handler];
            Te(i) && $t(s, i, e)
        }
}

function X5(e) {
    const t = e.type,
        {
            mixins: n,
            extends: r
        } = t,
        {
            mixins: s,
            optionsCache: i,
            config: {
                optionMergeStrategies: o
            }
        } = e.appContext,
        a = i.get(t);
    let l;
    return a ? l = a : !s.length && !n && !r ? l = t : (l = {}, s.length && s.forEach(c => z_(l, c, o, !0)), z_(l, t, o)), i.set(t, l), l
}

function z_(e, t, n, r = !1) {
    const {
        mixins: s,
        extends: i
    } = t;
    i && z_(e, i, n, !0), s && s.forEach(o => z_(e, o, n, !0));
    for (const o in t)
        if (!(r && o === "expose")) {
            const a = hle[o] || n && n[o];
            e[o] = a ? a(e[o], t[o]) : t[o]
        }
    return e
}
const hle = {
    data: pR,
    props: Sa,
    emits: Sa,
    methods: Sa,
    computed: Sa,
    beforeCreate: er,
    created: er,
    beforeMount: er,
    mounted: er,
    beforeUpdate: er,
    updated: er,
    beforeDestroy: er,
    beforeUnmount: er,
    destroyed: er,
    unmounted: er,
    activated: er,
    deactivated: er,
    errorCaptured: er,
    serverPrefetch: er,
    components: Sa,
    directives: Sa,
    watch: mle,
    provide: pR,
    inject: ple
};

function pR(e, t) {
    return t ? e ? function() {
        return Gt(Te(e) ? e.call(this, this) : e, Te(t) ? t.call(this, this) : t)
    } : t : e
}

function ple(e, t) {
    return Sa(t1(e), t1(t))
}

function t1(e) {
    if (he(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
        return t
    }
    return e
}

function er(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}

function Sa(e, t) {
    return e ? Gt(Gt(Object.create(null), e), t) : t
}

function mle(e, t) {
    if (!e) return t;
    if (!t) return e;
    const n = Gt(Object.create(null), e);
    for (const r in t) n[r] = er(e[r], t[r]);
    return n
}

function gle(e, t, n, r = !1) {
    const s = {},
        i = {};
    L_(i, ub, 1), e.propsDefaults = Object.create(null), Q5(e, t, s, i);
    for (const o in e.propsOptions[0]) o in s || (s[o] = void 0);
    n ? e.props = r ? s : F_(s) : e.type.props ? e.props = s : e.props = i, e.attrs = i
}

function _le(e, t, n, r) {
    const {
        props: s,
        attrs: i,
        vnode: {
            patchFlag: o
        }
    } = e, a = ze(s), [l] = e.propsOptions;
    let c = !1;
    if ((r || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = e.vnode.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                let f = u[d];
                if (rb(e.emitsOptions, f)) continue;
                const h = t[f];
                if (l)
                    if (qe(i, f)) h !== i[f] && (i[f] = h, c = !0);
                    else {
                        const p = Vr(f);
                        s[p] = n1(l, a, p, h, e, !1)
                    }
                else h !== i[f] && (i[f] = h, c = !0)
            }
        }
    } else {
        Q5(e, t, s, i) && (c = !0);
        let u;
        for (const d in a)(!t || !qe(t, d) && ((u = Ns(d)) === d || !qe(t, u))) && (l ? n && (n[d] !== void 0 || n[u] !== void 0) && (s[d] = n1(l, a, d, void 0, e, !0)) : delete s[d]);
        if (i !== a)
            for (const d in i)(!t || !qe(t, d) && !0) && (delete i[d], c = !0)
    }
    c && Ii(e, "set", "$attrs")
}

function Q5(e, t, n, r) {
    const [s, i] = e.propsOptions;
    let o = !1,
        a;
    if (t)
        for (let l in t) {
            if (df(l)) continue;
            const c = t[l];
            let u;
            s && qe(s, u = Vr(l)) ? !i || !i.includes(u) ? n[u] = c : (a || (a = {}))[u] = c : rb(e.emitsOptions, l) || (!(l in r) || c !== r[l]) && (r[l] = c, o = !0)
        }
    if (i) {
        const l = ze(n),
            c = a || dt;
        for (let u = 0; u < i.length; u++) {
            const d = i[u];
            n[d] = n1(s, l, d, c[d], e, !qe(c, d))
        }
    }
    return o
}

function n1(e, t, n, r, s, i) {
    const o = e[n];
    if (o != null) {
        const a = qe(o, "default");
        if (a && r === void 0) {
            const l = o.default;
            if (o.type !== Function && Te(l)) {
                const {
                    propsDefaults: c
                } = s;
                n in c ? r = c[n] : (Jo(s), r = c[n] = l.call(null, t), No())
            } else r = l
        }
        o[0] && (i && !a ? r = !1 : o[1] && (r === "" || r === Ns(n)) && (r = !0))
    }
    return r
}

function J5(e, t, n = !1) {
    const r = t.propsCache,
        s = r.get(e);
    if (s) return s;
    const i = e.props,
        o = {},
        a = [];
    let l = !1;
    if (!Te(e)) {
        const u = d => {
            l = !0;
            const [f, h] = J5(d, t, !0);
            Gt(o, f), h && a.push(...h)
        };
        !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u)
    }
    if (!i && !l) return r.set(e, Uc), Uc;
    if (he(i))
        for (let u = 0; u < i.length; u++) {
            const d = Vr(i[u]);
            mR(d) && (o[d] = dt)
        } else if (i)
            for (const u in i) {
                const d = Vr(u);
                if (mR(d)) {
                    const f = i[u],
                        h = o[d] = he(f) || Te(f) ? {
                            type: f
                        } : f;
                    if (h) {
                        const p = yR(Boolean, h.type),
                            m = yR(String, h.type);
                        h[0] = p > -1, h[1] = m < 0 || p < m, (p > -1 || qe(h, "default")) && a.push(d)
                    }
                }
            }
    const c = [o, a];
    return r.set(e, c), c
}

function mR(e) {
    return e[0] !== "$"
}

function gR(e) {
    const t = e && e.toString().match(/^\s*function (\w+)/);
    return t ? t[1] : e === null ? "null" : ""
}

function _R(e, t) {
    return gR(e) === gR(t)
}

function yR(e, t) {
    return he(t) ? t.findIndex(n => _R(n, e)) : Te(t) && _R(t, e) ? 0 : -1
}
const Z5 = e => e[0] === "_" || e === "$stable",
    uk = e => he(e) ? e.map(Ar) : [Ar(e)],
    yle = (e, t, n) => {
        if (t._n) return t;
        const r = Re((...s) => uk(t(...s)), n);
        return r._c = !1, r
    },
    eV = (e, t, n) => {
        const r = e._ctx;
        for (const s in e) {
            if (Z5(s)) continue;
            const i = e[s];
            if (Te(i)) t[s] = yle(s, i, r);
            else if (i != null) {
                const o = uk(i);
                t[s] = () => o
            }
        }
    },
    tV = (e, t) => {
        const n = uk(t);
        e.slots.default = () => n
    },
    vle = (e, t) => {
        if (e.vnode.shapeFlag & 32) {
            const n = t._;
            n ? (e.slots = ze(t), L_(t, "_", n)) : eV(t, e.slots = {})
        } else e.slots = {}, t && tV(e, t);
        L_(e.slots, ub, 1)
    },
    ble = (e, t, n) => {
        const {
            vnode: r,
            slots: s
        } = e;
        let i = !0,
            o = dt;
        if (r.shapeFlag & 32) {
            const a = t._;
            a ? n && a === 1 ? i = !1 : (Gt(s, t), !n && a === 1 && delete s._) : (i = !t.$stable, eV(t, s)), o = t
        } else t && (tV(e, t), o = {
            default: 1
        });
        if (i)
            for (const a in s) !Z5(a) && !(a in o) && delete s[a]
    };

function nV() {
    return {
        app: null,
        config: {
            isNativeTag: Yoe,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let wle = 0;

function Ele(e, t) {
    return function(r, s = null) {
        Te(r) || (r = Object.assign({}, r)), s != null && !qt(s) && (s = null);
        const i = nV(),
            o = new Set;
        let a = !1;
        const l = i.app = {
            _uid: wle++,
            _component: r,
            _props: s,
            _container: null,
            _context: i,
            _instance: null,
            version: fb,
            get config() {
                return i.config
            },
            set config(c) {},
            use(c, ...u) {
                return o.has(c) || (c && Te(c.install) ? (o.add(c), c.install(l, ...u)) : Te(c) && (o.add(c), c(l, ...u))), l
            },
            mixin(c) {
                return i.mixins.includes(c) || i.mixins.push(c), l
            },
            component(c, u) {
                return u ? (i.components[c] = u, l) : i.components[c]
            },
            directive(c, u) {
                return u ? (i.directives[c] = u, l) : i.directives[c]
            },
            mount(c, u, d) {
                if (!a) {
                    const f = ne(r, s);
                    return f.appContext = i, u && t ? t(f, c) : e(f, c, d), a = !0, l._container = c, c.__vue_app__ = l, db(f.component) || f.component.proxy
                }
            },
            unmount() {
                a && (e(null, l._container), delete l._container.__vue_app__)
            },
            provide(c, u) {
                return i.provides[c] = u, l
            }
        };
        return l
    }
}

function W_(e, t, n, r, s = !1) {
    if (he(e)) {
        e.forEach((f, h) => W_(f, t && (he(t) ? t[h] : t), n, r, s));
        return
    }
    if (qa(r) && !s) return;
    const i = r.shapeFlag & 4 ? db(r.component) || r.component.proxy : r.el,
        o = s ? null : i,
        {
            i: a,
            r: l
        } = e,
        c = t && t.r,
        u = a.refs === dt ? a.refs = {} : a.refs,
        d = a.setupState;
    if (c != null && c !== l && (Lt(c) ? (u[c] = null, qe(d, c) && (d[c] = null)) : gt(c) && (c.value = null)), Te(l)) Ps(l, a, 12, [o, u]);
    else {
        const f = Lt(l),
            h = gt(l);
        if (f || h) {
            const p = () => {
                if (e.f) {
                    const m = f ? u[l] : l.value;
                    s ? he(m) && V$(m, i) : he(m) ? m.includes(i) || m.push(i) : f ? (u[l] = [i], qe(d, l) && (d[l] = u[l])) : (l.value = [i], e.k && (u[e.k] = l.value))
                } else f ? (u[l] = o, qe(d, l) && (d[l] = o)) : gt(l) && (l.value = o, e.k && (u[e.k] = o))
            };
            o ? (p.id = -1, xn(p, n)) : p()
        }
    }
}
let Zi = !1;
const Im = e => /svg/.test(e.namespaceURI) && e.tagName !== "foreignObject",
    xm = e => e.nodeType === 8;

function Sle(e) {
    const {
        mt: t,
        p: n,
        o: {
            patchProp: r,
            createText: s,
            nextSibling: i,
            parentNode: o,
            remove: a,
            insert: l,
            createComment: c
        }
    } = e, u = (y, _) => {
        if (!_.hasChildNodes()) {
            n(null, y, _), V_();
            return
        }
        Zi = !1, d(_.firstChild, y, null, null, null), V_(), Zi && console.error("Hydration completed but contains mismatches.")
    }, d = (y, _, E, b, w, T = !1) => {
        const S = xm(y) && y.data === "[",
            v = () => m(y, _, E, b, w, S),
            {
                type: $,
                ref: k,
                shapeFlag: C,
                patchFlag: O
            } = _,
            R = y.nodeType;
        _.el = y, O === -2 && (T = !1, _.dynamicChildren = null);
        let N = null;
        switch ($) {
            case ku:
                R !== 3 ? _.children === "" ? (l(_.el = s(""), y.parentElement, y), N = y) : N = v() : (y.data !== _.children && (Zi = !0, y.data = _.children), N = i(y));
                break;
            case qn:
                R !== 8 || S ? N = v() : N = i(y);
                break;
            case Ya:
                if (R !== 1) N = v();
                else {
                    N = y;
                    const J = !_.children.length;
                    for (let Y = 0; Y < _.staticCount; Y++) J && (_.children += N.outerHTML), Y === _.staticCount - 1 && (_.anchor = N), N = i(N);
                    return N
                }
                break;
            case Ht:
                S ? N = p(y, _, E, b, w, T) : N = v();
                break;
            default:
                if (C & 1) R !== 1 || _.type.toLowerCase() !== y.tagName.toLowerCase() ? N = v() : N = f(y, _, E, b, w, T);
                else if (C & 6) {
                    _.slotScopeIds = w;
                    const J = o(y);
                    if (t(_, J, null, E, b, Im(J), T), N = S ? g(y) : i(y), N && xm(N) && N.data === "teleport end" && (N = i(N)), qa(_)) {
                        let Y;
                        S ? (Y = ne(Ht), Y.anchor = N ? N.previousSibling : J.lastChild) : Y = y.nodeType === 3 ? hn("") : ne("div"), Y.el = y, _.component.subTree = Y
                    }
                } else C & 64 ? R !== 8 ? N = v() : N = _.type.hydrate(y, _, E, b, w, T, e, h) : C & 128 && (N = _.type.hydrate(y, _, E, b, Im(o(y)), w, T, e, d))
        }
        return k != null && W_(k, null, b, _), N
    }, f = (y, _, E, b, w, T) => {
        T = T || !!_.dynamicChildren;
        const {
            type: S,
            props: v,
            patchFlag: $,
            shapeFlag: k,
            dirs: C
        } = _, O = S === "input" && C || S === "option";
        if (O || $ !== -1) {
            if (C && Ts(_, null, E, "created"), v)
                if (O || !T || $ & 48)
                    for (const N in v)(O && N.endsWith("value") || xp(N) && !df(N)) && r(y, N, null, v[N], !1, void 0, E);
                else v.onClick && r(y, "onClick", null, v.onClick, !1, void 0, E);
            let R;
            if ((R = v && v.onVnodeBeforeMount) && yr(R, E, _), C && Ts(_, null, E, "beforeMount"), ((R = v && v.onVnodeMounted) || C) && M5(() => {
                    R && yr(R, E, _), C && Ts(_, null, E, "mounted")
                }, b), k & 16 && !(v && (v.innerHTML || v.textContent))) {
                let N = h(y.firstChild, _, y, E, b, w, T);
                for (; N;) {
                    Zi = !0;
                    const J = N;
                    N = N.nextSibling, a(J)
                }
            } else k & 8 && y.textContent !== _.children && (Zi = !0, y.textContent = _.children)
        }
        return y.nextSibling
    }, h = (y, _, E, b, w, T, S) => {
        S = S || !!_.dynamicChildren;
        const v = _.children,
            $ = v.length;
        for (let k = 0; k < $; k++) {
            const C = S ? v[k] : v[k] = Ar(v[k]);
            if (y) y = d(y, C, b, w, T, S);
            else {
                if (C.type === ku && !C.children) continue;
                Zi = !0, n(null, C, E, null, b, w, Im(E), T)
            }
        }
        return y
    }, p = (y, _, E, b, w, T) => {
        const {
            slotScopeIds: S
        } = _;
        S && (w = w ? w.concat(S) : S);
        const v = o(y),
            $ = h(i(y), _, v, E, b, w, T);
        return $ && xm($) && $.data === "]" ? i(_.anchor = $) : (Zi = !0, l(_.anchor = c("]"), v, $), $)
    }, m = (y, _, E, b, w, T) => {
        if (Zi = !0, _.el = null, T) {
            const $ = g(y);
            for (;;) {
                const k = i(y);
                if (k && k !== $) a(k);
                else break
            }
        }
        const S = i(y),
            v = o(y);
        return a(y), n(null, _, v, S, E, b, Im(v), w), S
    }, g = y => {
        let _ = 0;
        for (; y;)
            if (y = i(y), y && xm(y) && (y.data === "[" && _++, y.data === "]")) {
                if (_ === 0) return i(y);
                _--
            }
        return y
    };
    return [u, d]
}
const xn = M5;

function rV(e) {
    return iV(e)
}

function sV(e) {
    return iV(e, Sle)
}

function iV(e, t) {
    const n = eae();
    n.__VUE__ = !0;
    const {
        insert: r,
        remove: s,
        patchProp: i,
        createElement: o,
        createText: a,
        createComment: l,
        setText: c,
        setElementText: u,
        parentNode: d,
        nextSibling: f,
        setScopeId: h = ps,
        cloneNode: p,
        insertStaticContent: m
    } = e, g = (I, A, P, B = null, F = null, j = null, te = !1, q = null, Q = !!A.dynamicChildren) => {
        if (I === A) return;
        I && !Is(I, A) && (B = V(I), mn(I, F, j, !0), I = null), A.patchFlag === -2 && (Q = !1, A.dynamicChildren = null);
        const {
            type: H,
            ref: _e,
            shapeFlag: ue
        } = A;
        switch (H) {
            case ku:
                y(I, A, P, B);
                break;
            case qn:
                _(I, A, P, B);
                break;
            case Ya:
                I == null && E(A, P, B, te);
                break;
            case Ht:
                R(I, A, P, B, F, j, te, q, Q);
                break;
            default:
                ue & 1 ? T(I, A, P, B, F, j, te, q, Q) : ue & 6 ? N(I, A, P, B, F, j, te, q, Q) : (ue & 64 || ue & 128) && H.process(I, A, P, B, F, j, te, q, Q, we)
        }
        _e != null && F && W_(_e, I && I.ref, j, A || I, !A)
    }, y = (I, A, P, B) => {
        if (I == null) r(A.el = a(A.children), P, B);
        else {
            const F = A.el = I.el;
            A.children !== I.children && c(F, A.children)
        }
    }, _ = (I, A, P, B) => {
        I == null ? r(A.el = l(A.children || ""), P, B) : A.el = I.el
    }, E = (I, A, P, B) => {
        [I.el, I.anchor] = m(I.children, A, P, B, I.el, I.anchor)
    }, b = ({
        el: I,
        anchor: A
    }, P, B) => {
        let F;
        for (; I && I !== A;) F = f(I), r(I, P, B), I = F;
        r(A, P, B)
    }, w = ({
        el: I,
        anchor: A
    }) => {
        let P;
        for (; I && I !== A;) P = f(I), s(I), I = P;
        s(A)
    }, T = (I, A, P, B, F, j, te, q, Q) => {
        te = te || A.type === "svg", I == null ? S(A, P, B, F, j, te, q, Q) : k(I, A, F, j, te, q, Q)
    }, S = (I, A, P, B, F, j, te, q) => {
        let Q, H;
        const {
            type: _e,
            props: ue,
            shapeFlag: le,
            transition: ye,
            patchFlag: Ae,
            dirs: lt
        } = I;
        if (I.el && p !== void 0 && Ae === -1) Q = I.el = p(I.el);
        else {
            if (Q = I.el = o(I.type, j, ue && ue.is, ue), le & 8 ? u(Q, I.children) : le & 16 && $(I.children, Q, null, B, F, j && _e !== "foreignObject", te, q), lt && Ts(I, null, B, "created"), ue) {
                for (const yt in ue) yt !== "value" && !df(yt) && i(Q, yt, null, ue[yt], j, I.children, B, F, D);
                "value" in ue && i(Q, "value", null, ue.value), (H = ue.onVnodeBeforeMount) && yr(H, B, I)
            }
            v(Q, I, I.scopeId, te, B)
        }
        lt && Ts(I, null, B, "beforeMount");
        const Me = (!F || F && !F.pendingBranch) && ye && !ye.persisted;
        Me && ye.beforeEnter(Q), r(Q, A, P), ((H = ue && ue.onVnodeMounted) || Me || lt) && xn(() => {
            H && yr(H, B, I), Me && ye.enter(Q), lt && Ts(I, null, B, "mounted")
        }, F)
    }, v = (I, A, P, B, F) => {
        if (P && h(I, P), B)
            for (let j = 0; j < B.length; j++) h(I, B[j]);
        if (F) {
            let j = F.subTree;
            if (A === j) {
                const te = F.vnode;
                v(I, te, te.scopeId, te.slotScopeIds, F.parent)
            }
        }
    }, $ = (I, A, P, B, F, j, te, q, Q = 0) => {
        for (let H = Q; H < I.length; H++) {
            const _e = I[H] = q ? lo(I[H]) : Ar(I[H]);
            g(null, _e, A, P, B, F, j, te, q)
        }
    }, k = (I, A, P, B, F, j, te) => {
        const q = A.el = I.el;
        let {
            patchFlag: Q,
            dynamicChildren: H,
            dirs: _e
        } = A;
        Q |= I.patchFlag & 16;
        const ue = I.props || dt,
            le = A.props || dt;
        let ye;
        P && ya(P, !1), (ye = le.onVnodeBeforeUpdate) && yr(ye, P, A, I), _e && Ts(A, I, P, "beforeUpdate"), P && ya(P, !0);
        const Ae = F && A.type !== "foreignObject";
        if (H ? C(I.dynamicChildren, H, q, P, B, Ae, j) : te || Ue(I, A, q, null, P, B, Ae, j, !1), Q > 0) {
            if (Q & 16) O(q, A, ue, le, P, B, F);
            else if (Q & 2 && ue.class !== le.class && i(q, "class", null, le.class, F), Q & 4 && i(q, "style", ue.style, le.style, F), Q & 8) {
                const lt = A.dynamicProps;
                for (let Me = 0; Me < lt.length; Me++) {
                    const yt = lt[Me],
                        xr = ue[yt],
                        Yi = le[yt];
                    (Yi !== xr || yt === "value") && i(q, yt, xr, Yi, F, I.children, P, B, D)
                }
            }
            Q & 1 && I.children !== A.children && u(q, A.children)
        } else !te && H == null && O(q, A, ue, le, P, B, F);
        ((ye = le.onVnodeUpdated) || _e) && xn(() => {
            ye && yr(ye, P, A, I), _e && Ts(A, I, P, "updated")
        }, B)
    }, C = (I, A, P, B, F, j, te) => {
        for (let q = 0; q < A.length; q++) {
            const Q = I[q],
                H = A[q],
                _e = Q.el && (Q.type === Ht || !Is(Q, H) || Q.shapeFlag & 70) ? d(Q.el) : P;
            g(Q, H, _e, null, B, F, j, te, !0)
        }
    }, O = (I, A, P, B, F, j, te) => {
        if (P !== B) {
            for (const q in B) {
                if (df(q)) continue;
                const Q = B[q],
                    H = P[q];
                Q !== H && q !== "value" && i(I, q, H, Q, te, A.children, F, j, D)
            }
            if (P !== dt)
                for (const q in P) !df(q) && !(q in B) && i(I, q, P[q], null, te, A.children, F, j, D);
            "value" in B && i(I, "value", P.value, B.value)
        }
    }, R = (I, A, P, B, F, j, te, q, Q) => {
        const H = A.el = I ? I.el : a(""),
            _e = A.anchor = I ? I.anchor : a("");
        let {
            patchFlag: ue,
            dynamicChildren: le,
            slotScopeIds: ye
        } = A;
        ye && (q = q ? q.concat(ye) : ye), I == null ? (r(H, P, B), r(_e, P, B), $(A.children, P, _e, F, j, te, q, Q)) : ue > 0 && ue & 64 && le && I.dynamicChildren ? (C(I.dynamicChildren, le, P, F, j, te, q), (A.key != null || F && A === F.subTree) && dk(I, A, !0)) : Ue(I, A, P, _e, F, j, te, q, Q)
    }, N = (I, A, P, B, F, j, te, q, Q) => {
        A.slotScopeIds = q, I == null ? A.shapeFlag & 512 ? F.ctx.activate(A, P, B, te, Q) : J(A, P, B, F, j, te, Q) : Y(I, A, Q)
    }, J = (I, A, P, B, F, j, te) => {
        const q = I.component = uV(I, B, F);
        if (Np(I) && (q.ctx.renderer = we), fV(q), q.asyncDep) {
            if (F && F.registerDep(q, ie), !I.el) {
                const Q = q.subTree = ne(qn);
                _(null, Q, A, P)
            }
            return
        }
        ie(q, I, A, P, F, j, te)
    }, Y = (I, A, P) => {
        const B = A.component = I.component;
        if (Xae(I, A, P))
            if (B.asyncDep && !B.asyncResolved) {
                ce(B, A, P);
                return
            } else B.next = A, zae(B.update), B.update();
        else A.el = I.el, B.vnode = A
    }, ie = (I, A, P, B, F, j, te) => {
        const q = () => {
                if (I.isMounted) {
                    let {
                        next: _e,
                        bu: ue,
                        u: le,
                        parent: ye,
                        vnode: Ae
                    } = I, lt = _e, Me;
                    ya(I, !1), _e ? (_e.el = Ae.el, ce(I, _e, te)) : _e = Ae, ue && Vc(ue), (Me = _e.props && _e.props.onVnodeBeforeUpdate) && yr(Me, ye, _e, Ae), ya(I, !0);
                    const yt = _g(I),
                        xr = I.subTree;
                    I.subTree = yt, g(xr, yt, d(xr.el), V(xr), I, F, j), _e.el = yt.el, lt === null && rk(I, yt.el), le && xn(le, F), (Me = _e.props && _e.props.onVnodeUpdated) && xn(() => yr(Me, ye, _e, Ae), F)
                } else {
                    let _e;
                    const {
                        el: ue,
                        props: le
                    } = A, {
                        bm: ye,
                        m: Ae,
                        parent: lt
                    } = I, Me = qa(A);
                    if (ya(I, !1), ye && Vc(ye), !Me && (_e = le && le.onVnodeBeforeMount) && yr(_e, lt, A), ya(I, !0), ue && ee) {
                        const yt = () => {
                            I.subTree = _g(I), ee(ue, I.subTree, I, F, null)
                        };
                        Me ? A.type.__asyncLoader().then(() => !I.isUnmounted && yt()) : yt()
                    } else {
                        const yt = I.subTree = _g(I);
                        g(null, yt, P, B, I, F, j), A.el = yt.el
                    }
                    if (Ae && xn(Ae, F), !Me && (_e = le && le.onVnodeMounted)) {
                        const yt = A;
                        xn(() => yr(_e, lt, yt), F)
                    }(A.shapeFlag & 256 || lt && qa(lt.vnode) && lt.vnode.shapeFlag & 256) && I.a && xn(I.a, F), I.isMounted = !0, A = P = B = null
                }
            },
            Q = I.effect = new Rp(q, () => Z$(H), I.scope),
            H = I.update = () => Q.run();
        H.id = I.uid, ya(I, !0), H()
    }, ce = (I, A, P) => {
        A.component = I;
        const B = I.vnode.props;
        I.vnode = A, I.next = null, _le(I, A.props, B, P), ble(I, A.children, P), Pl(), nb(void 0, I.update), Ml()
    }, Ue = (I, A, P, B, F, j, te, q, Q = !1) => {
        const H = I && I.children,
            _e = I ? I.shapeFlag : 0,
            ue = A.children,
            {
                patchFlag: le,
                shapeFlag: ye
            } = A;
        if (le > 0) {
            if (le & 128) {
                Yt(H, ue, P, B, F, j, te, q, Q);
                return
            } else if (le & 256) {
                Kt(H, ue, P, B, F, j, te, q, Q);
                return
            }
        }
        ye & 8 ? (_e & 16 && D(H, F, j), ue !== H && u(P, ue)) : _e & 16 ? ye & 16 ? Yt(H, ue, P, B, F, j, te, q, Q) : D(H, F, j, !0) : (_e & 8 && u(P, ""), ye & 16 && $(ue, P, B, F, j, te, q, Q))
    }, Kt = (I, A, P, B, F, j, te, q, Q) => {
        I = I || Uc, A = A || Uc;
        const H = I.length,
            _e = A.length,
            ue = Math.min(H, _e);
        let le;
        for (le = 0; le < ue; le++) {
            const ye = A[le] = Q ? lo(A[le]) : Ar(A[le]);
            g(I[le], ye, P, null, F, j, te, q, Q)
        }
        H > _e ? D(I, F, j, !0, !1, ue) : $(A, P, B, F, j, te, q, Q, ue)
    }, Yt = (I, A, P, B, F, j, te, q, Q) => {
        let H = 0;
        const _e = A.length;
        let ue = I.length - 1,
            le = _e - 1;
        for (; H <= ue && H <= le;) {
            const ye = I[H],
                Ae = A[H] = Q ? lo(A[H]) : Ar(A[H]);
            if (Is(ye, Ae)) g(ye, Ae, P, null, F, j, te, q, Q);
            else break;
            H++
        }
        for (; H <= ue && H <= le;) {
            const ye = I[ue],
                Ae = A[le] = Q ? lo(A[le]) : Ar(A[le]);
            if (Is(ye, Ae)) g(ye, Ae, P, null, F, j, te, q, Q);
            else break;
            ue--, le--
        }
        if (H > ue) {
            if (H <= le) {
                const ye = le + 1,
                    Ae = ye < _e ? A[ye].el : B;
                for (; H <= le;) g(null, A[H] = Q ? lo(A[H]) : Ar(A[H]), P, Ae, F, j, te, q, Q), H++
            }
        } else if (H > le)
            for (; H <= ue;) mn(I[H], F, j, !0), H++;
        else {
            const ye = H,
                Ae = H,
                lt = new Map;
            for (H = Ae; H <= le; H++) {
                const Jn = A[H] = Q ? lo(A[H]) : Ar(A[H]);
                Jn.key != null && lt.set(Jn.key, H)
            }
            let Me, yt = 0;
            const xr = le - Ae + 1;
            let Yi = !1,
                zp = 0;
            const ws = new Array(xr);
            for (H = 0; H < xr; H++) ws[H] = 0;
            for (H = ye; H <= ue; H++) {
                const Jn = I[H];
                if (yt >= xr) {
                    mn(Jn, F, j, !0);
                    continue
                }
                let Wr;
                if (Jn.key != null) Wr = lt.get(Jn.key);
                else
                    for (Me = Ae; Me <= le; Me++)
                        if (ws[Me - Ae] === 0 && Is(Jn, A[Me])) {
                            Wr = Me;
                            break
                        }
                Wr === void 0 ? mn(Jn, F, j, !0) : (ws[Wr - Ae] = H + 1, Wr >= zp ? zp = Wr : Yi = !0, g(Jn, A[Wr], P, null, F, j, te, q, Q), yt++)
            }
            const Wp = Yi ? Tle(ws) : Uc;
            for (Me = Wp.length - 1, H = xr - 1; H >= 0; H--) {
                const Jn = Ae + H,
                    Wr = A[Jn],
                    Gp = Jn + 1 < _e ? A[Jn + 1].el : B;
                ws[H] === 0 ? g(null, Wr, P, Gp, F, j, te, q, Q) : Yi && (Me < 0 || H !== Wp[Me] ? pn(Wr, P, Gp, 2) : Me--)
            }
        }
    }, pn = (I, A, P, B, F = null) => {
        const {
            el: j,
            type: te,
            transition: q,
            children: Q,
            shapeFlag: H
        } = I;
        if (H & 6) {
            pn(I.component.subTree, A, P, B);
            return
        }
        if (H & 128) {
            I.suspense.move(A, P, B);
            return
        }
        if (H & 64) {
            te.move(I, A, P, we);
            return
        }
        if (te === Ht) {
            r(j, A, P);
            for (let ue = 0; ue < Q.length; ue++) pn(Q[ue], A, P, B);
            r(I.anchor, A, P);
            return
        }
        if (te === Ya) {
            b(I, A, P);
            return
        }
        if (B !== 2 && H & 1 && q)
            if (B === 0) q.beforeEnter(j), r(j, A, P), xn(() => q.enter(j), F);
            else {
                const {
                    leave: ue,
                    delayLeave: le,
                    afterLeave: ye
                } = q, Ae = () => r(j, A, P), lt = () => {
                    ue(j, () => {
                        Ae(), ye && ye()
                    })
                };
                le ? le(j, Ae, lt) : lt()
            }
        else r(j, A, P)
    }, mn = (I, A, P, B = !1, F = !1) => {
        const {
            type: j,
            props: te,
            ref: q,
            children: Q,
            dynamicChildren: H,
            shapeFlag: _e,
            patchFlag: ue,
            dirs: le
        } = I;
        if (q != null && W_(q, null, P, I, !0), _e & 256) {
            A.ctx.deactivate(I);
            return
        }
        const ye = _e & 1 && le,
            Ae = !qa(I);
        let lt;
        if (Ae && (lt = te && te.onVnodeBeforeUnmount) && yr(lt, A, I), _e & 6) se(I.component, P, B);
        else {
            if (_e & 128) {
                I.suspense.unmount(P, B);
                return
            }
            ye && Ts(I, null, A, "beforeUnmount"), _e & 64 ? I.type.remove(I, A, P, F, we, B) : H && (j !== Ht || ue > 0 && ue & 64) ? D(H, A, P, !1, !0) : (j === Ht && ue & 384 || !F && _e & 16) && D(Q, A, P), B && pr(I)
        }(Ae && (lt = te && te.onVnodeUnmounted) || ye) && xn(() => {
            lt && yr(lt, A, I), ye && Ts(I, null, A, "unmounted")
        }, P)
    }, pr = I => {
        const {
            type: A,
            el: P,
            anchor: B,
            transition: F
        } = I;
        if (A === Ht) {
            L(P, B);
            return
        }
        if (A === Ya) {
            w(I);
            return
        }
        const j = () => {
            s(P), F && !F.persisted && F.afterLeave && F.afterLeave()
        };
        if (I.shapeFlag & 1 && F && !F.persisted) {
            const {
                leave: te,
                delayLeave: q
            } = F, Q = () => te(P, j);
            q ? q(I.el, j, Q) : Q()
        } else j()
    }, L = (I, A) => {
        let P;
        for (; I !== A;) P = f(I), s(I), I = P;
        s(A)
    }, se = (I, A, P) => {
        const {
            bum: B,
            scope: F,
            update: j,
            subTree: te,
            um: q
        } = I;
        B && Vc(B), F.stop(), j && (j.active = !1, mn(te, I, A, P)), q && xn(q, A), xn(() => {
            I.isUnmounted = !0
        }, A), A && A.pendingBranch && !A.isUnmounted && I.asyncDep && !I.asyncResolved && I.suspenseId === A.pendingId && (A.deps--, A.deps === 0 && A.resolve())
    }, D = (I, A, P, B = !1, F = !1, j = 0) => {
        for (let te = j; te < I.length; te++) mn(I[te], A, P, B, F)
    }, V = I => I.shapeFlag & 6 ? V(I.component.subTree) : I.shapeFlag & 128 ? I.suspense.next() : f(I.anchor || I.el), oe = (I, A, P) => {
        I == null ? A._vnode && mn(A._vnode, null, null, !0) : g(A._vnode || null, I, A, null, null, null, P), V_(), A._vnode = I
    }, we = {
        p: g,
        um: mn,
        m: pn,
        r: pr,
        mt: J,
        mc: $,
        pc: Ue,
        pbc: C,
        n: V,
        o: e
    };
    let ge, ee;
    return t && ([ge, ee] = t(we)), {
        render: oe,
        hydrate: ge,
        createApp: Ele(oe, ge)
    }
}

function ya({
    effect: e,
    update: t
}, n) {
    e.allowRecurse = t.allowRecurse = n
}

function dk(e, t, n = !1) {
    const r = e.children,
        s = t.children;
    if (he(r) && he(s))
        for (let i = 0; i < r.length; i++) {
            const o = r[i];
            let a = s[i];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = s[i] = lo(s[i]), a.el = o.el), n || dk(o, a))
        }
}

function Tle(e) {
    const t = e.slice(),
        n = [0];
    let r, s, i, o, a;
    const l = e.length;
    for (r = 0; r < l; r++) {
        const c = e[r];
        if (c !== 0) {
            if (s = n[n.length - 1], e[s] < c) {
                t[r] = s, n.push(r);
                continue
            }
            for (i = 0, o = n.length - 1; i < o;) a = i + o >> 1, e[n[a]] < c ? i = a + 1 : o = a;
            c < e[n[i]] && (i > 0 && (t[r] = n[i - 1]), n[i] = r)
        }
    }
    for (i = n.length, o = n[i - 1]; i-- > 0;) n[i] = o, o = t[o];
    return n
}
const $le = e => e.__isTeleport,
    gf = e => e && (e.disabled || e.disabled === ""),
    vR = e => typeof SVGElement != "undefined" && e instanceof SVGElement,
    r1 = (e, t) => {
        const n = e && e.to;
        return Lt(n) ? t ? t(n) : null : n
    },
    kle = {
        __isTeleport: !0,
        process(e, t, n, r, s, i, o, a, l, c) {
            const {
                mc: u,
                pc: d,
                pbc: f,
                o: {
                    insert: h,
                    querySelector: p,
                    createText: m,
                    createComment: g
                }
            } = c, y = gf(t.props);
            let {
                shapeFlag: _,
                children: E,
                dynamicChildren: b
            } = t;
            if (e == null) {
                const w = t.el = m(""),
                    T = t.anchor = m("");
                h(w, n, r), h(T, n, r);
                const S = t.target = r1(t.props, p),
                    v = t.targetAnchor = m("");
                S && (h(v, S), o = o || vR(S));
                const $ = (k, C) => {
                    _ & 16 && u(E, k, C, s, i, o, a, l)
                };
                y ? $(n, T) : S && $(S, v)
            } else {
                t.el = e.el;
                const w = t.anchor = e.anchor,
                    T = t.target = e.target,
                    S = t.targetAnchor = e.targetAnchor,
                    v = gf(e.props),
                    $ = v ? n : T,
                    k = v ? w : S;
                if (o = o || vR(T), b ? (f(e.dynamicChildren, b, $, s, i, o, a), dk(e, t, !0)) : l || d(e, t, $, k, s, i, o, a, !1), y) v || Cm(t, n, w, c, 1);
                else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                    const C = t.target = r1(t.props, p);
                    C && Cm(t, C, null, c, 0)
                } else v && Cm(t, T, S, c, 1)
            }
        },
        remove(e, t, n, r, {
            um: s,
            o: {
                remove: i
            }
        }, o) {
            const {
                shapeFlag: a,
                children: l,
                anchor: c,
                targetAnchor: u,
                target: d,
                props: f
            } = e;
            if (d && i(u), (o || !gf(f)) && (i(c), a & 16))
                for (let h = 0; h < l.length; h++) {
                    const p = l[h];
                    s(p, t, n, !0, !!p.dynamicChildren)
                }
        },
        move: Cm,
        hydrate: Ile
    };

function Cm(e, t, n, {
    o: {
        insert: r
    },
    m: s
}, i = 2) {
    i === 0 && r(e.targetAnchor, t, n);
    const {
        el: o,
        anchor: a,
        shapeFlag: l,
        children: c,
        props: u
    } = e, d = i === 2;
    if (d && r(o, t, n), (!d || gf(u)) && l & 16)
        for (let f = 0; f < c.length; f++) s(c[f], t, n, 2);
    d && r(a, t, n)
}

function Ile(e, t, n, r, s, i, {
    o: {
        nextSibling: o,
        parentNode: a,
        querySelector: l
    }
}, c) {
    const u = t.target = r1(t.props, l);
    if (u) {
        const d = u._lpa || u.firstChild;
        if (t.shapeFlag & 16)
            if (gf(t.props)) t.anchor = c(o(e), t, a(e), n, r, s, i), t.targetAnchor = d;
            else {
                t.anchor = o(e);
                let f = d;
                for (; f;)
                    if (f = o(f), f && f.nodeType === 8 && f.data === "teleport anchor") {
                        t.targetAnchor = f, u._lpa = t.targetAnchor && o(t.targetAnchor);
                        break
                    }
                c(d, t, u, n, r, s, i)
            }
    }
    return t.anchor && o(t.anchor)
}
const xle = kle,
    Ht = Symbol(void 0),
    ku = Symbol(void 0),
    qn = Symbol(void 0),
    Ya = Symbol(void 0),
    _f = [];
let Er = null;

function z(e = !1) {
    _f.push(Er = e ? null : [])
}

function oV() {
    _f.pop(), Er = _f[_f.length - 1] || null
}
let bl = 1;

function s1(e) {
    bl += e
}

function aV(e) {
    return e.dynamicChildren = bl > 0 ? Er || Uc : null, oV(), bl > 0 && Er && Er.push(e), e
}

function Se(e, t, n, r, s, i) {
    return aV(K(e, t, n, r, s, i, !0))
}

function ke(e, t, n, r, s) {
    return aV(ne(e, t, n, r, s, !0))
}

function Qo(e) {
    return e ? e.__v_isVNode === !0 : !1
}

function Is(e, t) {
    return e.type === t.type && e.key === t.key
}

function Cle(e) {}
const ub = "__vInternal",
    lV = ({
        key: e
    }) => e != null ? e : null,
    yg = ({
        ref: e,
        ref_key: t,
        ref_for: n
    }) => e != null ? Lt(e) || gt(e) || Te(e) ? {
        i: jn,
        r: e,
        k: t,
        f: !!n
    } : e : null;

function K(e, t = null, n = null, r = 0, s = null, i = e === Ht ? 0 : 1, o = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && lV(t),
        ref: t && yg(t),
        scopeId: sb,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: i,
        patchFlag: r,
        dynamicProps: s,
        dynamicChildren: null,
        appContext: null
    };
    return a ? (fk(l, n), i & 128 && e.normalize(l)) : n && (l.shapeFlag |= Lt(n) ? 8 : 16), bl > 0 && !o && Er && (l.patchFlag > 0 || i & 6) && l.patchFlag !== 32 && Er.push(l), l
}
const ne = Ale;

function Ale(e, t = null, n = null, r = 0, s = null, i = !1) {
    if ((!e || e === G5) && (e = qn), Qo(e)) {
        const a = _s(e, t, !0);
        return n && fk(a, n), bl > 0 && !i && Er && (a.shapeFlag & 6 ? Er[Er.indexOf(e)] = a : Er.push(a)), a.patchFlag |= -2, a
    }
    if (Ble(e) && (e = e.__vccOpts), t) {
        t = cV(t);
        let {
            class: a,
            style: l
        } = t;
        a && !Lt(a) && (t.class = wn(a)), qt(l) && (q$(l) && !he(l) && (l = Gt({}, l)), t.style = Ip(l))
    }
    const o = Lt(e) ? 1 : N5(e) ? 128 : $le(e) ? 64 : qt(e) ? 4 : Te(e) ? 2 : 0;
    return K(e, t, n, r, s, o, i, !0)
}

function cV(e) {
    return e ? q$(e) || ub in e ? Gt({}, e) : e : null
}

function _s(e, t, n = !1) {
    const {
        props: r,
        ref: s,
        patchFlag: i,
        children: o
    } = e, a = t ? xi(r || {}, t) : r;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: a,
        key: a && lV(a),
        ref: t && t.ref ? n && s ? he(s) ? s.concat(yg(t)) : [s, yg(t)] : yg(t) : s,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: o,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== Ht ? i === -1 ? 16 : i | 16 : i,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && _s(e.ssContent),
        ssFallback: e.ssFallback && _s(e.ssFallback),
        el: e.el,
        anchor: e.anchor
    }
}

function hn(e = " ", t = 0) {
    return ne(ku, null, e, t)
}

function Rle(e, t) {
    const n = ne(Ya, null, e);
    return n.staticCount = t, n
}

function Ve(e = "", t = !1) {
    return t ? (z(), ke(qn, null, e)) : ne(qn, null, e)
}

function Ar(e) {
    return e == null || typeof e == "boolean" ? ne(qn) : he(e) ? ne(Ht, null, e.slice()) : typeof e == "object" ? lo(e) : ne(ku, null, String(e))
}

function lo(e) {
    return e.el === null || e.memo ? e : _s(e)
}

function fk(e, t) {
    let n = 0;
    const {
        shapeFlag: r
    } = e;
    if (t == null) t = null;
    else if (he(t)) n = 16;
    else if (typeof t == "object")
        if (r & 65) {
            const s = t.default;
            s && (s._c && (s._d = !1), fk(e, s()), s._c && (s._d = !0));
            return
        } else {
            n = 32;
            const s = t._;
            !s && !(ub in t) ? t._ctx = jn : s === 3 && jn && (jn.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
        }
    else Te(t) ? (t = {
        default: t,
        _ctx: jn
    }, n = 32) : (t = String(t), r & 64 ? (n = 16, t = [hn(t)]) : n = 8);
    e.children = t, e.shapeFlag |= n
}

function xi(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        for (const s in r)
            if (s === "class") t.class !== r.class && (t.class = wn([t.class, r.class]));
            else if (s === "style") t.style = Ip([t.style, r.style]);
        else if (xp(s)) {
            const i = t[s],
                o = r[s];
            o && i !== o && !(he(i) && i.includes(o)) && (t[s] = i ? [].concat(i, o) : o)
        } else s !== "" && (t[s] = r[s])
    }
    return t
}

function yr(e, t, n, r = null) {
    Fr(e, t, 7, [n, r])
}
const Ole = nV();
let Dle = 0;

function uV(e, t, n) {
    const r = e.type,
        s = (t ? t.appContext : e.appContext) || Ole,
        i = {
            uid: Dle++,
            vnode: e,
            type: r,
            parent: t,
            appContext: s,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new z$(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: t ? t.provides : Object.create(s.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: J5(r, s),
            emitsOptions: O5(r, s),
            emit: null,
            emitted: null,
            propsDefaults: dt,
            inheritAttrs: r.inheritAttrs,
            ctx: dt,
            data: dt,
            props: dt,
            attrs: dt,
            slots: dt,
            refs: dt,
            setupState: dt,
            setupContext: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return i.ctx = {
        _: i
    }, i.root = t ? t.root : i, i.emit = Gae.bind(null, i), e.ce && e.ce(i), i
}
let on = null;
const Qn = () => on || jn,
    Jo = e => {
        on = e, e.scope.on()
    },
    No = () => {
        on && on.scope.off(), on = null
    };

function dV(e) {
    return e.vnode.shapeFlag & 4
}
let Iu = !1;

function fV(e, t = !1) {
    Iu = t;
    const {
        props: n,
        children: r
    } = e.vnode, s = dV(e);
    gle(e, n, s, t), vle(e, r);
    const i = s ? Nle(e, t) : void 0;
    return Iu = !1, i
}

function Nle(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null), e.proxy = Op(new Proxy(e.ctx, ZE));
    const {
        setup: r
    } = n;
    if (r) {
        const s = e.setupContext = r.length > 1 ? pV(e) : null;
        Jo(e), Pl();
        const i = Ps(r, e, 0, [e.props, s]);
        if (Ml(), No(), H$(i)) {
            if (i.then(No, No), t) return i.then(o => {
                i1(e, o, t)
            }).catch(o => {
                Ll(o, e, 0)
            });
            e.asyncDep = i
        } else i1(e, i, t)
    } else hV(e, t)
}

function i1(e, t, n) {
    Te(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : qt(t) && (e.setupState = X$(t)), hV(e, n)
}
let G_, o1;

function Ple(e) {
    G_ = e, o1 = t => {
        t.render._rc && (t.withProxy = new Proxy(t.ctx, ule))
    }
}
const Mle = () => !G_;

function hV(e, t, n) {
    const r = e.type;
    if (!e.render) {
        if (!t && G_ && !r.render) {
            const s = r.template;
            if (s) {
                const {
                    isCustomElement: i,
                    compilerOptions: o
                } = e.appContext.config, {
                    delimiters: a,
                    compilerOptions: l
                } = r, c = Gt(Gt({
                    isCustomElement: i,
                    delimiters: a
                }, o), l);
                r.render = G_(s, c)
            }
        }
        e.render = r.render || ps, o1 && o1(e)
    }
    Jo(e), Pl(), dle(e), Ml(), No()
}

function Lle(e) {
    return new Proxy(e.attrs, {
        get(t, n) {
            return Hr(e, "get", "$attrs"), t[n]
        }
    })
}

function pV(e) {
    const t = r => {
        e.exposed = r || {}
    };
    let n;
    return {
        get attrs() {
            return n || (n = Lle(e))
        },
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}

function db(e) {
    if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(X$(Op(e.exposed)), {
        get(t, n) {
            if (n in t) return t[n];
            if (n in j_) return j_[n](e)
        }
    }))
}
const Fle = /(?:^|[-_])(\w)/g,
    Ule = e => e.replace(Fle, t => t.toUpperCase()).replace(/[-_]/g, "");

function q_(e) {
    return Te(e) && e.displayName || e.name
}

function mV(e, t, n = !1) {
    let r = q_(t);
    if (!r && t.__file) {
        const s = t.__file.match(/([^/\\]+)\.\w+$/);
        s && (r = s[1])
    }
    if (!r && e && e.parent) {
        const s = i => {
            for (const o in i)
                if (i[o] === t) return o
        };
        r = s(e.components || e.parent.type.components) || s(e.appContext.components)
    }
    return r ? Ule(r) : n ? "App" : "Anonymous"
}

function Ble(e) {
    return Te(e) && "__vccOpts" in e
}
const Fe = (e, t) => Lae(e, t, Iu);

function Vle() {
    return null
}

function Hle() {
    return null
}

function jle(e) {}

function zle(e, t) {
    return null
}

function Wle() {
    return gV().slots
}

function Gle() {
    return gV().attrs
}

function gV() {
    const e = Qn();
    return e.setupContext || (e.setupContext = pV(e))
}

function qle(e, t) {
    const n = he(e) ? e.reduce((r, s) => (r[s] = {}, r), {}) : e;
    for (const r in t) {
        const s = n[r];
        s ? he(s) || Te(s) ? n[r] = {
            type: s,
            default: t[r]
        } : s.default = t[r] : s === null && (n[r] = {
            default: t[r]
        })
    }
    return n
}

function Yle(e, t) {
    const n = {};
    for (const r in e) t.includes(r) || Object.defineProperty(n, r, {
        enumerable: !0,
        get: () => e[r]
    });
    return n
}

function Kle(e) {
    const t = Qn();
    let n = e();
    return No(), H$(n) && (n = n.catch(r => {
        throw Jo(t), r
    })), [n, () => Jo(t)]
}

function Vs(e, t, n) {
    const r = arguments.length;
    return r === 2 ? qt(t) && !he(t) ? Qo(t) ? ne(e, null, [t]) : ne(e, t) : ne(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Qo(n) && (n = [n]), ne(e, t, n))
}
const _V = Symbol(""),
    Xle = () => {
        {
            const e = bt(_V);
            return e || $5("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), e
        }
    };

function Qle() {}

function Jle(e, t, n, r) {
    const s = n[r];
    if (s && yV(s, e)) return s;
    const i = t();
    return i.memo = e.slice(), n[r] = i
}

function yV(e, t) {
    const n = e.memo;
    if (n.length != t.length) return !1;
    for (let r = 0; r < n.length; r++)
        if (wu(n[r], t[r])) return !1;
    return bl > 0 && Er && Er.push(e), !0
}
const fb = "3.2.34",
    Zle = {
        createComponentInstance: uV,
        setupComponent: fV,
        renderComponentRoot: _g,
        setCurrentRenderingInstance: xh,
        isVNode: Qo,
        normalizeVNode: Ar
    },
    ece = Zle,
    tce = null,
    nce = null,
    rce = "http://www.w3.org/2000/svg",
    ka = typeof document != "undefined" ? document : null,
    bR = ka && ka.createElement("template"),
    sce = {
        insert: (e, t, n) => {
            t.insertBefore(e, n || null)
        },
        remove: e => {
            const t = e.parentNode;
            t && t.removeChild(e)
        },
        createElement: (e, t, n, r) => {
            const s = t ? ka.createElementNS(rce, e) : ka.createElement(e, n ? {
                is: n
            } : void 0);
            return e === "select" && r && r.multiple != null && s.setAttribute("multiple", r.multiple), s
        },
        createText: e => ka.createTextNode(e),
        createComment: e => ka.createComment(e),
        setText: (e, t) => {
            e.nodeValue = t
        },
        setElementText: (e, t) => {
            e.textContent = t
        },
        parentNode: e => e.parentNode,
        nextSibling: e => e.nextSibling,
        querySelector: e => ka.querySelector(e),
        setScopeId(e, t) {
            e.setAttribute(t, "")
        },
        cloneNode(e) {
            const t = e.cloneNode(!0);
            return "_value" in e && (t._value = e._value), t
        },
        insertStaticContent(e, t, n, r, s, i) {
            const o = n ? n.previousSibling : t.lastChild;
            if (s && (s === i || s.nextSibling))
                for (; t.insertBefore(s.cloneNode(!0), n), !(s === i || !(s = s.nextSibling)););
            else {
                bR.innerHTML = r ? `<svg>${e}</svg>` : e;
                const a = bR.content;
                if (r) {
                    const l = a.firstChild;
                    for (; l.firstChild;) a.appendChild(l.firstChild);
                    a.removeChild(l)
                }
                t.insertBefore(a, n)
            }
            return [o ? o.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
        }
    };

function ice(e, t, n) {
    const r = e._vtc;
    r && (t = (t ? [t, ...r] : [...r]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}

function oce(e, t, n) {
    const r = e.style,
        s = Lt(n);
    if (n && !s) {
        for (const i in n) a1(r, i, n[i]);
        if (t && !Lt(t))
            for (const i in t) n[i] == null && a1(r, i, "")
    } else {
        const i = r.display;
        s ? t !== n && (r.cssText = n) : t && e.removeAttribute("style"), "_vod" in e && (r.display = i)
    }
}
const wR = /\s*!important$/;

function a1(e, t, n) {
    if (he(n)) n.forEach(r => a1(e, t, r));
    else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n);
    else {
        const r = ace(e, t);
        wR.test(n) ? e.setProperty(Ns(r), n.replace(wR, ""), "important") : e[r] = n
    }
}
const ER = ["Webkit", "Moz", "ms"],
    O0 = {};

function ace(e, t) {
    const n = O0[t];
    if (n) return n;
    let r = Vr(t);
    if (r !== "filter" && r in e) return O0[t] = r;
    r = Ap(r);
    for (let s = 0; s < ER.length; s++) {
        const i = ER[s] + r;
        if (i in e) return O0[t] = i
    }
    return t
}
const SR = "http://www.w3.org/1999/xlink";

function lce(e, t, n, r, s) {
    if (r && t.startsWith("xlink:")) n == null ? e.removeAttributeNS(SR, t.slice(6, t.length)) : e.setAttributeNS(SR, t, n);
    else {
        const i = Hoe(t);
        n == null || i && !s5(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : n)
    }
}

function cce(e, t, n, r, s, i, o) {
    if (t === "innerHTML" || t === "textContent") {
        r && o(r, s, i), e[t] = n == null ? "" : n;
        return
    }
    if (t === "value" && e.tagName !== "PROGRESS" && !e.tagName.includes("-")) {
        e._value = n;
        const l = n == null ? "" : n;
        (e.value !== l || e.tagName === "OPTION") && (e.value = l), n == null && e.removeAttribute(t);
        return
    }
    let a = !1;
    if (n === "" || n == null) {
        const l = typeof e[t];
        l === "boolean" ? n = s5(n) : n == null && l === "string" ? (n = "", a = !0) : l === "number" && (n = 0, a = !0)
    }
    try {
        e[t] = n
    } catch {}
    a && e.removeAttribute(t)
}
const [vV, uce] = (() => {
    let e = Date.now,
        t = !1;
    if (typeof window != "undefined") {
        Date.now() > document.createEvent("Event").timeStamp && (e = () => performance.now());
        const n = navigator.userAgent.match(/firefox\/(\d+)/i);
        t = !!(n && Number(n[1]) <= 53)
    }
    return [e, t]
})();
let l1 = 0;
const dce = Promise.resolve(),
    fce = () => {
        l1 = 0
    },
    hce = () => l1 || (dce.then(fce), l1 = vV());

function si(e, t, n, r) {
    e.addEventListener(t, n, r)
}

function pce(e, t, n, r) {
    e.removeEventListener(t, n, r)
}

function mce(e, t, n, r, s = null) {
    const i = e._vei || (e._vei = {}),
        o = i[t];
    if (r && o) o.value = r;
    else {
        const [a, l] = gce(t);
        if (r) {
            const c = i[t] = _ce(r, s);
            si(e, a, c, l)
        } else o && (pce(e, a, o, l), i[t] = void 0)
    }
}
const TR = /(?:Once|Passive|Capture)$/;

function gce(e) {
    let t;
    if (TR.test(e)) {
        t = {};
        let n;
        for (; n = e.match(TR);) e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0
    }
    return [Ns(e.slice(2)), t]
}

function _ce(e, t) {
    const n = r => {
        const s = r.timeStamp || vV();
        (uce || s >= n.attached - 1) && Fr(yce(r, n.value), t, 5, [r])
    };
    return n.value = e, n.attached = hce(), n
}

function yce(e, t) {
    if (he(t)) {
        const n = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            n.call(e), e._stopped = !0
        }, t.map(r => s => !s._stopped && r && r(s))
    } else return t
}
const $R = /^on[a-z]/,
    vce = (e, t, n, r, s = !1, i, o, a, l) => {
        t === "class" ? ice(e, r, s) : t === "style" ? oce(e, n, r) : xp(t) ? B$(t) || mce(e, t, n, r, o) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : bce(e, t, r, s)) ? cce(e, t, r, i, o, a, l) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r), lce(e, t, r, s))
    };

function bce(e, t, n, r) {
    return r ? !!(t === "innerHTML" || t === "textContent" || t in e && $R.test(t) && Te(n)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || $R.test(t) && Lt(n) ? !1 : t in e
}

function bV(e, t) {
    const n = Ir(e);
    class r extends hb {
        constructor(i) {
            super(n, i, t)
        }
    }
    return r.def = n, r
}
const wce = e => bV(e, PV),
    Ece = typeof HTMLElement != "undefined" ? HTMLElement : class {};
class hb extends Ece {
    constructor(t, n = {}, r) {
        super(), this._def = t, this._props = n, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this.shadowRoot && r ? r(this._createVNode(), this.shadowRoot) : this.attachShadow({
            mode: "open"
        })
    }
    connectedCallback() {
        this._connected = !0, this._instance || this._resolveDef()
    }
    disconnectedCallback() {
        this._connected = !1, ln(() => {
            this._connected || (d1(null, this.shadowRoot), this._instance = null)
        })
    }
    _resolveDef() {
        if (this._resolved) return;
        this._resolved = !0;
        for (let r = 0; r < this.attributes.length; r++) this._setAttr(this.attributes[r].name);
        new MutationObserver(r => {
            for (const s of r) this._setAttr(s.attributeName)
        }).observe(this, {
            attributes: !0
        });
        const t = r => {
                const {
                    props: s,
                    styles: i
                } = r, o = !he(s), a = s ? o ? Object.keys(s) : s : [];
                let l;
                if (o)
                    for (const c in this._props) {
                        const u = s[c];
                        (u === Number || u && u.type === Number) && (this._props[c] = Ko(this._props[c]), (l || (l = Object.create(null)))[c] = !0)
                    }
                this._numberProps = l;
                for (const c of Object.keys(this)) c[0] !== "_" && this._setProp(c, this[c], !0, !1);
                for (const c of a.map(Vr)) Object.defineProperty(this, c, {
                    get() {
                        return this._getProp(c)
                    },
                    set(u) {
                        this._setProp(c, u)
                    }
                });
                this._applyStyles(i), this._update()
            },
            n = this._def.__asyncLoader;
        n ? n().then(t) : t(this._def)
    }
    _setAttr(t) {
        let n = this.getAttribute(t);
        this._numberProps && this._numberProps[t] && (n = Ko(n)), this._setProp(Vr(t), n, !1)
    }
    _getProp(t) {
        return this._props[t]
    }
    _setProp(t, n, r = !0, s = !0) {
        n !== this._props[t] && (this._props[t] = n, s && this._instance && this._update(), r && (n === !0 ? this.setAttribute(Ns(t), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(Ns(t), n + "") : n || this.removeAttribute(Ns(t))))
    }
    _update() {
        d1(this._createVNode(), this.shadowRoot)
    }
    _createVNode() {
        const t = ne(this._def, Gt({}, this._props));
        return this._instance || (t.ce = n => {
            this._instance = n, n.isCE = !0, n.emit = (s, ...i) => {
                this.dispatchEvent(new CustomEvent(s, {
                    detail: i
                }))
            };
            let r = this;
            for (; r = r && (r.parentNode || r.host);)
                if (r instanceof hb) {
                    n.parent = r._instance;
                    break
                }
        }), t
    }
    _applyStyles(t) {
        t && t.forEach(n => {
            const r = document.createElement("style");
            r.textContent = n, this.shadowRoot.appendChild(r)
        })
    }
}

function Sce(e = "$style") {
    {
        const t = Qn();
        if (!t) return dt;
        const n = t.type.__cssModules;
        if (!n) return dt;
        const r = n[e];
        return r || dt
    }
}

function Tce(e) {
    const t = Qn();
    if (!t) return;
    const n = () => c1(t.subTree, e(t.proxy));
    L5(n), jr(() => {
        const r = new MutationObserver(n);
        r.observe(t.subTree.el.parentNode, {
            childList: !0
        }), Fl(() => r.disconnect())
    })
}

function c1(e, t) {
    if (e.shapeFlag & 128) {
        const n = e.suspense;
        e = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => {
            c1(n.activeBranch, t)
        })
    }
    for (; e.component;) e = e.component.subTree;
    if (e.shapeFlag & 1 && e.el) kR(e.el, t);
    else if (e.type === Ht) e.children.forEach(n => c1(n, t));
    else if (e.type === Ya) {
        let {
            el: n,
            anchor: r
        } = e;
        for (; n && (kR(n, t), n !== r);) n = n.nextSibling
    }
}

function kR(e, t) {
    if (e.nodeType === 1) {
        const n = e.style;
        for (const r in t) n.setProperty(`--${r}`, t[r])
    }
}
const eo = "transition",
    pd = "animation",
    Zo = (e, {
        slots: t
    }) => Vs(ok, EV(e), t);
Zo.displayName = "Transition";
const wV = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    },
    $ce = Zo.props = Gt({}, ok.props, wV),
    va = (e, t = []) => {
        he(e) ? e.forEach(n => n(...t)) : e && e(...t)
    },
    IR = e => e ? he(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;

function EV(e) {
    const t = {};
    for (const R in e) R in wV || (t[R] = e[R]);
    if (e.css === !1) return t;
    const {
        name: n = "v",
        type: r,
        duration: s,
        enterFromClass: i = `${n}-enter-from`,
        enterActiveClass: o = `${n}-enter-active`,
        enterToClass: a = `${n}-enter-to`,
        appearFromClass: l = i,
        appearActiveClass: c = o,
        appearToClass: u = a,
        leaveFromClass: d = `${n}-leave-from`,
        leaveActiveClass: f = `${n}-leave-active`,
        leaveToClass: h = `${n}-leave-to`
    } = e, p = kce(s), m = p && p[0], g = p && p[1], {
        onBeforeEnter: y,
        onEnter: _,
        onEnterCancelled: E,
        onLeave: b,
        onLeaveCancelled: w,
        onBeforeAppear: T = y,
        onAppear: S = _,
        onAppearCancelled: v = E
    } = t, $ = (R, N, J) => {
        io(R, N ? u : a), io(R, N ? c : o), J && J()
    };
    let k = !1;
    const C = (R, N) => {
            k = !1, io(R, d), io(R, h), io(R, f), N && N()
        },
        O = R => (N, J) => {
            const Y = R ? S : _,
                ie = () => $(N, R, J);
            va(Y, [N, ie]), xR(() => {
                io(N, R ? l : i), Zs(N, R ? u : a), IR(Y) || CR(N, r, m, ie)
            })
        };
    return Gt(t, {
        onBeforeEnter(R) {
            va(y, [R]), Zs(R, i), Zs(R, o)
        },
        onBeforeAppear(R) {
            va(T, [R]), Zs(R, l), Zs(R, c)
        },
        onEnter: O(!1),
        onAppear: O(!0),
        onLeave(R, N) {
            k = !0;
            const J = () => C(R, N);
            Zs(R, d), TV(), Zs(R, f), xR(() => {
                !k || (io(R, d), Zs(R, h), IR(b) || CR(R, r, g, J))
            }), va(b, [R, J])
        },
        onEnterCancelled(R) {
            $(R, !1), va(E, [R])
        },
        onAppearCancelled(R) {
            $(R, !0), va(v, [R])
        },
        onLeaveCancelled(R) {
            C(R), va(w, [R])
        }
    })
}

function kce(e) {
    if (e == null) return null;
    if (qt(e)) return [D0(e.enter), D0(e.leave)]; {
        const t = D0(e);
        return [t, t]
    }
}

function D0(e) {
    return Ko(e)
}

function Zs(e, t) {
    t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e._vtc || (e._vtc = new Set)).add(t)
}

function io(e, t) {
    t.split(/\s+/).forEach(r => r && e.classList.remove(r));
    const {
        _vtc: n
    } = e;
    n && (n.delete(t), n.size || (e._vtc = void 0))
}

function xR(e) {
    requestAnimationFrame(() => {
        requestAnimationFrame(e)
    })
}
let Ice = 0;

function CR(e, t, n, r) {
    const s = e._endId = ++Ice,
        i = () => {
            s === e._endId && r()
        };
    if (n) return setTimeout(i, n);
    const {
        type: o,
        timeout: a,
        propCount: l
    } = SV(e, t);
    if (!o) return r();
    const c = o + "end";
    let u = 0;
    const d = () => {
            e.removeEventListener(c, f), i()
        },
        f = h => {
            h.target === e && ++u >= l && d()
        };
    setTimeout(() => {
        u < l && d()
    }, a + 1), e.addEventListener(c, f)
}

function SV(e, t) {
    const n = window.getComputedStyle(e),
        r = p => (n[p] || "").split(", "),
        s = r(eo + "Delay"),
        i = r(eo + "Duration"),
        o = AR(s, i),
        a = r(pd + "Delay"),
        l = r(pd + "Duration"),
        c = AR(a, l);
    let u = null,
        d = 0,
        f = 0;
    t === eo ? o > 0 && (u = eo, d = o, f = i.length) : t === pd ? c > 0 && (u = pd, d = c, f = l.length) : (d = Math.max(o, c), u = d > 0 ? o > c ? eo : pd : null, f = u ? u === eo ? i.length : l.length : 0);
    const h = u === eo && /\b(transform|all)(,|$)/.test(n[eo + "Property"]);
    return {
        type: u,
        timeout: d,
        propCount: f,
        hasTransform: h
    }
}

function AR(e, t) {
    for (; e.length < t.length;) e = e.concat(e);
    return Math.max(...t.map((n, r) => RR(n) + RR(e[r])))
}

function RR(e) {
    return Number(e.slice(0, -1).replace(",", ".")) * 1e3
}

function TV() {
    return document.body.offsetHeight
}
const $V = new WeakMap,
    kV = new WeakMap,
    xce = {
        name: "TransitionGroup",
        props: Gt({}, $ce, {
            tag: String,
            moveClass: String
        }),
        setup(e, {
            slots: t
        }) {
            const n = Qn(),
                r = ik();
            let s, i;
            return cb(() => {
                if (!s.length) return;
                const o = e.moveClass || `${e.name||"v"}-move`;
                if (!Dce(s[0].el, n.vnode.el, o)) return;
                s.forEach(Ace), s.forEach(Rce);
                const a = s.filter(Oce);
                TV(), a.forEach(l => {
                    const c = l.el,
                        u = c.style;
                    Zs(c, o), u.transform = u.webkitTransform = u.transitionDuration = "";
                    const d = c._moveCb = f => {
                        f && f.target !== c || (!f || /transform$/.test(f.propertyName)) && (c.removeEventListener("transitionend", d), c._moveCb = null, io(c, o))
                    };
                    c.addEventListener("transitionend", d)
                })
            }), () => {
                const o = ze(e),
                    a = EV(o);
                let l = o.tag || Ht;
                s = i, i = t.default ? ib(t.default()) : [];
                for (let c = 0; c < i.length; c++) {
                    const u = i[c];
                    u.key != null && vl(u, Su(u, a, r, n))
                }
                if (s)
                    for (let c = 0; c < s.length; c++) {
                        const u = s[c];
                        vl(u, Su(u, a, r, n)), $V.set(u, u.el.getBoundingClientRect())
                    }
                return ne(l, null, i)
            }
        }
    },
    Cce = xce;

function Ace(e) {
    const t = e.el;
    t._moveCb && t._moveCb(), t._enterCb && t._enterCb()
}

function Rce(e) {
    kV.set(e, e.el.getBoundingClientRect())
}

function Oce(e) {
    const t = $V.get(e),
        n = kV.get(e),
        r = t.left - n.left,
        s = t.top - n.top;
    if (r || s) {
        const i = e.el.style;
        return i.transform = i.webkitTransform = `translate(${r}px,${s}px)`, i.transitionDuration = "0s", e
    }
}

function Dce(e, t, n) {
    const r = e.cloneNode();
    e._vtc && e._vtc.forEach(o => {
        o.split(/\s+/).forEach(a => a && r.classList.remove(a))
    }), n.split(/\s+/).forEach(o => o && r.classList.add(o)), r.style.display = "none";
    const s = t.nodeType === 1 ? t : t.parentNode;
    s.appendChild(r);
    const {
        hasTransform: i
    } = SV(r);
    return s.removeChild(r), i
}
const ea = e => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return he(t) ? n => Vc(t, n) : t
};

function Nce(e) {
    e.target.composing = !0
}

function OR(e) {
    const t = e.target;
    t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}
const Y_ = {
        created(e, {
            modifiers: {
                lazy: t,
                trim: n,
                number: r
            }
        }, s) {
            e._assign = ea(s);
            const i = r || s.props && s.props.type === "number";
            si(e, t ? "change" : "input", o => {
                if (o.target.composing) return;
                let a = e.value;
                n && (a = a.trim()), i && (a = Ko(a)), e._assign(a)
            }), n && si(e, "change", () => {
                e.value = e.value.trim()
            }), t || (si(e, "compositionstart", Nce), si(e, "compositionend", OR), si(e, "change", OR))
        },
        mounted(e, {
            value: t
        }) {
            e.value = t == null ? "" : t
        },
        beforeUpdate(e, {
            value: t,
            modifiers: {
                lazy: n,
                trim: r,
                number: s
            }
        }, i) {
            if (e._assign = ea(i), e.composing || document.activeElement === e && e.type !== "range" && (n || r && e.value.trim() === t || (s || e.type === "number") && Ko(e.value) === t)) return;
            const o = t == null ? "" : t;
            e.value !== o && (e.value = o)
        }
    },
    hk = {
        deep: !0,
        created(e, t, n) {
            e._assign = ea(n), si(e, "change", () => {
                const r = e._modelValue,
                    s = xu(e),
                    i = e.checked,
                    o = e._assign;
                if (he(r)) {
                    const a = Yv(r, s),
                        l = a !== -1;
                    if (i && !l) o(r.concat(s));
                    else if (!i && l) {
                        const c = [...r];
                        c.splice(a, 1), o(c)
                    }
                } else if (Nl(r)) {
                    const a = new Set(r);
                    i ? a.add(s) : a.delete(s), o(a)
                } else o(xV(e, i))
            })
        },
        mounted: DR,
        beforeUpdate(e, t, n) {
            e._assign = ea(n), DR(e, t, n)
        }
    };

function DR(e, {
    value: t,
    oldValue: n
}, r) {
    e._modelValue = t, he(t) ? e.checked = Yv(t, r.props.value) > -1 : Nl(t) ? e.checked = t.has(r.props.value) : t !== n && (e.checked = Yo(t, xV(e, !0)))
}
const pk = {
        created(e, {
            value: t
        }, n) {
            e.checked = Yo(t, n.props.value), e._assign = ea(n), si(e, "change", () => {
                e._assign(xu(e))
            })
        },
        beforeUpdate(e, {
            value: t,
            oldValue: n
        }, r) {
            e._assign = ea(r), t !== n && (e.checked = Yo(t, r.props.value))
        }
    },
    IV = {
        deep: !0,
        created(e, {
            value: t,
            modifiers: {
                number: n
            }
        }, r) {
            const s = Nl(t);
            si(e, "change", () => {
                const i = Array.prototype.filter.call(e.options, o => o.selected).map(o => n ? Ko(xu(o)) : xu(o));
                e._assign(e.multiple ? s ? new Set(i) : i : i[0])
            }), e._assign = ea(r)
        },
        mounted(e, {
            value: t
        }) {
            NR(e, t)
        },
        beforeUpdate(e, t, n) {
            e._assign = ea(n)
        },
        updated(e, {
            value: t
        }) {
            NR(e, t)
        }
    };

function NR(e, t) {
    const n = e.multiple;
    if (!(n && !he(t) && !Nl(t))) {
        for (let r = 0, s = e.options.length; r < s; r++) {
            const i = e.options[r],
                o = xu(i);
            if (n) he(t) ? i.selected = Yv(t, o) > -1 : i.selected = t.has(o);
            else if (Yo(xu(i), t)) {
                e.selectedIndex !== r && (e.selectedIndex = r);
                return
            }
        }!n && e.selectedIndex !== -1 && (e.selectedIndex = -1)
    }
}

function xu(e) {
    return "_value" in e ? e._value : e.value
}

function xV(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t
}
const CV = {
    created(e, t, n) {
        Am(e, t, n, null, "created")
    },
    mounted(e, t, n) {
        Am(e, t, n, null, "mounted")
    },
    beforeUpdate(e, t, n, r) {
        Am(e, t, n, r, "beforeUpdate")
    },
    updated(e, t, n, r) {
        Am(e, t, n, r, "updated")
    }
};

function AV(e, t) {
    switch (e) {
        case "SELECT":
            return IV;
        case "TEXTAREA":
            return Y_;
        default:
            switch (t) {
                case "checkbox":
                    return hk;
                case "radio":
                    return pk;
                default:
                    return Y_
            }
    }
}

function Am(e, t, n, r, s) {
    const o = AV(e.tagName, n.props && n.props.type)[s];
    o && o(e, t, n, r)
}

function Pce() {
    Y_.getSSRProps = ({
        value: e
    }) => ({
        value: e
    }), pk.getSSRProps = ({
        value: e
    }, t) => {
        if (t.props && Yo(t.props.value, e)) return {
            checked: !0
        }
    }, hk.getSSRProps = ({
        value: e
    }, t) => {
        if (he(e)) {
            if (t.props && Yv(e, t.props.value) > -1) return {
                checked: !0
            }
        } else if (Nl(e)) {
            if (t.props && e.has(t.props.value)) return {
                checked: !0
            }
        } else if (e) return {
            checked: !0
        }
    }, CV.getSSRProps = (e, t) => {
        if (typeof t.type != "string") return;
        const n = AV(t.type.toUpperCase(), t.props && t.props.type);
        if (n.getSSRProps) return n.getSSRProps(e, t)
    }
}
const Mce = ["ctrl", "shift", "alt", "meta"],
    Lce = {
        stop: e => e.stopPropagation(),
        prevent: e => e.preventDefault(),
        self: e => e.target !== e.currentTarget,
        ctrl: e => !e.ctrlKey,
        shift: e => !e.shiftKey,
        alt: e => !e.altKey,
        meta: e => !e.metaKey,
        left: e => "button" in e && e.button !== 0,
        middle: e => "button" in e && e.button !== 1,
        right: e => "button" in e && e.button !== 2,
        exact: (e, t) => Mce.some(n => e[`${n}Key`] && !t.includes(n))
    },
    u1 = (e, t) => (n, ...r) => {
        for (let s = 0; s < t.length; s++) {
            const i = Lce[t[s]];
            if (i && i(n, t)) return
        }
        return e(n, ...r)
    },
    Fce = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    },
    RV = (e, t) => n => {
        if (!("key" in n)) return;
        const r = Ns(n.key);
        if (t.some(s => s === r || Fce[s] === r)) return e(n)
    },
    Rh = {
        beforeMount(e, {
            value: t
        }, {
            transition: n
        }) {
            e._vod = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : md(e, t)
        },
        mounted(e, {
            value: t
        }, {
            transition: n
        }) {
            n && t && n.enter(e)
        },
        updated(e, {
            value: t,
            oldValue: n
        }, {
            transition: r
        }) {
            !t != !n && (r ? t ? (r.beforeEnter(e), md(e, !0), r.enter(e)) : r.leave(e, () => {
                md(e, !1)
            }) : md(e, t))
        },
        beforeUnmount(e, {
            value: t
        }) {
            md(e, t)
        }
    };

function md(e, t) {
    e.style.display = t ? e._vod : "none"
}

function Uce() {
    Rh.getSSRProps = ({
        value: e
    }) => {
        if (!e) return {
            style: {
                display: "none"
            }
        }
    }
}
const OV = Gt({
    patchProp: vce
}, sce);
let yf, PR = !1;

function DV() {
    return yf || (yf = rV(OV))
}

function NV() {
    return yf = PR ? yf : sV(OV), PR = !0, yf
}
const d1 = (...e) => {
        DV().render(...e)
    },
    PV = (...e) => {
        NV().hydrate(...e)
    },
    MV = (...e) => {
        const t = DV().createApp(...e),
            {
                mount: n
            } = t;
        return t.mount = r => {
            const s = FV(r);
            if (!s) return;
            const i = t._component;
            !Te(i) && !i.render && !i.template && (i.template = s.innerHTML), s.innerHTML = "";
            const o = n(s, !1, s instanceof SVGElement);
            return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), o
        }, t
    },
    LV = (...e) => {
        const t = NV().createApp(...e),
            {
                mount: n
            } = t;
        return t.mount = r => {
            const s = FV(r);
            if (s) return n(s, !0, s instanceof SVGElement)
        }, t
    };

function FV(e) {
    return Lt(e) ? document.querySelector(e) : e
}
let MR = !1;
const Bce = () => {
        MR || (MR = !0, Pce(), Uce())
    },
    Vce = () => {};
var Hce = Object.freeze(Object.defineProperty({
    __proto__: null,
    compile: Vce,
    EffectScope: z$,
    ReactiveEffect: Rp,
    customRef: Dae,
    effect: rae,
    effectScope: l5,
    getCurrentScope: u5,
    isProxy: q$,
    isReactive: ms,
    isReadonly: Eu,
    isRef: gt,
    isShallow: U_,
    markRaw: Op,
    onScopeDispose: d5,
    proxyRefs: X$,
    reactive: Pr,
    readonly: Zv,
    ref: ae,
    shallowReactive: F_,
    shallowReadonly: Cae,
    shallowRef: yl,
    stop: sae,
    toRaw: ze,
    toRef: Q$,
    toRefs: Nae,
    triggerRef: Fd,
    unref: fe,
    camelize: Vr,
    capitalize: Ap,
    normalizeClass: wn,
    normalizeProps: Goe,
    normalizeStyle: Ip,
    toDisplayString: xs,
    toHandlerKey: ff,
    BaseTransition: ok,
    Comment: qn,
    Fragment: Ht,
    KeepAlive: ole,
    Static: Ya,
    Suspense: P5,
    Teleport: xle,
    Text: ku,
    callWithAsyncErrorHandling: Fr,
    callWithErrorHandling: Ps,
    cloneVNode: _s,
    compatUtils: nce,
    computed: Fe,
    createBlock: ke,
    createCommentVNode: Ve,
    createElementBlock: Se,
    createElementVNode: K,
    createHydrationRenderer: sV,
    createPropsRestProxy: Yle,
    createRenderer: rV,
    createSlots: q5,
    createStaticVNode: Rle,
    createTextVNode: hn,
    createVNode: ne,
    defineAsyncComponent: Tu,
    defineComponent: Ir,
    defineEmits: Hle,
    defineExpose: jle,
    defineProps: Vle,
    get devtools() {
        return dc
    },
    getCurrentInstance: Qn,
    getTransitionRawChildren: ib,
    guardReactiveProps: cV,
    h: Vs,
    handleError: Ll,
    initCustomFormatter: Qle,
    inject: bt,
    isMemoSame: yV,
    isRuntimeOnly: Mle,
    isVNode: Qo,
    mergeDefaults: qle,
    mergeProps: xi,
    nextTick: ln,
    onActivated: ob,
    onBeforeMount: ak,
    onBeforeUnmount: pa,
    onBeforeUpdate: V5,
    onDeactivated: ab,
    onErrorCaptured: W5,
    onMounted: jr,
    onRenderTracked: z5,
    onRenderTriggered: j5,
    onServerPrefetch: H5,
    onUnmounted: Fl,
    onUpdated: cb,
    openBlock: z,
    popScopeId: nk,
    provide: fi,
    pushScopeId: tk,
    queuePostFlushCb: ek,
    registerRuntimeCompiler: Ple,
    renderList: $u,
    renderSlot: Gn,
    resolveComponent: Do,
    resolveDirective: cle,
    resolveDynamicComponent: Ah,
    resolveFilter: tce,
    resolveTransitionHooks: Su,
    setBlockTracking: s1,
    setDevtoolsHook: R5,
    setTransitionHooks: vl,
    ssrContextKey: _V,
    ssrUtils: ece,
    toHandlers: QE,
    transformVNodeArgs: Cle,
    useAttrs: Gle,
    useSSRContext: Xle,
    useSlots: Wle,
    useTransitionState: ik,
    version: fb,
    warn: $5,
    watch: $t,
    watchEffect: sr,
    watchPostEffect: L5,
    watchSyncEffect: nle,
    withAsyncContext: Kle,
    withCtx: Re,
    withDefaults: zle,
    withDirectives: H_,
    withMemo: Jle,
    withScopeId: D5,
    Transition: Zo,
    TransitionGroup: Cce,
    VueElement: hb,
    createApp: MV,
    createSSRApp: LV,
    defineCustomElement: bV,
    defineSSRCustomElement: wce,
    hydrate: PV,
    initDirectivesForSSR: Bce,
    render: d1,
    useCssModule: Sce,
    useCssVars: Tce,
    vModelCheckbox: hk,
    vModelDynamic: CV,
    vModelRadio: pk,
    vModelSelect: IV,
    vModelText: Y_,
    vShow: Rh,
    withKeys: RV,
    withModifiers: u1
}, Symbol.toStringTag, {
    value: "Module"
}));

function jce(...e) {
    const t = e.reduce((r, s) => _l(r, s), {}),
        n = () => {};
    return n.library = function(r) {
        const s = Fc(r.props.type);
        De(t, s) && r.define(t[s])
    }, n
}

function zce(e) {
    let t = 1;
    return Array.isArray(e) ? e.map(n => typeof n == "string" || typeof n == "number" ? {
        label: String(n),
        value: String(n)
    } : (typeof n == "object" && "value" in n && typeof n.value != "string" && Object.assign(n, {
        value: `__mask_${t++}`,
        __original: n.value
    }), n)) : Object.keys(e).map(n => ({
        label: e[n],
        value: n
    }))
}

function Cu(e, t) {
    if (Array.isArray(e)) {
        for (const n of e)
            if (t == n.value) return "__original" in n ? n.__original : n.value
    }
    return t
}

function Au(e, t) {
    return e === null && t === void 0 || e === void 0 && t === null ? !1 : e == t ? !0 : gl(e) && gl(t) ? Qe(e, t) : !1
}

function mk(e) {
    e.hook.prop((t, n) => (t.prop === "options" && (typeof t.value == "function" ? (e.props.optionsLoader = t.value, t.value = []) : t.value = zce(t.value)), n(t)))
}
const ma = Pe("outer", () => ({
        $el: "div",
        attrs: {
            key: "$id",
            "data-family": "$family || undefined",
            "data-type": "$type",
            "data-multiple": '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
            "data-disabled": "$disabled || undefined",
            "data-complete": "$state.complete || undefined",
            "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
            "data-errors": "$state.errors || undefined",
            "data-submitted": "$state.submitted || undefined",
            "data-prefix-icon": "$_rawPrefixIcon !== undefined || undefined",
            "data-suffix-icon": "$_rawSuffixIcon !== undefined || undefined",
            "data-prefix-icon-click": "$onPrefixIconClick !== undefined || undefined",
            "data-suffix-icon-click": "$onSuffixIconClick !== undefined || undefined"
        }
    }), !0),
    Ci = Pe("inner", "div"),
    id = Pe("wrapper", "div"),
    Pp = Pe("label", () => ({
        $el: "label",
        if: "$label",
        attrs: {
            for: "$id"
        }
    })),
    Bi = Pe("messages", () => ({
        $el: "ul",
        if: "$defaultMessagePlacement && $fns.length($messages)"
    })),
    Vi = Pe("message", () => ({
        $el: "li",
        for: ["message", "$messages"],
        attrs: {
            key: "$message.key",
            id: "$id + '-' + $message.key",
            "data-message-type": "$message.type"
        }
    })),
    Hs = Pe("prefix", null),
    js = Pe("suffix", null),
    zs = Pe("help", () => ({
        $el: "div",
        if: "$help",
        attrs: {
            id: '$: "help-" + $id'
        }
    })),
    UV = Pe("fieldset", () => ({
        $el: "fieldset",
        attrs: {
            id: "$id",
            "aria-describedby": {
                if: "$help",
                then: '$: "help-" + $id',
                else: void 0
            }
        }
    })),
    K_ = Pe("decorator", () => ({
        $el: "span",
        attrs: {
            "aria-hidden": "true"
        }
    })),
    X_ = Pe("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            type: "$type",
            name: "$node.props.altName || $node.name",
            disabled: "$option.attrs.disabled || $disabled",
            onInput: "$handlers.toggleChecked",
            checked: "$fns.eq($_value, $onValue)",
            onBlur: "$handlers.blur",
            value: "$: true",
            id: "$id",
            "aria-describedby": {
                if: "$options.length",
                then: {
                    if: "$option.help",
                    then: '$: "help-" + $option.attrs.id',
                    else: void 0
                },
                else: {
                    if: "$help",
                    then: '$: "help-" + $id',
                    else: void 0
                }
            }
        }
    })),
    BV = Pe("legend", () => ({
        $el: "legend",
        if: "$label"
    })),
    VV = Pe("option", () => ({
        $el: "li",
        for: ["option", "$options"],
        attrs: {
            "data-disabled": "$option.attrs.disabled || $disabled"
        }
    })),
    HV = Pe("options", "ul"),
    Q_ = Pe("wrapper", () => ({
        $el: "label",
        attrs: {
            "data-disabled": {
                if: "$options.length",
                then: void 0,
                else: "$disabled || undefined"
            },
            "data-checked": {
                if: "$options == undefined",
                then: "$fns.eq($_value, $onValue) || undefined",
                else: "$fns.isChecked($option.value) || undefined"
            }
        }
    })),
    jV = Pe("optionHelp", () => ({
        $el: "div",
        if: "$option.help",
        attrs: {
            id: '$: "help-" + $option.attrs.id'
        }
    })),
    J_ = Pe("label", "span"),
    Wce = Pe("input", () => ({
        $el: "button",
        bind: "$attrs",
        attrs: {
            type: "$type",
            disabled: "$disabled",
            name: "$node.name",
            id: "$id"
        }
    })),
    Gce = Pe("default", null),
    qce = Pe("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            type: "file",
            disabled: "$disabled",
            name: "$node.name",
            onChange: "$handlers.files",
            onBlur: "$handlers.blur",
            id: "$id",
            "aria-describedby": "$describedBy"
        }
    })),
    Yce = Pe("fileItem", () => ({
        $el: "li",
        for: ["file", "$value"]
    })),
    Kce = Pe("fileList", () => ({
        $el: "ul",
        if: "$value.length",
        attrs: {
            "data-has-multiple": {
                if: "$value.length > 1",
                then: "true"
            }
        }
    })),
    Xce = Pe("fileName", () => ({
        $el: "span",
        attrs: {
            class: "$classes.fileName"
        }
    })),
    LR = Pe("fileRemove", () => ({
        $el: "button",
        attrs: {
            onClick: "$handlers.resetFiles"
        }
    })),
    Qce = Pe("noFiles", () => ({
        $el: "span",
        if: "$value.length == 0"
    })),
    Jce = Pe("form", () => ({
        $el: "form",
        bind: "$attrs",
        attrs: {
            id: "$id",
            name: "$node.name",
            onSubmit: "$handlers.submit",
            "data-loading": "$state.loading || undefined"
        }
    }), !0),
    Zce = Pe("actions", () => ({
        $el: "div",
        if: "$actions"
    })),
    eue = Pe("submit", () => ({
        $cmp: "FormKit",
        bind: "$submitAttrs",
        props: {
            type: "submit",
            disabled: "$disabled",
            label: "$submitLabel"
        }
    })),
    zV = Pe("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            type: "$type",
            disabled: "$disabled",
            name: "$node.name",
            onInput: "$handlers.DOMInput",
            onBlur: "$handlers.blur",
            value: "$_value",
            id: "$id",
            "aria-describedby": "$describedBy"
        }
    })),
    WV = Pe("wrapper", null, !0),
    tue = Pe("input", () => ({
        $el: "select",
        bind: "$attrs",
        attrs: {
            id: "$id",
            "data-placeholder": "$fns.showPlaceholder($_value, $placeholder)",
            disabled: "$disabled",
            class: "$classes.input",
            name: "$node.name",
            onChange: "$handlers.onChange",
            onInput: "$handlers.selectInput",
            onBlur: "$handlers.blur",
            "aria-describedby": "$describedBy"
        }
    })),
    nue = Pe("option", () => ({
        $el: "option",
        for: ["option", "$options"],
        bind: "$option.attrs",
        attrs: {
            class: "$classes.option",
            value: "$option.value",
            selected: "$fns.isSelected($option)"
        }
    })),
    rue = () => ({
        $el: null,
        if: "$options.length",
        for: ["option", "$options"],
        children: "$slots.option"
    }),
    sue = Pe("input", () => ({
        $el: "textarea",
        bind: "$attrs",
        attrs: {
            disabled: "$disabled",
            name: "$node.name",
            onInput: "$handlers.DOMInput",
            onBlur: "$handlers.blur",
            value: "$_value",
            id: "$id",
            "aria-describedby": "$describedBy"
        },
        children: "$initialValue"
    })),
    En = (e, t) => Pe(`${e}Icon`, () => {
        const n = `_raw${e.charAt(0).toUpperCase()}${e.slice(1)}Icon`;
        return {
            if: `$${e}Icon && $${n}`,
            $el: `${t||"span"}`,
            attrs: {
                class: `$classes.${e}Icon + " formkit-icon"`,
                innerHTML: `$${n}`,
                onClick: `$handlers.iconClick(${e})`,
                for: {
                    if: `${t==="label"}`,
                    then: "$id"
                }
            }
        }
    })();

function GV(e) {
    return function(t, n) {
        return t.prop === "options" && Array.isArray(t.value) && (t.value = t.value.map(r => {
            var s;
            return !((s = r.attrs) === null || s === void 0) && s.id ? r : _l(r, {
                attrs: {
                    id: `${e.name}-option-${D$(String(r.value))}`
                }
            })
        }), e.props.type === "checkbox" && !Array.isArray(e.value) && (e.isCreated ? e.input([], !1) : e.on("created", () => {
            Array.isArray(e.value) || e.input([], !1)
        }))), n(t)
    }
}

function iue(e, t) {
    const n = t.target;
    if (n instanceof HTMLInputElement) {
        const r = Array.isArray(e.props.options) ? Cu(e.props.options, n.value) : n.value;
        Array.isArray(e.props.options) && e.props.options.length ? Array.isArray(e._value) ? e._value.some(s => Au(r, s)) ? e.input(e._value.filter(s => !Au(r, s))) : e.input([...e._value, r]) : e.input([r]) : n.checked ? e.input(e.props.onValue) : e.input(e.props.offValue)
    }
}

function oue(e, t) {
    var n, r;
    return (n = e.context) === null || n === void 0 || n.value, (r = e.context) === null || r === void 0 || r._value, Array.isArray(e._value) ? e._value.some(s => Au(Cu(e.props.options, t), s)) : !1
}

function aue(e) {
    e.on("created", () => {
        var t, n;
        !((t = e.context) === null || t === void 0) && t.handlers && (e.context.handlers.toggleChecked = iue.bind(null, e)), !((n = e.context) === null || n === void 0) && n.fns && (e.context.fns.isChecked = oue.bind(null, e)), De(e.props, "onValue") || (e.props.onValue = !0), De(e.props, "offValue") || (e.props.offValue = !1)
    }), e.hook.prop(GV(e))
}

function pb(e) {
    e.on("created", () => {
        e.props.disabled = Ye(e.props.disabled)
    }), e.hook.prop(({
        prop: t,
        value: n
    }, r) => (n = t === "disabled" ? Ye(n) : n, r({
        prop: t,
        value: n
    }))), e.on("prop:disabled", ({
        payload: t
    }) => {
        e.config.disabled = Ye(t)
    }), e.on("created", () => {
        e.config.disabled = Ye(e.props.disabled)
    })
}

function vg(e, t) {
    return n => {
        n.store.set(Nn({
            key: e,
            type: "ui",
            value: t || e,
            meta: {
                localize: !0,
                i18nArgs: [n]
            }
        }))
    }
}
const FR = typeof window != "undefined";

function qV(e) {
    e.target instanceof HTMLElement && e.target.hasAttribute("data-file-hover") && e.target.removeAttribute("data-file-hover")
}

function UR(e, t) {
    t.target instanceof HTMLInputElement ? e === "dragover" && t.target.setAttribute("data-file-hover", "true") : t.preventDefault(), e === "drop" && qV(t)
}

function lue(e) {
    vg("noFiles", "Select file")(e), vg("removeAll", "Remove all")(e), vg("remove")(e), FR && (window._FormKit_File_Drop || (window.addEventListener("dragover", UR.bind(null, "dragover")), window.addEventListener("drop", UR.bind(null, "drop")), window.addEventListener("dragleave", qV), window._FormKit_File_Drop = !0)), e.hook.input((t, n) => n(Array.isArray(t) ? t : [])), e.on("created", () => {
        Array.isArray(e.value) || e.input([], !1), e.context && (e.context.handlers.resetFiles = t => {
            if (t.preventDefault(), e.input([]), e.props.id && FR) {
                const n = document.getElementById(e.props.id);
                n && (n.value = "")
            }
        }, e.context.handlers.files = t => {
            var n, r;
            const s = [];
            if (t.target instanceof HTMLInputElement && t.target.files) {
                for (let i = 0; i < t.target.files.length; i++) {
                    let o;
                    (o = t.target.files.item(i)) && s.push({
                        name: o.name,
                        file: o
                    })
                }
                e.input(s)
            }
            e.context && (e.context.files = s), typeof((n = e.props.attrs) === null || n === void 0 ? void 0 : n.onChange) == "function" && ((r = e.props.attrs) === null || r === void 0 || r.onChange(t))
        })
    })
}
async function cue(e, t) {
    t.preventDefault(), await e.settled;
    const n = r => r.store.set(Nn({
        key: "submitted",
        value: !0,
        visible: !1
    }));
    if (e.walk(n), n(e), typeof e.props.onSubmitRaw == "function" && e.props.onSubmitRaw(t, e), e.ledger.value("blocking")) typeof e.props.onSubmitInvalid == "function" && e.props.onSubmitInvalid(e), e.props.incompleteMessage !== !1 && e.store.set(Nn({
        blocking: !1,
        key: "incomplete",
        meta: {
            localize: e.props.incompleteMessage === void 0,
            i18nArgs: [{
                node: e
            }],
            showAsMessage: !0
        },
        type: "ui",
        value: e.props.incompleteMessage || "Form incomplete."
    }));
    else if (typeof e.props.onSubmit == "function") {
        const r = e.props.onSubmit(e.hook.submit.dispatch(qo(e.value)), e);
        if (r instanceof Promise) {
            const s = e.props.disabled === void 0 && e.props.submitBehavior !== "live";
            s && (e.props.disabled = !0), e.store.set(Nn({
                key: "loading",
                value: !0,
                visible: !1
            })), await r, s && (e.props.disabled = !1), e.store.remove("loading")
        }
    } else t.target instanceof HTMLFormElement && t.target.submit()
}

function uue(e) {
    e.props.isForm = !0, e.on("created", () => {
        var t;
        !((t = e.context) === null || t === void 0) && t.handlers && (e.context.handlers.submit = cue.bind(null, e)), De(e.props, "actions") || (e.props.actions = !0)
    }), e.on("settled:blocking", () => e.store.remove("incomplete"))
}

function due(e) {
    e.props.ignore === void 0 && (e.props.ignore = !0, e.parent = null)
}

function fue(e) {
    e.on("created", () => {
        e.context && (e.context.initialValue = e.value || "")
    })
}

function hue(e, t) {
    t.target instanceof HTMLInputElement && e.input(Cu(e.props.options, t.target.value))
}

function pue(e, t) {
    var n, r;
    return (n = e.context) === null || n === void 0 || n.value, (r = e.context) === null || r === void 0 || r._value, Au(Cu(e.props.options, t), e._value)
}

function mue(e) {
    e.on("created", () => {
        var t, n;
        Array.isArray(e.props.options) || Dl(350, e), !((t = e.context) === null || t === void 0) && t.handlers && (e.context.handlers.toggleChecked = hue.bind(null, e)), !((n = e.context) === null || n === void 0) && n.fns && (e.context.fns.isChecked = pue.bind(null, e))
    }), e.hook.prop(GV(e))
}

function gue(e, t) {
    e.context && e.context.value;
    const n = "__original" in t ? t.__original : t.value;

    function r() {
        return !e.props.options.some(s => ("__original" in s ? s.__original : s.value) === null)
    }
    return Array.isArray(e._value) ? e._value.some(s => Au(s, n)) : (e._value === void 0 || e._value === null && r()) && t.attrs && t.attrs["data-is-placeholder"] ? !0 : Au(n, e._value)
}
async function _ue(e, t) {
    var n;
    typeof((n = e.props.attrs) === null || n === void 0 ? void 0 : n.onChange) == "function" && (await new Promise(r => setTimeout(r, 0)), await e.settled, e.props.attrs.onChange(t))
}

function yue(e, t) {
    const n = t.target,
        r = n.hasAttribute("multiple") ? Array.from(n.selectedOptions).map(s => Cu(e.props.options, s.value)) : Cu(e.props.options, n.value);
    e.input(r)
}

function BR(e, t) {
    return e.some(n => n.attrs && n.attrs["data-is-placeholder"]) ? e : [{
        label: t,
        value: "",
        attrs: {
            hidden: !0,
            disabled: !0,
            "data-is-placeholder": "true"
        }
    }, ...e]
}

function vue(e) {
    e.on("created", () => {
        var t, n, r;
        const s = Ye((t = e.props.attrs) === null || t === void 0 ? void 0 : t.multiple);
        !s && e.props.placeholder && Array.isArray(e.props.options) && (e.hook.prop(({
            prop: i,
            value: o
        }, a) => (i === "options" && (o = BR(o, e.props.placeholder)), a({
            prop: i,
            value: o
        }))), e.props.options = BR(e.props.options, e.props.placeholder)), s ? e.value === void 0 && e.input([], !1) : e.context && !e.context.options && (e.props.attrs = Object.assign({}, e.props.attrs, {
            value: e._value
        }), e.on("input", ({
            payload: i
        }) => {
            e.props.attrs = Object.assign({}, e.props.attrs, {
                value: i
            })
        })), !((n = e.context) === null || n === void 0) && n.handlers && (e.context.handlers.selectInput = yue.bind(null, e), e.context.handlers.onChange = _ue.bind(null, e)), !((r = e.context) === null || r === void 0) && r.fns && (e.context.fns.isSelected = gue.bind(null, e), e.context.fns.showPlaceholder = (i, o) => {
            if (!Array.isArray(e.props.options)) return !1;
            const a = e.props.options.some(l => {
                if (l.attrs && "data-is-placeholder" in l.attrs) return !1;
                const c = "__original" in l ? l.__original : l.value;
                return Qe(i, c)
            });
            return o && !a ? !0 : void 0
        })
    }), e.hook.input((t, n) => {
        var r, s, i;
        return !e.props.placeholder && t === void 0 && Array.isArray((r = e.props) === null || r === void 0 ? void 0 : r.options) && e.props.options.length && !Ye((i = (s = e.props) === null || s === void 0 ? void 0 : s.attrs) === null || i === void 0 ? void 0 : i.multiple) && (t = "__original" in e.props.options[0] ? e.props.options[0].__original : e.props.options[0].value), n(t)
    })
}

function jc(e, t) {
    return n => {
        n.props[`${e}Icon`] === void 0 && (n.props[`${e}Icon`] = `default:${t}`)
    }
}

function Z_(e) {
    return typeof e == "object" && ("$el" in e || "$cmp" in e || "$formkit" in e)
}

function f1(e) {
    return !!(lc(e) && e.if && e.if.startsWith("$slots.") && typeof e.then == "string" && e.then.startsWith("$slots.") && "else" in e)
}

function Vd(e, t = {}) {
    return typeof e == "string" ? Z_(t) || typeof t == "string" ? t : e : Array.isArray(e) ? Z_(t) ? t : e : _l(e, t)
}

function bue(e) {
    return ma(id(Pp("$label"), Ci(Hs(), e(), js())), zs("$help"), Bi(Vi("$message.value")))
}

function Pe(e, t, n = !1) {
    return (...r) => {
        const s = i => {
            const o = !t || typeof t == "string" ? {
                $el: t
            } : t();
            return (Sh(o) || Th(o)) && (o.meta || (o.meta = {
                section: e
            }), r.length && !o.children && (o.children = [...r.map(a => typeof a == "string" ? a : a(i))]), Sh(o) && (o.attrs = x({
                class: `$classes.${e}`
            }, o.attrs || {}))), {
                if: `$slots.${e}`,
                then: `$slots.${e}`,
                else: e in i ? Vd(o, i[e]) : o
            }
        };
        return s._s = e, n ? YV(s) : s
    }
}

function YV(e) {
    return t => [e(t)]
}

function os(e, t, n) {
    const r = s => {
        const i = t(s);
        if (n || Z_(i) && "if" in i || f1(i)) {
            const o = {
                if: e,
                then: i
            };
            return n && (o.else = n(s)), o
        } else f1(i) ? Object.assign(i.else, {
            if: e
        }) : Z_(i) && Object.assign(i, {
            if: e
        });
        return i
    };
    return r._s = ha(), r
}

function bg(e, t) {
    const n = r => {
        const s = e({});
        return f1(s) ? (Array.isArray(s.else) || (s.else = Vd(Vd(s.else, t), e._s ? r[e._s] : {})), s) : Vd(Vd(s, t), e._s ? r[e._s] : {})
    };
    return n._s = e._s, n
}

function wue(e) {
    return YV(e)
}
const VR = {
        schema: ma(Bi(Vi("$message.value")), id(Wce(En("prefix"), Hs(), Gce("$label || $ui.submit.value"), js(), En("suffix"))), zs("$help")),
        type: "input",
        family: "button",
        props: [],
        features: [vg("submit"), due]
    },
    Eue = {
        schema: ma(os("$options == undefined", Q_(Ci(Hs(), X_(), K_(En("decorator")), js()), bg(J_("$label"), {
            if: "$label"
        })), UV(BV("$label"), zs("$help"), HV(VV(Q_(Ci(Hs(), bg(X_(), {
            bind: "$option.attrs",
            attrs: {
                id: "$option.attrs.id",
                value: "$option.value",
                checked: "$fns.isChecked($option.value)"
            }
        }), K_(En("decorator")), js()), bg(J_("$option.label"), {
            if: "$option.label"
        })), jV("$option.help"))))), os("$options == undefined && $help", zs("$help")), Bi(Vi("$message.value"))),
        type: "input",
        family: "box",
        props: ["options", "onValue", "offValue", "optionsLoader"],
        features: [mk, aue, jc("decorator", "checkboxDecorator")]
    },
    Sue = {
        schema: ma(id(Pp("$label"), Ci(En("prefix", "label"), Hs(), qce(), Kce(Yce(En("fileItem"), Xce("$file.name"), os("$value.length === 1", LR(En("fileRemove"), "$ui.remove.value")))), os("$value.length > 1", LR("$ui.removeAll.value")), Qce(En("noFiles"), "$ui.noFiles.value"), js(), En("suffix"))), zs("$help"), Bi(Vi("$message.value"))),
        type: "input",
        family: "text",
        props: [],
        features: [lue, jc("fileItem", "fileItem"), jc("fileRemove", "fileRemove"), jc("noFiles", "noFiles")]
    },
    Tue = {
        schema: Jce("$slots.default", Bi(Vi("$message.value")), Zce(eue())),
        type: "group",
        props: ["actions", "submit", "submitLabel", "submitAttrs", "submitBehavior", "incompleteMessage"],
        features: [uue, pb]
    },
    $ue = {
        schema: WV("$slots.default"),
        type: "group",
        props: [],
        features: [pb]
    },
    kue = {
        schema: wue(zV()),
        type: "input",
        props: [],
        features: []
    },
    Iue = {
        schema: WV("$slots.default"),
        type: "list",
        props: [],
        features: [pb]
    },
    xue = {
        schema: ma(os("$options == undefined", Q_(Ci(Hs(), X_(), K_(En("decorator")), js()), os("$label", J_("$label"))), UV(BV("$label"), zs("$help"), HV(VV(Q_(Ci(Hs(), bg(X_(), {
            bind: "$option.attrs",
            attrs: {
                id: "$option.attrs.id",
                value: "$option.value",
                checked: "$fns.isChecked($option.value)"
            }
        }), K_(En("decorator")), js()), os("$option.label", J_("$option.label"))), jV("$option.help"))))), os("$options === undefined && $help", zs("$help")), Bi(Vi("$message.value"))),
        type: "input",
        family: "box",
        props: ["options", "onValue", "offValue", "optionsLoader"],
        features: [pb, mk, mue, jc("decorator", "radioDecorator")]
    },
    Cue = {
        schema: ma(id(Pp("$label"), Ci(En("prefix"), Hs(), tue(os("$slots.default", () => "$slots.default", os("$slots.option", rue, nue("$option.label")))), os("$attrs.multiple !== undefined", () => "", En("select")), js(), En("suffix"))), zs("$help"), Bi(Vi("$message.value"))),
        type: "input",
        props: ["options", "placeholder", "optionsLoader"],
        features: [mk, vue, jc("select", "select")]
    },
    Aue = {
        schema: ma(id(Pp("$label"), Ci(En("prefix", "label"), Hs(), sue(), js(), En("suffix"))), zs("$help"), Bi(Vi("$message.value"))),
        type: "input",
        props: [],
        features: [fue]
    },
    gr = {
        schema: ma(id(Pp("$label"), Ci(En("prefix", "label"), Hs(), zV(), js(), En("suffix"))), zs("$help"), Bi(Vi("$message.value"))),
        type: "input",
        family: "text",
        props: [],
        features: []
    };
var Rue = Object.freeze({
    __proto__: null,
    button: VR,
    submit: VR,
    checkbox: Eue,
    file: Sue,
    form: Tue,
    group: $ue,
    hidden: kue,
    list: Iue,
    radio: xue,
    select: Cue,
    textarea: Aue,
    text: gr,
    color: gr,
    date: gr,
    datetimeLocal: gr,
    email: gr,
    month: gr,
    number: gr,
    password: gr,
    search: gr,
    tel: gr,
    time: gr,
    url: gr,
    week: gr,
    range: gr
});
const KV = function({
    value: t
}) {
    return ["yes", "on", "1", 1, !0, "true"].includes(t)
};
KV.skipEmpty = !1;
const Oue = function({
        value: e
    }, t = !1) {
        const n = Date.parse(t || new Date),
            r = Date.parse(String(e));
        return isNaN(r) ? !1 : r > n
    },
    Due = function({
        value: e
    }, t = "default") {
        const n = {
                default: /^[a-zA-Z---]+$/,
                latin: /^[a-zA-Z]+$/
            },
            r = De(n, t) ? t : "default";
        return n[r].test(String(e))
    },
    Nue = function({
        value: e
    }, t = "default") {
        const n = {
                default: /^[a-zA-Z--- ]+$/,
                latin: /^[a-zA-Z ]+$/
            },
            r = De(n, t) ? t : "default";
        return n[r].test(String(e))
    },
    Pue = function({
        value: e
    }, t = "default") {
        const n = {
                default: /^[a-zA-Z0-9---]+$/,
                latin: /^[a-zA-Z0-9]+$/
            },
            r = De(n, t) ? t : "default";
        return n[r].test(String(e))
    },
    Mue = function({
        value: e
    }, t = !1) {
        const n = Date.parse(t || new Date),
            r = Date.parse(String(e));
        return isNaN(r) ? !1 : r < n
    },
    Lue = function({
        value: t
    }, n, r) {
        if (!isNaN(t) && !isNaN(n) && !isNaN(r)) {
            const s = 1 * t;
            n = Number(n), r = Number(r);
            const [i, o] = n <= r ? [n, r] : [r, n];
            return s >= 1 * i && s <= 1 * o
        }
        return !1
    },
    HR = /(_confirm(?:ed)?)$/,
    Fue = function(t, n, r = "loose") {
        var s;
        n || (n = HR.test(t.name) ? t.name.replace(HR, "") : `${t.name}_confirm`);
        const i = (s = t.at(n)) === null || s === void 0 ? void 0 : s.value;
        return r === "strict" ? t.value === i : t.value == i
    },
    Uue = function({
        value: t
    }, n, r) {
        n = n instanceof Date ? n.getTime() : Date.parse(n), r = r instanceof Date ? r.getTime() : Date.parse(r);
        const s = t instanceof Date ? t.getTime() : Date.parse(String(t));
        if (n && !r) r = n, n = Date.now();
        else if (!n || !s) return !1;
        return s >= n && s <= r
    },
    Bue = function({
        value: t
    }, n) {
        return n && typeof n == "string" ? vie(n).test(String(t)) : !isNaN(Date.parse(String(t)))
    },
    Vue = function({
        value: t
    }) {
        return /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i.test(String(t))
    },
    Hue = function({
        value: t
    }, ...n) {
        return typeof t == "string" && n.length ? n.some(r => t.endsWith(r)) : typeof t == "string" && n.length === 0
    },
    jue = function({
        value: t
    }, ...n) {
        return n.some(r => typeof r == "object" ? Qe(r, t) : r == t)
    },
    zue = function({
        value: t
    }, n = 0, r = 1 / 0) {
        n = parseInt(n), r = isNaN(parseInt(r)) ? 1 / 0 : parseInt(r);
        const s = n <= r ? n : r,
            i = r >= n ? r : n;
        if (typeof t == "string" || Array.isArray(t)) return t.length >= s && t.length <= i;
        if (t && typeof t == "object") {
            const o = Object.keys(t).length;
            return o >= s && o <= i
        }
        return !1
    },
    Wue = function({
        value: t
    }, ...n) {
        return n.some(r => (typeof r == "string" && r.substr(0, 1) === "/" && r.substr(-1) === "/" && (r = new RegExp(r.substr(1, r.length - 2))), r instanceof RegExp ? r.test(String(t)) : r === t))
    },
    Gue = function({
        value: t
    }, n = 10) {
        return Array.isArray(t) ? t.length <= n : Number(t) <= Number(n)
    },
    que = function({
        value: t
    }, n = 1) {
        return Array.isArray(t) ? t.length >= n : Number(t) >= Number(n)
    },
    Yue = function({
        value: t
    }, ...n) {
        return !n.some(r => typeof r == "object" ? Qe(r, t) : r === t)
    },
    Kue = function({
        value: t
    }) {
        return !isNaN(t)
    },
    XV = function({
        value: t
    }, n = "default") {
        return n === "trim" && typeof t == "string" ? !wh(t.trim()) : !wh(t)
    };
XV.skipEmpty = !1;
const Xue = function({
        value: t
    }, ...n) {
        return typeof t == "string" && n.length ? n.some(r => t.startsWith(r)) : typeof t == "string" && n.length === 0
    },
    Que = function({
        value: t
    }, ...n) {
        try {
            const r = n.length ? n : ["http:", "https:"],
                s = new URL(String(t));
            return r.includes(s.protocol)
        } catch {
            return !1
        }
    };
var Jue = Object.freeze(Object.defineProperty({
    __proto__: null,
    accepted: KV,
    alpha: Due,
    alpha_spaces: Nue,
    alphanumeric: Pue,
    between: Lue,
    confirm: Fue,
    date_after: Oue,
    date_before: Mue,
    date_between: Uue,
    date_format: Bue,
    email: Vue,
    ends_with: Hue,
    is: jue,
    length: zue,
    matches: Wue,
    max: Gue,
    min: que,
    not: Yue,
    number: Kue,
    required: XV,
    starts_with: Xue,
    url: Que
}, Symbol.toStringTag, {
    value: "Module"
}));
const QV = new WeakSet;

function Oh(e, t) {
    const n = t || Object.assign(new Map, {
            active: !1
        }),
        r = new Map,
        s = function(u) {
            var d;
            !n.active || (n.has(e) || n.set(e, new Set), (d = n.get(e)) === null || d === void 0 || d.add(u))
        },
        i = function(u) {
            return new Proxy(u, {
                get(...d) {
                    return typeof d[1] == "string" && s(`prop:${d[1]}`), Reflect.get(...d)
                }
            })
        },
        o = function(u) {
            return new Proxy(u, {
                get(...d) {
                    return d[1] === "value" ? f => (s(`count:${f}`), u.value(f)) : Reflect.get(...d)
                }
            })
        },
        a = function(u, d) {
            return kp(u) ? Oh(u, n) : (d === "value" && s("commit"), d === "props" ? i(u) : d === "ledger" ? o(u) : u)
        },
        {
            proxy: l,
            revoke: c
        } = Proxy.revocable(e, {
            get(...u) {
                switch (u[1]) {
                    case "_node":
                        return e;
                    case "deps":
                        return n;
                    case "watch":
                        return (f, h) => eH(l, f, h);
                    case "observe":
                        return () => {
                            const f = new Map(n);
                            return n.clear(), n.active = !0, f
                        };
                    case "stopObserve":
                        return () => {
                            const f = new Map(n);
                            return n.active = !1, f
                        };
                    case "receipts":
                        return r;
                    case "kill":
                        return () => {
                            ZV(r), QV.add(u[2]), c()
                        }
                }
                const d = Reflect.get(...u);
                return typeof d == "function" ? (...f) => {
                    const h = d(...f);
                    return a(h, u[1])
                } : a(d, u[1])
            }
        });
    return l
}

function JV(e, [t, n], r) {
    t.forEach((s, i) => {
        s.forEach(o => {
            var a;
            e.receipts.has(i) || e.receipts.set(i, {}), e.receipts.set(i, Object.assign((a = e.receipts.get(i)) !== null && a !== void 0 ? a : {}, {
                [o]: i.on(o, r)
            }))
        })
    }), n.forEach((s, i) => {
        s.forEach(o => {
            if (e.receipts.has(i)) {
                const a = e.receipts.get(i);
                a && De(a, o) && (i.off(a[o]), delete a[o], e.receipts.set(i, a))
            }
        })
    })
}

function ZV(e) {
    e.forEach((t, n) => {
        for (const r in t) n.off(t[r])
    })
}

function eH(e, t, n) {
    const r = o => {
            const a = e.stopObserve();
            JV(e, tH(s, a), () => eH(e, t, n)), n && n(o)
        },
        s = new Map(e.deps);
    e.observe();
    const i = t(e);
    i instanceof Promise ? i.then(o => r(o)) : r(i)
}

function tH(e, t) {
    const n = new Map,
        r = new Map;
    return t.forEach((s, i) => {
        if (!e.has(i)) n.set(i, s);
        else {
            const o = new Set,
                a = e.get(i);
            s.forEach(l => !(a != null && a.has(l)) && o.add(l)), n.set(i, o)
        }
    }), e.forEach((s, i) => {
        if (!t.has(i)) r.set(i, s);
        else {
            const o = new Set,
                a = t.get(i);
            s.forEach(l => !(a != null && a.has(l)) && o.add(l)), r.set(i, o)
        }
    }), [n, r]
}

function nH(e) {
    return QV.has(e)
}
const jR = Nn({
    type: "state",
    blocking: !0,
    visible: !1,
    value: !0,
    key: "validating"
});

function Zue(e = {}) {
    return function(n) {
        let r = Kr(n.props.validationRules || {}),
            s = x(x({}, e), r),
            i = Oh(n);
        const o = {
            input: ha(),
            rerun: null,
            isPassing: !0
        };
        let a = Kr(n.props.validation);
        n.on("prop:validation", ({
            payload: c
        }) => l(c, s)), n.on("prop:validationRules", ({
            payload: c
        }) => l(a, c));

        function l(c, u) {
            var d;
            Qe(Object.keys(r || {}), Object.keys(u || {})) && Qe(a, c) || (r = Kr(u), a = Kr(c), s = x(x({}, e), r), ZV(i.receipts), (d = n.props.parsedRules) === null || d === void 0 || d.forEach(f => {
                var h;
                f.messageObserver = (h = f.messageObserver) === null || h === void 0 ? void 0 : h.kill()
            }), n.store.filter(() => !1, "validation"), n.props.parsedRules = WR(c, s), i.kill(), i = Oh(n), h1(i, n.props.parsedRules, o))
        }
        n.props.parsedRules = WR(a, s), h1(i, n.props.parsedRules, o)
    }
}

function h1(e, t, n) {
    nH(e) || (n.input = ha(), n.isPassing = !0, e.store.filter(r => !r.meta.removeImmediately, "validation"), t.forEach(r => r.debounce && clearTimeout(r.timer)), t.length && (e.store.set(jR), p1(0, t, e, n, !1, () => {
        e.store.remove(jR.key)
    })))
}

function p1(e, t, n, r, s, i) {
    const o = t[e];
    if (!o) return i();
    const a = r.input;
    o.state = null;

    function l(c, u) {
        r.isPassing = r.isPassing && !!u, o.queued = !1;
        const d = n.stopObserve();
        JV(n, tH(o.deps, d), () => {
            o.queued = !0, r.rerun && clearTimeout(r.rerun), r.rerun = setTimeout(h1, 0, n, t, r)
        }), o.deps = d, r.input === a && (o.state = u, u === !1 ? nde(n, o, s || c) : tde(n, o), t.length > e + 1 ? p1(e + 1, t, n, r, s || c, i) : i())
    }(!wh(n.value) || !o.skipEmpty) && (r.isPassing || o.force) ? o.queued ? ede(o, n, c => {
        c instanceof Promise ? c.then(u => l(!0, u)) : l(!1, c)
    }) : p1(e + 1, t, n, r, s, i): wh(n.value) && o.skipEmpty && r.isPassing ? (n.observe(), n.value, l(!1, r.isPassing)) : l(!1, null)
}

function ede(e, t, n) {
    e.debounce ? e.timer = setTimeout(() => {
        t.observe(), n(e.rule(t, ...e.args))
    }, e.debounce) : (t.observe(), n(e.rule(t, ...e.args)))
}

function tde(e, t) {
    const n = `rule_${t.name}`;
    t.messageObserver && (t.messageObserver = t.messageObserver.kill()), De(e.store, n) && e.store.remove(n)
}

function nde(e, t, n) {
    nH(e) || (t.messageObserver || (t.messageObserver = Oh(e._node)), t.messageObserver.watch(r => sde(r, t), r => {
        const s = rde(e, t, r),
            i = Nn({
                blocking: t.blocking,
                key: `rule_${t.name}`,
                meta: {
                    messageKey: t.name,
                    removeImmediately: n,
                    localize: !s,
                    i18nArgs: r
                },
                type: "validation",
                value: s || "This field is not valid."
            });
        e.store.set(i)
    }))
}

function rde(e, t, n) {
    const r = e.props.validationMessages && De(e.props.validationMessages, t.name) ? e.props.validationMessages[t.name] : void 0;
    return typeof r == "function" ? r(...n) : r
}

function sde(e, t) {
    return [{
        node: e,
        name: ide(e),
        args: t.args
    }]
}

function ide(e) {
    return typeof e.props.validationLabel == "function" ? e.props.validationLabel(e) : e.props.validationLabel || e.props.label || e.props.name || String(e.name)
}
const rH = "(?:[\\*+?()0-9]+)",
    sH = "[a-zA-Z][a-zA-Z0-9_]+",
    ode = new RegExp(`^(${rH}?${sH})(?:\\:(.*)+)?$`, "i"),
    ade = new RegExp(`^(${rH})(${sH})$`, "i"),
    lde = /([\*+?]+)?(\(\d+\))([\*+?]+)?/,
    zR = /\(\d+\)/,
    cde = {
        blocking: !0,
        debounce: 0,
        force: !1,
        skipEmpty: !0,
        name: ""
    };

function WR(e, t) {
    return e ? (typeof e == "string" ? ude(e) : qo(e)).reduce((r, s) => {
        let i = s.shift();
        const o = {};
        if (typeof i == "string") {
            const [a, l] = fde(i);
            De(t, a) && (i = t[a], Object.assign(o, l))
        }
        return typeof i == "function" && r.push(x(x({
            rule: i,
            args: s,
            timer: 0,
            state: null,
            queued: !0,
            deps: new Map
        }, cde), hde(o, i))), r
    }, []) : []
}

function ude(e) {
    return e.split("|").reduce((t, n) => {
        const r = dde(n);
        return r && t.push(r), t
    }, [])
}

function dde(e) {
    const t = e.trim();
    if (t) {
        const n = t.match(ode);
        if (n && typeof n[1] == "string") {
            const r = n[1].trim(),
                s = n[2] && typeof n[2] == "string" ? n[2].split(",").map(i => i.trim()) : [];
            return [r, ...s]
        }
    }
    return !1
}

function fde(e) {
    const t = e.match(ade);
    if (!t) return [e, {
        name: e
    }];
    const n = {
            "*": {
                force: !0
            },
            "+": {
                skipEmpty: !1
            },
            "?": {
                blocking: !1
            }
        },
        [, r, s] = t,
        i = zR.test(r) ? r.match(lde) || [] : [, r];
    return [s, [i[1], i[2], i[3]].reduce((o, a) => (a && (zR.test(a) ? o.debounce = parseInt(a.substr(1, a.length - 1)) : a.split("").forEach(l => De(n, l) && Object.assign(o, n[l]))), o), {
        name: s
    })]
}

function hde(e, t) {
    return e.name || (e.name = t.ruleName || t.name), ["skipEmpty", "force", "debounce", "blocking"].reduce((n, r) => (De(t, r) && !De(n, r) && Object.assign(n, {
        [r]: t[r]
    }), n), e)
}

function At(e) {
    return e[0].toUpperCase() + e.substr(1)
}

function GR(e, t = "or") {
    return e.reduce((n, r, s) => (n += r, s <= e.length - 2 && e.length > 2 && (n += ", "), s === e.length - 2 && (n += `${e.length===2?" ":""}${t} `), n), "")
}

function Rm(e) {
    const t = typeof e == "string" ? new Date(Date.parse(e)) : e;
    return t instanceof Date ? new Intl.DateTimeFormat(void 0, {
        dateStyle: "medium",
        timeZone: "UTC"
    }).format(t) : "(unknown)"
}

function pde(e, t) {
    return Number(e) >= Number(t) ? [t, e] : [e, t]
}
const mde = {
        add: "Add",
        remove: "Remove",
        removeAll: "Remove all",
        incomplete: "Sorry, not all fields are filled out correctly.",
        submit: "Submit",
        noFiles: "No file chosen",
        moveUp: "Move up",
        moveDown: "Move down",
        isLoading: "Loading...",
        loadMore: "Load more",
        next: "Next",
        prev: "Previous",
        addAllValues: "Add all values",
        addSelectedValues: "Add selected values",
        removeAllValues: "Remove all values",
        removeSelectedValues: "Remove selected values",
        chooseDate: "Choose date",
        changeDate: "Change date",
        invalidDate: "The selected date is invalid."
    },
    gde = {
        accepted({
            name: e
        }) {
            return `Please accept the ${e}.`
        },
        date_after({
            name: e,
            args: t
        }) {
            return Array.isArray(t) && t.length ? `${At(e)} must be after ${Rm(t[0])}.` : `${At(e)} must be in the future.`
        },
        alpha({
            name: e
        }) {
            return `${At(e)} can only contain alphabetical characters.`
        },
        alphanumeric({
            name: e
        }) {
            return `${At(e)} can only contain letters and numbers.`
        },
        alpha_spaces({
            name: e
        }) {
            return `${At(e)} can only contain letters and spaces.`
        },
        date_before({
            name: e,
            args: t
        }) {
            return Array.isArray(t) && t.length ? `${At(e)} must be before ${Rm(t[0])}.` : `${At(e)} must be in the past.`
        },
        between({
            name: e,
            args: t
        }) {
            if (isNaN(t[0]) || isNaN(t[1])) return "This field was configured incorrectly and can\u2019t be submitted.";
            const [n, r] = pde(t[0], t[1]);
            return `${At(e)} must be between ${n} and ${r}.`
        },
        confirm({
            name: e
        }) {
            return `${At(e)} does not match.`
        },
        date_format({
            name: e,
            args: t
        }) {
            return Array.isArray(t) && t.length ? `${At(e)} is not a valid date, please use the format ${t[0]}` : "This field was configured incorrectly and can\u2019t be submitted"
        },
        date_between({
            name: e,
            args: t
        }) {
            return `${At(e)} must be between ${Rm(t[0])} and ${Rm(t[1])}`
        },
        email: "Please enter a valid email address.",
        ends_with({
            name: e,
            args: t
        }) {
            return `${At(e)} doesn\u2019t end with ${GR(t)}.`
        },
        is({
            name: e
        }) {
            return `${At(e)} is not an allowed value.`
        },
        length({
            name: e,
            args: [t = 0, n = 1 / 0]
        }) {
            const r = Number(t) <= Number(n) ? t : n,
                s = Number(n) >= Number(t) ? n : t;
            return r == 1 && s === 1 / 0 ? `${At(e)} must be at least one character.` : r == 0 && s ? `${At(e)} must be less than or equal to ${s} characters.` : r === s ? `${At(e)} should be ${s} characters long.` : r && s === 1 / 0 ? `${At(e)} must be greater than or equal to ${r} characters.` : `${At(e)} must be between ${r} and ${s} characters.`
        },
        matches({
            name: e
        }) {
            return `${At(e)} is not an allowed value.`
        },
        max({
            name: e,
            node: {
                value: t
            },
            args: n
        }) {
            return Array.isArray(t) ? `Cannot have more than ${n[0]} ${e}.` : `${At(e)} must be less than or equal to ${n[0]}.`
        },
        mime({
            name: e,
            args: t
        }) {
            return t[0] ? `${At(e)} must be of the type: ${t[0]}` : "No file formats allowed."
        },
        min({
            name: e,
            node: {
                value: t
            },
            args: n
        }) {
            return Array.isArray(t) ? `Cannot have fewer than ${n[0]} ${e}.` : `Must be at least ${n[0]} ${e} .`
        },
        not({
            name: e,
            node: {
                value: t
            }
        }) {
            return `\u201C${t}\u201D is not an allowed ${e}.`
        },
        number({
            name: e
        }) {
            return `${At(e)} must be a number.`
        },
        required({
            name: e
        }) {
            return `${At(e)} is required.`
        },
        starts_with({
            name: e,
            args: t
        }) {
            return `${At(e)} doesn\u2019t start with ${GR(t)}.`
        },
        url() {
            return "Please enter a valid URL."
        }
    };
var _de = Object.freeze({
    __proto__: null,
    ui: mde,
    validation: gde
});

function yde(e) {
    return function(n) {
        let r = qR(n.config.locale, e),
            s = r ? e[r] : {};
        n.on("prop:locale", ({
            payload: i
        }) => {
            r = qR(i, e), s = r ? e[r] : {}, n.store.touch()
        }), n.on("prop:label", () => n.store.touch()), n.on("prop:validationLabel", () => n.store.touch()), n.hook.text((i, o) => {
            var a, l;
            const c = ((a = i.meta) === null || a === void 0 ? void 0 : a.messageKey) || i.key;
            if (De(s, i.type) && De(s[i.type], c)) {
                const u = s[i.type][c];
                typeof u == "function" ? i.value = Array.isArray((l = i.meta) === null || l === void 0 ? void 0 : l.i18nArgs) ? u(...i.meta.i18nArgs) : u(i) : i.value = u
            }
            return o(i)
        })
    }
}

function qR(e, t) {
    if (De(t, e)) return e;
    const [n] = e.split("-");
    if (De(t, n)) return n;
    for (const r in t) return r;
    return !1
}

function vde(e) {
    const t = {};
    return Object.keys(e).forEach(n => {
        Object.keys(e[n]).forEach(r => {
            t[r] ? t[r][n] = e[n][r] : t[r] = {
                [n]: e[n][r]
            }
        })
    }), Object.keys(t).forEach(n => {
        const r = t[n];
        t[n] = function(s, i) {
            return bde(s, i, r)
        }
    }), t
}

function bde(e, t, n) {
    const r = e.props.type,
        s = e.props.family;
    let i = "";
    n.global && (i += n.global + " "), n[`family:${s}`] && (i += n[`family:${s}`] + " "), n[r] && (i += n[r]);
    const o = i.split("$reset");
    return o.length > 1 ? `$reset ${o[o.length-1].trim()}` : o[0].trim()
}
let as, Es = null,
    ey, iH = !1,
    Hd = !1;
const wde = new Promise(e => {
        ey = () => {
            iH = !0, e()
        }
    }),
    hi = typeof window != "undefined" && typeof fetch != "undefined";
as = hi ? getComputedStyle(document.documentElement) : void 0;
const wc = {},
    N0 = {};

function Ede(e, t, n, r) {
    t && Object.assign(wc, t), hi && !Hd && (as == null ? void 0 : as.getPropertyValue("--formkit-theme")) ? (ey(), Hd = !0) : e && !Hd && hi ? Sde(e) : !Hd && hi && ey();
    const s = function(o) {
        var a, l;
        o.addProps(["iconLoader", "iconLoaderUrl"]), o.props.iconHandler = vf(!((a = o.props) === null || a === void 0) && a.iconLoader ? o.props.iconLoader : r, !((l = o.props) === null || l === void 0) && l.iconLoaderUrl ? o.props.iconLoaderUrl : n), kde(o, o.props.iconHandler), o.on("created", () => {
            var c;
            !((c = o == null ? void 0 : o.context) === null || c === void 0) && c.handlers && (o.context.handlers.iconClick = u => {
                const d = `on${u.charAt(0).toUpperCase()}${u.slice(1)}IconClick`,
                    f = o.props[d];
                if (f && typeof f == "function") return h => f(o, h)
            })
        })
    };
    return s.iconHandler = vf(r, n), s
}

function Sde(e) {
    if (!(!e || !hi || typeof getComputedStyle != "function") && (Hd = !0, Es = document.getElementById("formkit-theme"), e && hi && (!(as != null && as.getPropertyValue("--formkit-theme")) && !Es || (Es == null ? void 0 : Es.getAttribute("data-theme")) && (Es == null ? void 0 : Es.getAttribute("data-theme")) !== e))) {
        const n = `https://cdn.jsdelivr.net/npm/@formkit/themes@${M_.startsWith("__")?"latest":M_}/dist/${e}/theme.css`,
            r = document.createElement("link");
        r.type = "text/css", r.rel = "stylesheet", r.id = "formkit-theme", r.setAttribute("data-theme", e), r.onload = () => {
            as = getComputedStyle(document.documentElement), ey()
        }, document.head.appendChild(r), r.href = n, Es && Es.remove()
    }
}

function vf(e, t) {
    return n => {
        if (typeof n == "boolean") return;
        if (n.startsWith("<svg")) return n;
        if (typeof n != "string") return;
        const r = n.startsWith("default:");
        n = r ? n.split(":")[1] : n;
        const s = n in wc;
        let i;
        if (s) return wc[n];
        if (!N0[n]) {
            if (i = Tde(n), i = hi && typeof i == "undefined" ? Promise.resolve(i) : i, i instanceof Promise) N0[n] = i.then(o => !o && typeof n == "string" && !r ? i = typeof e == "function" ? e(n) : $de(n, t) : o).then(o => (typeof n == "string" && (wc[r ? `default:${n}` : n] = o), o));
            else if (typeof i == "string") return wc[r ? `default:${n}` : n] = i, i
        }
        return N0[n]
    }
}

function Tde(e) {
    if (!!hi) return iH ? YR(e) : wde.then(() => YR(e))
}

function YR(e) {
    const t = as == null ? void 0 : as.getPropertyValue(`--fk-icon-${e}`);
    if (t) {
        const n = atob(t);
        if (n.startsWith("<svg")) return wc[e] = n, n
    }
}

function $de(e, t) {
    const n = M_.startsWith("__") ? "latest" : M_,
        r = typeof t == "function" ? t(e) : `https://cdn.jsdelivr.net/npm/@formkit/icons@${n}/dist/icons/${e}.svg`;
    if (!!hi) return fetch(`${r}`).then(async s => {
        const i = await s.text();
        if (i.startsWith("<svg")) return i
    }).catch(s => {
        console.error(s)
    })
}

function kde(e, t) {
    const n = /^[a-zA-Z-]+(?:-icon|Icon)$/;
    Object.keys(e.props).filter(s => n.test(s)).forEach(s => Ide(e, t, s))
}

function Ide(e, t, n) {
    const r = e.props[n],
        s = t(r),
        i = `_raw${n.charAt(0).toUpperCase()}${n.slice(1)}`,
        o = `on${n.charAt(0).toUpperCase()}${n.slice(1)}Click`;
    if (e.addProps([i, o]), e.on(`prop:${n}`, xde), s instanceof Promise) return s.then(a => {
        e.props[i] = a
    });
    e.props[i] = s
}

function xde(e) {
    var t;
    const n = e.origin,
        r = e.payload,
        s = (t = n == null ? void 0 : n.props) === null || t === void 0 ? void 0 : t.iconHandler,
        i = e.name.split(":")[1],
        o = `_raw${i.charAt(0).toUpperCase()}${i.slice(1)}`;
    if (s && typeof s == "function") {
        const a = s(r);
        if (a instanceof Promise) return a.then(l => {
            n.props[o] = l
        });
        n.props[o] = a
    }
}
let gk = !1;
const KR = {
        100: ({
            data: e
        }) => `Only groups, lists, and forms can have children (${e.name}).`,
        101: ({
            data: e
        }) => `You cannot directly modify the store (${e.name}). See: https://formkit.com/advanced/core#message-store`,
        102: ({
            data: [e, t]
        }) => `You cannot directly assign node.${t} (${e.name})`,
        103: ({
            data: [e]
        }) => `Schema expressions cannot start with an operator (${e})`,
        104: ({
            data: [e, t]
        }) => `Schema expressions cannot end with an operator (${e} in "${t}")`,
        105: ({
            data: e
        }) => `Invalid schema expression: ${e}`,
        106: ({
            data: e
        }) => `Cannot submit because (${e}) is not in a form.`,
        107: ({
            data: [e, t]
        }) => `Cannot set ${e.name} to non object value: ${t}`,
        108: ({
            data: [e, t]
        }) => `Cannot set ${e.name} to non array value: ${t}`,
        300: ({
            data: [e]
        }) => `Cannot set behavior prop to overscroll (on ${e.name} input) when options prop is a function.`,
        600: ({
            data: e
        }) => `Unknown input type${typeof e.props.type=="string"?' "'+e.props.type+'"':""} ("${e.name}")`,
        601: ({
            data: e
        }) => `Input definition${typeof e.props.type=="string"?' "'+e.props.type+'"':""} is missing a schema or component property (${e.name}).`
    },
    XR = {
        150: ({
            data: e
        }) => `Schema function "${e}()" is not a valid function.`,
        151: ({
            data: e
        }) => `No form element with id: ${e}`,
        152: ({
            data: e
        }) => `No input element with id: ${e}`,
        350: ({
            data: e
        }) => `Invalid options prop for radio input (${e.name}). See https://formkit.com/inputs/radio`,
        650: 'Schema "$get()" must use the id of an input to access.',
        651: ({
            data: e
        }) => `Cannot setErrors() on "${e}" because no such id exists.`,
        652: ({
            data: e
        }) => `Cannot clearErrors() on "${e}" because no such id exists.`,
        800: ({
            data: e
        }) => `${e} is deprecated.`
    },
    Cde = (e, t) => {
        if (e.code in KR) {
            const n = KR[e.code];
            e.message = typeof n == "function" ? n(e) : n
        }
        return t(e)
    };
gk || P$(Cde);
const Ade = (e, t) => {
    if (e.code in XR) {
        const n = XR[e.code];
        e.message = typeof n == "function" ? n(e) : n
    }
    return t(e)
};
gk || M$(Ade);
gk = !0;
const P0 = {};
let nr;
const Ia = new Map,
    Rde = "__raw__",
    Ode = /[a-zA-Z0-9\-][cC]lass$/;

function Dde(e, t) {
    const n = ae(null);
    if (e === "get") {
        const s = {};
        return n.value = Nde.bind(null, s), n
    }
    const r = e.split(".");
    return sr(() => {
        n.value = _k(gt(t) ? t.value : t, r)
    }), n
}

function _k(e, t) {
    if (Array.isArray(e)) {
        for (const s of e) {
            const i = s !== !1 && _k(s, t);
            if (i !== void 0) return i
        }
        return
    }
    let n, r = e;
    for (const s in t) {
        const i = t[s];
        if (typeof r != "object" || r === null) {
            n = void 0;
            break
        }
        const o = r[i];
        if (Number(s) === t.length - 1 && o !== void 0) {
            n = typeof o == "function" ? o.bind(r) : o;
            break
        }
        r = o
    }
    return n
}

function Nde(e, t) {
    if (typeof t != "string") return Dl(650);
    if (t in e || (e[t] = ae(void 0)), e[t].value === void 0) {
        e[t].value = null;
        const n = Ro(t);
        n && (e[t].value = n.context), zie(t, ({
            payload: r
        }) => {
            e[t].value = kp(r) ? r.context : r
        })
    }
    return e[t].value
}

function QR(e, t) {
    function n(d, f) {
        const h = u(Zr(f.if), {
                if: !0
            }),
            p = l(d, f.then),
            m = f.else ? l(d, f.else) : null;
        return [h, p, m]
    }

    function r(d, f) {
        var h, p;
        const m = u(Zr(d.if));
        let g = () => f,
            y = () => f;
        return typeof d.then == "object" ? y = s(d.then, void 0) : typeof d.then == "string" && ((h = d.then) === null || h === void 0 ? void 0 : h.startsWith("$")) ? y = u(Zr(d.then)) : y = () => d.then, De(d, "else") && (typeof d.else == "object" ? g = s(d.else) : typeof d.else == "string" && ((p = d.else) === null || p === void 0 ? void 0 : p.startsWith("$")) ? g = u(Zr(d.else)) : g = () => d.else), () => m() ? y() : g()
    }

    function s(d, f, h = {}) {
        const p = new Set(Object.keys(d || {})),
            m = f ? u(Zr(f)) : () => ({}),
            g = [y => {
                const _ = m();
                for (const E in _) p.has(E) || (y[E] = _[E])
            }];
        if (d) {
            if (lc(d)) return r(d, h);
            for (let y in d) {
                const _ = d[y];
                let E;
                const b = typeof _ == "string";
                y.startsWith(Rde) ? (y = y.substring(7), E = () => _) : b && _.startsWith("$") && _.length > 1 && !(_.startsWith("$reset") && Ode.test(y)) ? E = u(Zr(_)) : typeof _ == "object" && lc(_) ? E = r(_, void 0) : typeof _ == "object" && gl(_) ? E = s(_) : E = () => _, g.push(w => {
                    w[y] = E()
                })
            }
        }
        return () => {
            const y = Array.isArray(d) ? [] : {};
            return g.forEach(_ => _(y)), y
        }
    }

    function i(d, f) {
        let h = null,
            p = () => null,
            m = !1,
            g = null,
            y = null,
            _ = null,
            E = !1;
        const b = Poe(f);
        if (Sh(b) ? (h = b.$el, p = b.$el !== "text" ? s(b.attrs, b.bind) : () => null) : Th(b) ? (typeof b.$cmp == "string" ? De(d, b.$cmp) ? h = d[b.$cmp] : (h = b.$cmp, E = !0) : h = b.$cmp, p = s(b.props, b.bind)) : lc(b) && ([m, g, y] = n(d, b)), !lc(b) && "if" in b ? m = u(Zr(b.if)) : !lc(b) && h === null && (m = () => !0), "children" in b && b.children)
            if (typeof b.children == "string")
                if (b.children.startsWith("$slots.")) h = h === "text" ? "slot" : h, g = u(Zr(b.children));
                else if (b.children.startsWith("$") && b.children.length > 1) {
            const w = u(Zr(b.children));
            g = () => String(w())
        } else g = () => String(b.children);
        else if (Array.isArray(b.children)) g = l(d, b.children);
        else {
            const [w, T, S] = n(d, b.children);
            g = v => w && w() ? T && T(v) : S && S(v)
        }
        if (Th(b))
            if (g) {
                const w = g;
                g = T => ({
                    default (S, v) {
                        var $, k, C, O;
                        const R = nr;
                        v && (nr = v), S && (($ = Ia.get(nr)) === null || $ === void 0 || $.unshift(S)), T && ((k = Ia.get(nr)) === null || k === void 0 || k.unshift(T));
                        const N = w(T);
                        return S && ((C = Ia.get(nr)) === null || C === void 0 || C.shift()), T && ((O = Ia.get(nr)) === null || O === void 0 || O.shift()), nr = R, N
                    }
                }), g.slot = !0
            } else g = () => ({});
        if ("for" in b && b.for) {
            const w = b.for.length === 3 ? b.for[2] : b.for[1];
            _ = [typeof w == "string" && w.startsWith("$") ? u(Zr(w)) : () => w, b.for[0], b.for.length === 3 ? String(b.for[1]) : null]
        }
        return [m, h, p, g, y, _, E]
    }

    function o(d, f) {
        const h = d(f),
            p = nr;
        return Object.keys(h).reduce((m, g) => {
            const y = h && h[g];
            return m[g] = _ => y && y(_, p) || null, m
        }, {})
    }

    function a(d, f) {
        const [h, p, m, g, y, _, E] = i(d, f);
        let b = w => {
            if (h && p === null && g) return h() ? g(w) : y && y(w);
            if (p && (!h || h())) {
                if (p === "text" && g) return hn(String(g()));
                if (p === "slot" && g) return g(w);
                const T = E ? Do(p) : p,
                    S = g != null && g.slot ? o(g, w) : null;
                return Vs(T, m(), S || (g ? g(w) : []))
            }
            return typeof y == "function" ? y(w) : y
        };
        if (_) {
            const w = b,
                [T, S, v] = _;
            b = () => {
                const $ = T(),
                    k = isNaN($) ? $ : Array(Number($)).fill(0).map((N, J) => J),
                    C = [];
                if (typeof k != "object") return null;
                const O = Ia.get(nr) || [],
                    R = Array.isArray(k);
                for (const N in k) {
                    if (R && N in Array.prototype) continue;
                    const J = Object.defineProperty(x(G(x({}, O.reduce((Y, ie) => Y.__idata ? x(x({}, Y), ie) : ie, {})), {
                        [S]: k[N]
                    }), v !== null ? {
                        [v]: R ? Number(N) : N
                    } : {}), "__idata", {
                        enumerable: !1,
                        value: !0
                    });
                    O.unshift(J), C.push(w.bind(null, J)()), O.shift()
                }
                return C
            }
        }
        return b
    }

    function l(d, f) {
        if (Array.isArray(f)) {
            const p = f.map(a.bind(null, d));
            return m => p.map(g => g(m))
        }
        const h = a(d, f);
        return p => h(p)
    }
    const c = [];

    function u(d, f = {}) {
        const h = {};
        return c.push((p, m) => {
            h[m] = d.provide(g => p(g, f))
        }), () => h[nr]()
    }
    return function(f, h) {
        const p = JSON.stringify(t),
            [m, g] = De(P0, p) ? P0[p] : [l(e, t), c];
        return P0[p] = [m, g], g.forEach(y => {
            y(f, h)
        }), () => (nr = h, m())
    }
}

function oH(e, t) {
    const n = Ia.get(nr) || [];
    let r;
    return n.length && (r = _k(n, e.split("."))), r === void 0 ? t : r
}

function Pde(e, t) {
    return new Proxy(e, {
        get(...n) {
            let r;
            const s = n[1];
            if (typeof s == "string") {
                const i = nr;
                nr = t, r = oH(s, void 0), nr = i
            }
            return r !== void 0 ? r : Reflect.get(...n)
        }
    })
}

function JR(e, t, n) {
    return e((r, s = {}) => r.reduce((i, o) => {
        if (o.startsWith("slots.")) {
            const a = o.substring(6),
                l = () => t.slots && De(t.slots, a) && typeof t.slots[a] == "function";
            if (s.if) i[o] = l;
            else if (t.slots) {
                const c = Pde(t, n);
                i[o] = () => l() ? t.slots[a](c) : null
            }
        } else {
            const a = Dde(o, t);
            i[o] = () => oH(o, a.value)
        }
        return i
    }, {}), n)
}
let ZR = 0;
const yk = Ir({
        name: "FormKitSchema",
        props: {
            schema: {
                type: [Array, Object],
                required: !0
            },
            data: {
                type: Object,
                default: () => ({})
            },
            library: {
                type: Object,
                default: () => ({})
            }
        },
        setup(e, t) {
            const n = Qn();
            let r = Symbol(String(ZR++));
            Ia.set(r, []);
            let s = QR(e.library, e.schema),
                i, o;
            return $t(() => e.schema, (a, l) => {
                var c;
                r = Symbol(String(ZR++)), s = QR(e.library, e.schema), i = JR(s, o, r), a === l && ((c = n == null ? void 0 : n.proxy) === null || c === void 0 ? void 0 : c.$forceUpdate)()
            }, {
                deep: !0
            }), sr(() => {
                o = Object.assign(Pr(e.data), {
                    slots: t.slots
                }), i = JR(s, o, r)
            }), () => i()
        }
    }),
    Mde = {
        config: {
            type: Object,
            default: {}
        },
        classes: {
            type: Object,
            required: !1
        },
        delay: {
            type: Number,
            required: !1
        },
        errors: {
            type: Array,
            default: []
        },
        inputErrors: {
            type: Object,
            default: () => ({})
        },
        index: {
            type: Number,
            required: !1
        },
        id: {
            type: String,
            required: !1
        },
        modelValue: {
            required: !1
        },
        name: {
            type: String,
            required: !1
        },
        parent: {
            type: Object,
            required: !1
        },
        plugins: {
            type: Array,
            default: []
        },
        sectionsSchema: {
            type: Object,
            default: {}
        },
        type: {
            type: [String, Object],
            default: "text"
        },
        validation: {
            type: [String, Array],
            required: !1
        },
        validationMessages: {
            type: Object,
            required: !1
        },
        validationRules: {
            type: Object,
            required: !1
        },
        validationLabel: {
            type: [String, Function],
            required: !1
        }
    },
    Lde = Mde,
    ty = Symbol("FormKitParent"),
    Fde = Ir({
        props: Lde,
        emits: {
            input: (e, t) => !0,
            inputRaw: (e, t) => !0,
            "update:modelValue": e => !0,
            node: e => !!e,
            submit: (e, t) => !0,
            submitRaw: (e, t) => !0,
            submitInvalid: e => !0
        },
        inheritAttrs: !1,
        setup(e, t) {
            const n = Gde(e, t);
            if (n.props.definition || Tr(600, n), n.props.definition.component) return () => {
                var o;
                return Vs((o = n.props.definition) === null || o === void 0 ? void 0 : o.component, {
                    context: n.context
                }, x({}, t.slots))
            };
            const r = ae([]),
                s = () => {
                    var o, a;
                    const l = (a = (o = n.props) === null || o === void 0 ? void 0 : o.definition) === null || a === void 0 ? void 0 : a.schema;
                    l || Tr(601, n), r.value = typeof l == "function" ? l(x({}, e.sectionsSchema)) : l
                };
            s(), n.on("schema", s), t.emit("node", n);
            const i = n.props.definition.library;
            return t.expose({
                node: n
            }), () => Vs(yk, {
                schema: r.value,
                data: n.context,
                library: i
            }, x({}, t.slots))
        }
    });

function Ude(e, t) {
    return e.component(t.alias || "FormKit", Fde).component(t.schemaAlias || "FormKitSchema", yk), {
        get: Ro,
        setLocale: n => {
            var r;
            !((r = t.config) === null || r === void 0) && r.rootConfig && (t.config.rootConfig.locale = n)
        },
        clearErrors: Foe,
        setErrors: Loe,
        submit: KB,
        reset: XB
    }
}
const vk = Symbol.for("FormKitOptions"),
    Bde = Symbol.for("FormKitConfig"),
    Vde = {
        install(e, t) {
            const n = Object.assign({
                    alias: "FormKit",
                    schemaAlias: "FormKitSchema"
                }, typeof t == "function" ? t() : t),
                r = Wie(n.config || {});
            n.config = {
                rootConfig: r
            }, e.config.globalProperties.$formkit = Ude(e, n), e.provide(vk, n), e.provide(Bde, r)
        }
    },
    m1 = Symbol();

function Hde(e, t) {
    const n = {},
        r = o => {
            for (const a of o) a.__str in n && n[a.__str](), n[a.__str] = $t(zde.bind(null, e, a), i.bind(null, a), {
                deep: !1
            })
        },
        i = jde(e, t, r, o => {
            if (!!o.length)
                for (const a in n) `${a}`.startsWith(`${o.__str}.`) && (n[a](), delete n[a])
        });
    r(bk(e))
}

function jde(e, t, n, r) {
    return s => {
        const i = aH(e, s);
        i !== m1 && (s.__deep && r(s), typeof i == "object" && n(bk(i, [s], ...s)), t(s, i, e))
    }
}

function zde(e, t) {
    const n = aH(e, t);
    return n && typeof n == "object" ? Object.keys(n) : n
}

function aH(e, t) {
    if (gt(e)) {
        if (t.length === 0) return e.value;
        e = e.value
    }
    return t.reduce((n, r) => n === m1 ? n : n === null || typeof n != "object" ? m1 : n[r], e)
}

function bk(e, t = [], ...n) {
    if (e === null) return t;
    if (!n.length) {
        const r = Object.defineProperty([], "__str", {
            value: ""
        });
        if (e = gt(e) ? e.value : e, e && typeof e == "object") Object.defineProperty(r, "__deep", {
            value: !0
        }), t.push(r);
        else return [r]
    }
    if (e === null || typeof e != "object") return t;
    for (const r in e) {
        const s = n.concat(r);
        Object.defineProperty(s, "__str", {
            value: s.join(".")
        });
        const i = e[r];
        gl(i) || Array.isArray(i) ? (t.push(Object.defineProperty(s, "__deep", {
            value: !0
        })), t = t.concat(bk(i, [], ...s))) : t.push(s)
    }
    return t
}

function wg(e) {
    return e === null || typeof e != "object" || (ms(e) ? e = ze(e) : gt(e) && (e = ms(e.value) ? wg(e.value) : e.value)), e
}
const M0 = ["help", "label", "ignore", "disabled", "preserve", /^preserve(-e|E)rrors/, /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/, /^[a-zA-Z-]+(?:-class|Class)$/, "prefixIcon", "suffixIcon", /^[a-zA-Z-]+(?:-icon|Icon)$/];

function eO(e, t) {
    t.classes && Object.keys(t.classes).forEach(n => {
        typeof n == "string" && (e.props[`_${n}Class`] = t.classes[n], ml(t.classes[n]) && n === "inner" && Object.values(t.classes[n]))
    })
}

function Wde(e) {
    return e ? ["Submit", "SubmitRaw", "SubmitInvalid"].reduce((n, r) => {
        const s = `on${r}`;
        return s in e && typeof e[s] == "function" && (n[s] = e[s]), n
    }, {}) : {}
}

function Gde(e, t, n = {}) {
    var r;
    const s = Object.assign({}, bt(vk) || {}, n),
        i = Qn(),
        o = Wde(i == null ? void 0 : i.vnode.props),
        a = "modelValue" in ((r = i == null ? void 0 : i.vnode.props) !== null && r !== void 0 ? r : {}),
        l = e.modelValue !== void 0 ? e.modelValue : Kr(t.attrs.value);

    function c() {
        const w = x(x({}, Ql(e)), o),
            T = qA(Ql(t.attrs), M0);
        T.key || (T.key = ha()), w.attrs = T;
        const S = YA(Ql(t.attrs), M0);
        for (const $ in S) w[Fc($)] = S[$];
        const v = {
            props: {}
        };
        return eO(v, e), Object.assign(w, v.props), typeof w.type != "string" && (w.definition = w.type, delete w.type), w
    }
    const u = c(),
        d = u.ignore ? null : e.parent || bt(ty, null),
        f = Doe(_l(s || {}, {
            name: e.name || void 0,
            value: l,
            parent: d,
            plugins: (s.plugins || []).concat(e.plugins),
            config: e.config,
            props: u,
            index: e.index
        }, !1, !0));
    f.props.definition || Tr(600, f);
    const h = ae(new Set(f.props.definition.props || []));
    f.on("added-props", ({
        payload: w
    }) => {
        Array.isArray(w) && w.forEach(T => h.value.add(T))
    });
    const p = Fe(() => M0.concat([...h.value]).reduce((w, T) => (typeof T == "string" ? (w.push(Fc(T)), w.push(zB(T))) : w.push(T), w), []));
    sr(() => eO(f, e));
    const m = Ql(e);
    for (const w in m) $t(() => e[w], () => {
        e[w] !== void 0 && (f.props[w] = e[w])
    });
    const g = new Set,
        y = Ql(t.attrs);
    sr(() => {
        _(YA(y, p.value))
    });

    function _(w) {
        g.forEach(T => {
            T(), g.delete(T)
        });
        for (const T in w) {
            const S = Fc(T);
            g.add($t(() => t.attrs[T], () => {
                f.props[S] = t.attrs[T]
            }))
        }
    }
    if (sr(() => {
            const w = qA(Ql(t.attrs), p.value);
            "multiple" in w && (w.multiple = Ye(w.multiple)), f.props.attrs = Object.assign({}, f.props.attrs || {}, w)
        }), sr(() => {
            const w = e.errors.map(T => Nn({
                key: D$(T),
                type: "error",
                value: T,
                meta: {
                    source: "prop"
                }
            }));
            f.store.apply(w, T => T.type === "error" && T.meta.source === "prop")
        }), f.type !== "input") {
        const w = `${f.name}-prop`;
        sr(() => {
            const T = Object.keys(e.inputErrors);
            T.length || f.clearErrors(!0, w);
            const S = T.reduce((v, $) => {
                let k = e.inputErrors[$];
                return typeof k == "string" && (k = [k]), Array.isArray(k) && (v[$] = k.map(C => Nn({
                    key: C,
                    type: "error",
                    value: C,
                    meta: {
                        source: w
                    }
                }))), v
            }, {});
            f.store.apply(S, v => v.type === "error" && v.meta.source === w)
        })
    }
    sr(() => Object.assign(f.config, e.config)), f.type !== "input" && fi(ty, f);
    let E;
    const b = new WeakSet;
    return f.on("modelUpdated", () => {
        var w, T;
        if (t.emit("inputRaw", (w = f.context) === null || w === void 0 ? void 0 : w.value, f), clearTimeout(E), E = setTimeout(t.emit, 20, "input", (T = f.context) === null || T === void 0 ? void 0 : T.value, f), a && f.context) {
            const S = wg(f.context.value);
            ml(S) && wg(e.modelValue) !== S && b.add(S), t.emit("update:modelValue", S)
        }
    }), a && (Hde(Q$(e, "modelValue"), (w, T) => {
        var S;
        const v = wg(T);
        if (ml(v) && b.has(v)) return b.delete(v);
        w.length ? (S = f.at(w)) === null || S === void 0 || S.input(T, !1) : f.input(T, !1)
    }), f.value !== l && f.emit("modelUpdated")), pa(() => f.destroy()), f
}
let qde = 1;

function Yde(e) {
    return typeof e == "function" && e.length === 2 || typeof e == "object" && !Array.isArray(e) && !("$el" in e) && !("$cmp" in e) && !("if" in e)
}

function Kde(e, t = {}) {
    const n = x({
        type: "input"
    }, t);
    let r;
    if (Yde(e)) {
        const s = `SchemaComponent${qde++}`;
        r = Pe("input", () => ({
            $cmp: s,
            props: {
                context: "$node.context"
            }
        })), n.library = {
            [s]: Op(e)
        }
    } else typeof e == "function" ? r = e : r = Pe("input", () => Kr(e));
    return n.schema = bue(r || "Schema undefined"), n
}
const Xde = Pe("messages", () => ({
        $el: "ul",
        if: "$fns.length($messages)"
    }), !0),
    Qde = Pe("message", () => ({
        $el: "li",
        for: ["message", "$messages"],
        attrs: {
            key: "$message.key",
            id: "$id + '-' + $message.key",
            "data-message-type": "$message.type"
        }
    })),
    Jde = Xde(Qde("$message.value"));
Ir({
    props: {
        node: {
            type: Object,
            required: !1
        },
        sectionsSchema: {
            type: Object,
            default: {}
        },
        defaultPosition: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(e, t) {
        const n = Fe(() => e.node || bt(ty, void 0));
        $t(n, () => {
            var i;
            ((i = n.value) === null || i === void 0 ? void 0 : i.context) && !Ye(e.defaultPosition) && (n.value.context.defaultMessagePlacement = !1)
        }, {
            immediate: !0
        });
        const r = Jde(e.sectionsSchema || {}),
            s = Fe(() => {
                var i, o, a, l, c, u;
                return {
                    messages: ((o = (i = n.value) === null || i === void 0 ? void 0 : i.context) === null || o === void 0 ? void 0 : o.messages) || {},
                    fns: ((l = (a = n.value) === null || a === void 0 ? void 0 : a.context) === null || l === void 0 ? void 0 : l.fns) || {},
                    classes: ((u = (c = n.value) === null || c === void 0 ? void 0 : c.context) === null || u === void 0 ? void 0 : u.classes) || {}
                }
            });
        return () => {
            var i;
            return !((i = n.value) === null || i === void 0) && i.context ? Vs(yk, {
                schema: r,
                data: s.value
            }, x({}, t.slots)) : null
        }
    }
});
const Zde = function(t) {
        t.ledger.count("blocking", S => S.blocking);
        const n = ae(!t.ledger.value("blocking"));
        t.ledger.count("errors", S => S.type === "error");
        const r = ae(!!t.ledger.value("errors"));
        let s = !1;
        ln(() => {
            s = !0
        });
        const i = Pr(t.store.reduce((S, v) => (v.visible && (S[v.key] = v), S), {})),
            o = ae(t.props.validationVisibility || "blur");
        t.on("prop:validationVisibility", ({
            payload: S
        }) => {
            o.value = S
        });
        const a = ae(o.value === "live"),
            l = Fe(() => {
                if (_.state.submitted) return !0;
                if (!a.value && !_.state.settled) return !1;
                switch (o.value) {
                    case "live":
                        return !0;
                    case "blur":
                        return _.state.blurred;
                    case "dirty":
                        return _.state.dirty;
                    default:
                        return !1
                }
            }),
            c = Fe(() => u.value ? n.value && !r.value : _.state.dirty && !wh(_.value)),
            u = ae(Array.isArray(t.props.parsedRules) && t.props.parsedRules.length > 0);
        t.on("prop:parsedRules", ({
            payload: S
        }) => {
            u.value = Array.isArray(S) && S.length > 0
        });
        const d = Fe(() => {
                const S = {};
                for (const v in i) {
                    const $ = i[v];
                    ($.type !== "validation" || l.value) && (S[v] = $)
                }
                return S
            }),
            f = Pr(t.store.reduce((S, v) => (v.type === "ui" && v.visible && (S[v.key] = v), S), {})),
            h = Pr({}),
            p = new Proxy(h, {
                get(...S) {
                    const [v, $] = S;
                    let k = Reflect.get(...S);
                    return !k && typeof $ == "string" && !De(v, $) && !$.startsWith("__v") && Oh(t).watch(O => {
                        const R = typeof O.config.rootClasses == "function" ? O.config.rootClasses($, O) : {},
                            N = O.config.classes ? gg($, O, O.config.classes[$]) : {},
                            J = gg($, O, O.props[`_${$}Class`]),
                            Y = gg($, O, O.props[`${$}Class`]);
                        k = Moe(O, $, R, N, J, Y), v[$] = k != null ? k : ""
                    }), k
                }
            }),
            m = Fe(() => {
                const S = [];
                _.help && S.push(`help-${t.props.id}`);
                for (const v in d.value) S.push(`${t.props.id}-${v}`);
                return S.length ? S.join(" ") : void 0
            }),
            g = ae(t.value),
            y = ae(t.value),
            _ = Pr({
                _value: y,
                attrs: t.props.attrs,
                disabled: t.props.disabled,
                describedBy: m,
                fns: {
                    length: S => Object.keys(S).length,
                    number: S => Number(S),
                    string: S => String(S),
                    json: S => JSON.stringify(S),
                    eq: Qe
                },
                handlers: {
                    blur: S => {
                        t.store.set(Nn({
                            key: "blurred",
                            visible: !1,
                            value: !0
                        })), typeof t.props.attrs.onBlur == "function" && t.props.attrs.onBlur(S)
                    },
                    touch: () => {
                        var S;
                        const v = _.dirtyBehavior === "compare";
                        if (((S = t.store.dirty) === null || S === void 0 ? void 0 : S.value) && !v) return;
                        const $ = !Qe(t.props._init, t._value);
                        !$ && !v || t.store.set(Nn({
                            key: "dirty",
                            visible: !1,
                            value: $
                        }))
                    },
                    DOMInput: S => {
                        t.input(S.target.value), t.emit("dom-input-event", S)
                    }
                },
                help: t.props.help,
                id: t.props.id,
                label: t.props.label,
                messages: d,
                node: Op(t),
                options: t.props.options,
                defaultMessagePlacement: !0,
                state: {
                    blurred: !1,
                    complete: c,
                    dirty: !1,
                    submitted: !1,
                    settled: t.isSettled,
                    valid: n,
                    errors: r,
                    rules: u,
                    validationVisible: l
                },
                type: t.props.type,
                family: t.props.family,
                ui: f,
                value: g,
                classes: p
            });
        t.on("created", () => {
            Qe(_.value, t.value) || (y.value = t.value, g.value = t.value, Fd(g), Fd(y)), (async () => (await t.settled, t.props._init = Kr(t.value)))()
        }), t.on("settled", ({
            payload: S
        }) => {
            _.state.settled = S
        });

        function E(S) {
            S.forEach(v => {
                v = Fc(v), !De(_, v) && De(t.props, v) && (_[v] = t.props[v]), t.on(`prop:${v}`, ({
                    payload: $
                }) => {
                    _[v] = $
                })
            })
        }
        E((() => {
            const S = ["help", "label", "disabled", "options", "type", "attrs", "preserve", "preserveErrors", "id", "dirtyBehavior"],
                v = /^[a-zA-Z-]+(?:-icon|Icon)$/,
                $ = Object.keys(t.props).filter(k => v.test(k));
            return S.concat($)
        })());

        function w(S) {
            S.props && E(S.props)
        }
        t.props.definition && w(t.props.definition), t.on("added-props", ({
            payload: S
        }) => E(S)), t.on("input", ({
            payload: S
        }) => {
            t.type !== "input" && !gt(S) && !ms(S) ? y.value = KA(S) : (y.value = S, Fd(y))
        }), t.on("commit", ({
            payload: S
        }) => {
            t.type !== "input" && !gt(S) && !ms(S) ? g.value = y.value = KA(S) : (g.value = y.value = S, Fd(g)), t.emit("modelUpdated"), (!_.state.dirty || _.dirtyBehavior === "compare") && t.isCreated && s && _.handlers.touch(), c && t.type === "input" && r.value && !Ye(t.props.preserveErrors) && t.store.filter(v => {
                var $;
                return !(v.type === "error" && (($ = v.meta) === null || $ === void 0 ? void 0 : $.autoClear) === !0)
            })
        });
        const T = async S => {
            S.type === "ui" && S.visible && !S.meta.showAsMessage ? f[S.key] = S : S.visible ? i[S.key] = S : S.type === "state" && (_.state[S.key] = !!S.value)
        };
        t.on("message-added", S => T(S.payload)), t.on("message-updated", S => T(S.payload)), t.on("message-removed", ({
            payload: S
        }) => {
            delete f[S.key], delete i[S.key], delete _.state[S.key]
        }), t.on("settled:blocking", () => {
            n.value = !0
        }), t.on("unsettled:blocking", () => {
            n.value = !1
        }), t.on("settled:errors", () => {
            r.value = !1
        }), t.on("unsettled:errors", () => {
            r.value = !0
        }), $t(l, S => {
            S && (a.value = !0)
        }), t.context = _, t.emit("context", t, !1)
    },
    efe = (e = {}) => {
        const m = e,
            {
                rules: t = {},
                locales: n = {},
                inputs: r = {},
                messages: s = {},
                locale: i = void 0,
                theme: o = void 0,
                iconLoaderUrl: a = void 0,
                iconLoader: l = void 0,
                icons: c = {}
            } = m,
            u = Gr(m, ["rules", "locales", "inputs", "messages", "locale", "theme", "iconLoaderUrl", "iconLoader", "icons"]),
            d = Zue(x(x({}, Jue), t || {})),
            f = yde(_l(x({
                en: _de
            }, n || {}), s)),
            h = jce(Rue, r),
            p = Ede(o, c, a, l);
        return _l(x({
            plugins: [h, p, Zde, f, d]
        }, i ? {
            config: {
                locale: i
            }
        } : {}), u || {}, !0)
    };
Ir({
    name: "FormKitIcon",
    props: {
        icon: {
            type: String,
            default: ""
        },
        iconLoader: {
            type: Function,
            default: null
        },
        iconLoaderUrl: {
            type: Function,
            default: null
        }
    },
    setup(e) {
        var t, n;
        const r = ae(void 0),
            s = bt(vk, {}),
            i = bt(ty, null);
        let o;

        function a() {
            if (!o || typeof o != "function") return;
            const l = o(e.icon);
            l instanceof Promise ? l.then(c => {
                r.value = c
            }) : r.value = l
        }
        if (e.iconLoader && typeof e.iconLoader == "function") o = vf(e.iconLoader);
        else if (i && ((t = i.props) === null || t === void 0 ? void 0 : t.iconLoader)) o = vf(i.props.iconLoader);
        else if (e.iconLoaderUrl && typeof e.iconLoaderUrl == "function") o = vf(o, e.iconLoaderUrl);
        else {
            const l = (n = s == null ? void 0 : s.plugins) === null || n === void 0 ? void 0 : n.find(c => typeof c.iconHandler == "function");
            l && (o = l.iconHandler)
        }
        return $t(() => e.icon, () => {
            a()
        }, {
            immediate: !0
        }), () => e.icon && r.value ? Vs("span", {
            class: "formkit-icon",
            innerHTML: r.value
        }) : null
    }
});
var tfe = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 27"><polygon fill="currentColor" points="26.99 0 10.13 17.17 4.69 11.63 0 16.41 10.4 27 15.05 22.27 15.09 22.31 32 5.1 26.99 0"/></svg>',
    nfe = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><circle fill="currentColor" cx="16" cy="16" r="16"/></svg>',
    tO = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 16"><path d="M10,12.5c-.13,0-.26-.05-.35-.15L1.65,4.35c-.2-.2-.2-.51,0-.71,.2-.2,.51-.2,.71,0L10.35,11.65c.2,.2,.2,.51,0,.71-.1,.1-.23,.15-.35,.15Z" fill="currentColor"/><path d="M2,12.5c-.13,0-.26-.05-.35-.15-.2-.2-.2-.51,0-.71L9.65,3.65c.2-.2,.51-.2,.71,0,.2,.2,.2,.51,0,.71L2.35,12.35c-.1,.1-.23,.15-.35,.15Z" fill="currentColor"/></svg>',
    rfe = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 15"><path fill="currentColor" d="M7.56,13.88c-.28,0-.5-.22-.5-.5s.22-.5,.5-.5c2.96,0,5.38-2.41,5.38-5.38S10.53,2.12,7.56,2.12c-.28,0-.5-.22-.5-.5s.22-.5,.5-.5c3.52,0,6.38,2.86,6.38,6.38s-2.86,6.38-6.38,6.38Z"/></svg>',
    sfe = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 15"><path fill="currentColor" d="M11.41,8.41h0l1.14-.93,1.14-.93c.48-.39,.37-.74-.25-.77l-1.58-.09-2.5-.14-.41-1.05s0,0,0,0l-.53-1.38-.53-1.38c-.22-.58-.59-.58-.81,0l-1.07,2.75s0,0,0,0l-.41,1.05-2.5,.14-1.58,.09c-.62,.03-.73,.38-.25,.77l1.14,.93,1.14,.93h0l.87,.71-.57,2.15-.47,1.79c-.16,.6,.14,.81,.66,.48l2.48-1.6h0s.94-.61,.94-.61l.94,.61h0s1.24,.8,1.24,.8l1.24,.8c.52,.33,.82,.12,.66-.48l-.47-1.79-.57-2.15,.87-.71Z"/></svg>',
    ife = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M14.5,4H1.5c-.28,0-.5-.22-.5-.5s.22-.5,.5-.5H14.5c.28,0,.5,.22,.5,.5s-.22,.5-.5,.5Z" fill="currentColor"/><path d="M11.02,3.81l-.44-1.46c-.06-.21-.26-.36-.48-.36H5.9c-.22,0-.41,.14-.48,.36l-.44,1.46-.96-.29,.44-1.46c.19-.64,.77-1.07,1.44-1.07h4.2c.67,0,1.24,.43,1.44,1.07l.44,1.46-.96,.29Z" fill="currentColor"/><path d="M11.53,15H4.47c-.81,0-1.47-.64-1.5-1.45l-.34-9.87,1-.03,.34,9.87c0,.27,.23,.48,.5,.48h7.07c.27,0,.49-.21,.5-.48l.34-9.87,1,.03-.34,9.87c-.03,.81-.69,1.45-1.5,1.45Z" fill="currentColor"/><path d="M6.5,11.62c-.28,0-.5-.22-.5-.5V7.12c0-.28,.22-.5,.5-.5s.5,.22,.5,.5v4c0,.28-.22,.5-.5,.5Z" fill="currentColor"/><path d="M9.5,11.62c-.28,0-.5-.22-.5-.5V7.12c0-.28,.22-.5,.5-.5s.5,.22,.5,.5v4c0,.28-.22,.5-.5,.5Z" fill="currentColor"/></svg>',
    ofe = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9 16"><path d="M4.5,13c-.28,0-.5-.22-.5-.5V3.5c0-.28,.22-.5,.5-.5s.5,.22,.5,.5V12.5c0,.28-.22,.5-.5,.5Z" fill="currentColor"/><path d="M4.5,14c-.13,0-.26-.05-.35-.15L.65,10.35c-.2-.2-.2-.51,0-.71,.2-.2,.51-.2,.71,0l3.15,3.15,3.15-3.15c.2-.2,.51-.2,.71,0,.2,.2,.2,.51,0,.71l-3.5,3.5c-.1,.1-.23,.15-.35,.15Z" fill="currentColor"/></svg>',
    afe = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9 16"><path d="M4.5,14c-.28,0-.5-.22-.5-.5V4.5c0-.28,.22-.5,.5-.5s.5,.22,.5,.5V13.5c0,.28-.22,.5-.5,.5Z" fill="currentColor"/><path d="M8,7.5c-.13,0-.26-.05-.35-.15l-3.15-3.15L1.35,7.35c-.2,.2-.51,.2-.71,0-.2-.2-.2-.51,0-.71l3.5-3.5c.2-.2,.51-.2,.71,0l3.5,3.5c.2,.2,.2,.51,0,.71-.1,.1-.23,.15-.35,.15Z" fill="currentColor"/></svg>',
    nO = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 16"><path d="M12.5,16H2.5c-.83,0-1.5-.67-1.5-1.5V1.5c0-.83,.67-1.5,1.5-1.5h7.09c.4,0,.78,.16,1.06,.44l2.91,2.91c.28,.28,.44,.66,.44,1.06V14.5c0,.83-.67,1.5-1.5,1.5ZM2.5,1c-.28,0-.5,.22-.5,.5V14.5c0,.28,.22,.5,.5,.5H12.5c.28,0,.5-.22,.5-.5V4.41c0-.13-.05-.26-.15-.35l-2.91-2.91c-.09-.09-.22-.15-.35-.15H2.5Z" fill="currentColor"/><path d="M13.38,5h-2.91c-.81,0-1.47-.66-1.47-1.47V.62c0-.28,.22-.5,.5-.5s.5,.22,.5,.5V3.53c0,.26,.21,.47,.47,.47h2.91c.28,0,.5,.22,.5,.5s-.22,.5-.5,.5Z" fill="currentColor"/><path d="M10,13H5c-.28,0-.5-.22-.5-.5s.22-.5,.5-.5h5c.28,0,.5,.22,.5,.5s-.22,.5-.5,.5Z" fill="currentColor"/><path d="M10,10H5c-.28,0-.5-.22-.5-.5s.22-.5,.5-.5h5c.28,0,.5,.22,.5,.5s-.22,.5-.5,.5Z" fill="currentColor"/><path d="M7,7h-2c-.28,0-.5-.22-.5-.5s.22-.5,.5-.5h2c.28,0,.5,.22,.5,.5s-.22,.5-.5,.5Z" fill="currentColor"/></svg>';
const lfe = ["__key", "__init", "__shim", "__original", "__index", "__prevKey"];

function wk() {
    return Math.random().toString(36).substring(2, 15)
}

function Ai(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}

function mb(e, t, n = !0, r = ["__key"]) {
    if (e === t) return !0;
    if (typeof t == "object" && typeof e == "object") {
        if (e instanceof Map || e instanceof Set || e instanceof Date || e === null || t === null || Object.keys(e).length !== Object.keys(t).length) return !1;
        for (const s of r)
            if ((s in e || s in t) && e[s] !== t[s]) return !1;
        for (const s in e)
            if (!(s in t) || e[s] !== t[s] && !n || n && !mb(e[s], t[s], n, r)) return !1;
        return !0
    }
    return !1
}

function rO(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}

function ny(e) {
    if (rO(e) === !1 || e.__FKNode__ || e.__POJO__ === !1) return !1;
    const t = e.constructor;
    if (t === void 0) return !0;
    const n = t.prototype;
    return !(rO(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)
}

function Ek(e, t, n = !1, r = !1) {
    if (t === null) return null;
    const s = {};
    if (typeof t == "string") return t;
    for (const i in e)
        if (Ai(t, i) && (t[i] !== void 0 || !r)) {
            if (n && Array.isArray(e[i]) && Array.isArray(t[i])) {
                s[i] = e[i].concat(t[i]);
                continue
            }
            if (t[i] === void 0) continue;
            ny(e[i]) && ny(t[i]) ? s[i] = Ek(e[i], t[i], n, r) : s[i] = t[i]
        } else s[i] = e[i];
    for (const i in t) !Ai(s, i) && t[i] !== void 0 && (s[i] = t[i]);
    return s
}

function cfe(e) {
    return e.replace(/-([a-z0-9])/gi, (t, n) => n.toUpperCase())
}

function ufe(e) {
    return e.replace(/([a-z0-9])([A-Z])/g, (t, n, r) => n + "-" + r.toLowerCase()).replace(" ", "-").toLowerCase()
}

function Dh(e, t = lfe) {
    if (e === null || e instanceof RegExp || e instanceof Date || e instanceof Map || e instanceof Set || typeof File == "function" && e instanceof File) return e;
    let n;
    Array.isArray(e) ? n = e.map(r => typeof r == "object" ? Dh(r, t) : r) : n = Object.keys(e).reduce((r, s) => (r[s] = typeof e[s] == "object" ? Dh(e[s], t) : e[s], r), {});
    for (const r of t) r in e && Object.defineProperty(n, r, {
        enumerable: !1,
        value: e[r]
    });
    return n
}

function Eg(e) {
    return typeof e == "object" ? Dh(e) : e
}

function wo(e) {
    return e !== void 0 && e !== "false" && e !== !1 ? !0 : void 0
}

function Nh(e) {
    return Object.isFrozen(e) ? e : Object.defineProperty(e, "__init", {
        enumerable: !1,
        value: !0
    })
}

function lH(e) {
    return e.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().replace(/[^a-z0-9]/g, " ").trim().replace(/\s+/g, "-")
}

function cH() {
    const e = [];
    let t = 0;
    const n = s => e.push(s),
        r = s => {
            const i = e[t];
            return typeof i == "function" ? i(s, o => (t++, r(o === void 0 ? s : o))) : (t = 0, s)
        };
    return n.dispatch = r, n.unshift = s => e.unshift(s), n.remove = s => {
        const i = e.indexOf(s);
        i > -1 && e.splice(i, 1)
    }, n
}

function dfe() {
    const e = new Map,
        t = new Map;
    let n;
    const r = (s, i) => {
        if (n) {
            n.set(i.name, [s, i]);
            return
        }
        e.has(i.name) && e.get(i.name).forEach(o => {
            (i.origin === s || o.modifiers.includes("deep")) && o.listener(i)
        }), i.bubble && s.bubble(i)
    };
    return r.on = (s, i) => {
        const [o, ...a] = s.split("."), l = i.receipt || wk(), c = {
            modifiers: a,
            event: o,
            listener: i,
            receipt: l
        };
        return e.has(o) ? e.get(o).push(c) : e.set(o, [c]), t.has(l) ? t.get(l).push(o) : t.set(l, [o]), l
    }, r.off = s => {
        var i;
        t.has(s) && ((i = t.get(s)) === null || i === void 0 || i.forEach(o => {
            const a = e.get(o);
            Array.isArray(a) && e.set(o, a.filter(l => l.receipt !== s))
        }), t.delete(s))
    }, r.pause = s => {
        n || (n = new Map), s && s.walk(i => i._e.pause())
    }, r.play = s => {
        if (!n) return;
        const i = n;
        n = void 0, i.forEach(([o, a]) => r(o, a)), s && s.walk(o => o._e.play())
    }, r
}

function ffe(e, t, n, r, s = !0) {
    return t._e(e, {
        payload: r,
        name: n,
        bubble: s,
        origin: e
    }), e
}

function hfe(e, t, n) {
    return Tk(e.parent) && e.parent._e(e.parent, n), e
}

function pfe(e, t, n, r) {
    return t._e.on(n, r)
}

function mfe(e, t, n) {
    return t._e.off(n), e
}
const uH = cH();
uH((e, t) => (e.message || (e.message = String(`E${e.code}`)), t(e)));
const dH = cH();
dH((e, t) => {
    e.message || (e.message = String(`W${e.code}`));
    const n = t(e);
    return console && typeof console.warn == "function" && console.warn(n.message), n
});

function Sk(e, t = {}) {
    dH.dispatch({
        code: e,
        data: t
    })
}

function Ph(e, t = {}) {
    throw Error(uH.dispatch({
        code: e,
        data: t
    }).message)
}

function bf(e, t) {
    const n = x({
        blocking: !1,
        key: wk(),
        meta: {},
        type: "state",
        visible: !0
    }, e);
    return t && n.value && n.meta.localize !== !1 && (n.value = t.t(n), n.meta.locale = t.config.locale), n
}

function gfe(e, ...t) {
    const n = `${e.name}-set`,
        r = s => bf({
            key: lH(s),
            type: "error",
            value: s,
            meta: {
                source: n,
                autoClear: !0
            }
        });
    return t.filter(s => !!s).map(s => {
        if (typeof s == "string" && (s = [s]), Array.isArray(s)) return s.map(i => r(i)); {
            const i = {};
            for (const o in s) Array.isArray(s[o]) ? i[o] = s[o].map(a => r(a)) : i[o] = [r(s[o])];
            return i
        }
    })
}
const fH = new Map,
    L0 = new Map,
    _fe = dfe();

function yfe(e) {
    if (L0.has(e)) {
        const t = L0.get(e);
        L0.delete(e), fH.delete(t), _fe(e, {
            payload: null,
            name: t,
            bubble: !1,
            origin: e
        })
    }
}

function vfe(e) {
    return fH.get(e)
}

function sO(e, t, n) {
    let r = !0;
    return t in e.config._t ? r = !1 : e.emit(`config:${t}`, n, !1), t in e.props || (e.emit("prop", {
        prop: t,
        value: n
    }), e.emit(`prop:${t}`, n)), r
}

function bfe(e) {
    const t = document.getElementById(e);
    if (t instanceof HTMLFormElement) {
        const n = new Event("submit", {
            cancelable: !0,
            bubbles: !0
        });
        t.dispatchEvent(n);
        return
    }
    Sk(151, e)
}

function wfe(e) {
    const t = n => {
        for (const r in n.store) {
            const s = n.store[r];
            s.type === "error" || s.type === "ui" && r === "incomplete" ? n.store.remove(r) : s.type === "state" && n.store.set(G(x({}, s), {
                value: !1
            }))
        }
    };
    t(e), e.walk(t)
}

function Efe(e, t) {
    const n = typeof e == "string" ? vfe(e) : e;
    if (n) {
        const r = i => Eg(i.props.initial) || (i.type === "group" ? {} : i.type === "list" ? [] : void 0);
        n._e.pause(n), n.input(Eg(t) || r(n), !1), n.walk(i => i.input(r(i), !1));
        const s = r(n);
        return n.input(typeof s == "object" ? Eg(t) || Nh(s) : s, !1), n._e.play(n), wfe(n), n.emit("reset", n), n
    }
    Sk(152, e)
}
const Sfe = {
        delimiter: ".",
        delay: 0,
        locale: "en",
        rootClasses: e => ({
            [`formkit-${ufe(e)}`]: !0
        })
    },
    Tfe = Symbol("index"),
    g1 = Symbol("removed"),
    _1 = Symbol("moved"),
    hH = Symbol("inserted");

function $fe(e) {
    return e.type === "list" && Array.isArray(e._value)
}

function Tk(e) {
    return e && typeof e == "object" && e.__FKNode__ === !0
}
const Sg = (e, t, n) => {
    Ph(102, [e, n])
};
et(jfe, Sg, !1), et(Pfe), et(Nfe), et(Wfe, Sg, !1), et(Gfe), et(hfe), et(the), et(Rfe), et(!1), et(Dfe), et(Afe), et(Ofe), et(Cfe), et(Hfe, Vfe, !1), et(Ife), et(Ffe), et(ffe), et(Yfe), et(pfe), et(mfe), et(!1, Mfe), et(!1), et(Lfe), et(Xfe, Sg, !1), et(ehe), et(Bfe), et(gH), et(Zfe), et(Jfe), et(mH), et(zfe, !1, !1), et(Ufe);

function et(e, t, n = !0) {
    return {
        get: e ? (r, s) => n ? (...i) => e(r, s, ...i) : e(r, s) : !1,
        set: t !== void 0 ? t : Sg.bind(null)
    }
}

function kfe(e) {
    return e.type === "group" ? Nh(e.value && typeof e.value == "object" && !Array.isArray(e.value) ? e.value : {}) : e.type === "list" ? Nh(Array.isArray(e.value) ? e.value : []) : e.value
}

function Ife(e, t, n, r = !0) {
    return t._value = xfe(e, e.hook.input.dispatch(n)), e.emit("input", t._value), t.isSettled && e.disturb(), r ? (t._tmo && clearTimeout(t._tmo), t._tmo = setTimeout(ry, e.props.delay, e, t)) : ry(e, t), t.settled
}

function xfe(e, t) {
    switch (e.type) {
        case "input":
            break;
        case "group":
            (!t || typeof t != "object") && Ph(107, [e, t]);
            break;
        case "list":
            Array.isArray(t) || Ph(108, [e, t]);
            break
    }
    return t
}

function ry(e, t, n = !0, r = !0) {
    t._value = t.value = e.hook.commit.dispatch(t._value), e.type !== "input" && r && e.hydrate(), e.emit("commit", t.value), n && e.calm()
}

function pH(e, {
    name: t,
    value: n,
    from: r
}) {
    if (!Object.isFrozen(e._value)) {
        if ($fe(e)) {
            const s = n === g1 ? [] : n === _1 && typeof r == "number" ? e._value.splice(r, 1) : [n];
            e._value.splice(t, n === _1 || r === hH ? 0 : 1, ...s);
            return
        }
        n !== g1 ? e._value[t] = n : delete e._value[t]
    }
}

function Cfe(e, t) {
    const n = t._value;
    return t.children.forEach(r => {
        if (typeof n == "object")
            if (r.name in n) {
                const s = r.type !== "input" || n[r.name] && typeof n[r.name] == "object" ? Nh(n[r.name]) : n[r.name];
                r.input(s, !1)
            } else(e.type !== "list" || typeof r.name == "number") && pH(t, {
                name: r.name,
                value: r.value
            }), n.__init || (r.type === "group" ? r.input({}, !1) : r.type === "list" ? r.input([], !1) : r.input(void 0, !1))
    }), e
}

function Afe(e, t) {
    var n;
    return t._d <= 0 && (t.isSettled = !1, e.emit("settled", !1, !1), t.settled = new Promise(r => {
        t._resolve = r
    }), e.parent && ((n = e.parent) === null || n === void 0 || n.disturb())), t._d++, e
}

function Rfe(e, t, n) {
    var r;
    if (n !== void 0 && e.type !== "input") return pH(t, n), ry(e, t, !0, !1);
    t._d > 0 && t._d--, t._d === 0 && (t.isSettled = !0, e.emit("settled", !0, !1), e.parent && ((r = e.parent) === null || r === void 0 || r.calm({
        name: e.name,
        value: t.value
    })), t._resolve && t._resolve(t.value))
}

function Ofe(e, t) {
    e.emit("destroying", e), e.store.filter(() => !1), e.parent && (e.parent.emit("childRemoved", e), e.parent.remove(e)), yfe(e), t._value = t.value = void 0, e.emit("destroyed", e)
}

function Dfe(e, t, n) {
    t.type = n.type, t.props.definition = Dh(n), t.value = t._value = kfe({
        type: e.type,
        value: t.value
    }), n.forceTypeProp && (e.props.type && (e.props.originalType = e.props.type), t.props.type = n.forceTypeProp), n.family && (t.props.family = n.family), n.features && n.features.forEach(r => r(e)), n.props && e.addProps(n.props), e.emit("defined", n)
}

function Nfe(e, t, n) {
    var r;
    if (e.props.attrs) {
        const s = x({}, e.props.attrs);
        e.props._emit = !1;
        for (const o in s) {
            const a = cfe(o);
            n.includes(a) && (e.props[a] = s[o], delete s[o])
        }
        const i = Eg(t._value);
        e.props.initial = e.type !== "input" ? Nh(i) : i, e.props._emit = !0, e.props.attrs = s, e.props.definition && (e.props.definition.props = [...((r = e.props.definition) === null || r === void 0 ? void 0 : r.props) || [], ...n])
    }
    return e.emit("added-props", n), e
}

function Pfe(e, t, n, r) {
    if (e.type === "input" && Ph(100, e), n.parent && n.parent !== e && n.parent.remove(n), t.children.includes(n) || (r !== void 0 && e.type === "list" ? (t.children.splice(r, 0, n), Array.isArray(e.value) && e.value.length < t.children.length && e.disturb().calm({
            name: r,
            value: n.value,
            from: hH
        })) : t.children.push(n), n.isSettled || e.disturb()), n.parent !== e) {
        if (n.parent = e, n.parent !== e) return e.remove(n), n.parent.add(n), e
    } else n.use(e.plugins);
    return ry(e, t, !1), e.ledger.merge(n), e.emit("child", n), e
}

function Mfe(e, t, n, r) {
    return Tk(r) ? (e.parent && e.parent !== r && e.parent.remove(e), t.parent = r, e.resetConfig(), r.children.includes(e) ? e.use(r.plugins) : r.add(e), !0) : r === null ? (t.parent = null, !0) : !1
}

function Lfe(e, t, n) {
    const r = t.children.indexOf(n);
    if (r !== -1) {
        n.isSettled && e.disturb(), t.children.splice(r, 1);
        let s = wo(n.props.preserve),
            i = n.parent;
        for (; s === void 0 && i;) s = wo(i.props.preserve), i = i.parent;
        s ? e.calm() : e.calm({
            name: e.type === "list" ? r : n.name,
            value: g1
        }), n.parent = null, n.config._rmn = n
    }
    return e.ledger.unmerge(n), e
}

function Ffe(e, t, n) {
    t.children.forEach(r => n(r))
}

function Ufe(e, t, n, r = !1) {
    t.children.forEach(s => {
        (n(s) !== !1 || !r) && s.walk(n, r)
    })
}

function Bfe(e, t) {
    const n = e.parent || void 0;
    t.config = Qfe(e.config._t, n), e.walk(r => r.resetConfig())
}

function mH(e, t, n, r = !0, s = !0) {
    return Array.isArray(n) || n instanceof Set ? (n.forEach(i => mH(e, t, i)), e) : (t.plugins.has(n) || (s && typeof n.library == "function" && n.library(e), r && n(e) !== !1 && (t.plugins.add(n), e.children.forEach(i => i.use(n)))), e)
}

function Vfe(e, t, n, r) {
    if (Tk(e.parent)) {
        const s = e.parent.children,
            i = r >= s.length ? s.length - 1 : r < 0 ? 0 : r,
            o = s.indexOf(e);
        return o === -1 ? !1 : (s.splice(o, 1), s.splice(i, 0, e), e.parent.children = s, e.parent.type === "list" && e.parent.disturb().calm({
            name: i,
            value: _1,
            from: o
        }), !0)
    }
    return !1
}

function Hfe(e) {
    if (e.parent) {
        const t = [...e.parent.children].indexOf(e);
        return t === -1 ? e.parent.children.length : t
    }
    return -1
}

function jfe(e, t) {
    return t
}

function zfe(e, t) {
    var n;
    return ((n = e.parent) === null || n === void 0 ? void 0 : n.type) === "list" ? e.index : t.name !== Tfe ? t.name : e.index
}

function Wfe(e, t) {
    return t.parent ? t.parent.address.concat([e.name]) : [e.name]
}

function Gfe(e, t, n) {
    const r = typeof n == "string" ? n.split(e.config.delimiter) : n;
    if (!r.length) return;
    const s = r[0];
    let i = e.parent;
    for (i || (String(r[0]) === String(e.name) && r.shift(), i = e), s === "$parent" && r.shift(); i && r.length;) {
        const o = r.shift();
        switch (o) {
            case "$root":
                i = e.root;
                break;
            case "$parent":
                i = i.parent;
                break;
            case "$self":
                i = e;
                break;
            default:
                i = i.children.find(a => String(a.name) === String(o)) || qfe(i, o)
        }
    }
    return i || void 0
}

function qfe(e, t) {
    const n = String(t).match(/^(find)\((.*)\)$/);
    if (n) {
        const [, r, s] = n, i = s.split(",").map(o => o.trim());
        switch (r) {
            case "find":
                return e.find(i[0], i[1]);
            default:
                return
        }
    }
}

function Yfe(e, t, n, r) {
    return Kfe(e, n, r)
}

function Kfe(e, t, n = "name") {
    const r = typeof n == "string" ? i => i[n] == t : n,
        s = [e];
    for (; s.length;) {
        const i = s.shift();
        if (r(i, t)) return i;
        s.push(...i.children)
    }
}

function Xfe(e) {
    let t = e;
    for (; t.parent;) t = t.parent;
    return t
}

function Qfe(e = {}, t) {
    let n;
    return new Proxy(e, {
        get(...r) {
            const s = r[1];
            if (s === "_t") return e;
            const i = Reflect.get(...r);
            if (i !== void 0) return i;
            if (t) {
                const o = t.config[s];
                if (o !== void 0) return o
            }
            if (e.rootConfig && typeof s == "string") {
                const o = e.rootConfig[s];
                if (o !== void 0) return o
            }
            return s === "delay" && (n == null ? void 0 : n.type) === "input" ? 20 : Sfe[s]
        },
        set(...r) {
            const s = r[1],
                i = r[2];
            if (s === "_n") return n = i, e.rootConfig && e.rootConfig._add(n), !0;
            if (s === "_rmn") return e.rootConfig && e.rootConfig._rm(n), n = void 0, !0;
            if (!mb(e[s], i, !1)) {
                const o = Reflect.set(...r);
                return n && (n.emit(`config:${s}`, i, !1), sO(n, s, i), n.walk(a => sO(a, s, i), !0)), o
            }
            return !0
        }
    })
}

function Jfe(e, t, n, r = "ui") {
    const s = typeof n == "string" ? {
            key: n,
            value: n,
            type: r
        } : n,
        i = e.hook.text.dispatch(s);
    return e.emit("text", i, !1), i.value
}

function Zfe(e) {
    const t = e.name;
    do {
        if (e.props.isForm === !0) break;
        e.parent || Ph(106, t), e = e.parent
    } while (e);
    e.props.id && bfe(e.props.id)
}

function ehe(e, t, n) {
    return Efe(e, n)
}

function gH(e, t, n, r) {
    const s = `${e.name}-set`,
        i = e.hook.setErrors.dispatch({
            localErrors: n,
            childErrors: r
        });
    return gfe(e, i.localErrors, i.childErrors).forEach(o => {
        e.store.apply(o, a => a.meta.source === s)
    }), e
}

function the(e, t, n = !0, r) {
    return gH(e, t, []), n && (r = r || `${e.name}-set`, e.walk(s => {
        s.store.filter(i => !(i.type === "error" && i.meta && i.meta.source === r))
    })), e
}

function iO(e) {
    return typeof e != "string" && Ai(e, "$el")
}

function nhe(e) {
    return typeof e != "string" && Ai(e, "$cmp")
}

function rhe(e) {
    return !e || typeof e == "string" ? !1 : Ai(e, "if") && Ai(e, "then")
}

function $k(e) {
    let t = 1;
    return Array.isArray(e) ? e.map(n => typeof n == "string" || typeof n == "number" ? {
        label: String(n),
        value: String(n)
    } : (typeof n == "object" && "value" in n && typeof n.value != "string" && Object.assign(n, {
        value: `__mask_${t++}`,
        __original: n.value
    }), n)) : Object.keys(e).map(n => ({
        label: e[n],
        value: n
    }))
}

function Ru(e, t) {
    if (Array.isArray(e)) {
        for (const n of e)
            if (t == n.value) return "__original" in n ? n.__original : n.value
    }
    return t
}

function Ou(e, t) {
    return e == t ? !0 : ny(e) && ny(t) ? mb(e, t) : !1
}

function Ul(e) {
    e.hook.prop((t, n) => (t.prop === "options" && (typeof t.value == "function" ? (e.props.optionsLoader = t.value, t.value = []) : t.value = $k(t.value)), n(t)))
}
const Bl = We("outer", () => ({
        $el: "div",
        attrs: {
            key: "$id",
            "data-family": "$family || undefined",
            "data-type": "$type",
            "data-multiple": '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
            "data-disabled": "$disabled || undefined",
            "data-complete": "$state.complete || undefined",
            "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
            "data-errors": "$state.errors || undefined",
            "data-submitted": "$state.submitted || undefined",
            "data-prefix-icon": "$_rawPrefixIcon !== undefined || undefined",
            "data-suffix-icon": "$_rawSuffixIcon !== undefined || undefined",
            "data-prefix-icon-click": "$onPrefixIconClick !== undefined || undefined",
            "data-suffix-icon-click": "$onSuffixIconClick !== undefined || undefined"
        }
    }), !0),
    ta = We("inner", "div"),
    Mp = We("wrapper", "div"),
    gb = We("label", () => ({
        $el: "label",
        if: "$label",
        attrs: {
            for: "$id"
        }
    })),
    ga = We("messages", () => ({
        $el: "ul",
        if: "$defaultMessagePlacement && $fns.length($messages)"
    })),
    _a = We("message", () => ({
        $el: "li",
        for: ["message", "$messages"],
        attrs: {
            key: "$message.key",
            id: "$id + '-' + $message.key",
            "data-message-type": "$message.type"
        }
    })),
    Ri = We("prefix", null),
    Oi = We("suffix", null),
    Di = We("help", () => ({
        $el: "div",
        if: "$help",
        attrs: {
            id: '$: "help-" + $id'
        }
    })),
    _H = We("fieldset", () => ({
        $el: "fieldset",
        attrs: {
            id: "$id",
            "aria-describedby": {
                if: "$help",
                then: '$: "help-" + $id',
                else: void 0
            }
        }
    })),
    sy = We("decorator", () => ({
        $el: "span",
        attrs: {
            "aria-hidden": "true"
        }
    })),
    iy = We("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            type: "$type",
            name: "$node.props.altName || $node.name",
            disabled: "$option.attrs.disabled || $disabled",
            onInput: "$handlers.toggleChecked",
            checked: "$fns.eq($_value, $onValue)",
            onBlur: "$handlers.blur",
            value: "$: true",
            id: "$id",
            "aria-describedby": {
                if: "$options.length",
                then: {
                    if: "$option.help",
                    then: '$: "help-" + $option.attrs.id',
                    else: void 0
                },
                else: {
                    if: "$help",
                    then: '$: "help-" + $id',
                    else: void 0
                }
            }
        }
    })),
    yH = We("legend", () => ({
        $el: "legend",
        if: "$label"
    })),
    vH = We("option", () => ({
        $el: "li",
        for: ["option", "$options"],
        attrs: {
            "data-disabled": "$option.attrs.disabled || $disabled"
        }
    })),
    bH = We("options", "ul"),
    oy = We("wrapper", () => ({
        $el: "label",
        attrs: {
            "data-disabled": {
                if: "$options.length",
                then: void 0,
                else: "$disabled || undefined"
            },
            "data-checked": {
                if: "$options == undefined",
                then: "$fns.eq($_value, $onValue) || undefined",
                else: "$fns.isChecked($option.value) || undefined"
            }
        }
    })),
    wH = We("optionHelp", () => ({
        $el: "div",
        if: "$option.help",
        attrs: {
            id: '$: "help-" + $option.attrs.id'
        }
    })),
    ay = We("label", "span"),
    she = We("input", () => ({
        $el: "button",
        bind: "$attrs",
        attrs: {
            type: "$type",
            disabled: "$disabled",
            name: "$node.name",
            id: "$id"
        }
    })),
    ihe = We("default", null),
    ohe = We("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            type: "file",
            disabled: "$disabled",
            name: "$node.name",
            onChange: "$handlers.files",
            onBlur: "$handlers.blur",
            id: "$id",
            "aria-describedby": "$describedBy"
        }
    })),
    ahe = We("fileItem", () => ({
        $el: "li",
        for: ["file", "$value"]
    })),
    lhe = We("fileList", () => ({
        $el: "ul",
        if: "$value.length",
        attrs: {
            "data-has-multiple": {
                if: "$value.length > 1",
                then: "true"
            }
        }
    })),
    che = We("fileName", () => ({
        $el: "span",
        attrs: {
            class: "$classes.fileName"
        }
    })),
    oO = We("fileRemove", () => ({
        $el: "button",
        attrs: {
            onClick: "$handlers.resetFiles"
        }
    })),
    uhe = We("noFiles", () => ({
        $el: "span",
        if: "$value.length == 0"
    })),
    dhe = We("form", () => ({
        $el: "form",
        bind: "$attrs",
        attrs: {
            id: "$id",
            name: "$node.name",
            onSubmit: "$handlers.submit",
            "data-loading": "$state.loading || undefined"
        }
    }), !0),
    fhe = We("actions", () => ({
        $el: "div",
        if: "$actions"
    })),
    hhe = We("submit", () => ({
        $cmp: "FormKit",
        bind: "$submitAttrs",
        props: {
            type: "submit",
            disabled: "$disabled",
            label: "$submitLabel"
        }
    })),
    EH = We("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            type: "$type",
            disabled: "$disabled",
            name: "$node.name",
            onInput: "$handlers.DOMInput",
            onBlur: "$handlers.blur",
            value: "$_value",
            id: "$id",
            "aria-describedby": "$describedBy"
        }
    })),
    SH = We("wrapper", null, !0),
    phe = We("input", () => ({
        $el: "select",
        bind: "$attrs",
        attrs: {
            id: "$id",
            "data-placeholder": "$fns.showPlaceholder($_value, $placeholder)",
            disabled: "$disabled",
            class: "$classes.input",
            name: "$node.name",
            onChange: "$handlers.onChange",
            onInput: "$handlers.selectInput",
            onBlur: "$handlers.blur",
            "aria-describedby": "$describedBy"
        }
    })),
    mhe = We("option", () => ({
        $el: "option",
        for: ["option", "$options"],
        bind: "$option.attrs",
        attrs: {
            class: "$classes.option",
            value: "$option.value",
            selected: "$fns.isSelected($option)"
        }
    })),
    ghe = () => ({
        $el: null,
        if: "$options.length",
        for: ["option", "$options"],
        children: "$slots.option"
    }),
    _he = We("input", () => ({
        $el: "textarea",
        bind: "$attrs",
        attrs: {
            disabled: "$disabled",
            name: "$node.name",
            onInput: "$handlers.DOMInput",
            onBlur: "$handlers.blur",
            value: "$_value",
            id: "$id",
            "aria-describedby": "$describedBy"
        },
        children: "$initialValue"
    })),
    an = (e, t) => We(`${e}Icon`, () => {
        const n = `_raw${e.charAt(0).toUpperCase()}${e.slice(1)}Icon`;
        return {
            if: `$${e}Icon && $${n}`,
            $el: `${t||"span"}`,
            attrs: {
                class: `$classes.${e}Icon + " formkit-icon"`,
                innerHTML: `$${n}`,
                onClick: `$handlers.iconClick(${e})`,
                for: {
                    if: `${t==="label"}`,
                    then: "$id"
                }
            }
        }
    })();

function TH(e) {
    return function(t, n) {
        return t.prop === "options" && Array.isArray(t.value) && (t.value = t.value.map(r => {
            var s;
            return !((s = r.attrs) === null || s === void 0) && s.id ? r : Ek(r, {
                attrs: {
                    id: `${e.name}-option-${lH(String(r.value))}`
                }
            })
        }), e.props.type === "checkbox" && !Array.isArray(e.value) && (e.isCreated ? e.input([], !1) : e.on("created", () => {
            Array.isArray(e.value) || e.input([], !1)
        }))), n(t)
    }
}

function yhe(e, t) {
    const n = t.target;
    if (n instanceof HTMLInputElement) {
        const r = Array.isArray(e.props.options) ? Ru(e.props.options, n.value) : n.value;
        Array.isArray(e.props.options) && e.props.options.length ? Array.isArray(e._value) ? e._value.some(s => Ou(r, s)) ? e.input(e._value.filter(s => !Ou(r, s))) : e.input([...e._value, r]) : e.input([r]) : n.checked ? e.input(e.props.onValue) : e.input(e.props.offValue)
    }
}

function vhe(e, t) {
    var n, r;
    return (n = e.context) === null || n === void 0 || n.value, (r = e.context) === null || r === void 0 || r._value, Array.isArray(e._value) ? e._value.some(s => Ou(Ru(e.props.options, t), s)) : !1
}

function bhe(e) {
    e.on("created", () => {
        var t, n;
        !((t = e.context) === null || t === void 0) && t.handlers && (e.context.handlers.toggleChecked = yhe.bind(null, e)), !((n = e.context) === null || n === void 0) && n.fns && (e.context.fns.isChecked = vhe.bind(null, e)), Ai(e.props, "onValue") || (e.props.onValue = !0), Ai(e.props, "offValue") || (e.props.offValue = !1)
    }), e.hook.prop(TH(e))
}

function _b(e) {
    e.on("created", () => {
        e.props.disabled = wo(e.props.disabled)
    }), e.hook.prop(({
        prop: t,
        value: n
    }, r) => (n = t === "disabled" ? wo(n) : n, r({
        prop: t,
        value: n
    }))), e.on("prop:disabled", ({
        payload: t
    }) => {
        e.config.disabled = wo(t)
    }), e.on("created", () => {
        e.config.disabled = wo(e.props.disabled)
    })
}

function Dt(e, t) {
    return n => {
        n.store.set(bf({
            key: e,
            type: "ui",
            value: t || e,
            meta: {
                localize: !0,
                i18nArgs: [n]
            }
        }))
    }
}
const aO = typeof window != "undefined";

function $H(e) {
    e.target instanceof HTMLElement && e.target.hasAttribute("data-file-hover") && e.target.removeAttribute("data-file-hover")
}

function lO(e, t) {
    t.target instanceof HTMLInputElement ? e === "dragover" && t.target.setAttribute("data-file-hover", "true") : t.preventDefault(), e === "drop" && $H(t)
}

function whe(e) {
    Dt("noFiles", "Select file")(e), Dt("removeAll", "Remove all")(e), Dt("remove")(e), aO && (window._FormKit_File_Drop || (window.addEventListener("dragover", lO.bind(null, "dragover")), window.addEventListener("drop", lO.bind(null, "drop")), window.addEventListener("dragleave", $H), window._FormKit_File_Drop = !0)), e.hook.input((t, n) => n(Array.isArray(t) ? t : [])), e.on("created", () => {
        Array.isArray(e.value) || e.input([], !1), e.context && (e.context.handlers.resetFiles = t => {
            if (t.preventDefault(), e.input([]), e.props.id && aO) {
                const n = document.getElementById(e.props.id);
                n && (n.value = "")
            }
        }, e.context.handlers.files = t => {
            var n, r;
            const s = [];
            if (t.target instanceof HTMLInputElement && t.target.files) {
                for (let i = 0; i < t.target.files.length; i++) {
                    let o;
                    (o = t.target.files.item(i)) && s.push({
                        name: o.name,
                        file: o
                    })
                }
                e.input(s)
            }
            e.context && (e.context.files = s), typeof((n = e.props.attrs) === null || n === void 0 ? void 0 : n.onChange) == "function" && ((r = e.props.attrs) === null || r === void 0 || r.onChange(t))
        })
    })
}
async function Ehe(e, t) {
    if (t.preventDefault(), await e.settled, e.walk(n => {
            n.store.set(bf({
                key: "submitted",
                value: !0,
                visible: !1
            }))
        }), typeof e.props.onSubmitRaw == "function" && e.props.onSubmitRaw(t, e), e.ledger.value("blocking")) typeof e.props.onSubmitInvalid == "function" && e.props.onSubmitInvalid(e), e.props.incompleteMessage !== !1 && e.store.set(bf({
        blocking: !1,
        key: "incomplete",
        meta: {
            localize: e.props.incompleteMessage === void 0,
            i18nArgs: [{
                node: e
            }],
            showAsMessage: !0
        },
        type: "ui",
        value: e.props.incompleteMessage || "Form incomplete."
    }));
    else if (typeof e.props.onSubmit == "function") {
        const n = e.props.onSubmit(e.hook.submit.dispatch(Dh(e.value)), e);
        if (n instanceof Promise) {
            const r = e.props.disabled === void 0 && e.props.submitBehavior !== "live";
            r && (e.props.disabled = !0), e.store.set(bf({
                key: "loading",
                value: !0,
                visible: !1
            })), await n, r && (e.props.disabled = !1), e.store.remove("loading")
        }
    } else t.target instanceof HTMLFormElement && t.target.submit()
}

function She(e) {
    e.props.isForm = !0, e.on("created", () => {
        var t;
        !((t = e.context) === null || t === void 0) && t.handlers && (e.context.handlers.submit = Ehe.bind(null, e)), Ai(e.props, "actions") || (e.props.actions = !0)
    }), e.on("settled:blocking", () => e.store.remove("incomplete"))
}

function The(e) {
    e.props.ignore === void 0 && (e.props.ignore = !0, e.parent = null)
}

function $he(e) {
    e.on("created", () => {
        e.context && (e.context.initialValue = e.value || "")
    })
}

function khe(e, t) {
    t.target instanceof HTMLInputElement && e.input(Ru(e.props.options, t.target.value))
}

function Ihe(e, t) {
    var n, r;
    return (n = e.context) === null || n === void 0 || n.value, (r = e.context) === null || r === void 0 || r._value, Ou(Ru(e.props.options, t), e._value)
}

function xhe(e) {
    e.on("created", () => {
        var t, n;
        Array.isArray(e.props.options) || Sk(350, e), !((t = e.context) === null || t === void 0) && t.handlers && (e.context.handlers.toggleChecked = khe.bind(null, e)), !((n = e.context) === null || n === void 0) && n.fns && (e.context.fns.isChecked = Ihe.bind(null, e))
    }), e.hook.prop(TH(e))
}

function Che(e, t) {
    e.context && e.context.value;
    const n = "__original" in t ? t.__original : t.value;

    function r() {
        return !e.props.options.some(s => ("__original" in s ? s.__original : s.value) === null)
    }
    return Array.isArray(e._value) ? e._value.some(s => Ou(s, n)) : (e._value === void 0 || e._value === null && r()) && t.attrs && t.attrs["data-is-placeholder"] ? !0 : Ou(n, e._value)
}
async function Ahe(e, t) {
    var n;
    typeof((n = e.props.attrs) === null || n === void 0 ? void 0 : n.onChange) == "function" && (await new Promise(r => setTimeout(r, 0)), await e.settled, e.props.attrs.onChange(t))
}

function Rhe(e, t) {
    const n = t.target,
        r = n.hasAttribute("multiple") ? Array.from(n.selectedOptions).map(s => Ru(e.props.options, s.value)) : Ru(e.props.options, n.value);
    e.input(r)
}

function cO(e, t) {
    return e.some(n => n.attrs && n.attrs["data-is-placeholder"]) ? e : [{
        label: t,
        value: "",
        attrs: {
            hidden: !0,
            disabled: !0,
            "data-is-placeholder": "true"
        }
    }, ...e]
}

function Ohe(e) {
    e.on("created", () => {
        var t, n, r;
        const s = wo((t = e.props.attrs) === null || t === void 0 ? void 0 : t.multiple);
        !s && e.props.placeholder && Array.isArray(e.props.options) && (e.hook.prop(({
            prop: i,
            value: o
        }, a) => (i === "options" && (o = cO(o, e.props.placeholder)), a({
            prop: i,
            value: o
        }))), e.props.options = cO(e.props.options, e.props.placeholder)), s ? e.value === void 0 && e.input([], !1) : e.context && !e.context.options && (e.props.attrs = Object.assign({}, e.props.attrs, {
            value: e._value
        }), e.on("input", ({
            payload: i
        }) => {
            e.props.attrs = Object.assign({}, e.props.attrs, {
                value: i
            })
        })), !((n = e.context) === null || n === void 0) && n.handlers && (e.context.handlers.selectInput = Rhe.bind(null, e), e.context.handlers.onChange = Ahe.bind(null, e)), !((r = e.context) === null || r === void 0) && r.fns && (e.context.fns.isSelected = Che.bind(null, e), e.context.fns.showPlaceholder = (i, o) => {
            if (!Array.isArray(e.props.options)) return !1;
            const a = e.props.options.some(l => {
                if (l.attrs && "data-is-placeholder" in l.attrs) return !1;
                const c = "__original" in l ? l.__original : l.value;
                return mb(i, c)
            });
            return o && !a ? !0 : void 0
        })
    }), e.hook.input((t, n) => {
        var r, s, i;
        return !e.props.placeholder && t === void 0 && Array.isArray((r = e.props) === null || r === void 0 ? void 0 : r.options) && e.props.options.length && !wo((i = (s = e.props) === null || s === void 0 ? void 0 : s.attrs) === null || i === void 0 ? void 0 : i.multiple) && (t = "__original" in e.props.options[0] ? e.props.options[0].__original : e.props.options[0].value), n(t)
    })
}

function tt(e, t) {
    return n => {
        n.props[`${e}Icon`] === void 0 && (n.props[`${e}Icon`] = `default:${t}`)
    }
}

function Mh(e) {
    return typeof e == "object" && ("$el" in e || "$cmp" in e || "$formkit" in e)
}

function ly(e) {
    return !!(rhe(e) && e.if && e.if.startsWith("$slots.") && typeof e.then == "string" && e.then.startsWith("$slots.") && "else" in e)
}

function Fa(e, t = {}) {
    return typeof e == "string" ? Mh(t) || typeof t == "string" ? t : e : Array.isArray(e) ? Mh(t) ? t : e : Ek(e, t)
}

function We(e, t, n = !1) {
    return (...r) => {
        const s = i => {
            const o = !t || typeof t == "string" ? {
                $el: t
            } : t();
            return (iO(o) || nhe(o)) && (o.meta || (o.meta = {
                section: e
            }), r.length && !o.children && (o.children = [...r.map(a => typeof a == "string" ? a : a(i))]), iO(o) && (o.attrs = x({
                class: `$classes.${e}`
            }, o.attrs || {}))), {
                if: `$slots.${e}`,
                then: `$slots.${e}`,
                else: e in i ? Fa(o, i[e]) : o
            }
        };
        return s._s = e, n ? kH(s) : s
    }
}

function kH(e) {
    return t => [e(t)]
}

function ls(e, t, n) {
    const r = s => {
        const i = t(s);
        if (n || Mh(i) && "if" in i || ly(i)) {
            const o = {
                if: e,
                then: i
            };
            return n && (o.else = n(s)), o
        } else ly(i) ? Object.assign(i.else, {
            if: e
        }) : Mh(i) && Object.assign(i, {
            if: e
        });
        return i
    };
    return r._s = wk(), r
}

function Tg(e, t) {
    const n = r => {
        const s = e({});
        return ly(s) ? (Array.isArray(s.else) || (s.else = Fa(Fa(s.else, t), e._s ? r[e._s] : {})), s) : Fa(Fa(s, t), e._s ? r[e._s] : {})
    };
    return n._s = e._s, n
}

function Dhe(e) {
    return kH(e)
}
Bl(ga(_a("$message.value")), Mp(she(an("prefix"), Ri(), ihe("$label || $ui.submit.value"), Oi(), an("suffix"))), Di("$help")), Dt("submit");
Bl(ls("$options == undefined", oy(ta(Ri(), iy(), sy(an("decorator")), Oi()), Tg(ay("$label"), {
    if: "$label"
})), _H(yH("$label"), Di("$help"), bH(vH(oy(ta(Ri(), Tg(iy(), {
    bind: "$option.attrs",
    attrs: {
        id: "$option.attrs.id",
        value: "$option.value",
        checked: "$fns.isChecked($option.value)"
    }
}), sy(an("decorator")), Oi()), Tg(ay("$option.label"), {
    if: "$option.label"
})), wH("$option.help"))))), ls("$options == undefined && $help", Di("$help")), ga(_a("$message.value"))), tt("decorator", "checkboxDecorator");
Bl(Mp(gb("$label"), ta(an("prefix", "label"), Ri(), ohe(), lhe(ahe(an("fileItem"), che("$file.name"), ls("$value.length === 1", oO(an("fileRemove"), "$ui.remove.value")))), ls("$value.length > 1", oO("$ui.removeAll.value")), uhe(an("noFiles"), "$ui.noFiles.value"), Oi(), an("suffix"))), Di("$help"), ga(_a("$message.value"))), tt("fileItem", "fileItem"), tt("fileRemove", "fileRemove"), tt("noFiles", "noFiles");
dhe("$slots.default", ga(_a("$message.value")), fhe(hhe()));
SH("$slots.default");
Dhe(EH());
SH("$slots.default");
Bl(ls("$options == undefined", oy(ta(Ri(), iy(), sy(an("decorator")), Oi()), ls("$label", ay("$label"))), _H(yH("$label"), Di("$help"), bH(vH(oy(ta(Ri(), Tg(iy(), {
    bind: "$option.attrs",
    attrs: {
        id: "$option.attrs.id",
        value: "$option.value",
        checked: "$fns.isChecked($option.value)"
    }
}), sy(an("decorator")), Oi()), ls("$option.label", ay("$option.label"))), wH("$option.help"))))), ls("$options === undefined && $help", Di("$help")), ga(_a("$message.value"))), tt("decorator", "radioDecorator");
Bl(Mp(gb("$label"), ta(an("prefix"), Ri(), phe(ls("$slots.default", () => "$slots.default", ls("$slots.option", ghe, mhe("$option.label")))), ls("$attrs.multiple !== undefined", () => "", an("select")), Oi(), an("suffix"))), Di("$help"), ga(_a("$message.value"))), tt("select", "select");
Bl(Mp(gb("$label"), ta(an("prefix", "label"), Ri(), _he(), Oi(), an("suffix"))), Di("$help"), ga(_a("$message.value")));
Bl(Mp(gb("$label"), ta(an("prefix", "label"), Ri(), EH(), Oi(), an("suffix"))), Di("$help"), ga(_a("$message.value")));

function Nhe(e, t) {
    e in Ig || (Ig[e] = {
        timer: 0,
        inputs: new Set
    });
    const n = Ig[e];
    clearTimeout(n.timer), n.inputs.add(t), n.timer = Fk(Phe.bind(null, e), 500)
}

function Phe(e) {
    if (cj) {
        window.addEventListener(Rpe(), o => {
            const a = new URL(o.blockedURI).hostname;
            k1.some((l, c) => MO(c) === a) && (uO(e), console.warn("[FormKit]: Enterprise license required for restrictive CSP."))
        });
        let t = 0;
        const n = _i(xpe),
            r = "://",
            s = new Date().getDate(),
            i = async () => {
                Dpe(e);
                const o = Array.from(Ig[e].inputs),
                    a = o.filter(l => !(yd[e] && yd[e].has(l))).join("");
                if (a) {
                    t++;
                    try {
                        const l = await window[_i(Ape)](`${n}${r}${MO((s+t)%k1.length)}/${function(u){const d=Math.round(9*Math.random());let f="";for(let h=0;h<u.length;h++){let p=u.charCodeAt(h);p>=48&&p<=57?p=48+(p+d)%58%48:p>=97&&p<=122&&(p=97+(p+d)%123%97),f+=String.fromCharCode(p)}return`
                                $ {
                                    d
                                }
                                $ {
                                    f
                                }
                                `}(`
                                $ {
                                    e.substring(3)
                                }
                                x$ {
                                    a
                                }
                                `)}`),
                            c = await l.json();
                        if (c[_i(Cpe)]) return uO(e, c.schema);
                        if (l.ok) return yd[e] || (yd[e] = new Set), void o.forEach(u => yd[e].add(u))
                    } catch {}
                    t < 2 && Fk(i, 1e4 * Math.random())
                }
            };
        i()
    }
}

function uO(e, t) {
    hy.add(e),
        function(n, r) {
            Sf[n] && Sf[n].forEach(s => s(r))
        }(e, t)
}

function dO(e, t, n) {
    if (Nhe(t, n), !t) throw new Error("FormKitNoKey");
    return fy[t] || (fy[t] = Fk(() => hy.add(t), 3e3)), hy.has(t) ? null : e
}

function Po(e, t) {
    return new Array(e).fill("").map((n, r) => t(r))
}

function IH(e) {
    const t = e && ml(e) && e.__v_raw;
    return t ? IH(t) : e
}

function Ws(e, t) {
    if (cj) {
        const n = document.getElementById(e);
        if (n) return t(n);
        const r = new MutationObserver(() => {
            const s = document.getElementById(e);
            s && (r.disconnect(), t(s))
        });
        r.observe(document.body, {
            childList: !0,
            subtree: !0
        })
    }
}

function y1(e) {
    return Bs(e) && "value" in e && "label" in e
}

function kk(e) {
    return e ? e.reduce((t, n) => {
        var r;
        return ((r = t.at(-1)) === null || r === void 0 ? void 0 : r.type) === n.type ? t.at(-1).value += n.value : t.push({
            type: n.type,
            value: n.value
        }), t
    }, []) : []
}

function Mhe(e, t, n, r) {
    return (...s) => i => o => {
        const a = function(l, c, u, d, f, h) {
            const p = h[u],
                m = typeof d == "function" ? d() : {
                    $el: d
                },
                g = f.map(b => typeof b == "string" ? b : b(c)(h));
            let y = g.length && m ? Fa(m, {
                children: g
            }) : m;
            if (y = Fa(y, p), typeof y == "object") {
                let b = y;
                if (!Sh(y) && !Th(y) || y.meta || (y.meta = {
                        section: u,
                        node: d
                    }), Sh(y)) {
                    const _ = y,
                        {
                            $el: w
                        } = _,
                        T = Gr(_, ["$el"]);
                    T.attrs ? "class" in T.attrs || "if" in T.attrs || (T.attrs = x({
                        class: `$classes.${u}`
                    }, T.attrs)) : T.attrs = {
                        class: `$classes.${u}`
                    }, b = F0(c, u, Object.defineProperty(T, "$el", {
                        enumerable: !1,
                        get: dO.bind(null, w, c, l)
                    }))
                } else if (Th(y)) {
                    const E = y,
                        {
                            $cmp: w
                        } = E,
                        T = Gr(E, ["$cmp"]);
                    b = F0(c, u, Object.defineProperty(T, "$cmp", {
                        enumerable: !1,
                        get: dO.bind(null, w, c, l)
                    }))
                } else "$formkit" in y && (y.outerClass = `$classes.${u}`);
                return b
            }
            return F0(c, u, y)
        }(e, i, t, n, s, o);
        return r && Bs(a) && (a.memo = e + JSON.stringify(o)), r ? [a] : a
    }
}

function F0(e, t, n) {
    const r = s => e ? s || `$slots.${t}` : null;
    return Object.defineProperties({}, {
        if: {
            enumerable: !1,
            get: r
        },
        then: {
            enumerable: !1,
            get: r
        },
        else: {
            enumerable: !1,
            get: r.bind(null, n)
        }
    })
}

function Hi(e) {
    return (t, n, r = !1) => Mhe(e, t, n, r)
}

function ji(e) {
    return {
        outer: e("outer", Npe, !0),
        wrapper: e("wrapper", "div", !1),
        inner: e("inner", Ppe, !1),
        icon: I1,
        label: e("label", Mpe, !1),
        prefix: e("prefix", UO, !1),
        suffix: e("suffix", UO, !1),
        help: e("help", Upe, !1),
        messages: e("messages", Lpe, !1),
        message: e("message", Fpe, !1)
    }
}

function xH(e) {
    return {
        overlayPlaceholder: e("overlayPlaceholder", Bpe),
        overlayLiteral: e("overlayLiteral", Vpe),
        overlayChar: e("overlayChar", Hpe),
        overlayEnum: e("overlayEnum", jpe),
        overlay: e("overlay", zpe),
        overlayParts: e("overlayParts", Gpe),
        overlayInner: e("overlayInner", Wpe)
    }
}

function Mt(e, t, n) {
    return r => s => {
        const i = typeof t == "string" ? t : t(r)(s);
        return n ? {
            if: e,
            then: i,
            else: typeof n == "string" ? n : n(r)(s)
        } : (ly(i) ? Object.assign(i.else, {
            if: e
        }) : Mh(i) && Object.assign(i, {
            if: e
        }), i)
    }
}

function de(e) {
    return "__original" in e ? e.__original : e.value
}

function zc(e, t = !0) {
    e.store.set(dj), e.props.loadingCounter++, e.store.set(Nn({
        key: "hasNextPage",
        type: "state",
        value: !1,
        visible: !1
    }));
    const n = e.props.nonceKey && e.props[e.props.nonceKey],
        r = e.props.optionsLoader(e.context, uj.get(e)),
        s = e.props.applyLoadedOptions.bind(null, e, t);
    return (r instanceof Promise ? r.then((...i) => {
        e.props.nonceKey !== void 0 && n !== e.props[e.props.nonceKey] || s(...i)
    }) : Promise.resolve(s(r))).finally(() => {
        e.props.loadingCounter--
    })
}

function CH(e, t, n) {
    const r = $k(n),
        s = [...r, ...[...e.props.options].reverse()].find(i => {
            var o;
            return !(!((o = i.attrs) === null || o === void 0) && o.disabled)
        });
    e.props.options = e.props.options.concat(r), t && s && (e.props.activeValue = de(s))
}

function Lhe(e, t) {
    new MutationObserver(() => {
        const n = e.props.positionListBox(t);
        Uh.delete(e), AH(e, n);
        let r, s = null;
        const i = new ResizeObserver(() => {
            clearTimeout(r), r = setTimeout(() => {
                e.props.styleWrapper(), e.props.positionListBox(t), s || (s = e.on("prop:expanded", () => {
                    i.disconnect(), e.off(s)
                }))
            }, 100)
        });
        i.observe(t)
    }).observe(t, {
        childList: !0,
        subtree: !0
    })
}

function AH(e, t) {
    if (!e.props.expanded || !e.props.options || !e.props.options.length || Uh.has(e)) return;
    const n = e.props.options.reduce((s, i, o) => {
            var a;
            if (!((a = i.attrs) === null || a === void 0) && a.disabled) return s;
            const l = document.getElementById(`${e.props.id}_listitem_${o}`);
            return l && s.push([l, i]), s
        }, []),
        r = document.getElementById(`${e.props.id}_load_more`);
    r && n.push([r, e.props.loadMoreOption]), Uh.add(e), n.length && RH(e, n, t)
}

function Fhe(e, t) {
    let n = null;
    if (e.props.activeDescendant && (n = e.props.options.filter(i => {
            var o;
            return !(!((o = i.attrs) === null || o === void 0) && o.disabled)
        }).findIndex(i => Qe(e.value, de(i))), n === -1 && (n = null), document.getElementById(e.props.activeDescendant) && OH(e)), typeof window == "undefined") return n;
    const r = t.getBoundingClientRect(),
        s = document.getElementById(`${e.props.id}`);
    if (s) {
        const i = s.getBoundingClientRect();
        i.top + i.height + r.height > window.innerHeight && i.top + i.height > r.height ? e.props.dropdownWrapperStyles = G(x({}, e.props.dropdownWrapperStyles), {
            top: "auto",
            bottom: "100%"
        }) : e.props.dropdownWrapperStyles = G(x({}, e.props.dropdownWrapperStyles), {
            bottom: "auto",
            top: "100%"
        })
    }
    return n
}

function Uhe() {}

function RH(e, t, n) {
    var r, s, i;
    const o = document.getElementById(`${e.props.id}_dropdown_wrapper`);
    if (e.props.trackHover) {
        const a = o ? o.getBoundingClientRect() : {
            top: 0,
            bottom: 0
        };
        if (n = null, e.props.mouseY > a.top && e.props.mouseY < a.bottom) {
            let l = n || 0,
                c = n;
            const u = (d, f) => {
                var h;
                const p = f[0],
                    {
                        y: m,
                        height: g,
                        x: y,
                        width: _
                    } = p.getBoundingClientRect();
                if (e.props.mouseX > y && e.props.mouseX < y + _ && e.props.mouseY > m && e.props.mouseY < m + g) {
                    n = d;
                    const E = f[1];
                    return e.props.activeValue = E && !(!((h = E.attrs) === null || h === void 0) && h.disabled) ? de(E) : void 0, !0
                }
                return !1
            };
            do {
                if (l !== null && u(l, t[l]) || c !== null && u(c, t[c])) break;
                l !== null && (l++, l > t.length - 1 && (l = null)), c !== null && (c--, c < 0 && (c = null))
            } while (l !== null || c !== null)
        }
        n === null && (e.props.activeValue = void 0)
    }
    e.props.trackHover || OH(e), e.props.expanded ? (o && e.props.loadOnScroll && !(!((r = e.store.loading) === null || r === void 0) && r.value) && ((s = e.store.hasNextPage) === null || s === void 0 ? void 0 : s.value) && o.scrollTop + o.offsetHeight > o.scrollHeight - 200 && (e.props.allowAppendOptions = !0, (i = e.context) === null || i === void 0 || i.handlers.loadMore(!1)), Uh.has(e) ? requestAnimationFrame(RH.bind(null, e, t, n)) : AH(e, n)) : Uh.delete(e)
}

function OH(e) {
    const t = document.getElementById(`${e.props.id}_dropdown_wrapper`),
        n = document.getElementById(e.props.activeDescendant);
    if (!t || !n) return;
    const {
        y: r,
        height: s
    } = n.getBoundingClientRect(), {
        y: i,
        height: o
    } = t.getBoundingClientRect();
    r < i ? (e.props.ignoreScroll = !0, t.scrollTop = n.offsetTop) : r + s > i + o && (e.props.ignoreScroll = !0, t.scrollTop = n.offsetTop + s - o)
}

function DH(e, t) {
    e.props.page++, uj.set(e, t), e.store.set(Nn({
        key: "hasNextPage",
        type: "state",
        value: !0,
        visible: !1
    }))
}

function NH(e) {
    e.props.didLoadMore = !0, setTimeout(() => {
        e.props.didLoadMore = !1
    }, 300), zc(e)
}

function Ik(...e) {
    return t => {
        t.addProps(["activeDescendant", "activeValue", "dropdownWrapperStyles", "emptyMessage", "expanded", "forceExpanded", "hasNextPage", "isLoadingOption", "listboxStyles", "loadMoreOption", "loadOnScroll", "option", "optionLoader", "options", "optionsLoader", "page", "placeholder", "selections", "showEmptyMessage"]), t.props.dropdownWrapperStyles = {
            position: "absolute",
            top: "100%",
            overflow: "auto",
            minWidth: "100%"
        }, t.props.page = 1, t.props.loadMoreOption = {
            label: "Load more",
            value: Xr
        }, t.props.listboxStyles = {}, t.props.styleWrapper = Uhe.bind(null, t), t.props.positionListBox = Fhe.bind(null, t), t.props.hasNextPage = DH.bind(null, t), t.props.applyLoadedOptions = CH, t.props.loadingCounter = 0, t.props.optionsLoader || !t.props.options || t.props.options.length || t.props.disabled !== void 0 || t.props.emptyMessage !== void 0 || (t.props.disabled = !0), t.props.disabled = Ye(t.props.disabled), t.on("created", () => {
            if (!t.context) return;
            t.props.trackHover = !0, t.props.loadOnScroll = Ye(t.props.loadOnScroll), t.props.forceExpanded = Ye(t.props.forceExpanded), t.props.forceExpanded && (t.props.expanded = !0), t.context.touch = () => {
                var s;
                (s = t.context) === null || s === void 0 || s._value
            }, t.context.handlers.loadMoreSelected = s => {
                var i, o;
                t.props.allowAppendOptions = !0, (i = t.context) === null || i === void 0 || i.handlers.loadMore(t), s instanceof MouseEvent && (t.props.ignoreClickAway = !0, (o = document.getElementById(`${t.props.id}`)) === null || o === void 0 || o.focus())
            }, t.context.handlers.loadMore = NH.bind(null, t), t.context.handlers.click = s => {
                t.props.disabled || (document.getElementById(`${t.props.id}`) && s.pointerType !== "mouse" ? (t.props.mouseX = -1, t.props.mouseY = -1) : (t.props.mouseX = s.clientX, t.props.mouseY = s.clientY), t.emit("click", s))
            };
            const r = t.context.handlers.blur;
            t.context.handlers.blur = s => {
                t.props.expanded ? setTimeout(() => r(s), 300) : r(s), t.emit("blur")
            }, t.context.handlers.keydown = s => {
                t.props.disabled || (t.props.trackHover = !1, t.emit("keydown", s))
            }, t.context.handlers.selectOption = s => () => {
                t.props.ignoreFocus = !0, t.emit("optionSelected", s)
            }, t.context.fns.isActive = s => Qe(t.props.activeValue, de(s)) || void 0, G0 && (Ws(`${t.props.id}_dropdown_wrapper`, s => {
                t.props.behavior !== "overscroll" && getComputedStyle(s).maxHeight === "none" && (t.props.dropdownWrapperStyles = G(x({}, t.props.dropdownWrapperStyles), {
                    maxHeight: "400px"
                }))
            }), Ws(`${t.props.id}_dropdown_wrapper`, Lhe.bind(null, t)))
        }), t.on("prop:expanded", ({
            payload: r
        }) => {
            t.props.dropdownWrapperStyles = G(x({}, t.props.dropdownWrapperStyles), {
                zIndex: r || t.props.forceExpanded ? "999" : "-1",
                pointerEvents: r ? "auto" : "none"
            })
        });
        const n = () => {
            t.props.ignoreScroll ? t.props.ignoreScroll = !1 : t.props.trackHover = !0
        };
        if (t.on("prop:trackHover", ({
                payload: r
            }) => {
                var s, i;
                G0 && (r ? (i = document.getElementById(`${t.props.id}_dropdown_wrapper`)) === null || i === void 0 || i.removeEventListener("scroll", n) : (s = document.getElementById(`${t.props.id}_dropdown_wrapper`)) === null || s === void 0 || s.addEventListener("scroll", n))
            }), t.on("prop:activeValue", ({
                payload: r
            }) => {
                if (r === Xr) return void(t.props.activeDescendant = `${t.props.id}_load_more`);
                const s = t.props.options.findIndex(i => Qe(de(i), r));
                t.props.activeDescendant = s >= 0 ? `${t.props.id}_listitem_${s}` : void 0
            }), typeof window != "undefined") {
            const r = i => {
                    i.target && i.target instanceof Element && (i.target.id === t.props.id && t.props.searchValue || i.target.closest(`#${t.props.id}_listbox`)) || t.props.ignoreClickAway ? t.props.ignoreClickAway = !1 : (t._value || (t.props.searchValue = ""), t.props.expanded = !1)
                },
                s = i => {
                    t.props.mouseX = i.clientX, t.props.mouseY = i.clientY;
                    const o = document.getElementById(`${t.props.id}_dropdown_wrapper`);
                    if (o) {
                        const a = o.getBoundingClientRect();
                        i.clientX > a.x && i.clientX < a.x + a.width && i.clientY > a.y && i.clientY < a.y + a.height && (t.props.trackHover = !0)
                    }
                };
            t.on("prop:expanded", ({
                payload: i
            }) => {
                i ? (setTimeout(() => document.addEventListener("click", r), 10), t.props.styleWrapper(), document.addEventListener("mousemove", s), t.props.optionsLoader && t.props.options.length === 0 && zc(t)) : (document.removeEventListener("click", r), document.removeEventListener("mousemove", s))
            })
        }
        t.on("prop:loadingCounter", ({
            payload: r
        }) => {
            r === 0 && t.store.set(py)
        }), t.on("prop:options", ({
            payload: r
        }) => {
            t.props.disabled = r.length === 0 && !t.props.emptyMessage && !t.props.optionsLoader && !t.props.searchValue
        }), G0 && window.addEventListener("blur", r => {
            r.target === window && t.props.expanded && (t.props.expanded = !1)
        }), e.map(r => r(t))
    }
}

function v1(e, t, n) {
    const r = e.props.optionLoader(t, n),
        s = o => typeof o == "string" ? {
            label: o,
            value: t
        } : y1(o) ? o : Bs(o) ? Object.assign({
            label: String(t),
            value: t
        }, o) : {
            label: String(t),
            value: t
        },
        i = o => (Array.isArray(e.props.memoOptions) && e.props.memoOptions.push(o), o);
    return r instanceof Promise ? (e.props.type === "transferlist" && (e.props.targetLoading = !0), e.props.loadingCounter++, e.store.set(dj), Lp(e), r.then(o => {
        if (typeof o == "string" || y1(o)) return i(s(o))
    }).finally(() => {
        e.props.targetLoading = !1, e.props.loadingCounter--
    })) : i(s(r))
}

function xk(e, t) {
    return n => {
        n.on("commit", ({
            payload: r
        }) => {
            if (r === q0.get(n) && q0.get(n) !== void 0) return;
            if (q0.set(n, Array.isArray(r) ? [...r] : r), BO && r !== void 0 && typeof n.props.optionLoader == "function") {
                const i = e(n, r);
                if (n.props.multiple && Array.isArray(r))
                    if (r.forEach(o => {
                            v1(n, o, Array.isArray(i) && i.find(a => Qe(de(a), o)))
                        }), n.props.loadingCounter) {
                        n.props.isLoadingOption = !0;
                        const o = n.on("prop:loadingCounter", () => {
                            n.props.loadingCounter || (n.props.isLoadingOption = !1, t(n, e(n, r)), n.off(o))
                        })
                    } else t(n, e(n, r));
                else if (!n.props.multiple && !Array.isArray(i) && r) {
                    const o = v1(n, r, i);
                    o instanceof Promise ? (n.props.isLoadingOption = !0, o.then(a => {
                        t(n, a, r), n.props.isLoadingOption = !1
                    })) : t(n, o, r)
                }
                return
            }
            const s = e(n, r);
            if (!BO || s || r === void 0 || n.props.options && n.props.options.length || typeof n.props.optionsLoader != "function") t(n, s, r);
            else {
                const i = zc(n);
                t(n), i.then(() => {
                    t(n, e(n, r), r)
                })
            }
        })
    }
}

function b1(e, t) {
    const n = Array.isArray(e.props.options) ? e.props.options : [],
        r = (Array.isArray(e.props.memoOptions) ? e.props.memoOptions : []).concat(n);
    return !!r.length && (e.props.multiple ? !!Array.isArray(e.value) && e.value.reduce((s, i) => {
        const o = r.find(a => Qe(i, de(a)));
        return o && s.push(o), s
    }, []) : r.find(s => Qe(de(s), t)) || !1)
}

function Ck(e) {
    if (!e.props.options || !e.props.options.length) return;
    const t = function(n) {
        return n.props.options.find(r => Qe(de(r), n.value))
    }(e);
    if (t) e.props.activeValue = t.value;
    else {
        const n = e.props.options.find(r => {
            var s;
            return !(!((s = r == null ? void 0 : r.attrs) === null || s === void 0) && s.disabled)
        });
        e.props.activeValue = n == null ? void 0 : n.value
    }
}

function Lp(e, t, n) {
    var r;
    if (e.props.multiple && Array.isArray(t)) return e.props.option = {
        label: t.map(s => s.label).join(", "),
        value: e.value
    }, void(e.props.selections = t);
    typeof t == "string" ? e.props.option = {
        label: t,
        value: n
    } : t ? e.props.option = t : t || n == null || ((r = e.store.loading) === null || r === void 0 ? void 0 : r.value) ? (e.props.option = {
        label: e.props.placeholder || "\xA0",
        value: void 0,
        isPlaceholder: !0
    }, e.props.selections = []) : e.props.option = {
        label: n,
        value: n
    }, e.props.option.isPlaceholder || (e.props.selections = [e.props.option])
}

function Ak(e) {
    e.on("keydown", ({
        payload: t
    }) => {
        var n, r;
        if (t.key === "Tab" && e.props.expanded) t.preventDefault();
        else if (["ArrowDown", "ArrowUp"].includes(t.key) && e.props.expanded) {
            t.preventDefault(), t.stopPropagation();
            const s = e.props.options;
            if (!Array.isArray(s) || !s.length) return;
            const i = s.reduce((a, l) => {
                var c;
                return !((c = l == null ? void 0 : l.attrs) === null || c === void 0) && c.disabled || a.push(de(l)), a
            }, []);
            !((n = e.store.hasNextPage) === null || n === void 0) && n.value && i.push(Xr);
            const o = i.indexOf(e.props.activeValue);
            o === -1 && i.length ? e.props.activeValue = i[0] : t.key === "ArrowDown" && i.length > o + 1 ? e.props.activeValue = i[o + 1] : t.key === "ArrowUp" && o > 0 && (e.props.activeValue = i[o - 1])
        } else if (!e.props.expanded && ["ArrowDown", "Up", "Down", "ArrowUp", "Enter"].includes(t.key) && e.props.id === ((r = document.activeElement) === null || r === void 0 ? void 0 : r.id)) {
            if (e.props.multiple && e.props.max && Array.isArray(e.value) && e.value.length >= e.props.max) return;
            t.preventDefault(), !e.props.expanded && e.isSettled && (e.props.expanded = !0)
        } else if (t.key === "Enter" && e.props.expanded && e.props.type !== "taglist") {
            if (t.preventDefault(), t.stopPropagation(), e.props.activeValue === Xr) return void e.emit("optionSelected", e.props.loadMoreOption);
            const s = e.props.options.find(i => Qe(de(i), e.props.activeValue));
            s && e.emit("optionSelected", s)
        } else ["Esc", "Escape"].includes(t.key) ? (t.preventDefault(), e.props.expanded = !1) : e.emit("unusedKeyDown", t)
    })
}

function PH(e) {
    e.on("created", () => {
        e.context && (e.context.fns.isSelected = t => Qe(e.value, de(t)))
    }), e.on("prop:expanded", ({
        payload: t
    }) => {
        t && Ck(e)
    }), e.on("optionSelected", ({
        payload: t
    }) => {
        var n, r, s;
        de(t) !== Xr ? !((r = t == null ? void 0 : t.attrs) === null || r === void 0) && r.disabled || (e.props.skipNextFilter = !0, e.input(de(t)), e.props.expanded = !1, e.props.id && ((s = document.getElementById(e.props.id)) === null || s === void 0 || s.focus())) : (n = e.context) === null || n === void 0 || n.handlers.loadMore()
    })
}

function Rk(e) {
    const t = e("dropdownWrapper", () => ({
            $el: "div",
            attrs: {
                id: '$id + "_dropdown_wrapper"',
                "data-is-wrapper": !0,
                style: "$dropdownWrapperStyles",
                onScroll: "$handlers.scroll"
            }
        })),
        n = e("listbox", () => ({
            $el: "ul",
            if: "$expanded || $forceExpanded",
            attrs: {
                style: "$listboxStyles",
                id: '$id + "_listbox"',
                role: "listbox",
                "aria-activedescendant": "$activeDescendant"
            }
        })),
        r = e("listitem", () => ({
            $el: "li",
            for: ["option", "index", "$options"],
            bind: "$option.attrs",
            attrs: {
                id: '$id + "_listitem_" + $index',
                "data-disabled": "$option.attrs.disabled",
                "data-value": "$option.value",
                key: "$option.value",
                onClick: "$handlers.selectOption($option)",
                role: "option",
                "aria-selected": "$fns.isSelected($option)",
                "data-is-active": "$fns.isActive($option)"
            }
        })),
        s = e("loadMore", () => ({
            $el: "li",
            if: "$state.loading || $state.hasNextPage",
            attrs: {
                id: '$id + "_load_more"',
                key: "loadMore",
                role: "option",
                onClick: "$handlers.loadMoreSelected",
                "aria-selected": "false",
                "data-is-active": "$fns.isActive($loadMoreOption)"
            }
        })),
        i = e("loadMoreInner", "span"),
        o = e("emptyMessage", () => ({
            $el: "li",
            if: "$showEmptyMessage && $state.loading !== true",
            attrs: {
                id: '$id + "_empty_message"',
                key: "$emptyMessage",
                role: "presentation"
            }
        })),
        a = e("emptyMessageInner", "span"),
        l = e("option", () => ({
            $el: "div",
            attrs: {
                "data-checked": "$fns.isSelected($option)"
            }
        }));
    return () => t(n(o(a("$emptyMessage")), r(Mt("$fns.isSelected($option)", I1("selected")), l("$option.label")), s(i(Mt("$state.loading", I1("loader")), "$state.loading && $ui.isLoading.value || $ui.loadMore.value"))))
}

function Bhe(e) {
    if (typeof window == "undefined") return;
    const t = document.getElementById(`${e.props.id}_dropdown_wrapper`),
        n = document.getElementById(`${e.props.id}`);
    if (!n || !t) return;
    const r = t.style.paddingTop,
        s = t.style.paddingBottom,
        i = t.style.paddingLeft;
    t.style.paddingTop = "0", t.style.paddingBottom = "0", t.style.paddingLeft = "0";
    const o = n.getBoundingClientRect(),
        a = t.getBoundingClientRect(),
        l = Math.round(o.top - a.top) + "px",
        c = Math.round(o.left - a.left - 5) + "px",
        u = Math.max(Math.round(Math.min(a.height - a.top, window.innerHeight) - (o.top + o.height)), 0) + "px";
    t.style.paddingTop = r, t.style.paddingBottom = s, t.style.paddingLeft = i, e.props.dropdownWrapperStyles = G(x({}, e.props.dropdownWrapperStyles), {
        paddingTop: l,
        paddingLeft: c,
        paddingBottom: u
    }), e.props.listboxStyles = G(x({}, e.props.listboxStyles), {
        minWidth: e.props.behavior === "overscroll" ? `min(${o.width+"px"}, calc(100vw - 4em))` : o.width + "px",
        maxWidth: "calc(100vw - 4em)"
    })
}

function Vhe(e, t) {
    let n = null;
    if (e.props.activeDescendant) {
        const r = document.getElementById(e.props.activeDescendant);
        if (!r) return n;
        e.props.ignoreScroll = !0;
        const s = document.getElementById(`${e.props.id}_listbox`);
        if (!s) return n;
        const i = t.getBoundingClientRect(),
            o = s.getBoundingClientRect(),
            a = parseInt(getComputedStyle(t).paddingTop),
            l = parseInt(getComputedStyle(t).paddingBottom),
            c = r.offsetTop - a,
            u = Math.max(c - a, 0),
            d = Math.max(t.scrollHeight - l - c - i.height, 0),
            f = o.height - u - d;
        t.scrollTop = c;
        const h = () => {
                t.scrollTop = d > 0 ? d < a ? t.scrollHeight : a : u < l ? 0 : c - l
            },
            p = Math.min(150, o.height);
        u > 0 && d > 0 || u === 0 && d === 0 || f > p ? t.scrollTop = c : h(), t.clientHeight / 2 < t.scrollTop && (n = e.props.options.filter(m => {
            var g;
            return !(!((g = m.attrs) === null || g === void 0) && g.disabled)
        }).findIndex(m => Qe(e.value, de(m)))), n === -1 && (n = null)
    }
    return n
}

function Hhe(e) {
    return e.props.type === "radio" && (e.props.altName = `${e.name}_${Xme++}`), !0
}

function MH(e) {
    return !ml(e) || "__key" in e || "__shim" in e || Object.defineProperty(e, "__key", {
        enumerable: !1,
        writable: !0,
        value: ha()
    }), e
}

function jhe({
    payload: e
}) {
    if (e.props.min = e.props.min !== void 0 ? Number(e.props.min) : 1, e.props.max = e.props.max !== void 0 ? Number(e.props.max) : 1 / 0, e.props.min > e.props.max) throw Error("Repeater: min must be less than max");
    if (e.props.disabled = Ye(e.props.disabled), Array.isArray(e.value))
        if (e.value.length < e.props.min) {
            const t = Po(e.props.min - e.value.length, () => ({}));
            e.input(e.value.concat(t), !1)
        } else e.value.length > e.props.max && e.input(e.value.slice(0, e.props.max), !1);
    else e.input(Po(e.props.min, () => ({})), !1);
    e.context && (e.context.fns.createRemover = t => () => {
        var n, r;
        (n = Ro(t)) === null || n === void 0 || n.each(s => s.destroy()), (r = Ro(t)) === null || r === void 0 || r.destroy()
    }, e.context.fns.createInsert = t => () => {
        if (Array.isArray(e.value)) {
            const n = e.value.findIndex(s => s.__key === t),
                r = e.value;
            r.splice(n + 1, 0, {}), e.input(r, !1)
        }
    }, e.context.fns.createShift = (t, n) => () => {
        const r = Ro(t);
        if (!r || !r.parent) return;
        const s = r.index + n;
        s >= 0 && s < r.parent.children.length && (r.index = r.index + n)
    }, e.context.fns.createAppend = () => () => {
        if (Array.isArray(e.value)) {
            const t = e.value;
            t.push({}), e.input(t, !1)
        }
    })
}

function fO(e, t) {
    const n = e._c.children.find(r => r.props.id === t);
    n && (n.props.preserve = !0, n.destroy())
}

function zhe(e, t, n, r) {
    if (Array.isArray(e)) {
        const s = function(i, o) {
            const a = i.map(l => l.__key);
            return o.children.reduce((l, c, u) => {
                const d = c.props.id;
                return d && !a.includes(d) && l.set(u, d), l
            }, new Map)
        }(e, t);
        e.forEach((i, o) => {
            MH(i);
            const [a, l] = function(c, u, d, f, h) {
                if (!d.has(c.__key) && !c.__shim && !Object.isFrozen(c)) {
                    const p = h && h.get(u);
                    c.__key = ha();
                    const m = Object.freeze(Object.defineProperties({}, {
                        __key: {
                            value: c.__key
                        },
                        __original: {
                            value: c
                        },
                        __index: {
                            value: u
                        },
                        __prevKey: {
                            value: p
                        }
                    }));
                    return d.add(c.__key), f.value++, [!0, m]
                }
                return [!1, c]
            }(i, o, n, r, s);
            a && (e.splice(o, 1, l), fO(t, l.__prevKey), s.delete(o))
        }), s.size && s.forEach(i => {
            const o = e.findIndex(a => a.__key === i);
            o !== -1 && e.splice(o, 1), fO(t, i)
        }), Uk.delete(t)
    }
    return e
}

function hO(e, t) {
    t.sort((n, r) => "__shim" in n || "__shim" in r ? "__shim" in r && !("__shim" in n) ? -1 : 1 : "__index" in n && "__index" in r ? n.__index > r.__index ? 1 : -1 : 0), e._c.children.sort((n, r) => {
        const s = t.findIndex(o => o.__key === n.props.id),
            i = t.findIndex(o => o.__key === r.props.id);
        return s !== -1 && i !== -1 ? s > i ? 1 : -1 : s === -1 && i == -1 ? 0 : s > -1 ? 1 : -1
    })
}

function Whe(e, t) {
    return t.type === "group" && t.hook.input((n, r) => (n === void 0 ? n = {
        __shim: !0
    } : (MH(n), e.has(n.__key) || n.__shim || !t.parent || Uk.add(t.parent)), r(n))), !1
}

function ba(e, t, n) {
    e.props[t] === void 0 && (e.props[t] = n)
}

function Ghe(e, t) {
    var n;
    if (!e.props.disabled && t.currentTarget instanceof HTMLElement) {
        let r;
        t instanceof MouseEvent ? r = t.clientX : (r = t.changedTouches[0].clientX, document.documentElement.style.overflow = e.props.initialBodyOverflow);
        let s = LH(e, r, t.currentTarget) || 0;
        s = s > e.props.min ? s : e.props.min, s = s < e.props.max ? s : e.props.max, e.input(s), (n = document.getElementById(`${e.props.id}`)) === null || n === void 0 || n.focus()
    }
}

function qhe(e, t) {
    !e.props.disabled && t.currentTarget instanceof HTMLElement && Ok(e, LH(e, (window.TouchEvent && t instanceof TouchEvent || !1) && t instanceof TouchEvent ? t.touches[0].clientX : t instanceof MouseEvent ? t.clientX : 0, t.currentTarget) || 0)
}

function Yhe(e) {
    Ok(e)
}

function LH(e, t, n) {
    const r = n.getBoundingClientRect();
    return function(s, i) {
        const o = 1 / (i || 1);
        return Math.ceil(s * o) / o
    }((t - r.x) / r.width * e.props.max, e.props.step)
}

function U0(e) {
    setTimeout(() => {
        const t = document.getElementById(`${e.props.id}`);
        t && (e.props.wrapperWidth = `0 0 ${t.offsetWidth/e.props.max}px`)
    })
}

function Ok(e, t) {
    let n = 0;
    n = t ? Math.round(t / e.props.max * 100) : typeof e._value == "number" ? Math.round(e._value / e.props.max * 100) : 0;
    const r = 100 - n;
    e.props.onWidth = n, e.props.offWidth = r
}

function FH(e, t, n) {
    if (e.props.allowAppendOptions) return e.props.allowAppendOptions = !1, CH(e, t, n);
    const r = $k(n);
    e.props.options = r, e.props.options.length || (e.store.set(py), e.store.set(Nn({
        key: "hasNextPage",
        type: "state",
        value: !1,
        visible: !1
    }))), Ck(e), fj.set(e, e.props.searchValue)
}

function Khe(e) {
    var t;
    e.props.max && e.props.multiple && Array.isArray(e._value) && e._value.length >= e.props.max || e.props.disabled || !e.props.optionsLoader && !e.props.options.length || (e.props.expanded = !e.props.expanded, e.props.expanded && ((t = document.getElementById(`${e.props.id}`)) === null || t === void 0 || t.focus()))
}

function $g(e, t, n = !0) {
    return () => {
        e.props.multiple ? (e.emit("optionRemoved", t), e.props.searchValue = "") : (e.input(void 0), e.props.searchValue = ""), n && setTimeout(() => {
            var r;
            e.props.openOnClick && (e.props.skipExpand = !0), (r = document.getElementById(`${e.props.id}`)) === null || r === void 0 || r.focus()
        }, 50)
    }
}

function B0(e, t = !1) {
    if (typeof e.props.optionsLoader == "function") {
        if (t && (e.props.options = []), e.props.search = e.props.searchValue, clearTimeout(HO.get(e)), e.props.skipNextFilter) return void(e.props.skipNextFilter = !1);
        HO.set(e, setTimeout(() => {
            var n;
            e.props.page = 1, (n = e.context) === null || n === void 0 || n.handlers.loadMore(!0)
        }, e.props.debounce || 200))
    } else Array.isArray(e.props.options) && (x1.add(e), typeof e.props.searchValue == "string" && (e.props.options = e.props.initialOptions.filter(n => e.props.filter(n, e.props.searchValue, e)), e.props.options.length || e.props.emptyMessage || (e.props.expanded = !1)));
    e.props.skipNextFilter = !1, Ck(e)
}

function UH(e, t) {
    var n;
    const r = e.props.highlightedRange,
        s = r.index,
        i = r.start + (s ? 1 : 0),
        o = t.length - 1 > s ? t[t.length - 1].end - t[s + 1].start : 0;
    return [i, ((n = e.props.inputText) === null || n === void 0 ? void 0 : n.length) - o + (t.length - 1 > r.index ? -1 : 0)]
}

function Xhe(e, t) {
    const n = document.getElementById(`${e.props.id}`);
    if (n instanceof HTMLInputElement) {
        const r = C1.get(e);
        if (r) {
            const [s, i] = r, o = t.touches[0].clientX - i;
            n.scrollLeft = s - o
        } else C1.set(e, [n.scrollLeft, t.changedTouches[0].clientX])
    }
}

function Qhe(e) {
    C1.delete(e)
}

function Jhe(e) {
    setTimeout(() => {
        document.activeElement && document.activeElement.id === e.props.id || document.activeElement && document.activeElement.id === `${e.props.id}_listbox_button` || e.props.expanded && (e.props.expanded = !1)
    }, 300)
}

function Zhe(e, t) {
    const n = t.target;
    e.props.expanded = !(!e.props.optionsLoader && !e.props.options.length && !e.props.emptyMessage), e.props.searchValue = n.value, e.props.searchValue === "" && (e.props.options && !e.props.options.length && (e.props.expanded = !1), e.input(void 0))
}

function epe(e, t) {
    const n = t.target;
    e.props.expanded = !(!e.props.optionsLoader && !e.props.options.length && !e.props.emptyMessage);
    const r = n.value;
    e.props.inputText = r, e.props.inputText === "" && e.props.options && !e.props.options.length ? e.props.expanded = !1 : e.props.expanded = !0, e.props.selectionAppearance !== "option" ? r === "" ? (e.props.searchValue = null, e.input([])) : !e._value || Array.isArray(e._value) && !e._value.length ? e.props.searchValue = r : Array.isArray(e._value) && e._value.length && (e.props.searchValue = function(s) {
        var i;
        const o = cy(s);
        if (s.props.highlightedRange) {
            const [a, l] = UH(s, o);
            return s.props.inputText.slice(a, l)
        }
        return s.props.inputText.slice(((i = o[o.length - 1]) === null || i === void 0 ? void 0 : i.end) + 2)
    }(e)) : e.props.searchValue = r
}

function cy(e) {
    const t = e.props.getSelections(e, e._value);
    return Array.isArray(t) && t.length ? t.reduce((n, r, s) => {
        var i;
        const o = ((i = n[s - 1]) === null || i === void 0 ? void 0 : i.end) || 0;
        let a = 0;
        return t.length - 1 !== s && a++, s !== 0 && a++, n.push({
            option: r,
            index: s,
            start: o,
            end: o + r.label.length + a
        }), n
    }, []) : []
}

function pO(e) {
    clearTimeout(jO.get(e)), jO.set(e, setTimeout(() => {
        var t, n, r;
        const s = document.getElementById(`${e.props.id}`);
        if (s instanceof HTMLInputElement) {
            const i = cy(e),
                o = i.findIndex(l => s.selectionStart !== null ? s.selectionStart >= l.start && s.selectionStart <= l.end : s.selectionEnd !== null && s.selectionEnd >= l.start && s.selectionEnd <= l.end),
                a = (t = i[i.length - 1]) === null || t === void 0 ? void 0 : t.end;
            if (s.selectionStart === 0 && s.selectionEnd === ((n = e.props.inputText) === null || n === void 0 ? void 0 : n.length)) return;
            if (typeof e.props.searchValue == "string" && e.props.highlightedRange) {
                if (i.length) {
                    const l = e.props.highlightedRange,
                        [c, u] = UH(e, i);
                    if (s.selectionEnd !== null && (s.selectionEnd < c || s.selectionEnd > u)) {
                        const d = l.end - l.start - (u - c),
                            f = s.selectionEnd;
                        e.props.inputText = e.props.option.label, e.props.highlightedRange = void 0, e.props.searchValue = null, s.value = e.props.inputText, s.selectionStart = s.selectionEnd = f + (f > c ? d : 0)
                    }
                }
            } else if (o >= 0 && s.selectionStart !== null && (a !== ((r = e.props.inputText) === null || r === void 0 ? void 0 : r.length) || s.selectionStart < a)) {
                const l = i[o],
                    c = e.props.inputText.substr(0, a),
                    u = l.start + (l.index > 0 ? 1 : 0),
                    d = l.end + (i.length - 1 > l.index ? -1 : 0);
                c !== e.props.inputText && (e.props.inputText = c, s.value = c), e.props.highlightedRange = l, s.selectionStart = u, s.selectionEnd = d
            } else e.props.highlightedRange = void 0, e.emit("scrollToEnd");
            if (s.selectionStart !== null && s.selectionStart >= a && e.props.inputText.substring(a, a + 2) !== ", " && e.props.searchValue === null) {
                let l = e.props.inputText.substring(0, a);
                l = e.props.multiple && e.props.max && Array.isArray(e._value) && e._value.length >= e.props.max ? l : `${l},`, e.props.inputText = `${l} ${e.props.inputText.substring(a).replace(/^[,\s]{1,2}/,"")}`
            }
        }
    }, 5))
}

function tpe(e) {
    e.on("prop:option", () => {
        if (Array.isArray(e._value) && e._value.length >= Number(e.props.max)) {
            const t = document.getElementById(`${e.props.id}`);
            t && t.blur()
        }
    }), e.props.selectionAppearance === "option" ? (e.on("prop:option", () => {
        e.props.inputText = "", e.props.searchValue !== void 0 && (e.props.searchValue = null)
    }), e.on("blur", () => {
        e.props.inputText = ""
    }), e.on("optionSelected", ({
        payload: t
    }) => {
        t.value !== Xr && (e.props.closeOnSelect !== !1 && (e.props.expanded = !1), e.props.searchValue = "")
    })) : function(t) {
        t.props.searchValue = null;
        const n = (s, i = !1) => {
            var o;
            const a = document.getElementById(`${t.props.id}`);
            if (!(a instanceof HTMLInputElement)) return !1;
            const l = cy(t),
                c = s >= 0 ? s : l.length - 1;
            if (l[c] === void 0) return !1;
            const u = (o = l[c]) === null || o === void 0 ? void 0 : o.end;
            return a.selectionStart !== null && (!i || a.selectionStart >= u && a.selectionStart <= u + 2) && (a.selectionStart = l[c].start + (c > 0 ? 1 : 0), a.selectionEnd = l[c].end + (c < l.length - 1 ? -1 : 0), !0)
        };
        let r;
        t.on("selectRange", ({
            payload: s
        }) => n(...s)), t.on("keydown", ({
            payload: s
        }) => {
            var i, o, a, l;
            if (["ArrowRight", "ArrowLeft"].includes(s.key) && s.target instanceof HTMLInputElement && s.target.selectionEnd !== null && s.target.selectionStart !== null) {
                if (s.target.selectionStart === 0 && s.target.selectionEnd === ((i = t.props.inputText) === null || i === void 0 ? void 0 : i.length)) s.key === "ArrowLeft" ? n(0) : n(-1);
                else if (!t.props.searchValue) {
                    t.props.searchValue = null;
                    const c = cy(t),
                        u = (o = c[c.length - 1]) === null || o === void 0 ? void 0 : o.end;
                    s.target.selectionStart < u && (s.target.selectionStart = Math.max(0, s.key === "ArrowLeft" ? s.target.selectionStart - 2 : s.target.selectionEnd + 2))
                }
            } else ["Delete", "Backspace"].includes(s.key) ? t.props.highlightedRange && !t.props.searchValue ? t.emit("optionRemoved", t.props.highlightedRange.option) : s.target instanceof HTMLInputElement && (t.props.searchValue = null, n(-1, !0) && s.preventDefault()) : s.target instanceof HTMLInputElement && s.target.selectionStart === 0 && s.target.selectionEnd === ((a = t.props.inputText) === null || a === void 0 ? void 0 : a.length) && ((l = t.props.inputText) === null || l === void 0 ? void 0 : l.length) && t.props.selections.length === 0 && s.preventDefault();
            s.key === "ArrowLeft" && n(-1, !0) && s.preventDefault(), pO(t)
        }), t.on("prop:highlightedRange", ({
            payload: s
        }) => {
            t.props.hasHighlightedRange = !!s, s && t.props.expanded && r !== s.option && (r = s.option, t.props.activeValue = de(s.option))
        }), t.on("scrollToEnd", () => {
            const s = document.getElementById(`${t.props.id}`);
            s && s.scrollTo({
                left: s.scrollWidth,
                behavior: "smooth"
            })
        }), t.on("prop:option", ({
            payload: s
        }) => {
            if (!s.isPlaceholder) {
                let i = "";
                if (zO) {
                    const o = document.getElementById(`${t.props.id}`);
                    if (document.activeElement === o && Array.isArray(t._value) && t._value.length) {
                        if (t.props.max && t._value.length >= Number(t.props.max)) return;
                        i = ", "
                    }
                }
                t.props.closeOnSelect !== !1 && (t.props.expanded = !1), t.props.inputText = s.label + i
            }
        }), t.on("blur", () => {
            if (t._value) {
                const s = t.props.option;
                Bs(s) && s.value !== void 0 ? t.props.inputText = s.label : t.props.inputText = ""
            } else t.props.inputText = ""
        })
    }(e), e.on("commit", () => {
        e.props.searchValue !== void 0 && (e.props.searchValue = null)
    }), e.on("created", () => {
        if (e.props.selectionAppearance !== "option" && function(t) {
                Ws(`${t.props.id}`, n => {
                    n instanceof HTMLInputElement && Y0.set(n, t)
                }), zO && !WO && (WO = !0, document.addEventListener("selectionchange", () => {
                    if (document.activeElement instanceof HTMLInputElement && Y0.has(document.activeElement)) {
                        const n = Y0.get(document.activeElement);
                        n && pO(n)
                    }
                }))
            }(e), e.props.option && Array.isArray(e.props.option.value))
            for (const t of e.props.option.value) e.props.initialOptions.find(n => {
                de(n) === t && e.props.memoOptions.push(n)
            });
        e.context && (e.context.handlers.input = epe.bind(null, e))
    }), e.on("optionRemoved", async ({
        payload: t
    }) => {
        if (Array.isArray(e._value)) {
            let n = -1;
            await e.input(e._value.filter((r, s) => r !== de(t) && !Qe(r, de(t)) || (n = s, !1))), e._value.length ? setTimeout(() => e.emit("selectRange", [n]), 20) : e.props.expanded = !1
        }
    }), e.on("prop:expanded", ({
        payload: t
    }) => {
        t || (e.props.searchValue = "")
    })
}

function BH(e) {
    return t => {
        let n;
        t.addProps(["inputText", "selectionAppearance", "searchValue", "openOnClick", "filteredOptions", "search", "debounce", "showInput", "visibilityStyles", "selectionStyles", "multiple", "filter", "hasHighlightedRange"]), t.props.memoOptions = [], t.props.initialOptions = t.props.options, t.props.applyLoadedOptions = FH, t.props.getSelections = e, t.props.nonceKey = "searchValue", t.props.multiple = Ye(t.props.multiple), t.props.selectionAppearance = t.props.selectionAppearance === "option" ? "option" : "text-input", typeof t.props.filter != "function" && (t.props.filter = (r, s) => r.label.toLowerCase().includes(s.toLowerCase())), t.props.selectionStyles = {
            position: "absolute",
            pointerEvents: "none",
            width: "100%",
            left: "0",
            top: "0",
            bottom: "0",
            opacity: "0",
            overflow: "hidden"
        }, t.props.multiple ? (t.addProps(["max", "closeOnSelect"]), function(r) {
            function s(i) {
                return !!Array.isArray(r.value) && r.value.some(o => Qe(o, de(i)))
            }
            r.on("created", () => {
                r.context && (r.context.fns.isSelected = s)
            }), r.on("optionSelected", ({
                payload: i
            }) => {
                var o, a, l;
                if (de(i) === Xr) return void((o = r.context) === null || o === void 0 || o.handlers.loadMore());
                if (!((a = i == null ? void 0 : i.attrs) === null || a === void 0) && a.disabled) return;
                const c = Array.isArray(r._value) ? r._value : [];
                s(i) ? r.emit("optionRemoved", i) : (r.props.memoOptions = [...r.props.memoOptions, i], r.props.highlightedRange ? (c.splice(r.props.highlightedRange.index, 1, de(i)), r.input(c), r.props.highlightedRange = void 0, r.props.expanded = !1) : (r.input(c.concat(de(i))), r.emit("scrollToEnd"))), r.props.id && ((l = document.getElementById(r.props.id)) === null || l === void 0 || l.focus())
            })
        }(t), tpe(t)) : (PH(t), function(r) {
            r.props.searchValue = "", r.on("created", () => {
                r.context && (r.context.handlers.input = Zhe.bind(null, r))
            }), r.on("input", ({
                payload: s
            }) => {
                const i = r.props.getSelections(r, s);
                r.props.searchValue = i && (i == null ? void 0 : i.label) || r.props.searchValue, r.props.selectionStyles = G(x({}, r.props.selectionStyles), {
                    opacity: s === void 0 ? "0" : "1",
                    pointerEvents: s === void 0 ? "none" : "auto"
                })
            }), r.on("optionSelected", ({
                payload: s
            }) => {
                s.value !== Xr && (r.props.expanded = !1)
            }), r.on("prop:option", ({
                payload: s
            }) => {
                Bs(s) && !s.isPlaceholder ? r.props.searchValue = s.label : s.isPlaceholder && (r.props.searchValue = "")
            }), r.on("blur", () => {
                setTimeout(() => {
                    var s;
                    if (r.props.didLoadMore) return r.props.didLoadMore = !1, void((s = document.getElementById(`${r.props.id}`)) === null || s === void 0 || s.focus());
                    if (r._value) {
                        const i = r.props.option;
                        Bs(i) && i.value !== void 0 ? r.props.searchValue = i.label : r.props.searchValue = ""
                    } else r.props.searchValue = ""
                }, 150)
            })
        }(t)), t.on("prop:options", ({
            payload: r
        }) => {
            r && r.length ? t.props.showEmptyMessage = !1 : r && !r.length && t.props.searchValue && t.props.emptyMessage && (t.props.showEmptyMessage = !0), typeof t.props.optionsLoader != "function" && (x1.has(t) ? x1.delete(t) : (t.props.initialOptions = [...r], setTimeout(() => B0(t), 0)))
        }), t.on("click", () => {
            t.props.openOnClick && (t.props.trackHover = !1, t.props.ignoreClickAway = !0, t.props.expanded = !0)
        }), t.on("focus", () => {
            if (t.props.ignoreFocus) t.props.ignoreFocus = !1;
            else if (t.props.openOnClick) {
                if (t.props.trackHover = !1, t.props.ignoreClickAway = !0, t.props.skipExpand) return void(t.props.skipExpand = !1);
                t.props.expanded = !0
            }
        }), t.on("created", () => {
            t.props.openOnClick = Ye(t.props.openOnClick), t.context && (t.context.handlers.toggleListbox = Khe.bind(null, t), t.context.handlers.removeSelection = $g.bind(null, t), t.context.handlers.touchmove = Xhe.bind(null, t), t.context.handlers.touchend = Qhe.bind(null, t), t.context.handlers.focusOut = Jhe.bind(null, t), t.context.handlers.focus = () => {
                if (t.emit("focus"), document && t.props.multiple && t.props.selectionAppearance !== "option") {
                    const r = new Event("selectionchange");
                    document.dispatchEvent(r)
                }
            })
        }), t.on("keydown", ({
            payload: r
        }) => {
            t.props.selectionAppearance !== "option" || !t._value || t.props.isLoadingOption || t.props.multiple || (["Backspace", "Delete"].includes(r.key) || r.key !== "Tab") && r.preventDefault()
        }), t.on("prop:expanded", ({
            payload: r
        }) => {
            r && t.props.searchValue ? B0(t) : r || fj.delete(t)
        }), t.on("prop:searchValue", ({
            payload: r
        }) => {
            t.props.multiple || (t.props.inputText = r), !r && !n || (r !== n && B0(t), n !== null && r === null && t.props.closeOnSelect !== !1 && (t.props.expanded = !1), n = r)
        })
    }
}

function mO(e, t = [], n, r) {
    function s(u) {
        if (u.currentTarget && u.currentTarget instanceof HTMLElement && u instanceof DragEvent && u.dataTransfer) {
            u.dataTransfer.dropEffect = "move";
            const d = u.currentTarget.parentNode;
            if (!d) return;
            const f = Lm.get(d),
                h = u.currentTarget;
            h.id = "dropZone";
            const p = d.children;
            if (p && p instanceof HTMLCollection) {
                for (let g = 0; g < p.length; g++)
                    if (p[g] instanceof HTMLElement) {
                        const y = p[g];
                        if (r && !r(y)) continue;
                        to.set(y, {
                            value: f[g],
                            index: g
                        })
                    }
            }
            const m = to.get(h);
            l = m.index, c = m.value, setTimeout(function() {
                const g = document.getElementById("dropZone");
                g && g.classList.add("dropZone")
            }, 1)
        }
    }

    function i(u) {
        if (u.preventDefault(), u instanceof DragEvent && u.relatedTarget !== u.currentTarget && u.currentTarget && u.currentTarget instanceof HTMLElement) {
            const d = to.get(u.currentTarget),
                f = d.index,
                h = u.currentTarget;
            if (c === d.value) return;
            const p = document.getElementById("dropZone");
            h && e && p && (f < l ? e.insertBefore(p, h) : e.insertBefore(p, h.nextSibling), l = f, c = d.value)
        }
    }

    function o() {
        const u = document.getElementById("dropZone"),
            d = u == null ? void 0 : u.parentNode;
        if (d && e === d && (d.removeEventListener("drop", o), u && u.parentNode)) {
            u.classList.remove("dropZone"), u.removeAttribute("id");
            const f = [],
                h = d.children;
            if (h && h instanceof HTMLCollection) {
                for (let p = 0; p < h.length; p++)
                    if (h[p] instanceof HTMLElement) {
                        const m = h[p];
                        if (r && !r(m)) continue;
                        const g = to.get(m);
                        f.push(g.value)
                    }
                Lm.set(d, f), n && n(f)
            }
        }
    }

    function a(u) {
        u.preventDefault(), o()
    }
    let l = 0,
        c = null;
    if (GO.has(e)) Lm.set(e, t), e.addEventListener("drop", o);
    else {
        new MutationObserver(function() {
            const h = e,
                p = [];
            for (let m = 0; m < h.children.length; m++) {
                const g = h.children[m];
                (r && r(g) || !r) && p.push(g)
            }
            p.forEach((m, g) => {
                const y = to.get(m);
                t && (y ? to.set(m, {
                    value: y.value,
                    index: g
                }) : to.set(m, {
                    value: t[g],
                    index: g
                })), m.setAttribute("draggable", "true"), m.setAttribute("tabindex", "0"), m.addEventListener("dragstart", s), m.addEventListener("dragend", a), m.addEventListener("dragenter", i)
            })
        }).observe(e, {
            childList: !0
        }), e.addEventListener("drop", o), document.addEventListener("drop", o), GO.add(e);
        const d = [];
        for (let h = 0; h < e.children.length; h++) {
            const p = e.children[h];
            (r && r(p) || !r) && d.push(p)
        }
        const f = [];
        for (let h = 0; h < d.length; h++) d[h].setAttribute("draggable", "true"), d[h].setAttribute("tabindex", "0"), d[h].addEventListener("dragstart", s), d[h].addEventListener("dragend", a), d[h].addEventListener("dragenter", i), to.set(d[h], {
            value: t[h],
            index: h
        }), f.push(t[h] ? t[h] : h);
        Lm.set(e, f)
    }
    document.addEventListener("dragover", function(u) {
        u.preventDefault()
    })
}

function VH(e) {
    function t(s) {
        e.input(s)
    }

    function n(s) {
        e.props.selectedTagValue = s.value
    }
    let r;
    e.addProps(["disableDragAndDrop", "allowNewValues", "multiple", "max"]), e.props.disableDragAndDrop = Ye(e.props.disableDragAndDrop), e.props.type === "taglist" ? (e.props.multiple = !0, e.props.selectionAppearance = "option", e.props.allowNewValues = Ye(e.props.allowNewValues), r = s => s.classList.contains("formkit-tag-wrapper")) : e.props.type === "autocomplete" && (r = s => s.classList.contains("formkit-selection")), e.on("created", () => {
        e.context && (e.context.handlers.selectTag = s => n.bind(null, s))
    }), e.on("prop:loadingCounter", ({
        payload: s
    }) => {
        s === 0 && K0 && !e.props.disableDragAndDrop && setTimeout(() => {
            const i = document.getElementById(`${e.props.id}_selections`);
            i && e.props.multiple === !0 && mO(i, e._value, t, r)
        })
    }), e.on("commit", ({
        payload: s
    }) => {
        if (e.context && K0) {
            const i = e.props.id;
            if (K0 && i && !e.props.disableDragAndDrop) {
                const o = document.getElementById(`${e.props.id}_selections`);
                if (!o || e.props.multiple !== !0) return;
                mO(o, s, t, r)
            }
        }
    }), e.on("keydown", ({
        payload: s
    }) => {
        if (s.currentTarget instanceof HTMLElement && document.activeElement instanceof HTMLElement && ["ArrowRight", "ArrowLeft"].includes(s.key) && s.altKey) {
            s.stopPropagation(), s.preventDefault();
            const i = document.activeElement,
                o = e.props.selections.find(l => l.value === e.props.selectedTagValue),
                a = e.props.selections.findIndex(l => l.value === e.props.selectedTagValue);
            s.key === "ArrowRight" ? a < e.props.selections.length - 1 && (e.props.selections.splice(a, 1), e.props.selections.splice(a + 1, 0, o)) : s.key === "ArrowLeft" && a > 0 && (e.props.selections.splice(a, 1), e.props.selections.splice(a - 1, 0, o)), Lp(e, e.props.selections), e.input(e.props.selections.map(l => l.value)), setTimeout(() => {
                i.focus()
            })
        } else if (s.target instanceof HTMLElement && document.activeElement && document.activeElement instanceof HTMLElement && ["ArrowRight", "ArrowLeft"].includes(s.key)) {
            if (s.key === "ArrowRight") {
                const i = s.target.nextElementSibling;
                if (i && i instanceof HTMLElement && i.getAttribute("data-value")) e.props.selectedTagValue = i.getAttribute("data-value"), i.focus();
                else if (i && i instanceof HTMLElement && i.id === e.props.id) {
                    const o = document.getElementById(e.props.id);
                    o && o.focus()
                }
            } else if (s.key === "ArrowLeft") {
                const i = s.target.previousElementSibling;
                i && i instanceof HTMLElement && i.getAttribute("data-value") && (e.props.selectedTagValue = i.getAttribute("data-value"), i.focus())
            }
        } else if (s.key === "Enter" && s.currentTarget && s.currentTarget instanceof HTMLInputElement && s.currentTarget.id === e.props.id && e.props.type === "taglist") {
            if (s.preventDefault(), e.props.activeValue === Xr) return void e.emit("optionSelected", e.props.loadMoreOption);
            const i = e.props.options.find(o => Qe(de(o), e.props.activeValue));
            i && e.props.expanded ? e.emit("optionSelected", i) : e.props.allowNewValues && e.props.inputText && e.emit("optionSelected", {
                value: e.props.inputText,
                label: e.props.inputText
            })
        } else if (s.currentTarget && s.currentTarget instanceof HTMLElement && s.currentTarget.id !== e.props.id && ["Backspace"].includes(s.key) && document.activeElement && document.activeElement instanceof HTMLElement && document.activeElement.id !== e.props.id) {
            const i = e.props.selections.findIndex(o => o.value === e.props.selectedTagValue);
            if (i === -1) return;
            if (i === 0 && e.props.selections.length === 1) $g(e, e.props.selections[i], !0)();
            else if (i === e.props.selections.length - 1) {
                $g(e, e.props.selections[i], !0)(), e.props.selectedTagValue = e.props.selections[i - 1].value;
                const o = document.activeElement.previousElementSibling;
                if (o) {
                    const a = o.getAttribute("data-value");
                    o && o instanceof HTMLElement && setTimeout(() => {
                        const l = document.querySelector(`[data-value="${a}"]`);
                        l && l instanceof HTMLElement && l.focus()
                    }, 50)
                }
            } else {
                e.props.selectedTagValue = e.props.selections[i + 1].value, $g(e, e.props.selections[i], !1)();
                const o = document.activeElement.nextElementSibling;
                if (o && o instanceof HTMLElement) {
                    const a = o.getAttribute("data-value");
                    a && setTimeout(() => {
                        const l = document.querySelector(`[data-value="${a}"]`);
                        l && l instanceof HTMLElement && l.focus()
                    }, 50)
                }
            }
        } else if (["ArrowLeft"].includes(s.key) && s.currentTarget && s.currentTarget instanceof HTMLInputElement && s.currentTarget.selectionStart === 0 && s.currentTarget.selectionEnd === 0) {
            if (s.stopPropagation(), e.props.selections.length === 0) return;
            e.props.selectedTagValue = e.props.selections[e.props.selections.length - 1].value;
            const i = s.currentTarget.previousElementSibling;
            i && i instanceof HTMLElement && i.focus()
        } else if (["Backspace"].includes(s.key) && s.currentTarget && s.currentTarget instanceof HTMLInputElement && s.currentTarget.selectionStart === 0 && s.currentTarget.selectionEnd === 0 && e.props.selections.length > 0) {
            s.stopPropagation(), e.props.selectedTagValue = e.props.selections[e.props.selections.length - 1].value;
            const i = s.currentTarget.previousElementSibling;
            i && i instanceof HTMLElement && i.focus()
        }
    })
}

function Dk(e, t) {
    var n;
    if (Ls.has(e)) return;
    Ls.set(e, []), t.reverse && Gc.add(e), t.prefix && od.set(e, t.prefix), t.suffix && bb.set(e, t.suffix), jH(e, t.pattern, t.partOverrides);
    const r = vb.get(e),
        s = r == null ? void 0 : r.some(a => Ni(a)),
        i = r == null ? void 0 : r.some(a => function(l) {
            return !!l && l.type === "group" && Array.isArray(l.parts)
        }(a));
    if (s && i) throw new Error("Cannot use enums and groups in the same mask.");
    const o = s ? "select" : (n = t.mode) !== null && n !== void 0 ? n : "shift";
    if (i && o === "select") throw new Error("Cannot use groups in select mode.");
    (t.placeholder || o === "select") && A1.add(e), Eo.set(e, o), t.onChange && Tf.set(e, t.onChange), e.addEventListener("beforeinput", a => {
        if (Cg) return;
        if (a.inputType.startsWith("history")) return function(f, h) {
            f.addEventListener("input", p => {
                var m;
                p.preventDefault(), p.stopImmediatePropagation();
                const g = Ls.get(f);
                if (g != null && g.length) {
                    const y = ((m = El.get(f)) !== null && m !== void 0 ? m : g.length - 1) + (h.endsWith("Undo") ? -1 : 1),
                        _ = g[y];
                    if (!_) return;
                    WH(f, _), f.setSelectionRange(..._.selectionAfter), El.set(f, y), Tf.has(f) && Tf.get(f)(_, f)
                }
            }, {
                once: !0
            })
        }(e, a.inputType);
        a.preventDefault();
        const l = (c = a.inputType).startsWith("insert") ? "insert" : !!c.startsWith("delete") && (c === "deleteContentForward" ? "deleteContentForward" : "deleteContentBackward");
        var c;
        const u = Ms(e),
            d = e.value;
        l && Lh(e, {
            type: l,
            selectionBefore: u,
            data: a.data,
            valueBefore: d,
            suffix: t.suffix,
            prefix: t.prefix
        })
    }), o === "select" && e.addEventListener("keydown", a => {
        switch (a.key) {
            case "ArrowRight":
                return a.preventDefault(), V0(e);
            case "ArrowLeft":
                return a.preventDefault(), V0(e, -1);
            case "ArrowUp":
                return void(TO(e, 1) && a.preventDefault());
            case "ArrowDown":
                return void(TO(e, -1) && a.preventDefault());
            case "Tab":
                return R1 ? void a.preventDefault() : void(V0(e, a.shiftKey ? -1 : 1) && a.preventDefault())
        }
    }), e.addEventListener("focus", () => function(a) {
        var l;
        const c = A1.has(a),
            u = Eo.get(a);
        if (c) {
            let d = null,
                f = null,
                h = !1;
            const p = u === "shift" ? 0 : 1,
                m = a.value;
            E1(a, {
                type: "insert",
                data: m,
                selectionBefore: [0, 0, "none"],
                valueBefore: m
            }, u === "shift" ? "" : m, (y, _) => (d === null && _.type === "char" && (d = y.pos - p), (pi(_) || Ni(_)) && y.value.endsWith(_.placeholder) ? (f = y.pos - p, !1) : (_.type === "char" && (h = !0), !0)));
            const g = (l = f != null ? f : h ? m.length : d) !== null && l !== void 0 ? l : null;
            if (g !== null) {
                let y = [g, g, "none"];
                if (Eo.get(a) === "select") {
                    const [_] = $r(a), E = mi(a, y);
                    E !== void 0 && E in _ && (y = _[E])
                }
                return function(_, E, b = 50) {
                    xa.set(_, wf(_, E));
                    const w = async () => {
                        if (!Bh || document.activeElement !== _) return;
                        Eo.get(_) === "select" && (await new Promise(S => setTimeout(S, 10)), function(S) {
                            let v = Ms(S);
                            if (v[0] === v[1] && v[0] === 0 || S.value.length === v[1] && v[0] === 0) return;
                            v = w1(S, v);
                            const [$] = $r(S), k = mi(S, v), C = v[0];
                            k !== void 0 && $.some(O => C >= O[0] && C < O[1]) && xa.set(S, wf(S, $[k]))
                        }(_));
                        const T = xa.get(_);
                        T && _.setSelectionRange(...T)
                    };
                    w(), document.addEventListener("selectionchange", w), setTimeout(() => {
                        document.removeEventListener("selectionchange", w), xa.delete(_)
                    }, b)
                }(a, y)
            }
        }
    }(e)), e.addEventListener("selection", a => function(l, c) {
        if (xa.get(l)) return;
        ej(l), c = w1(l, c);
        const [u] = $r(l), d = mi(l, c), f = d !== void 0 && wf(l, u[d]);
        f && !wl(c, f) && uy(l, f, !0)
    }(e, a.detail)), Lh(e, {
        type: "insert",
        selectionBefore: [0, 0, "forward"],
        data: e.value,
        valueBefore: "",
        suffix: t.suffix,
        prefix: t.prefix
    })
}

function gO(e) {
    var t, n;
    if (Ka.has(e)) return;
    const r = (t = Ls.get(e)) !== null && t !== void 0 ? t : [],
        s = r[(n = El.get(e)) !== null && n !== void 0 ? n : r.length - 1];
    if (s) {
        const i = s.selectionAfter,
            [o, a] = $r(e, s.valueAfter),
            l = mi(e, i, [o, a]);
        if (l !== void 0 && l in o) {
            const c = a[l],
                u = o[l],
                d = [i[0] - u[0], i[1] - u[0], "none"];
            Ka.set(e, [c, d])
        }
    }
}

function _O(e) {
    Ka.delete(e)
}

function yO(e, t) {
    const n = typeof e == "string" || !Ls.has(e),
        r = typeof e == "string" ? HH(e) : e;
    if (n) t.prefix && od.set(r, t.prefix), t.suffix && bb.set(r, t.suffix), r.value = Nk(r, r.value), Dk(r, t);
    else {
        const s = r.value;
        r.value = "", Lh(r, {
            type: "insert",
            selectionBefore: [0, 0, "none"],
            valueBefore: "",
            data: s,
            suffix: t.suffix,
            prefix: t.prefix
        })
    }
    return r.value
}

function HH(e) {
    return {
        value: e,
        selectionStart: 0,
        selectionEnd: 0,
        scrollWidth: 0,
        clientWidth: 0,
        addEventListener: () => {},
        dispatchEvent: () => {},
        setSelectionRange: () => {}
    }
}

function jH(e, t, n, r, s) {
    s = e && Gc.has(e) || s;
    const i = (r != null ? r : function(f) {
        const h = Object.values(y_e);
        if (!f) return h;
        const p = x({}, f),
            m = [];
        for (const y of h)
            if (!Du(y))
                if ("token" in y && y.token in f) {
                    const _ = x(x({}, y), f[y.token]);
                    vO(_) && m.push(_), delete p[y.token]
                } else m.push(y);
        const g = Object.values(p);
        for (const y of g) vO(y) ? m.push(y) : console.warn(`Invalid ${y.type} token`, y);
        return m
    }(n)).sort((f, h) => {
        const p = "token" in f ? f.token.length : -1,
            m = "token" in h ? h.token.length : -1;
        return p === m ? 0 : p > m ? -1 : 1
    });
    let o = [];
    [t, o] = function(f, h, p, m) {
        let g, y = 0,
            _ = "",
            E = "",
            b = "";
        const w = [];
        for (; _ = fr(f);) _ === h && g !== m ? (y++, y > 1 && (b += _)) : _ === p && y && g !== m ? (y--, y === 0 ? (E += `{$${w.length}}`, w.push(b), b = "") : b += _) : y ? b += _ : g !== m || _ !== h && _ !== p ? E += _ : E = `${E.substring(0,E.length-1)}${_}`, g = _, f = f.substring(_.length);
        return [E, w]
    }(t, "{", "}", "\\");
    const a = o.length;
    t = i.reduce((f, h, p) => "token" in h ? f.replaceAll(`\\${h.token}`, "{\u201C!\u201D}").replaceAll(h.token, `{$${a+p}}`).replaceAll("{\u201C!\u201D}", h.token) : f, t);
    const l = function(f, h, p) {
            return f.reduce((m, g) => {
                const [y, _] = function(w) {
                    const [T, ...S] = w.split("|"), v = S.reduce(($, k) => {
                        const [C, O = !0] = k.split(":");
                        return Object.assign($, {
                            [C]: O
                        })
                    }, {});
                    return [T, v]
                }(g);
                let E = jH(null, y, void 0, h, p);
                E = E.map(w => {
                    const T = x({}, w);
                    if (T.type === "char" && _.placeholder) T.placeholder = _.placeholder;
                    else if (T.type === "enum") throw new Error("Groups cannot contain enums.");
                    return T
                });
                const b = x({
                    type: "group",
                    parts: E
                }, _);
                return m.push(b), m
            }, [])
        }(o, i, s).concat(i),
        c = /\{\$\d+\}/g,
        u = t.match(c),
        d = t.split(c).reduce((f, h, p) => {
            if (h && f.push({
                    type: "literal",
                    value: s ? [...h].reverse().join("") : h
                }), u && u[p]) {
                const m = u[p],
                    g = Number(m.substring(2, m.length - 1));
                !isNaN(g) && l[g] && f.push(l[g])
            }
            return f
        }, []);
    return s && d.reverse(), e && vb.set(e, d), d
}

function vO(e) {
    return !!e && (Du(e) || pi(e) || Ni(e))
}

function pi(e) {
    return !!e && e.type === "char" && e.pattern instanceof RegExp && zH(e)
}

function Ni(e) {
    return !!e && e.type === "enum" && Array.isArray(e.values) && zH(e)
}

function zH(e) {
    return !!e && "placeholder" in e && "token" in e
}

function Du(e) {
    return !!e && e.type === "literal" && typeof e.value == "string"
}

function wl(e, t) {
    return e === t || e !== void 0 && t !== void 0 && e[0] === t[0] && e[1] === t[1]
}

function Ms(e) {
    var t, n;
    return [(t = e.selectionStart) !== null && t !== void 0 ? t : e.value.length, (n = e.selectionEnd) !== null && n !== void 0 ? n : e.value.length, "none"]
}

function Lh(e, t) {
    var n;
    Gc.has(e) && $O(t);
    let r = !1;
    switch (xg.set(e, "playing"), t.type) {
        case "insert":
            r = function(s, i) {
                let o = bO(i);
                const a = i.selectionBefore,
                    l = function(u, d) {
                        var f, h, p;
                        if (Eo.get(u) === "select") {
                            const [m, g] = $r(u), y = m.findIndex(E => wl(E, d.selectionBefore)), _ = (f = g[y]) !== null && f !== void 0 ? f : null;
                            if (pi(_)) {
                                const E = d.selectionBefore,
                                    b = E[1] - E[0],
                                    w = d.valueBefore.substring(E[0], E[1]),
                                    T = _.selectDirection === "left",
                                    S = qH(w, _),
                                    v = T ? 0 : function(k, C, O) {
                                        if (!k) return 0;
                                        let R = "";
                                        for (; k.length;) {
                                            const N = fr(k);
                                            k = k.substring(N.length), C.pattern.test(N) && (R += N)
                                        }
                                        return Math.min(Math.max(R.length, 1), O)
                                    }(d.data, _, b);
                                if (S.length >= b) return T || (d.insertPos = E[1] - v), ((h = _.selectFill) !== null && h !== void 0 ? h : _.placeholder).repeat(b);
                                const $ = ((p = _.selectFill) !== null && p !== void 0 ? p : _.placeholder).repeat(b - S.length - (T ? 0 : v));
                                return d.insertPos = T ? E[0] + S.length : E[1] - v, _.selectDirection === "left" ? `${S}${$}` : `${$}${S}${_.placeholder}`
                            }
                            if (Ni(_)) {
                                const E = d.selectionBefore;
                                return d.valueBefore.substring(E[0], E[1])
                            }
                        }
                        return ""
                    }(s, i);
                o = `${o.substring(0,a[0])}${l}${o.substring(a[1])}`;
                const c = E1(s, i, o);
                return __e.set(s, c.endPos), G(x({}, i), {
                    valueAfter: c.value,
                    selectionAfter: spe(s, c),
                    unmasked: c.unmasked,
                    complete: c.complete,
                    meta: c.meta
                })
            }(e, t);
            break;
        case "deleteContentBackward":
        case "deleteContentForward":
            r = function(s, i) {
                const o = bO(i),
                    a = i.selectionBefore,
                    l = Gc.has(s);
                let c = a[0],
                    u = a[1];
                c === u && (i.type !== "deleteContentBackward" || l ? u += kg(o, c) : c -= kg(o, c, "backward"));
                const d = Eo.get(s);
                let f = "";
                if (d === "select") {
                    const [m, g] = $r(s), y = mi(s, [c, u, "none"]);
                    if (y !== void 0) {
                        const _ = g[y],
                            E = m[y];
                        pi(_) ? f = _.placeholder.repeat(u - c) : Ni(_) && ([f, c] = wl(E, Ms(s)) ? [_.placeholder, c] : function(b, w, T, S) {
                            const v = S.valueBefore,
                                $ = kg(v, S.selectionBefore[0], "backward"),
                                k = Math.max(T[0], S.selectionBefore[0] - $),
                                C = v.substring(T[0], k),
                                O = Fp(w.values, C);
                            let R = O == null ? void 0 : O.substring(C.length);
                            return O && !R && KH(w.values, O) && (R = O), [R != null ? R : w.placeholder, R ? k : T[0]]
                        }(0, _, E, i))
                    }
                }
                const h = `${o.substring(0,c)}${f}${o.substring(u)}`,
                    p = E1(s, i, h);
                return G(x({}, i), {
                    valueAfter: p.value,
                    selectionAfter: lpe(s, p, i, c),
                    unmasked: p.unmasked,
                    complete: p.complete,
                    meta: p.meta
                })
            }(e, t)
    }
    if (Gc.has(e) && r && $O(r), r && function(s, i) {
            i.prefix && (i.valueAfter = i.prefix + i.valueAfter, i.selectionAfter = wf(s, i.selectionAfter)), i.suffix && (i.valueAfter += i.suffix)
        }(e, r), r && function(s) {
            return s.valueBefore !== s.valueAfter || s.selectionBefore[0] !== s.selectionAfter[0] || s.selectionBefore[1] !== s.selectionAfter[1]
        }(r)) {
        Tf.has(e) && Z0.set(e, () => {
            Z0.delete(e), r && Tf.get(e)(r, e)
        }), xg.set(e, "beforeCallback");
        let s = (n = Ls.get(e)) !== null && n !== void 0 ? n : [];
        const i = El.get(e);
        i && (s = s.slice(0, i), El.delete(e)), s.push(r), Ls.set(e, s), Bh && document.activeElement === e && typeof document.execCommand == "function" && !Cg ? (uy(e, [0, e.value.length, "forward"], !0), Cg = !0, document.execCommand("insertText", void 0, r.valueAfter), Cg = !1) : WH(e, r), Bh && document.activeElement === e && uy(e, r.selectionAfter);
        const o = Z0.get(e);
        o && o(), ej(e)
    }
    xg.set(e, "complete")
}

function Nk(e, t) {
    var n, r;
    const s = (n = od.get(e)) !== null && n !== void 0 ? n : "",
        i = (r = bb.get(e)) !== null && r !== void 0 ? r : "";
    return s && t.startsWith(s) && (t = t.substring(s.length)), i && t.endsWith(i) && (t = t.substring(0, t.length - i.length)), t
}

function wf(e, t) {
    const n = od.get(e),
        r = [...t];
    return n && (r[0] += n.length, r[1] += n.length), r
}

function w1(e, t) {
    const n = od.get(e),
        r = [...t];
    return n && (r[0] -= n.length, r[1] -= n.length), r
}

function bO(e) {
    let t = e.valueBefore;
    const n = e.selectionBefore;
    if (e.suffix && t.endsWith(e.suffix) && (t = t.substring(0, t.length - e.suffix.length), e.valueBefore = t, n[0] >= t.length && (n[0] = t.length), n[1] >= t.length && (n[1] = t.length)), e.prefix && t.startsWith(e.prefix)) {
        const r = e.prefix.length;
        t = t.substring(r), e.valueBefore = t, n[0] = Math.max(n[0] - r, 0), n[1] = Math.max(n[1] - r, 0)
    }
    return t
}

function uy(e, t, n = !1) {
    n && (Pu.add(e), setTimeout(() => Pu.delete(e), 5)), xa.get(e) && xa.set(e, t), e.setSelectionRange(...t)
}

function WH(e, t, n = "After") {
    if (e.value = t[`value${n}`], Bh) {
        const r = new InputEvent("input", {
            inputType: t.type === "insert" ? "insertText" : t.type,
            data: t.data
        });
        e.dispatchEvent(r)
    }
}

function fr(e) {
    if (e == null) return "";
    const t = my.test(e.charAt(0)) && my.test(e.charAt(1)) ? 2 : 1;
    return e.substring(0, t)
}

function kg(e, t, n = "forward") {
    if (n === "backward") return t === 0 ? 0 : t === 1 ? 1 : my.test(e.charAt(t)) && my.test(e.charAt(t - 1)) ? 2 : 1;
    const r = e.length - t;
    return r === 0 ? 0 : r === 1 ? 1 : fr(e.substring(t)).length
}

function GH(e, t) {
    const n = fr(e.data),
        r = n.length;
    if (e.value += n, e.pos += r, typeof e.data == "string" && (e.data = e.data.substring(r), e.data.length || (e.endPos = e.pos)), t) return t.substring(r)
}

function wO(e) {
    const t = fr(e.buffer),
        n = t.length;
    e.value += t, e.pos += n, e.buffer = e.buffer.substring(n)
}

function npe(e, t) {
    const n = fr(t),
        r = n.length;
    return e.value += n, e.pos += r, t.substring(r)
}

function rpe(e, t) {
    for (; t.buffer;) {
        const n = fr(t.buffer);
        if (e.pattern.test(n) || t.placeholder && e.placeholder === n) return void(t.mode !== "replace" && t.mode !== "select" || (t.buffer = t.buffer.substring(n.length)));
        t.buffer = t.buffer.substring(n.length)
    }
}

function EO(e, t) {
    const n = e.values.concat([e.placeholder]).map(r => r.toLowerCase()).sort((r, s) => r.length > s.length ? -1 : 1);
    for (; t.buffer;) {
        const r = t.buffer.toLowerCase(),
            s = n.find(i => r.startsWith(i));
        if (s) {
            const i = t.buffer.substring(0, s.length);
            return t.buffer = t.buffer.substring(s.length), i
        }
        t.buffer = t.buffer.substring(kg(t.buffer, 0))
    }
    return null
}

function qH(e, t) {
    let n = e.replaceAll(t.placeholder, "");
    const r = t.selectDirection === "left";
    if (t.selectFill) {
        const i = new RegExp(`${r?"":"^"}${s=t.selectFill,s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")}+${r?"$":""}`);
        n = n.replace(i, "")
    }
    var s;
    return n
}

function spe(e, t) {
    let n = [t.endPos, t.endPos, "forward"];
    if (t.mode !== "select") return n;
    const r = Ms(e);
    n = [r[0], t.endPos, "none"];
    const [s, i] = $r(e, t.value), o = mi(e, n, [s, i]);
    if (o === void 0 || !(o in s) || !(o in i)) return n;
    const a = s[o],
        l = i[o],
        c = t.value.slice(a[0], a[1]);
    if (pi(l) && qH(c, l).length === c.length && o < s.length - 1) return ZO(), s[o + 1];
    if (Ni(l) && t.insertPos >= a[0] && t.insertPos <= a[1]) {
        if (t.cycle) return a;
        const u = function(f, h, p) {
            if (f.originalData === null) return 0;
            const m = f.insertPos >= h ? f.value.substring(h, f.insertPos) : "",
                g = `${m}${f.originalData}`,
                y = Fp(p.values, g);
            return y ? YH(g, y).length - m.length : 0
        }(t, a[0], l);
        if (t.insertPos + u === a[1]) return KH(l.values, c) ? [a[1], a[1], "forward"] : (ZO(), s[o + 1] ? s[o + 1] : s[o]);
        const d = [t.insertPos + u, a[1], "none"];
        return wl(d, r) || (Pu.add(e), setTimeout(() => Pu.delete(e), 5)), d
    }
    return a
}

function E1(e, t, n, r) {
    var s, i;
    const o = (s = vb.get(e)) !== null && s !== void 0 ? s : [],
        a = {
            pos: 0,
            insertPos: (i = t.insertPos) !== null && i !== void 0 ? i : t.selectionBefore[0],
            range: t.selectionBefore,
            chars: 0,
            placeholder: A1.has(e),
            buffer: n,
            data: t.data,
            originalData: t.data,
            value: "",
            mode: Eo.get(e) || "replace",
            endPos: t.selectionBefore[0],
            rangeParts: $r(e),
            unmasked: "",
            complete: !0,
            cycle: t.cycle,
            meta: []
        };
    return S1(o, a, void 0, r), a
}

function S1(e, t, n, r) {
    var s, i;
    const o = x({}, t);
    n != null && n.placeholder && (t.placeholder = !0);
    const a = (n == null ? void 0 : n.repeat) && ((s = n.nextPart) === null || s === void 0 ? void 0 : s.type) === "literal" ? n.nextPart.value : null;
    let l = 0;
    const c = e.reduce((d, f) => d + (f.type === "char" ? 1 : 0), 0),
        u = t.chars;
    for (const d of e) {
        const f = e[l + 1];
        switch (d.type) {
            case "literal":
                ope(d, t, e.at(-1) === d);
                break;
            case "char":
                ape(d, t, a);
                break;
            case "enum":
                ipe(d, t);
                break;
            case "group":
                const p = {
                    repeat: (i = d.repeat) !== null && i !== void 0 && i,
                    nextPart: f,
                    repeats: 0,
                    placeholder: !!d.placeholder
                };
                S1(d.parts, t, p, r)
        }
        if (r && r(t, d) === !1) break;
        const h = Du(f) && l + 2 === e.length && u !== t.chars;
        if (!(t.buffer || t.data || t.placeholder || h)) break;
        l++
    }
    if (t.chars < c && (t.complete = !1), n) {
        const d = t.chars - u,
            f = d === c,
            h = !(!t.data || a && t.data.startsWith(a) && t.insertPos <= t.pos),
            p = !(t.buffer && a && t.buffer.startsWith(a) && t.insertPos >= t.pos + a.length) && (t.buffer || h);
        if (n.repeat && p && f) return n.repeats++, S1(e, t, n, r);
        if (!f) {
            t.complete = !1;
            const m = e.reverse().find(g => g.type === "literal");
            e.reverse(), Du(m) && t.value.endsWith(m.value) && (t.value = t.value.substring(0, t.value.length - m.value.length), t.pos = t.value.length)
        }
        c > 1 && d < c && d !== 0 && t.insertPos <= t.pos ? t.data = "" : n.repeat && !f && n.repeats && Object.assign(t, o)
    }
    t.placeholder = o.placeholder
}

function ipe(e, t) {
    const [n, r] = t.rangeParts, s = n[r.indexOf(e)];
    if (s && (t.insertPos <= t.pos || t.insertPos >= s[0] && t.insertPos <= s[1]) && t.data) {
        const i = t.buffer.substring(0, t.insertPos - t.pos),
            o = `${i}${t.data}`,
            a = Fp(e.values.concat([e.placeholder]), o);
        if (a) {
            const l = YH(o, a);
            return t.data = t.data.substring(l.length), t.value += a, a !== e.placeholder ? t.unmasked += a : t.complete = !1, t.meta.push({
                type: a !== e.placeholder ? "enum" : "placeholder",
                value: a
            }), i ? t.buffer = t.buffer.substring(i.length) : EO(e, t), t.endPos = t.pos + l.length, void(t.pos = t.value.length)
        }
        t.data = ""
    }
    if (t.buffer) {
        const i = EO(e, t);
        if (i) return t.value += i, i !== e.placeholder ? t.unmasked += i : t.complete = !1, t.meta.push({
            type: i !== e.placeholder ? "enum" : "placeholder",
            value: i
        }), void(t.pos = t.value.length)
    }
    t.complete = !1, t.value += e.placeholder, t.meta.push({
        type: "placeholder",
        value: e.placeholder
    }), t.pos = t.value.length
}

function ope(e, t, n) {
    let r = e.value;
    if (t.data === "" && !t.buffer && !t.placeholder && !n) return;
    let s = !1;
    for (; r;) {
        const i = t.insertPos <= t.pos ? fr(t.data) : "",
            o = fr(r);
        if (i === o) r = GH(t, r), t.meta.push({
            type: "literal",
            value: o
        }), s = !0;
        else if (!s || t.data || t.data === null || t.placeholder || n) r = npe(t, r), t.meta.push({
            type: "literal",
            value: o
        });
        else if (s && !t.data) break;
        t.buffer.startsWith(o) && (t.buffer = t.buffer.substring(o.length))
    }
    t.data === null && !t.buffer && t.insertPos <= t.pos && !t.placeholder && (t.value = t.value.substring(0, t.value.length - e.value.length), t.pos = t.endPos = t.value.length)
}

function ape(e, t, n) {
    var r;
    let s = !0;
    if (t.insertPos <= t.pos)
        for (; !((r = t.data) === null || r === void 0) && r.length;) {
            const i = fr(t.data);
            if (e.pattern.test(i)) return GH(t), t.meta.push({
                type: "char",
                value: i
            }), t.chars++, t.unmasked += i, void rpe(e, t);
            if (typeof t.data == "string") {
                if (n && t.data.startsWith(n)) {
                    s = !1;
                    break
                }
                t.data = t.data.substring(i.length)
            }
        }
    for (; s && t.buffer;) {
        const i = fr(t.buffer);
        if (e.pattern.test(i)) return t.chars++, t.unmasked += i, wO(t), void t.meta.push({
            type: "char",
            value: i
        });
        if (t.placeholder && i === e.placeholder) return wO(t), void t.meta.push({
            type: "placeholder",
            value: i
        });
        if (typeof t.buffer == "string") {
            if (n && t.buffer.startsWith(n)) {
                t.buffer = t.buffer.substring(n.length);
                break
            }
            t.buffer = t.buffer.substring(i.length)
        }
    }
    t.placeholder ? (t.value += e.placeholder, t.meta.push({
        type: "placeholder",
        value: e.placeholder
    })) : t.endPos = t.pos
}

function lpe(e, t, n, r) {
    const s = [r, r, "none"];
    if (t.mode === "select") {
        const i = $r(e),
            o = mi(e, s, i),
            [a, l] = $r(e, t.value),
            c = o !== void 0 && SO(n.valueBefore, i[0][o], i[1][o]);
        if (o !== void 0 && o in a) return c ? a.slice(o).every((d, f) => SO(t.value, d, l[o + f])) && a[o - 1] ? a[o - 1] : a[o] : [r, a[o][1], "none"]
    }
    return s
}

function SO(e, t, n) {
    if (Du(n)) return !1;
    if (pi(n)) {
        let r = t[0];
        for (; r < t[1];) {
            const s = fr(e.substring(r));
            if (s !== n.placeholder) return !1;
            r += s.length
        }
    }
    return !Ni(n) || e.substring(t[0], t[1]) === n.placeholder
}

function YH(e, t) {
    let n = "";
    do {
        const r = fr(e).toLowerCase(),
            s = fr(t).toLowerCase();
        if (r !== s) break;
        n += r, e = e.substring(r.length), t = t.substring(s.length)
    } while (e.length && t.length);
    return n
}

function $r(e, t) {
    const n = vb.get(e);
    if (!n) return [
        [],
        []
    ];
    if (Q0.has(e)) return Q0.get(e);
    const r = t != null ? t : Nk(e, e.value),
        s = [],
        i = [];
    let o = null,
        a = null,
        l = 0,
        c = !0;
    for (const d of n)
        if (Du(d)) o = d, a !== null && (s.push([a, l, "none"]), a = null), l += d.value.length;
        else {
            if (pi(o) && pi(d) && d.token === o.token) l++;
            else if (pi(d)) a === null ? (a = l, i.push(d)) : (s.push([a, l, "none"]), a = l, i.push(d)), l++;
            else if (Ni(d)) {
                a && s.push([a, l, "none"]), XH(d) || (c = !1);
                const f = cpe(r, d, l);
                a = null, s.push([l, l + f, "none"]), i.push(d), l += f
            }
            o = d
        }
    a !== null && s.push([a, l, "none"]);
    const u = [
        [...s],
        [...i]
    ];
    return c && !t && Q0.set(e, u), u
}

function cpe(e, t, n) {
    if (XH(t)) return t.values[0].length;
    const r = e.slice(n),
        s = Fp(t.values.concat([t.placeholder]), r);
    return s ? s.length : 0
}

function Fp(e, t, n = null, r) {
    var s;
    if (t.length === 0) return n;
    if (!r) {
        const c = e.find(u => u.toLowerCase() === t.toLowerCase());
        if (c) return c
    }
    const i = fr(t.toLowerCase()),
        o = `${r!=null?r:""}${i}`,
        a = e.filter(c => c.toLowerCase().startsWith(o)),
        l = a.find(c => c.toLowerCase() === o);
    return l && (n = l), a.length === 0 ? n : a.length === 1 ? a[0] : (a.length > 1 && (n = a[0]), (s = Fp(a, t.substring(i.length), n, o)) !== null && s !== void 0 ? s : a[0])
}

function KH(e, t) {
    return t = t.toLowerCase(), e.some(n => (n = n.toLowerCase()).startsWith(t.toLocaleLowerCase()) && n !== t)
}

function XH(e) {
    if (!J0.has(e) && Array.isArray(e.values) && e.values.length > 0) {
        const t = e.values[0].length;
        if (e.placeholder.length !== t) return !1;
        J0.set(e, e.values.every(n => n.length === t))
    }
    return J0.get(e)
}

function V0(e, t = 1) {
    const [n] = $r(e), r = mi(e, w1(e, Ms(e)));
    return r !== void 0 && n[r + t] !== void 0 && (e.setSelectionRange(...wf(e, n[r + t])), !0)
}

function TO(e, t = 1) {
    const [n, r] = $r(e), s = mi(e, Ms(e));
    if (s !== void 0 && s in r) {
        const i = r[s];
        if (Ni(i)) {
            const o = n[s],
                a = e.value.slice(o[0], o[1]);
            let l = null,
                c = i.values.indexOf(a);
            const u = i.values.length - 1;
            if (c !== -1) {
                const d = c + t;
                c = d < 0 ? u : d > u ? 0 : d, l = i.values[c]
            } else a === i.placeholder && (l = t > 0 ? i.values[0] : i.values[u]);
            if (l !== null) {
                const d = {
                    selectionBefore: o,
                    insertPos: o[0],
                    type: "insert",
                    data: l,
                    valueBefore: e.value,
                    cycle: !0
                };
                return setTimeout(() => Lh(e, d), 0), !0
            }
        }
    }
    return !1
}

function QH(e, t) {
    if (!e.length) return -1;
    if (e.length === 1) return e[0];
    const n = e.length / 2,
        r = Number.isInteger(n) ? n : Math.floor(n),
        s = Math.abs(t - e[r - 1]) < Math.abs(t - e[r]) ? [0, r] : [r];
    return QH(e.slice(...s), t)
}

function mi(e, t, n) {
    const [r] = n != null ? n : $r(e), s = r.findIndex(l => l[0] !== l[1] && (!!wl(l, t) || t[1] > l[0] && t[1] < l[1]));
    if (s !== -1) return s;
    const [i, o] = r.reduce((l, c, u) => (l[0].add(c[0]), l[0].add(c[1]), l[1][c[0]] = u, l[1][c[1]] = u, l), [new Set, {}]), a = QH([...i], t[1]);
    return a in o ? o[a] : void 0
}

function JH(e, t = !1) {
    var n, r;
    const s = (n = Ls.get(e)) !== null && n !== void 0 ? n : [],
        i = s[(r = El.get(e)) !== null && r !== void 0 ? r : s.length - 1];
    return i && (i.complete || t) ? Gc.has(e) ? [...i.unmasked].reverse().join("") : i.unmasked : t ? "" : null
}

function ZH(e) {
    var t, n, r;
    const s = (t = Ls.get(e)) !== null && t !== void 0 ? t : [],
        i = s[(n = El.get(e)) !== null && n !== void 0 ? n : s.length - 1];
    return (r = i == null ? void 0 : i.meta) !== null && r !== void 0 ? r : null
}

function $O(e) {
    const t = r => [...r].reverse().join(""),
        n = (r, s) => [s - r[1], s - r[0], r[2]];
    e.data && (e.data = t(e.data)), e.valueBefore = t(e.valueBefore), "valueAfter" in e && (e.valueAfter = t(e.valueAfter)), "selectionAfter" in e && (e.selectionAfter = n(e.selectionBefore, e.valueAfter.length)), e.selectionBefore = n(e.selectionBefore, e.valueBefore.length)
}

function ej(e) {
    if (e.scrollWidth > e.clientWidth && e.selectionStart !== null && e.selectionEnd !== null) {
        const t = e.selectionStart / e.value.length,
            n = e.selectionEnd / e.value.length;
        e.scrollLeft = n > .9 ? e.scrollWidth : t * e.scrollWidth - 20, e.dispatchEvent(new CustomEvent("input-scroll", {
            bubbles: !1,
            detail: e.scrollLeft
        }))
    }
}

function zt(e) {
    if (e || (e = new Date), e instanceof Date) {
        const t = new Date(e);
        return t.setMilliseconds(0), t
    }
    if (function(t) {
            const n = t.match(nD);
            if (n) {
                const r = Number(n[2]);
                if (r < 1 || r > 12) return !1;
                if (typeof n[3] !== void 0) {
                    const s = Number(n[3]);
                    if (s < 1 || s > 31) return !1
                }
                if (typeof n[4] !== void 0) {
                    const s = Number(n[4]);
                    if (s < 0 || s > 23) return !1
                }
                return !0
            }
            return !1
        }(e = e.trim())) return new Date(function(t) {
        const n = t.match(nD);
        return n && n[4] === void 0 ? t + "T00:00:00" : t
    }(e));
    throw new Error(`Non ISO 8601 compliant date (${e}).`)
}

function kO(e) {
    const t = zt(e);
    return t.setDate(1), t.setHours(0, 0, 0), t
}

function dy(e) {
    const t = zt(e);
    return t.setDate(1), t.setMonth(t.getMonth() + 1), t.setDate(0), t
}

function Up(e) {
    return dy(e).getDate()
}

function IO(e, t = 0) {
    const n = zt(e);
    let r = t - n.getDay();
    return r > 0 && (r -= 7), n.setDate(n.getDate() + r), n.setHours(0, 0, 0), n
}

function Wc(e, t = 1) {
    const n = zt(e);
    return n.setDate(n.getDate() + t), n
}

function co(e, t = 1, n = !1) {
    const r = zt(e),
        s = r.getDate();
    if (n || r.setDate(1), r.setMonth(r.getMonth() + t), !n) {
        const i = Up(r);
        r.setDate(i < s ? i : s)
    }
    return r
}

function fc(e, t = 1, n = !1) {
    const r = zt(e),
        s = r.getDate();
    if (n || r.setDate(1), r.setFullYear(r.getFullYear() + t), !n) {
        const i = Up(r);
        r.setDate(i < s ? i : s)
    }
    return r
}

function xO(e, t) {
    const n = zt(e),
        r = zt(t);
    return n.getDate() === r.getDate() && n.getMonth() === r.getMonth() && n.getFullYear() === r.getFullYear()
}

function CO(e, t, n) {
    if (!ew.has(e)) {
        const s = new Date(Bk),
            i = [3, 8, 9, 7, 6, 4, 3],
            o = ["weekday", "month", "dayPeriod"],
            a = ["long", "short", "narrow"],
            l = {};
        for (let c = 0; c < 12; c++) {
            s.setMonth(0 + c), c in i && s.setDate(i[c]), s.setUTCHours(8 + c);
            for (const u of a) {
                const d = new Intl.DateTimeFormat(e, o.reduce((f, h) => Object.assign(f, {
                    [h]: u
                }), {
                    hour12: !0,
                    timeZone: "UTC"
                })).formatToParts(s).map(gi);
                if (u === "long" || u === "short") {
                    const f = new Intl.DateTimeFormat(e, {
                            dateStyle: u === "short" ? "medium" : "long"
                        }).formatToParts(s).map(gi).find(p => p.type === "month"),
                        h = d.findIndex(p => p.type === "month");
                    h > -1 && f && (d[h] = f)
                }
                d.forEach(f => {
                    if (f.type === "literal") return;
                    const h = f.type;
                    l[h] = Object.assign(l[h] || {}, {
                        [f.value]: u
                    })
                })
            }
        }
        ew.set(e, l)
    }
    const r = ew.get(e);
    return r ? r[t][n] : void 0
}

function Ec(e, t) {
    const n = tD.get(t);
    if (n && n[e]) return n[e];
    const r = new Date(Bk);
    r.setUTCHours(e === "am" ? 5 : 20);
    const s = new Intl.DateTimeFormat(t, {
        timeStyle: "full",
        timeZone: "UTC",
        hour12: !0
    }).formatToParts(r).map(gi).find(i => i.type === "dayPeriod");
    if (s) {
        const i = n || {};
        return tD.set(t, Object.assign(i, {
            [e]: s.value
        })), s.value
    }
    return e
}

function upe(e, t) {
    const n = {
        timeZone: "UTC"
    };
    typeof e == "string" ? n.dateStyle = e : ("date" in e && (n.dateStyle = e.date), "time" in e && (n.timeStyle = e.time));
    const r = new Intl.DateTimeFormat(t, n),
        s = r.formatToParts(new Date(Bk)).map(gi),
        i = r.formatToParts(new Date("1999-04-05T23:05:01.000Z")).map(gi).find(a => a.type === "hour"),
        o = i && i.value === "23" ? 24 : 12;
    return s.map(a => {
        const l = a.type,
            c = function(d, f, h, p) {
                const m = f.length,
                    g = !isNaN(Number(f));
                let y;
                switch (d) {
                    case "year":
                        return m === 2 ? Pt.get("YY") : Pt.get("YYYY");
                    case "month":
                        return g ? m === 1 ? Pt.get("M") : Pt.get("MM") : (y = CO(h, d, f), y === "long" ? Pt.get("MMMM") : Pt.get("MMM"));
                    case "day":
                        return m === 1 ? Pt.get("D") : Pt.get("DD");
                    case "weekday":
                        switch (y = CO(h, d, f), y) {
                            case "narrow":
                                return Pt.get("d");
                            case "short":
                                return Pt.get("ddd");
                            default:
                                return Pt.get("dddd")
                        }
                    case "hour":
                        return p === 12 ? m === 1 ? Pt.get("h") : Pt.get("hh") : m === 1 ? Pt.get("H") : Pt.get("HH");
                    case "minute":
                        return m === 1 ? Pt.get("m") : Pt.get("mm");
                    case "second":
                        return m === 1 ? Pt.get("s") : Pt.get("ss");
                    case "dayPeriod":
                        return /^[A-Z]+$/u.test(f) ? Pt.get("A") : Pt.get("a");
                    case "literal":
                        return [f, {
                            literal: f
                        }, new RegExp("")];
                    case "timeZoneName":
                        const _ = f.split("-");
                        return _.length === 2 && _[1].length === 4 ? Pt.get("ZZ") : Pt.get("Z");
                    default:
                        return
                }
            }(a.type, a.value, t, a.type === "hour" ? o : void 0);
        if (c === void 0) return;
        const u = c[1][l];
        return u ? (c[2] || (c[2] = new RegExp(`${c[0]}`, "g")), {
            option: {
                [l]: u
            },
            partName: l,
            partValue: u,
            token: c[0],
            pattern: c[2],
            hour12: o === 12
        }) : void 0
    }).filter(a => !!a)
}

function Nu(e, t) {
    function n(l, [c, u, d]) {
        const f = Object.keys(u)[0];
        return {
            option: u,
            partName: f,
            partValue: u[f],
            token: c,
            pattern: d,
            hour12: l
        }
    }
    if (hj.includes(e) || typeof e == "object") return upe(e, t);
    let r = e,
        s = 0;
    const i = l => {
            if (l[2] || (l[2] = new RegExp(`(.)?(${l[0]})`, "g")), l[2].test(r)) {
                let c = 0;
                return r = r.replace(l[2], (u, d, f) => d === "\\" ? f : `${typeof d=="string"?d:""}{!${c++?s:s++}!}`), !!c
            }
            return !1
        },
        o = function(l) {
            const c = l.map(d => d.partName),
                u = new Set(c);
            if (c.length > u.size) throw new Error("Cannot reuse format tokens.");
            return l
        }(Vk.filter(i).concat(Hk.filter(i)).map(n.bind(null, !1)).concat(jk.filter(i).map(n.bind(null, !0)))),
        a = /^\{!(\d+)!\}$/;
    return r.split(/(\{!\d+!\})/).map(l => {
        const c = l.match(a);
        return c ? o[Number(c[1])] : {
            option: {
                literal: l
            },
            partName: "literal",
            partValue: l,
            token: l,
            pattern: new RegExp(""),
            hour12: !1
        }
    }).filter(l => !(l.partName === "literal" && l.partValue === ""))
}

function Pk(e, t = "en", n = !1, r = () => !0) {
    return Nu(e, t).filter(r).reduce((s, i) => s + (n && i.partName === "literal" ? function(o) {
        return Vk.concat(Hk).concat(jk).sort((a, l) => a[0].length > l[0].length ? 1 : -1).reduce((a, l) => a.replace(l[0], `\\${l[0]}`), o)
    }(i.token) : i.token), "").normalize("NFKC")
}

function dpe(e, t, n, r = !1) {
    function s({
        partName: a,
        partValue: l,
        token: c
    }) {
        if (a === "literal") return l;
        const u = i[a];
        if (a === "hour" && c === "H") return u.replace(/^0/, "");
        if (!(a !== "minute" && a !== "second" || c !== "mm" && c !== "ss" || u.length !== 1)) return `0${u}`;
        if (a === "dayPeriod") {
            const d = Ec(o.getHours() < 12 ? "am" : "pm", n);
            return c === "A" ? d.toUpperCase() : d.toLowerCase()
        }
        return a === "timeZoneName" ? rj(-1 * o.getTimezoneOffset()) : u
    }
    const i = function(a, l, c, u = !1) {
            function d(y, _ = !1) {
                const E = `${c}-u-hc-${_?"h12":"h23"}`;
                if (m.push(...new Intl.DateTimeFormat(E, y.reduce((b, w) => w.partName === "literal" ? b : (u && v_e.includes(w.token) && g.push(w), Object.assign(b, w.option)), {})).formatToParts(f).map(gi)), u && g.length)
                    for (const b of g) {
                        let w = [];
                        switch (b.token) {
                            case "MMMM":
                                w = new Intl.DateTimeFormat(E, {
                                    dateStyle: "long"
                                }).formatToParts(f).map(gi);
                                break;
                            case "MMM":
                                w = new Intl.DateTimeFormat(E, {
                                    dateStyle: "medium"
                                }).formatToParts(f).map(gi)
                        }
                        const T = w.find(v => v.type === b.partName),
                            S = m.findIndex(v => v.type === b.partName);
                        T && S > -1 && (m[S] = T)
                    }
            }
            const f = zt(a),
                h = l.filter(y => y.hour12),
                p = l.filter(y => !y.hour12),
                m = [],
                g = [];
            return h.length && d(h, !0), p.length && d(p), m.reduce((y, _) => (y[_.type] = _.value, y), {})
        }(e, t, n, r),
        o = zt(e);
    return t.map(a => G(x({}, a), {
        value: s(a)
    }))
}

function Rr(e, t = "long", n = "en", r = !1, s = () => !0) {
    return t === "ISO8601" ? zt(e).toISOString() : dpe(e, Nu(t, n).filter(s), n, r).map(i => i.value).join("")
}

function fpe(e) {
    return ["numeric", "2-digit"].includes(e.partValue)
}

function tj(e, t) {
    let n = 0;
    const r = a => [a[n++], a[n]];
    let s = 0;
    const i = [];
    let o;
    do {
        const [a, l] = r(t);
        o = l;
        let c = 1;
        if (a.partName === "literal") c = a.partValue.length;
        else if (a.token in gy) c = gy[a.token];
        else if (l)
            if (l.partName === "literal") {
                if (c = e.indexOf(l.partValue, s) - s, c < 0) throw new Error
            } else if (l.partName === "dayPeriod") {
            for (let u = 1; u <= 4; u++)
                if (isNaN(Number(e.charAt(s + u)))) {
                    c = u;
                    break
                }
        } else {
            const u = e.substring(s).search(/\d/);
            u !== -1 && (c = s + u)
        } else c = e.length;
        i.push(G(x({}, a), {
            value: e.substring(s, s + c)
        })), s += c
    } while (o);
    return i
}

function yb(e, t = "en", n = !1) {
    const r = (s, i) => Array(s).fill("").map((o, a) => `${i(a)}`);
    if (e === "M") return r(12, s => s + 1);
    if (e === "MM") return r(12, s => {
        const i = s + 1;
        return i < 10 ? `0${i}` : i
    });
    if (e.startsWith("M")) return yb("MM").map(s => Rr(`2000-${s}-05`, e, t, n));
    if (e.startsWith("d")) return r(7, s => `0${s+2}`).map(s => Rr(`2022-10-${s}`, e, t));
    if (e === "a") return [Ec("am", t).toLowerCase(), Ec("pm", t).toLowerCase()];
    if (e === "A") return [Ec("am", t).toUpperCase(), Ec("pm", t).toUpperCase()];
    if (e.startsWith("Y")) {
        const s = new Date().getFullYear();
        return r(120, i => i + 1).reduce((i, o) => (o !== "120" && i.push(Rr(`${s+Number(o)}-06-06`, e, t)), i.unshift(Rr(s - Number(o) + "-06-06", e, t)), i), [Rr(`${s}-06-06`, e, t)])
    }
    return e.startsWith("D") ? r(31, s => `${e==="DD"&&s<9?"0":""}${s+1}`) : e.startsWith("H") ? r(24, s => `${e==="HH"&&s<10?"0":""}${s}`) : e.startsWith("h") ? r(12, s => `${e==="hh"&&s<9?"0":""}${s+1}`) : e.startsWith("m") || e.startsWith("s") ? r(60, s => `${e.length>1&&s<10?"0":""}${s}`) : []
}

function oo(e, t = "ISO8601", n = "en") {
    let r, s = () => !0,
        i = "backward";
    if (typeof e == "object" ? {
            date: r,
            format: t = "ISO8601",
            locale: n = "en",
            dateOverflow: i = "backward",
            partFilter: s = () => !0
        } = e : r = e, !r) throw new Error("parse() requires a date string.");
    const o = () => {
        throw new Error(`Date (${r}) does not match format (${Pk(t,n)})`)
    };
    if (t === "ISO8601") return zt(r);
    const a = hj.includes(t) || typeof t == "object",
        l = function(v) {
            let $;
            for (const k of v) {
                if (k.partName === "literal" && !isNaN(parseFloat(k.partValue))) throw new Error(`Numbers in format (${k.partValue}).`);
                if ($ && $.partName !== "literal" && k.partName !== "literal" && !($.token in gy || k.token in gy || fpe($) && k.token.toLowerCase() === "a")) throw new Error(`Illegal adjacent tokens (${$.token}, ${k.token})`);
                $ = k
            }
            return v
        }(Nu(t, n).filter(s));
    if (!l.length) throw new Error("parse() requires a pattern.");
    let c;
    try {
        c = tj(r, l)
    } catch {
        return o()
    }
    const u = new Date,
        d = new Map([
            ["YYYY", u.getFullYear()],
            ["MM", u.getMonth() + 1],
            ["DD", u.getDate()],
            ["HH", 0],
            ["mm", 0],
            ["ss", 0]
        ]);
    let f = null,
        h = "";
    c.forEach(v => {
        if (v.partName === "literal") return;
        if (v.token === v.value) return o();
        const $ = Number(v.value);
        if (d.has(v.token)) d.set(v.token, $);
        else if (v.token === "YY") d.set("YYYY", function(k) {
            const C = new Date().getFullYear(),
                O = C % 100,
                R = Math.floor(C / 100),
                N = Number(k);
            return 100 * (R + (N > O + 20 ? -1 : 0)) + N
        }(v.value));
        else {
            const k = v.token;
            if (k.startsWith("d")) return;
            if (k === "D") d.set("DD", $);
            else if (k === "H" || k.startsWith("h")) d.set("HH", $);
            else if (k === "M") d.set("MM", $);
            else if (k === "a" || k === "A") f = v.value.toLowerCase() === Ec("am", n).toLowerCase();
            else if (k === "Z") h = nj(v.value);
            else {
                const C = yb(k, n, a).indexOf(v.value);
                if (C !== -1) switch (k) {
                    case "MMM":
                    case "MMMM":
                        d.set("MM", C + 1)
                }
            }
        }
    });
    let p = d.get("HH") || 0;
    f === !1 ? (p += p === 12 ? 0 : 12, d.set("HH", p === 24 ? 0 : p)) : f === !0 && p === 12 && d.set("HH", 0), d.set("MM", (d.get("MM") || 1) - 1);
    let [m, g, y, _, E, b] = Array.from(d.values());
    const w = Up(new Date(`${tw(m)}-${no(g+1)}-10`));
    if (w < y && i === "throw") throw new Error(`Invalid date ${tw(m)}-${no(g+1)}-${no(y)}`);
    y = i === "backward" ? Math.min(y, w) : y;
    const T = `${tw(m)}-${no(g+1)}-${no(y)}T${no(_)}:${no(E)}:${no(b)}${h}`,
        S = new Date(T);
    return isFinite(+S) ? S : o()
}

function nj(e) {
    if (!/^([+-])[0-3][0-9][0-6][0-9]$/.test(e)) throw new Error(`Invalid offset: ${e}`);
    return e
}

function T1(e, t = "UTC", n = "browser") {
    n = n === "browser" ? Intl.DateTimeFormat().resolvedOptions().timeZone : n;
    const r = zt(e),
        s = o => {
            const a = new Intl.DateTimeFormat("en-US", {
                    year: "numeric",
                    month: "2-digit",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit",
                    timeZone: o,
                    hourCycle: "h23"
                }).formatToParts(r).map(gi),
                l = {};
            return a.forEach(c => {
                l[c.type] = c.value
            }), new Date(`${l.year}-${l.month}-${l.day}T${l.hour}:${l.minute}:${l.second}Z`)
        },
        i = s(t);
    return rj((s(n).getTime() - i.getTime()) / 1e3 / 60)
}

function gi(e) {
    return e.type === "literal" && (e.value = e.value.normalize("NFKC")), e
}

function rj(e) {
    return `${e<0?"-":"+"}${String(Math.floor(Math.abs(e/60))).padStart(2,"0")}${String(Math.abs(e%60)).padStart(2,"0")}`
}

function sj(e, t = "+0000") {
    const n = zt(e),
        r = function(s) {
            nj(s);
            const [i, o, a, l] = s.match(/([+-])([0-3][0-9])([0-6][0-9])/), c = 60 * Number(a) + Number(l);
            return o === "+" ? c : -c
        }(t);
    return new Date(n.getTime() + 1e3 * r * 60)
}

function Jl(e, t = "+0000") {
    const n = t.slice(0, 1) === "+";
    return sj(e, t.replace(n ? "+" : "-", n ? "-" : "+"))
}

function gd(e, t, n = 7) {
    let r, s;
    const i = zt(e);
    switch (n) {
        case "month":
            s = i.getDate(), r = Up(i) - i.getDate();
            break;
        case "week":
            s = i.getDay() + 1, r = 6 - i.getDay();
            break;
        case "year":
            const o = function(l) {
                    const c = zt(l);
                    return (new Date(c.getFullYear() + 1, 0, 0).getTime() - new Date(c.getFullYear(), 0, 0).getTime()) / 864e5
                }(i),
                a = function(l) {
                    const c = zt(l);
                    return Math.round((new Date(c.getFullYear(), c.getMonth(), c.getDate(), 0, 0).getTime() - new Date(c.getFullYear(), 0, 0).getTime()) / 864e5)
                }(i);
            s = a, r = o - a;
            break;
        default:
            r = s = n
    }
    for (let o = 0; o <= r || o < s; o++) {
        if (o <= r) {
            const a = Wc(i, o);
            if (t(a)) return a
        }
        if (o && o <= s) {
            const a = Wc(i, -o);
            if (t(a)) return a
        }
    }
    return null
}

function Ef(e) {
    return e.partName !== "timeZoneName"
}

function hpe(e, t) {
    const n = [],
        r = zt(t);
    r.setDate(1);
    let s = IO(r, e.props.weekStart);
    s.setHours(r.getHours(), r.getMinutes(), r.getSeconds());
    const i = function(a, l = 0) {
        const c = IO(a, l);
        return c.setDate(c.getDate() + 6), c.setHours(23, 59, 59), c
    }(dy(t), e.props.weekStart);
    let o = [];
    do o.push(s), o.length === 7 && (n.push(o), o = []), s = Wc(s); while (s.getTime() <= i.getTime());
    return {
        monthDay: r,
        weeks: n
    }
}

function AO(e) {
    e.props.calendar = Po(e.props.showMonths, t => t).map(t => hpe(e, co(e.props.renderedDate, t))), e.props.years = function(t) {
        const n = Number(Rr(t.props.renderedDate, "YYYY")),
            r = n - n % 10;
        return t.props.decade = `${r} - ${r+9}`, Po(10, s => fc(t.props.renderedDate, r + s - n))
    }(e), e.props.months = function(t) {
        const n = zt(t.props.renderedDate);
        return n.setMonth(0), Po(12, r => co(n, r))
    }(e)
}

function ppe(e, t) {
    t.target && t.target instanceof Element && (t.target.closest(`#${e.props.id}_panels`) || !document.contains(t.target)) || D1.has(e) || (N1.add(e), e.props.expanded = !1)
}

function _d(e, t) {
    if (!t) return e.props.inputText = "", new Date;
    const n = t instanceof Date ? t : oo(t, e.props.valueFormat, e.props.valueLocale);
    return e.props.inputText = e.props.formatDate(n, e.props.format, e.props.locale, !1, Ef), n
}

function RO(e) {
    return Array.isArray(e.props.sequence) ? qo(e.props.sequence) : ["day"]
}

function Om(e, t, n = !0) {
    var r, s;
    if (e._value === t) return;
    if (t == null) return e.input(t, n);
    e.props.offset = e.props.timezone ? T1(t, e.props.timezone) : "+0000";
    const i = sj(t, (r = (s = e.props).offset) !== null && r !== void 0 ? r : s.offset = "+0000");
    e.input(Rr(i, e.props.valueFormat, e.props.valueLocale, !1), n)
}

function H0(e, t) {
    const n = ["prev_button", "month_button", "day_button", "year_button", "next_button"].find(s => document.getElementById(`${e.props.id}_${s}`)),
        r = document.getElementById(`${e.props.id}_${n}`);
    r instanceof HTMLElement && (t.preventDefault(), r.focus())
}

function mpe(e, t) {
    let n = "";
    if (!(t instanceof HTMLInputElement) || e.props.pickerOnly) return;
    _y.set(e, t), document.addEventListener("click", i => {
        e.props.expanded && i.target instanceof HTMLElement && i.target.closest(`#${e.props.id}_panels`) ? $f.add(e) : $f.delete(e)
    }), e.on("prop:inputText", ({
        payload: i
    }) => {
        i !== t.value && (xg.get(t) === "beforeCallback" && (n = t.value), gO(t), t.selectionStart = 0, t.selectionEnd = t.value.length, function(o, a) {
            var l, c;
            if (!Ls.has(o)) return;
            const u = (l = od.get(o)) !== null && l !== void 0 ? l : "",
                d = (c = bb.get(o)) !== null && c !== void 0 ? c : "";
            Lh(o, {
                type: "insert",
                selectionBefore: Ms(o),
                data: a,
                valueBefore: o.value,
                suffix: d,
                prefix: u
            })
        }(t, i), t.value = i, setTimeout(() => _O(t), 10))
    });
    const [r, s] = gpe(e);
    Dk(t, {
        pattern: r,
        partOverrides: s,
        onChange: ({
            valueAfter: i
        }) => {
            if (ij(e), O1.has(e)) return O1.delete(e);
            n && n === i ? n = "" : (gO(t), e.props.inputText = i, setTimeout(() => _O(t), 10))
        }
    })
}

function ij(e) {
    var t, n;
    if (e.props.overlay) {
        const r = _y.get(e);
        !r || !(!((t = e.props.attrs) === null || t === void 0) && t.placeholder) || e._value || JH(r, !0) || e.props._isFocused || e.props.activeDate && e.props.expanded ? r && (e.props._isPlaceholder = !1, e.props._overlayParts = kk(ZH(r))) : (e.props._isPlaceholder = !0, e.props._overlayParts = [{
            type: "placeholder",
            value: (n = e.props.attrs) === null || n === void 0 ? void 0 : n.placeholder
        }])
    }
}

function gpe(e) {
    const t = e.props.locale,
        n = ["full", "long", "medium", "short"].includes(e.props.format) || typeof e.props.format == "object",
        r = Nu(e.props.format, t);
    return [Pk(e.props.format, t, !0, Ef), r.reduce((s, i) => {
        if (i.partName === "literal") return s;
        let o = yb(i.token, t, n);
        if (i.token === "YYYY" && e.props.minDate && e.props.maxDate) {
            const l = e.props.minDate.getFullYear();
            o = Po(e.props.maxDate.getFullYear() - l + 1, c => String(l + c))
        }
        const a = {
            type: "enum",
            token: i.token,
            values: o,
            placeholder: i.token === "A" ? "A/P" : i.token,
            selectDirection: "left"
        };
        return s[i.token] = a, i.token.startsWith("D") && pj.set(e, o), s
    }, {})]
}

function _pe(e, t) {
    return !t || !!(e.props.minDate && t < e.props.minDate) || !!(e.props.maxDate && t > e.props.maxDate) || void 0
}

function ype(e) {
    return typeof e.props.validationLabel == "function" ? e.props.validationLabel(e) : e.props.validationLabel || e.props.label || e.props.name || String(e.name)
}

function vpe(e, t) {
    if (t instanceof HTMLInputElement && !sD.get(e) && b_e) {
        const n = document.getElementById(`${e.props.id}_overlay`),
            r = document.getElementById(`${e.props.id}_overlay_inner`);
        if (n && t && r) {
            sD.set(e, n);
            const s = getComputedStyle(t).color;
            t.style.color = "transparent", t.style.caretColor = s;
            const i = new ResizeObserver(() => {
                var a;
                const l = getComputedStyle(t),
                    c = t.getBoundingClientRect(),
                    u = (a = t.parentElement) === null || a === void 0 ? void 0 : a.getBoundingClientRect();
                e.props._overlayStyles = G(x({}, e.props._overlayStyles), {
                    width: l.width,
                    height: l.height,
                    boxSizing: l.boxSizing,
                    padding: l.padding,
                    margin: l.margin,
                    fontSize: l.fontSize,
                    lineHeight: l.lineHeight,
                    top: c.top - ((u == null ? void 0 : u.top) || c.top) + "px",
                    left: c.left - ((u == null ? void 0 : u.left) || c.left) + "px"
                })
            });
            i.observe(t);
            const o = a => {
                r.scrollLeft = a.detail
            };
            t.addEventListener("input-scroll", o), e.on("destroyed", () => {
                t.removeEventListener("input-scroll", o), i.disconnect()
            })
        }
    }
}

function oj(e) {
    e.addProps(["_overlayStyles", "_overlayParts", "_overlayInnerStyles", "_isPlaceholder"]), e.props._overlayStyles = {
        position: "absolute",
        top: "0",
        left: "0",
        pointerEvents: e.props._isPlaceholder ? "auto" : "none"
    }, e.props._overlayInnerStyles = {
        overflow: "hidden",
        whiteSpace: "nowrap",
        paddingRight: "20px"
    }, e.on("created", () => {
        e.props.overlay = Ye(e.props.overlay), e.props.pickerOnly = Ye(e.props.pickerOnly), e.props.overlay = e.props.pickerOnly ? void 0 : e.props.overlay, e.props.overlay && Ws(`${e.props.id}`, vpe.bind(null, e))
    }), e.on("prop:_isPlaceholder", () => {
        e.props._overlayStyles = G(x({}, e.props._overlayStyles), {
            pointerEvents: e.props._isPlaceholder ? "auto" : "none"
        })
    })
}

function OO(e) {
    const t = Array.isArray(e.props.options) ? e.props.options : [],
        n = (Array.isArray(e.props.memoOptions) ? e.props.memoOptions : []).concat(t);
    return !!n.length && !!Array.isArray(e.value) && e.value.reduce((r, s) => {
        const i = n.find(o => Qe(s, de(o)));
        return i ? r.push(i) : e.props.arbitraryValues && r.push({
            value: s,
            label: s
        }), r
    }, [])
}

function bpe(e, t) {
    if (!(t instanceof HTMLInputElement)) throw new Error(`Masks can only be applied to an HTMLInputElement (id: ${t.id}).`);
    M1.set(e, t), Dk(t, G(x({}, P1.get(e)), {
        onChange: ({
            valueAfter: n,
            meta: r
        }) => {
            e.props._maskValue = n, e.input({
                maskValue: n
            }), e.props._overlayParts = kk(r)
        }
    }))
}

function wpe(e) {
    const t = qc.get(e.parentElement);
    t && t.childIsDraggable && !t.childIsDraggable(e) || (e.setAttribute("draggable", "true"), e.addEventListener("dragstart", Spe), t && (t.accepts === !1 || t.dropBehavior == "append" || Array.isArray(t.accepts) && !t.accepts.length) || e.addEventListener("dragenter", $pe))
}

function DO(e, t) {
    if (t && t.accepts && Array.isArray(t.accepts)) {
        const n = [];
        for (const r of t.accepts) n.push(r);
        Wk.set(e, n)
    }
}

function $1(e) {
    const t = [],
        n = qc.get(e),
        r = Sl.get(e);
    for (let s = 0; s < e.children.length; s++) {
        const i = e.children[s];
        i instanceof HTMLElement && (n && n.childIsDraggable && !n.childIsDraggable(i) || t.push(i))
    }
    for (let s = 0; s < t.length; s++) {
        const i = t[s];
        wpe(i), cs.set(i, {
            value: r()[s],
            index: s
        })
    }
}

function NO(e, t, n, r) {
    cD.has(e) ? (qc.set(e, n), DO(e, n), Sl.set(e, t), L1.set(e, r), $1(e)) : (new MutationObserver(Epe).observe(e, {
        childList: !0
    }), qc.set(e, n), DO(e, n), cD.add(e), Sl.set(e, t), L1.set(e, r), function(s) {
        const i = qc.get(s.parentElement);
        i && (i.accepts === !1 || Array.isArray(i.accepts) && !i.accepts.length) || (s.addEventListener("drop", kpe), s.addEventListener("dragenter", Tpe))
    }(e), $1(e))
}

function Epe(e) {
    const t = [];
    for (const n of e) {
        $1(n.target);
        for (const r of n.addedNodes) r instanceof HTMLElement && cs.has(r) && t.push(r);
        for (const r of n.removedNodes) r instanceof HTMLElement && cs.has(r)
    }
    if (t.length && xe)
        for (const n of t)
            for (const r of na) cs.get(n).value !== cs.get(r).value || n.classList.add("dnd-placeholder");
    setTimeout(() => {
        Kc = !1
    }, 200)
}

function Spe(e) {
    if (Mk(e) && Fh(e.currentTarget.parentNode)) {
        const t = qc.get(e.currentTarget.parentNode);
        if (t && t.isDisabled && t.isDisabled()) return void e.preventDefault();
        if (xe = e.currentTarget, !xe.parentNode) return;
        const n = L1.get(e.currentTarget.parentNode)();
        n.includes(xe) || n.push(xe);
        const r = new DocumentFragment,
            s = document.createElement("div");
        s.id = "dnd-selections", s.style.display = "flex", s.style.flexDirection = "column", n.map(o => {
            na.push(o);
            let a = null;
            if (xe === o) {
                a = xe.cloneNode(!0);
                const l = xe.children;
                for (let c = 0; c < l.length; c++) {
                    const u = l[c];
                    u instanceof HTMLElement && (u.style.display = "none")
                }
                s.appendChild(a)
            } else a = o.cloneNode(!0), s.appendChild(a), o.style.display = "none"
        }), r.appendChild(s), xe.appendChild(r), xe.classList.add("dnd-dragging"), xe.parentNode.dispatchEvent(new CustomEvent("dndDragStart", {
            detail: cs.get(xe)
        }));
        const i = Sl.get(xe.parentNode)();
        wb.set(xe, i), Yc.set(xe, xe.parentNode)
    }
}

function Mk(e) {
    return !!e.currentTarget
}

function Lk(e) {
    return !!e && e instanceof HTMLElement
}

function Fh(e) {
    return !!e && e instanceof HTMLElement
}

function aj(e) {
    return Array.isArray(e) && e.length > 0
}

function Tpe(e) {
    if (Mk(e) && Lk(xe) && Fh(xe.parentNode) && aj(na) && !Kc) {
        const t = function(n, r) {
            const s = Wk.get(n),
                i = Yc.get(r),
                o = r.parentNode;
            return i !== n && o === n ? {
                accepted: !0,
                draggedElementReturned: !0
            } : s.includes(r.parentNode) ? i === n ? {
                accepted: !1,
                draggedElementReturned: !1
            } : i !== n ? {
                accepted: !0,
                draggedElementReturned: !1
            } : {
                accepted: !1,
                draggedElementReturned: !1
            } : {
                accepted: !1,
                draggedElementReturned: !1
            }
        }(e.currentTarget, xe);
        if (t.accepted && !t.draggedElementReturned) {
            Kc = !0;
            const n = [...Sl.get(e.currentTarget)()],
                r = [];
            for (const i of na) r.push(cs.get(i).value);
            const s = n.concat(r);
            Yc.set(xe, e.currentTarget), xe.style.display = "none", e.currentTarget.dispatchEvent(new CustomEvent("dndNewValue", {
                detail: s
            }))
        } else if (t.accepted && t.draggedElementReturned) {
            Kc = !0;
            const n = wb.get(xe);
            Yc.set(xe, e.currentTarget), xe.style.display = "", xe.parentNode.dispatchEvent(new CustomEvent("dndNewValue", {
                detail: n
            }))
        }
    }
}

function $pe(e) {
    if (Mk(e) && Fh(e.currentTarget.parentNode) && Lk(xe) && Fh(xe.parentNode) && aj(na) && function(t, n) {
            const r = Wk.get(t);
            return r ? r && r.length ? r.includes(n.parentNode) : void 0 : {
                accepted: !0,
                draggedElementReturned: !1
            }
        }(e.currentTarget.parentNode, xe) && function(t, n) {
            return cs.get(n).value !== cs.get(t).value
        }(e.currentTarget, xe) && !Kc) {
        Kc = !0;
        const t = [...Sl.get(e.currentTarget.parentNode)()],
            n = na.map(i => cs.get(i).value),
            r = [...t.filter(i => !n.includes(i))],
            s = cs.get(e.currentTarget).index;
        r.splice(s, 0, ...n), xe.style.display !== "none" && xe.parentNode !== e.currentTarget.parentNode ? xe.style.display = "none" : xe.style.display === "none" && xe.parentNode === e.currentTarget.parentNode && (xe.style.display = ""), Yc.set(xe, e.currentTarget.parentNode), e.currentTarget.parentNode.dispatchEvent(new CustomEvent("dndNewValue", {
            detail: r
        }))
    }
}

function kpe(e) {
    if (e.stopPropagation(), e.preventDefault(), F1 = !0, !e.currentTarget) return;
    const t = Sl.get(e.currentTarget)();
    e.currentTarget.dispatchEvent(new CustomEvent("dndDrop", {
        detail: t
    })), setTimeout(() => {
        lj()
    }, 50)
}

function lj() {
    xe && (wb.delete(xe), Yc.delete(xe));
    for (const e of na) e.style.display = "";
    document.querySelectorAll(".dnd-placeholder").forEach(e => {
        e.classList.remove("dnd-placeholder")
    }), document.querySelectorAll(".dnd-dragging").forEach(e => {
        e.classList.remove("dnd-dragging");
        for (let t = 0; t < e.children.length; t++) {
            const n = e.children[t];
            n instanceof HTMLElement && (n.getAttribute("id") === "dnd-selections" ? n.remove() : n.style.display === "none" && (n.style.display = ""))
        }
    }), xe = null, na = []
}

function Ipe(e, t = {}) {
    const n = e;
    try {
        let r = function(s) {
            dD.has(s) && function(o, a) {
                Sf[o] ? Sf[o].add(a) : Sf[o] = new Set([a])
            }(e, o => {
                s.props.definition && (s.props.definition.schema = o || [{
                    $el: _i(Gye),
                    children: `${_i(zye)}${_i(Wye)}`
                }]), s.emit("schema"), setTimeout(() => s.destroy(), 1e3)
            })
        };
        if (!n) throw new Error("FormKitNoKey");
        return function(s) {
            const i = () => {
                throw new Error(`InvalidFormKitKey ${s}`)
            };
            if (!/^fk-/i.test(s)) return i();
            const o = s.substring(3);
            if (!Ope.test(o)) return i();
            const a = parseInt(o, 16).toString(),
                l = Number(a[0]) < 6 ? Number(a[0]) : 6,
                c = a.substring(l, l + (a.length - 6)),
                u = a.substring(0, l) + a.substring(l + c.length),
                d = u.slice(0, 2),
                f = `${u[u.length-1]}${u[0]}`;
            Number(c) !== Math.floor(Number(u) * Number(d) / Number(f)) && i()
        }(n), r.library = s => {
            if (s.props.type in t) {
                const i = t[s.props.type],
                    {
                        schema: o
                    } = i,
                    a = Gr(i, ["schema"]);
                dD.add(s), s.define(G(x({}, a), {
                    schema: o(e)
                }))
            }
            Hye(() => hy.has(e) && s.emit(jye.toString(32)), 4e3)
        }, r
    } catch (r) {
        throw r instanceof Error && function(s) {
            if (s.message === "FormKitNoKey") throw new Error("A FormKit API key is required, please visit https://formkit.com/pro")
        }(r), r
    }
}
const PO = [988, 24029, 396, 13078, 980],
    xpe = 18806588,
    Cpe = 502357,
    Ape = 16217489;
let Zl = 189024;
const Rpe = () => [30548127325, 27022924, 34729821653783].map(_i).join("y"),
    Ope = /^[0-9a-f]+$/,
    cj = typeof window != "undefined",
    k1 = Po(32, e => e).map(() => {
        Zl |= 0, Zl = Zl + 1831565813 | 0;
        let e = Zl ^ Zl >>> 15 | Zl;
        return e = e + e ^ e >>> 427 | e ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296
    }),
    Fk = setTimeout,
    Dpe = e => {
        clearTimeout(fy[e]), delete fy[e]
    },
    fy = {},
    _i = e => e.toString(32),
    MO = e => `${_i(k1[e]).substring(2)}.${_i(PO[e%(PO.length-1)])}`,
    Ig = {},
    yd = {},
    hy = new Set(["", null, void 0]),
    Sf = {},
    j0 = {
        position: "fixed",
        overflow: "hidden",
        height: "100%",
        width: "100%"
    },
    z0 = {
        overflow: "hidden",
        height: "100%"
    },
    LO = {},
    FO = {};
let W0 = 0;
const Npe = () => ({
        $el: "div",
        attrs: {
            key: "$id",
            "data-type": "$type",
            "data-family": "$family",
            "data-multiple": "$attrs.multiple || $multiple || undefined",
            "data-disabled": "$disabled || undefined",
            "data-complete": "$state.complete || undefined",
            "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
            "data-errors": "$state.errors || undefined",
            "data-submitted": "$state.submitted || undefined",
            "data-loading": "$state.loading || undefined",
            "data-overscroll": '$behavior === "overscroll" && true || undefined',
            "data-id": "$id",
            "data-is-max": "$max && $value && $value.length >= $max || undefined",
            "data-multi-select": "$transferOnSelect === false || undefined",
            "data-has-overlay": "$overlay || undefined",
            "data-expanded": "$expanded || undefined",
            "data-focused": "$_isFocused || undefined"
        }
    }),
    Ppe = () => ({
        $el: "div",
        attrs: {
            id: '$id + "_inner"'
        }
    }),
    Mpe = () => ({
        if: "$label",
        $el: "label",
        attrs: {
            for: "$id",
            id: "$id + '_label'"
        }
    }),
    Lpe = () => ({
        $el: "ul",
        if: "$fns.length($messages)"
    }),
    Fpe = () => ({
        $el: "li",
        for: ["message", "$messages"],
        attrs: {
            key: "$message.key",
            id: "$id + '-' + $message.key",
            "data-message-type": "$message.type"
        }
    }),
    Upe = () => ({
        $el: "div",
        if: "$help"
    }),
    UO = () => ({
        $el: null
    }),
    I1 = (e, t) => () => an(e, t),
    Bpe = () => ({
        $el: "span",
        if: '$part.type === "placeholder" && $part.value'
    }),
    Vpe = () => ({
        $el: "span",
        if: '$part.type === "literal" && $part.value'
    }),
    Hpe = () => ({
        $el: "span",
        if: '$part.type === "char" && $part.value'
    }),
    jpe = () => ({
        $el: "span",
        if: '$part.type === "enum" && $part.value'
    }),
    zpe = () => ({
        $el: "div",
        if: "$overlay",
        attrs: {
            id: '$id + "_overlay"',
            class: "$classes.overlay",
            style: "$_overlayStyles",
            onClick: "$_isPlaceholder && $handlers.overlayClick"
        }
    }),
    Wpe = () => ({
        $el: "div",
        attrs: {
            id: '$id + "_overlay_inner"',
            class: "$classes.overlayInner",
            style: "$_overlayInnerStyles"
        }
    }),
    Gpe = () => ({
        $el: null,
        for: ["part", "$_overlayParts"]
    }),
    Uh = new WeakSet,
    uj = new WeakMap,
    G0 = typeof window != "undefined",
    dj = Nn({
        key: "loading",
        type: "state",
        value: !0,
        visible: !1
    }),
    py = Nn({
        key: "loading",
        type: "state",
        value: !1,
        visible: !1
    }),
    Xr = Symbol(),
    q0 = new WeakMap,
    BO = typeof window != "undefined",
    Vl = Hi("dd"),
    {
        outer: qpe,
        wrapper: Ype,
        inner: Kpe,
        icon: Dm,
        label: Xpe,
        prefix: Qpe,
        suffix: Jpe,
        help: Zpe,
        messages: eme,
        message: tme
    } = ji(Vl),
    nme = Vl("selector", () => ({
        $el: "button",
        bind: "$attrs",
        attrs: {
            id: "$id",
            type: "button",
            onClick: "$handlers.click",
            onBlur: "$handlers.blur",
            onKeydown: "$handlers.keydown",
            tabindex: "0",
            "aria-has-popup": "listbox",
            "aria-expanded": "$expanded",
            "aria-controls": '$expanded && $id + "_listbox" || undefined',
            "aria-describedBy": "$describedBy"
        }
    })),
    rme = Vl("selection", "div"),
    sme = Vl("placeholder", () => ({
        $el: "div",
        attrs: {
            key: "placeholder",
            "data-is-placeholder": "true"
        }
    })),
    ime = Vl("optionLoading", "span"),
    ome = Vl("option", () => ({
        $el: "div",
        attrs: {
            "data-is-placeholder": "$option.isPlaceholder || undefined"
        }
    })),
    ame = Rk(Vl),
    lme = {
        position: "fixed",
        top: 0,
        bottom: 0,
        right: 0,
        left: 0,
        pointerEvents: "none",
        zIndex: -1,
        overflowY: "auto",
        "-webkit-overflow-scrolling": "auto"
    },
    cme = {
        schema: qpe(Ype(Xpe("$label"), Kpe(Dm("prefix"), Qpe(), nme(Mt("$option.isPlaceholder && $state.loading !== true", sme("$option.label"), rme(ome(Mt("$state.loading", ime("$ui.isLoading.value"), "$option.label")))), Mt("$state.loading", Dm("loader")), Dm("select")), ame(), Jpe(), Dm("suffix"))), Zpe("$help"), eme(tme("$message.value"))),
        type: "input",
        family: "dropdown",
        props: [],
        features: [Ul, Ik(PH, function(e) {
            e.on("click", () => {
                e.props.trackHover = !1, (!e.props.options || e.props.options.length || e.props.emptyMessage || e.props.optionsLoader) && (e.props.options && !e.props.options.length && e.props.emptyMessage && (e.props.showEmptyMessage = !0), e.props.expanded = !0)
            })
        }, Ak, xk(b1, Lp), function(e) {
            let t, n = "";
            e.on("unusedKeyDown", ({
                payload: r
            }) => {
                if (!r.isComposing && [...r.key].length === 1) {
                    clearTimeout(t), n += r.key;
                    const s = e.props.options.find(i => i.label.toLowerCase().startsWith(n.toLowerCase()));
                    s && (e.props.activeValue = de(s)), t = setTimeout(() => {
                        n = ""
                    }, 400)
                }
            })
        }), function(e) {
            e.addProps(["behavior"]), e.on("created", () => {
                e.props.behavior === "overscroll" && (typeof e.props.optionsLoader == "function" && Tr(300, [e]), e.props.dropdownWrapperStyles = qo(lme), e.props.listboxStyles = {
                    display: "inline-block"
                }, e.props.styleWrapper = Bhe.bind(null, e), e.props.positionListBox = Vhe.bind(null, e))
            }), e.on("prop:expanded", ({
                payload: t
            }) => {
                e.props.behavior === "overscroll" && (t ? function() {
                    W0 = document.documentElement.scrollTop;
                    for (const n in j0) FO[n] = document.documentElement.style[n], document.documentElement.style[n] = j0[n];
                    for (const n in z0) LO[n] = document.body.style[n], document.body.style[n] = z0[n];
                    document.body.scrollTop = W0
                }() : function() {
                    for (const n in j0) document.documentElement.style[n] = FO[n];
                    for (const n in z0) document.body.style[n] = LO[n];
                    document.body.scrollTop = 0, document.documentElement.scrollTop = W0
                }())
            })
        }, tt("select", "select"), tt("selected", "check"), tt("loader", "spinner"), Dt("isLoading"), Dt("loadMore")]
    },
    zi = Hi("tg"),
    {
        outer: ume,
        wrapper: dme,
        label: HRe,
        prefix: fme,
        suffix: hme,
        help: pme,
        messages: mme,
        message: gme,
        icon: _me
    } = ji(zi),
    yme = zi("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            type: "checkbox",
            id: "$id",
            value: "$_value",
            checked: "$checked",
            onInput: "$handlers.toggles",
            onBlur: "$handlers.blur",
            disabled: "$disabled"
        }
    })),
    vme = zi("label", () => ({
        if: "($label && $onValueLabel === undefined && $offValueLabel === undefined) || ($valueLabelDisplay === inner) && $altLabelPosition !== true",
        $el: "label",
        attrs: {
            for: "$id"
        },
        children: "$label"
    })),
    bme = zi("altLabel", () => ({
        $el: "label",
        if: "($label && ($onValueLabel || $offValueLabel) && $valueLabelDisplay !== hidden && $valueLabelDisplay !== inner) || $altLabelPosition === true",
        attrs: {
            for: "$id",
            "data-label-alt": "true",
            style: {
                color: {
                    if: "$checked",
                    then: "$valueLabelColorOn",
                    else: "$valueLabelColorOff"
                }
            }
        },
        children: "$label"
    })),
    wme = zi("innerLabel", () => ({
        $el: "div",
        if: "$valueLabelDisplay === inner && ($checked && $onValueLabel || $offValueLabel)",
        attrs: {
            style: {
                color: {
                    if: "$checked",
                    then: "$valueLabelColorOn",
                    else: "$valueLabelColorOff"
                }
            }
        },
        children: {
            if: "$checked",
            then: "$onValueLabel",
            else: "$offValueLabel"
        }
    })),
    Eme = zi("valueLabel", () => ({
        $el: "label",
        if: "$valueLabelDisplay !== hidden && $valueLabelDisplay !== inner && (($checked === true && $onValueLabel) || ($checked === false && $offValueLabel))",
        attrs: {
            for: "$id"
        },
        children: {
            if: "$checked && $onValueLabel",
            then: "$onValueLabel",
            else: {
                if: "$offValueLabel",
                then: "$offValueLabel"
            }
        }
    })),
    Sme = zi("inner", () => ({
        $el: "label",
        attrs: {
            for: "$id",
            id: "$id + '_label'"
        }
    })),
    Tme = zi("track", () => ({
        $el: "div",
        attrs: {
            style: {
                backgroundColor: {
                    if: "$checked",
                    then: "$trackColorOn",
                    else: "$trackColorOff"
                }
            }
        }
    })),
    $me = zi("thumb", () => ({
        $el: "div",
        attrs: {
            style: {
                color: {
                    if: "$checked",
                    then: "$iconColorOn",
                    else: "$iconColorOff"
                },
                backgroundColor: {
                    if: "$checked",
                    then: "$thumbColorOn",
                    else: "$thumbColorOff"
                }
            }
        }
    })),
    kme = {
        schema: ume(dme(bme(), Sme(fme(), yme(), Tme(wme(), $me(Mt("$slots.default", "$slots.default", _me("thumb")))), hme()), Eme(), vme()), pme("$help"), mme(gme("$message.value"))),
        type: "input",
        props: ["checked", "thumbColorOff", "thumbColorOn", "iconColorOff", "iconColorOn", "valueLabelColorOff", "valueLabelColorOn", "offValue", "offValueLabel", "onValue", "onValueLabel", "thumbIcon", "trackColorOff", "trackColorOn", "valueLabelDisplay", "altLabelPosition"],
        features: [function(e) {
            function t(n, r) {
                r.target instanceof HTMLInputElement && (n.input(r.target.checked ? n.props.onValue : n.props.offValue), n.props.checked = r.target.checked)
            }
            e.on("created", () => {
                e.props.disabled = Ye(e.props.disabled), e.props.altLabelPosition = Ye(e.props.altLabelPosition), e.props.offValue === void 0 && (e.props.offValue = !1), e.props.onValue === void 0 && (e.props.onValue = !0), e.props.checked = Qe(e.value, e.props.onValue), e.context && (e.context.handlers.toggles = t.bind(null, e))
            }), e.on("commit", ({
                payload: n
            }) => {
                e.props.checked = Qe(n, e.props.onValue)
            })
        }]
    },
    $n = Hi("rp"),
    {
        outer: Ime,
        inner: xme,
        prefix: Cme,
        suffix: Ame,
        help: Rme,
        messages: Ome,
        message: Dme,
        icon: Nm
    } = ji($n),
    Nme = $n("insertControl", () => ({
        $el: "button",
        attrs: {
            disabled: "$value.length >= $max",
            onClick: "$fns.createInsert($item.__key)",
            type: "button"
        }
    })),
    Pme = $n("addButton", () => ({
        $formkit: "button",
        bind: "$addAttrs",
        if: "$addButton",
        disabled: "$value.length >= $max",
        onClick: "$fns.createAppend()",
        type: "button"
    })),
    Mme = $n("removeControl", () => ({
        $el: "button",
        attrs: {
            disabled: "$value.length <= $min",
            onClick: "$fns.createRemover($item.__key)",
            type: "button"
        }
    })),
    Lme = $n("items", () => ({
        $el: "ul",
        attrs: {
            role: "list"
        }
    })),
    Fme = $n("item", () => ({
        $el: "li",
        for: ["item", "index", "$value"],
        if: "$item.__key",
        attrs: {
            role: "listitem",
            key: "$item.__key",
            "data-index": "$item.__index"
        }
    })),
    Ume = $n("downControl", () => ({
        $el: "button",
        attrs: {
            disabled: "$index >= $value.length - 1",
            onClick: "$fns.createShift($item.__key, 1)",
            type: "button"
        }
    })),
    Bme = $n("upControl", () => ({
        $el: "button",
        attrs: {
            disabled: "$index <= 0",
            onClick: "$fns.createShift($item.__key, -1)",
            type: "button"
        }
    })),
    Vme = $n("content", "div"),
    Hme = $n("fieldset", () => ({
        $el: "fieldset",
        attrs: {
            id: "$id",
            disabled: "$disabled"
        }
    })),
    jme = $n("legend", () => ({
        $el: "legend",
        if: "$label"
    })),
    zme = $n("group", () => ({
        $formkit: "group",
        id: "$item.__key",
        index: "$item.__index"
    })),
    Wme = $n("controls", () => ({
        $el: "ul",
        if: "$removeControl || $insertControl || $upControl || $downControl"
    })),
    Gme = $n("remove", () => ({
        $el: "li",
        if: "$removeControl"
    })),
    qme = $n("insert", () => ({
        $el: "li",
        if: "$insertControl"
    })),
    Yme = $n("up", () => ({
        $el: "li",
        if: "$upControl"
    })),
    Kme = $n("down", () => ({
        $el: "li",
        if: "$downControl"
    })),
    Pm = $n("controlLabel", "span");
let Xme = 0;
const Uk = new Set,
    Qme = {
        schema: Ime(Hme(jme("$label"), Rme("$help"), xme(Cme(), Mt("$slots.default", Lme(Fme(Vme(zme("$slots.default")), Wme(Yme(Bme(Pm("$ui.moveUp.value"), Nm("moveUp"))), Gme(Mme(Pm("$ui.remove.value"), Nm("remove"))), qme(Nme(Pm("$ui.add.value"), Nm("add"))), Kme(Ume(Pm("$ui.moveDown.value"), Nm("moveDown"))))))), Ame()), Pme('$addLabel || ($ui.add.value + " " + ($label || ""))')), Ome(Dme("$message.value"))),
        type: "list",
        props: ["min", "max", "total", "upControl", "downControl", "removeControl", "insertControl", "addLabel", "addButton", "addAttrs"],
        features: [function(e) {
            const t = new Set,
                n = {
                    value: 0
                };
            ba(e, "removeControl", !0), ba(e, "upControl", !0), ba(e, "downControl", !0), ba(e, "insertControl", !1), ba(e, "addButton", !0), ba(e, "addLabel", !1), ba(e, "addAttrs", {}), e.plugins.add(Hhe), e.plugins.add(Whe.bind(null, t)), e.hook.input((r, s) => s(zhe(r, e, t, n))), e.on("commit", ({
                payload: r
            }) => {
                Uk.has(e) && e.input(r, !1)
            }), e.hook.commit((r, s) => {
                if (n.value && Array.isArray(r) && r.forEach((i, o) => {
                        const a = Object.isFrozen(i) && e.children.findIndex(l => l.props.id === i.__key);
                        if (a !== !1 && a !== -1) {
                            n.value--;
                            const l = i.__index,
                                c = i.__original;
                            Object.defineProperty(c, "__index", {
                                configurable: !0,
                                value: l
                            });
                            const u = IH(r);
                            u.splice(o, 1), u.splice(l, 0, c);
                            const [d] = e._c.children.splice(a, 1);
                            d && e._c.children.splice(l, 0, d), n.value === 0 && (hO(e, r), r.forEach(f => delete f.__index))
                        }
                    }), Array.isArray(r)) {
                    hO(e, r);
                    const i = r[r.length - 1];
                    ml(i) && "__shim" in i && function(o) {
                        const a = o.findIndex(l => ml(l) && "__shim" in l);
                        a !== -1 && o.splice(a)
                    }(r)
                }
                return s(r)
            }), e.on("created", jhe)
        }, Dt("remove"), Dt("add"), Dt("moveUp"), Dt("moveDown"), tt("remove", "trash"), tt("add", "add"), tt("moveUp", "arrowUp"), tt("moveDown", "arrowDown")]
    },
    VO = typeof window != "undefined",
    Hl = Hi("rt"),
    {
        outer: Jme,
        wrapper: Zme,
        inner: ege,
        label: tge,
        prefix: nge,
        suffix: rge,
        help: sge,
        messages: ige,
        message: oge,
        icon: Mm
    } = ji(Hl),
    age = Hl("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            id: "$id",
            type: "range",
            max: "$max",
            name: "$name",
            min: "0",
            disabled: "$disabled",
            step: "$step",
            onInput: "$handlers.DOMInput",
            onBlur: "$handlers.blur",
            value: "$_value",
            style: {
                position: "absolute",
                zIndex: "0",
                top: 0,
                right: 0,
                bottom: 0,
                opacity: "0"
            }
        }
    })),
    lge = Hl("itemsWrapper", () => ({
        $el: "div",
        attrs: {
            style: {
                position: "relative",
                zIndex: "2"
            },
            id: "$id + _items_wrapper",
            onMousemove: "$hoverHighlight && $handlers.ratingHoverOver",
            onMouseleave: "$hoverHighlight && $handlers.ratingHoverOut",
            onTouchstart: "$handlers.ratingHoverOver",
            onTouchmove: "$handlers.ratingHoverOver",
            onTouchend: "$handlers.handleClick",
            onClick: "$handlers.handleClick"
        }
    })),
    cge = Hl("onItems", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_on_wrapper"',
            style: {
                position: "relative",
                display: "flex",
                width: '$onWidth + "%"',
                top: "0",
                bottom: "0",
                left: "0",
                overflow: "hidden",
                color: "$onColor"
            }
        }
    })),
    uge = Hl("offItems", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_off_wrapper"',
            style: {
                position: "absolute",
                display: "flex",
                flexDirection: "row-reverse",
                width: '$offWidth + "%"',
                top: "0",
                bottom: "0",
                right: "0",
                overflow: "hidden",
                color: "$offColor"
            }
        }
    })),
    dge = Hl("onItemWrapper", () => ({
        $el: "div",
        for: ["item", "index", "$max"],
        attrs: {
            style: {
                flex: "$wrapperWidth"
            }
        }
    })),
    fge = Hl("offItemWrapper", () => ({
        $el: "div",
        for: ["item", "index", "$max"],
        attrs: {
            style: {
                flex: "$wrapperWidth"
            }
        }
    })),
    hge = {
        schema: Jme(Zme(tge("$label"), ege(Mm("prefix"), nge(), lge(cge(dge(Mt("$slots.onItem", () => () => "$slots.onItem", Mt("$slots.default", () => () => "$slots.default", Mm("rating"))))), uge(fge(Mt("$slots.offItem", () => () => "$slots.offItem", Mt("$slots.default", () => () => "$slots.default", Mm("rating")))))), age(), rge(), Mm("suffix"))), sge("$help"), ige(oge("$message.value"))),
        type: "input",
        props: [],
        features: [function(e) {
            e.addProps(["onWidth", "offWidth", "wrapperWidth", "max", "min", "icon", "step", "hoverHighlight", "ratingIcon", "onColor", "offColor"]), e.props.max = e.props.max || 5, e.props.min = e.props.min || 0, e.props.step = e.props.step || 1, e.props.hoverHighlight !== !1 && (e.props.hoverHighlight = !0), e.props.disabled = Ye(e.props.disabled), e.on("created", () => {
                VO && (e.props.initialBodyOverflow = document.documentElement.style.overflow), e.context && (e.context.handlers.ratingHoverOver = qhe.bind(null, e), e.context.handlers.ratingHoverOut = Yhe.bind(null, e), e.context.handlers.handleClick = Ghe.bind(null, e), VO && Ws(`${e.props.id}`, () => {
                    U0(e),
                        function(t) {
                            const n = document.getElementById(`${t.props.id}_items_wrapper`);
                            if (!n) return;
                            new ResizeObserver(() => {
                                U0(t)
                            }).observe(n)
                        }(e), setTimeout(() => U0(e), 100)
                }))
            }), e.on("input", () => Ok(e)), e.hook.input((t, n) => {
                if (t === null || t === "" || isNaN(t)) return n(t);
                const r = Number(t),
                    s = Number(e.props.min),
                    i = Number(e.props.max);
                return r > i ? n(i) : e.props.min && r <= s ? n(s) : n(r)
            })
        }, tt("rating", "star")]
    },
    x1 = new WeakSet,
    HO = new WeakMap,
    jO = new WeakMap,
    fj = new WeakMap,
    C1 = new WeakMap,
    Y0 = new WeakMap,
    zO = typeof window != "undefined";
let WO = !1;
const to = new WeakMap,
    Lm = new WeakMap,
    GO = new WeakSet,
    K0 = typeof window != "undefined",
    Wi = Hi("ac"),
    {
        outer: pge,
        wrapper: mge,
        inner: gge,
        icon: ec,
        label: _ge,
        prefix: yge,
        suffix: vge,
        help: bge,
        messages: wge,
        message: Ege
    } = ji(Wi),
    Sge = Wi("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            id: "$id",
            type: "text",
            onClick: "$handlers.click",
            onBlur: "$handlers.blur",
            onKeydown: "$handlers.keydown",
            onInput: "$handlers.input",
            value: "$inputText",
            placeholder: "$isLoadingOption && $ui.isLoading.value || $placeholder || undefined",
            tabindex: "0",
            role: "combobox",
            autocomplete: "off",
            autocapitalize: "none",
            readonly: "$attrs.readonly || $isLoadingOption || $multiple && $max && $value && $value.length >= $max && $hasHighlightedRange !== true || undefined",
            "data-selection-appearance": "$selectionAppearance",
            disabled: "$disabled || undefined",
            onTouchmove: "$handlers.touchmove",
            onTouchstart: "$handlers.touchmove",
            onTouchend: "$handlers.touchend",
            onFocus: "$handlers.focus",
            onFocusout: "$handlers.focusOut",
            "aria-autocomplete": "list",
            "aria-expanded": "$expanded",
            "aria-controls": '$expanded && $id + "_listbox" || undefined',
            "aria-describedBy": "$describedBy",
            "aria-activedescendant": "$expanded && $activeDescendant || undefined"
        }
    })),
    Tge = Wi("listboxButton", () => ({
        $el: "button",
        attrs: {
            style: "$visibilityStyles",
            id: '$id + "_listbox_button"',
            type: "button",
            onClick: "$handlers.toggleListbox",
            tabindex: "-1",
            "aria-haspopup": "true",
            "aria-expanded": "$expanded",
            "aria-controls": '$expanded && $id + "_listbox" || undefined'
        }
    })),
    qO = Wi("selection", () => ({
        for: ["option", "index", "$selections"],
        $el: "div",
        attrs: {
            key: "$option.value",
            "data-value": "$option.value",
            tabindex: "0",
            onClick: "$handlers.selectTag($option)",
            onFocus: "$handlers.selectTag($option)"
        }
    })),
    YO = Wi("selections", () => ({
        $el: "div",
        attrs: {
            "aria-live": "polite",
            id: '$id + "_selections"',
            onKeydown: "$handlers.keydown"
        }
    })),
    KO = Wi("removeSelection", () => ({
        $el: "button",
        if: "$_value !== undefined",
        attrs: {
            id: '$id + "_remove_selection_" + $index',
            tabindex: "-1",
            type: "button",
            onClick: "$disabled !== true && $handlers.removeSelection($option)",
            "aria-controls": "$id"
        }
    })),
    XO = Wi("optionLoading", "span"),
    QO = Wi("option", () => ({
        $el: "div",
        if: "$_value !== undefined"
    })),
    $ge = Rk(Wi),
    kge = {
        schema: pge(mge(_ge("$label"), gge(ec("prefix"), yge(), Sge(), Mt("$multiple !== true && $selectionAppearance === option", YO(qO(QO(Mt("$state.loading", XO("$ui.isLoading.value"), "$option.label")), KO(ec("close"))))), Mt("$state.loading", ec("loader")), Tge(ec("select")), $ge(), vge(), ec("suffix")), Mt("$multiple && $selectionAppearance === option", YO(qO(QO(Mt("$state.loading", XO("$ui.isLoading.value"), "$option.label")), KO(ec("close")))))), bge("$help"), wge(Ege("$message.value"))),
        type: "input",
        family: "dropdown",
        props: [],
        features: [Ul, VH, Ik(Ak, xk(b1, Lp)), BH(b1), tt("select", "select"), tt("close", "close"), tt("selected", "check"), tt("loader", "spinner"), Dt("isLoading"), Dt("loadMore")]
    },
    it = Hi("dp"),
    {
        outer: Ige,
        wrapper: xge,
        inner: Cge,
        icon: vd,
        label: Age,
        prefix: Rge,
        suffix: Oge,
        help: Dge,
        messages: Nge,
        message: Pge
    } = ji(it),
    Mge = it("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            id: "$id",
            onKeydown: "$handlers.inputKeydown",
            value: "$inputText",
            onInput: "$handlers.dateInput",
            onClick: "$pickerOnly && $handlers.open",
            onBlur: "$handlers._blur",
            onFocus: "$handlers.focus",
            readonly: "$pickerOnly || $expanded",
            disabled: "$disabled"
        }
    })),
    Lge = it("panelWrapper", () => ({
        $el: "div",
        if: "$expanded",
        attrs: {
            id: "$id + _panels",
            role: "dialog",
            "aria-modal": "true",
            "aria-label": "Choose date"
        }
    })),
    Fge = it("next", () => ({
        $el: "button",
        if: "$showPagination",
        attrs: {
            id: "$id + _next_button",
            onBlur: "$handlers._blurOut",
            type: "button",
            onClick: "$handlers.next"
        }
    })),
    Uge = it("nextLabel", "span"),
    Bge = it("prev", () => ({
        $el: "button",
        if: "$showPagination",
        attrs: {
            id: "$id + _prev_button",
            onBlur: "$handlers._blurOut",
            type: "button",
            onClick: "$handlers.prev"
        }
    })),
    Vge = it("prevLabel", "span"),
    Hge = it("calendar", () => ({
        if: '$panel === "day"',
        $el: "table",
        for: ["month", "$calendar"],
        attrs: {
            key: '$fns.format($month.monthDay, "YYYY-MM")'
        }
    })),
    jge = it("calendarWeeks", () => ({
        $el: "tbody"
    })),
    zge = it("calendarHeader", () => ({
        $el: "thead"
    })),
    Wge = it("weekDays", () => ({
        $el: "tr"
    })),
    Gge = it("weekDay", () => ({
        $el: "th",
        for: ["day", "$month.weeks.0"],
        attrs: {
            "aria-label": '$fns.format($day, "dddd")'
        }
    })),
    qge = it("week", () => ({
        $el: "tr",
        for: ["week", "$month.weeks"]
    })),
    Yge = it("dayCell", () => ({
        $el: "td",
        for: ["day", "$week"],
        attrs: {
            key: '$: "day" + $fns.format($day, "D")',
            onClick: "$handlers.setDate($day)",
            onKeydown: "$handlers.keyDown",
            onMouseenter: "$handlers.mouseEnter($day)",
            onMouseleave: "$handlers.mouseLeave",
            onBlur: "$handlers._blurOut",
            tabindex: '$fns.sameDay($day) && "0" || "-1"',
            "data-is-extra": "$fns.notInMonth($month.monthDay, $day)",
            "data-disabled": "$fns.isDisabled($day)",
            "aria-selected": "$fns.isSelected($day)",
            "aria-label": '$fns.format($day, "long")'
        }
    })),
    Kge = it("day", "div"),
    Xge = it("openButton", () => ({
        $el: "button",
        attrs: {
            style: "$visibilityStyles",
            id: '$id + "_listbox_button"',
            type: "button",
            onClick: "$handlers.open",
            tabIndex: '$pickerOnly && "-1" || "0"',
            disabled: "$disabled",
            "aria-label": '$value && ($ui.changeDate.value + ", " + $inputText) || $ui.chooseDate.value',
            "aria-haspopup": "true",
            "aria-expanded": "$expanded",
            "aria-controls": '$expanded && $id + "_listbox" || undefined'
        }
    })),
    Qge = it("years", () => ({
        if: '$panel === "year"',
        $el: "ul"
    })),
    Jge = it("year", () => ({
        for: ["year", "$years"],
        $el: "li",
        attrs: {
            key: '$: "year" + $fns.format($year, "YYYY")',
            onClick: "$handlers.setDate($year)",
            onKeydown: "$handlers.keyDown",
            onMouseenter: "$handlers.mouseEnter($year)",
            onMouseleave: "$handlers.mouseLeave",
            onBlur: "$handlers._blurOut",
            tabindex: '$fns.sameYear($year) && "0" || "-1"',
            "aria-selected": "$fns.isSelected($year)",
            "data-disabled": "$fns.isDisabledYear($year)"
        }
    })),
    Zge = it("months", () => ({
        if: '$panel === "month"',
        $el: "ul"
    })),
    e_e = it("month", () => ({
        $el: "li",
        for: ["month", "$months"],
        attrs: {
            key: '$: "month" + $fns.format($month, "M")',
            onClick: "$handlers.setDate($month)",
            onKeydown: "$handlers.keyDown",
            onMouseenter: "$handlers.mouseEnter($month)",
            onMouseleave: "$handlers.mouseLeave",
            onBlur: "$handlers._blurOut",
            tabindex: '$fns.sameMonth($month) && "0" || "-1"',
            "aria-selected": "$fns.isSelected($month)",
            "data-disabled": "$fns.isDisabledMonth($month)"
        }
    })),
    t_e = it("panelHeader", () => ({
        $el: "header",
        attrs: {
            "aria-live": "polite"
        }
    })),
    n_e = it("yearsHeader", () => ({
        $el: "div",
        if: '$panel === "year"'
    })),
    r_e = it("monthsHeader", () => ({
        $el: "div",
        if: '$panel === "month"'
    })),
    s_e = it("daysHeader", () => ({
        $el: "div",
        if: '$panel === "day"'
    })),
    i_e = it("timeHeader", () => ({
        $el: "div",
        if: '$panel === "time"'
    })),
    X0 = it("yearButton", () => ({
        $el: "button",
        attrs: {
            id: "$id + _year_button",
            onClick: "$handlers.jumpTo(year)",
            onBlur: "$handlers._blurOut"
        },
        children: "$fns.format($renderedDate, $yearFormat)"
    })),
    JO = it("monthButton", () => ({
        $el: "button",
        attrs: {
            id: "$id + _month_button",
            onClick: "$handlers.jumpTo(month)",
            onBlur: "$handlers._blurOut"
        },
        children: "$fns.format($renderedDate, $monthButtonFormat)"
    })),
    o_e = it("dayButton", () => ({
        $el: "button",
        attrs: {
            id: "$id + _day_button",
            onClick: "$handlers.jumpTo(day)",
            onBlur: "$handlers._blurOut",
            tabindex: "2"
        },
        children: "$fns.format($renderedDate, $dayButtonFormat)"
    })),
    a_e = it("time", () => ({
        $el: "div",
        if: '$panel === "time"'
    })),
    l_e = it("timeInput", () => ({
        $el: "input",
        attrs: {
            type: "time",
            value: "$localTime",
            onInput: "$handlers.localTime",
            onKeydown: "$handlers.keyDown",
            spellcheck: "false",
            onBlur: "$handlers._blurOut"
        }
    })),
    {
        overlayPlaceholder: c_e,
        overlayLiteral: u_e,
        overlayChar: d_e,
        overlayEnum: f_e,
        overlay: h_e,
        overlayParts: p_e,
        overlayInner: m_e
    } = xH(it),
    g_e = it("panel", "div"),
    Ls = new WeakMap,
    El = new WeakMap,
    Pu = new WeakSet,
    __e = new WeakMap,
    vb = new WeakMap,
    A1 = new WeakSet,
    Eo = new WeakMap,
    my = /[\uD800-\uDBFF]/,
    xa = new WeakMap,
    Q0 = new WeakMap,
    J0 = new WeakMap,
    Tf = new WeakMap,
    xg = new WeakMap,
    Gc = new WeakSet,
    od = new WeakMap,
    bb = new WeakMap,
    Z0 = new WeakMap,
    Ka = new WeakMap;
let R1 = !1;
const ZO = () => {
        R1 = !0, setTimeout(() => {
            R1 = !1
        }, 500)
    },
    y_e = {
        "#": {
            type: "char",
            pattern: /\d/,
            token: "#",
            placeholder: "_",
            selectDirection: "right"
        },
        a: {
            type: "char",
            pattern: /[a-zA-Z]/,
            token: "a",
            placeholder: "_",
            selectDirection: "left"
        },
        h: {
            type: "char",
            pattern: /[0-9a-fA-F]/,
            token: "h",
            placeholder: "_",
            selectDirection: "left"
        },
        "*": {
            type: "char",
            pattern: /./,
            token: "*",
            placeholder: "_",
            selectDirection: "left"
        }
    },
    eD = new WeakMap,
    Bh = typeof window != "undefined";
let Cg = !1;
Bh && document.addEventListener("selectionchange", () => {
    if (!(document.activeElement instanceof HTMLInputElement)) return;
    const e = document.activeElement;
    if (Ka.has(e)) return function(n) {
        const r = Ka.get(n);
        if (r) {
            const [s, i] = r, [o, a] = $r(n), l = a.indexOf(s);
            if (l === -1) return void Ka.delete(n);
            const c = o[l],
                u = [c[0] + i[0], c[1], "none"];
            wl(Ms(n), u) || uy(n, u)
        }
    }(e);
    if (Eo.get(e) !== "select") return;
    const t = Ms(e);
    if (!wl(t, eD.get(e))) {
        if (eD.set(e, t), Pu.has(e)) return Pu.delete(e);
        e.dispatchEvent(new CustomEvent("selection", {
            detail: Ms(e)
        }))
    }
});
const Bk = "1999-03-04T02:05:01.000Z",
    ew = new Map,
    Vk = [
        ["YYYY", {
            year: "numeric"
        }],
        ["YY", {
            year: "2-digit"
        }],
        ["MMMM", {
            month: "long"
        }],
        ["MMM", {
            month: "short"
        }],
        ["MM", {
            month: "2-digit"
        }],
        ["M", {
            month: "numeric"
        }],
        ["DD", {
            day: "2-digit"
        }],
        ["D", {
            day: "numeric"
        }],
        ["dddd", {
            weekday: "long"
        }],
        ["ddd", {
            weekday: "short"
        }],
        ["d", {
            weekday: "narrow"
        }],
        ["mm", {
            minute: "2-digit"
        }],
        ["m", {
            minute: "numeric"
        }],
        ["ss", {
            second: "2-digit"
        }],
        ["s", {
            second: "numeric"
        }],
        ["Z", {
            timeZoneName: "short"
        }]
    ],
    Hk = [
        ["HH", {
            hour: "2-digit"
        }],
        ["H", {
            hour: "numeric"
        }]
    ],
    jk = [
        ["hh", {
            hour: "2-digit"
        }],
        ["h", {
            hour: "numeric"
        }],
        ["a", {
            dayPeriod: "narrow"
        }],
        ["A", {
            dayPeriod: "narrow"
        }]
    ],
    gy = {
        DD: 2,
        HH: 2,
        MM: 2,
        YY: 2,
        YYYY: 4,
        hh: 2,
        mm: 2,
        ss: 2,
        Z: 5
    },
    v_e = ["MMMM", "MMM", "dddd", "ddd"],
    Pt = new Map([...Vk, ...Hk, ...jk].map(e => [e[0], e])),
    tD = new Map,
    hj = ["full", "long", "medium", "short"],
    nD = /^([0-9]{4})-([0-1][0-9])(?:-([0-3][0-9]))?(?:[T ]?([0-2][0-9])(?::([0-5][0-9]))?(?::([0-5][0-9]))?)?(?:\.[0-9]{3})?(Z|(?:\+|\-)[0-9]{4})?$/,
    no = e => String(e).padStart(2, "0"),
    tw = e => String(e).padStart(2, "0"),
    rD = typeof window != "undefined",
    O1 = new WeakSet,
    nw = new WeakSet,
    D1 = new WeakSet,
    _y = new WeakMap,
    pj = new WeakMap,
    rw = new WeakSet,
    N1 = new WeakSet,
    $f = new WeakSet,
    b_e = typeof window != "undefined",
    sD = new WeakMap,
    w_e = {
        schema: Ige(xge(Age("$label"), Cge(vd("prefix"), Rge(), h_e(m_e(p_e(c_e("$part.value"), u_e("$part.value"), d_e("$part.value"), f_e("$part.value")))), Mge(), Lge(t_e(Bge(Vge("$ui.prev.value"), vd("prev")), n_e("$decade"), r_e(X0()), s_e(JO(), X0()), i_e(JO(), o_e(), X0()), Fge(Uge("$ui.next.value"), vd("next"))), g_e(Qge(Jge("$fns.format($year, $yearFormat)")), Zge(e_e("$fns.format($month, $monthFormat)")), Hge(zge(Wge(Gge("$fns.format($day, $weekdayFormat)"))), jge(qge(Yge(Kge("$fns.format($day, $dateFormat)"))))), a_e(l_e()))), Xge(vd("calendar")), Oge(), vd("suffix"))), Dge("$help"), Nge(Pge("$message.value"))),
        type: "input",
        family: "text",
        props: ["dateFormat", "dayButtonFormat", "format", "monthButtonFormat", "monthFormat", "overlay", "pickerOnly", "showMonths", "showPagination", "weekStart", "weekdayFormat", "yearFormat", "years"],
        features: [oj, function(e) {
            var t, n, r, s, i, o, a, l, c, u, d, f, h, p, m, g, y, _, E, b, w, T;
            e.addProps(["_isDisabled", "_isFocused", "activeDate", "calendar", "disabled", "decade", "disabledDays", "expanded", "inputText", "localTime", "maxDate", "maxScan", "minDate", "months", "offset", "paginatedPanels", "panel", "pickerOnly", "renderedDate", "sequence", "timezone", "valueFormat", "valueLocale"]), e.hook.prop((v, $) => (v.prop === "expanded" && e.props.disabled && (v.value = !1), v.prop === "weekStart" && (v.value = Number(v.value || 0)), v.prop === "showMonths" && (v.value = Number(v.value || 1)), v.prop === "maxScan" && (v.value = Number(v.value || 7)), v.prop === "timezone" && (typeof e._value == "string" || e._value instanceof Date) && (e.props.offset = T1(e._value, v.value)), $(v))), e.props._isFocused = !1, e.props._isPlaceholder = !1, (t = (f = e.props).valueFormat) !== null && t !== void 0 || (f.valueFormat = "ISO8601"), (n = (h = e.props).weekdayFormat) !== null && n !== void 0 || (h.weekdayFormat = "d"), (r = (p = e.props).monthFormat) !== null && r !== void 0 || (p.monthFormat = "MMM"), (s = (m = e.props).monthButtonFormat) !== null && s !== void 0 || (m.monthButtonFormat = "MMMM"), (i = (g = e.props).dayButtonFormat) !== null && i !== void 0 || (g.dayButtonFormat = "D"), (o = (y = e.props).dateFormat) !== null && o !== void 0 || (y.dateFormat = "D"), (a = (_ = e.props).yearFormat) !== null && a !== void 0 || (_.yearFormat = "YYYY"), (l = (E = e.props).paginatedPanels) !== null && l !== void 0 || (E.paginatedPanels = ["day", "year"]), (c = (b = e.props).valueLocale) !== null && c !== void 0 || (b.valueLocale = e.props.locale), (u = (w = e.props).format) !== null && u !== void 0 || (w.format = "long"), e.props.panels = RO(e), e.props.pickerOnly = Ye(e.props.pickerOnly), e.props.disabled = Ye(e.props.disabled), (d = (T = e.props).maxScan) !== null && d !== void 0 || (T.maxScan = 7), e.props._isDisabled = typeof e.props.disabledDays == "function" ? e.props.disabledDays.bind(null, e) : _pe.bind(null, e),
                function(v) {
                    const $ = v._value;
                    let k = new Date;
                    if ($ instanceof Date) k = zt($);
                    else if (typeof $ == "string") try {
                        k = zt(oo($, v.props.valueFormat, v.props.valueLocale))
                    } catch {
                        console.warn(`Date (${$}) does not match format (${Pk(v.props.valueFormat,v.props.valueLocale)})`), k = void 0
                    } else $ || (k = void 0);
                    if (v.props.offset = v.props.timezone ? T1(k || new Date, v.props.timezone) : "+0000", v.props.minDate) {
                        const O = typeof v.props.minDate == "string" ? oo(v.props.minDate) : v.props.minDate;
                        v.props.minDate = Jl(O, v.props.offset)
                    }
                    if (v.props.maxDate) {
                        const O = typeof v.props.maxDate == "string" ? oo(v.props.maxDate) : v.props.maxDate;
                        v.props.maxDate = Jl(O, v.props.offset)
                    }
                    k = k && Jl(k, v.props.offset), k && Om(v, k, !1);
                    let C = k || new Date;
                    C = v.props.minDate > C ? v.props.minDate : C, v.props.renderedDate = C, v.props.activeDate = C, v.props.localTime = k && Rr(k, "HH:mm") || "12:00"
                }(e), e.props.calendar = [], e.props.inputText = "", e.props.showMonths = e.props.showMonths || 1, typeof e.props.format == "function" ? (e.props.formatDate = e.props.format, e.props.format = null) : e.props.formatDate = Rr, e.on("created", () => {
                    if (Ws(`${e.props.id}`, mpe.bind(null, e)), e.context) {
                        let v;
                        e.context.fns.format = ($, k) => Rr($, k, e.props.locale || "en", !1, Ef), e.context.fns.isDisabled = e.props._isDisabled, e.context.fns.isDisabledMonth = $ => !gd($, k => !e.props._isDisabled(k), "month"), e.context.fns.isDisabledYear = $ => !gd($, k => !e.props._isDisabled(k), "year"), e.context.fns.isSelected = $ => {
                            var k;
                            const C = (k = e.context) === null || k === void 0 ? void 0 : k.value;
                            if (C != null) return xO($, Jl(C instanceof Date ? C : oo(C, e.props.valueFormat, e.props.valueLocale), e.props.offset))
                        }, e.context.handlers._blur = () => {
                            var $, k;
                            e.props._isFocused = !1, typeof(($ = e.context) === null || $ === void 0 ? void 0 : $.handlers.blur) == "function" && ((k = e.context) === null || k === void 0 || k.handlers.blur())
                        }, e.context.handlers._blurOut = () => {
                            e.props.expanded && setTimeout(() => {
                                var $;
                                return (($ = document.activeElement) === null || $ === void 0 ? void 0 : $.closest(`#${e.props.id}_panels`)) || $f.has(e) ? $f.delete(e) : void(e.props.expanded = !1)
                            }, 150)
                        }, e.context.handlers.overlayClick = () => {
                            const $ = _y.get(e);
                            $ && ($.focus(), e.props._isPlaceholder = !1)
                        }, e.context.handlers.focus = () => {
                            e.props._isFocused = !0, e.props.pickerOnly && !nw.has(e) && (D1.add(e), e.props.expanded = !0, setTimeout(() => D1.delete(e), 200))
                        }, e.context.handlers.dateInput = $ => {
                            var k;
                            if (rw.has(e)) return rw.delete(e);
                            if ($.target instanceof HTMLInputElement && !e.props.expanded) try {
                                let C = oo({
                                    date: $.target.value,
                                    format: e.props.format,
                                    locale: e.props.locale,
                                    partFilter: Ef
                                });
                                if (function(O) {
                                        return Nu(O.props.format, O.props.locale).some(R => R.partName === "weekday")
                                    }(e) && e.props.activeDate instanceof Date && e.props.activeDate.getTime() === C.getTime() && !Ka.get($.target) && Rr(C, e.props.format, e.props.locale, !1, Ef) !== $.target.value) {
                                    const O = yb("dddd", e.props.locale),
                                        R = Nu(e.props.format, e.props.locale),
                                        N = (k = tj($.target.value, R).find(Y => Y.token === "dddd")) === null || k === void 0 ? void 0 : k.value,
                                        J = Rr(C, "dddd", e.props.locale);
                                    if (N && O.includes(N) && J !== N) {
                                        let Y = O.indexOf(N) - O.indexOf(J);
                                        Y = Y < -1 ? 7 + Y : Y, C = Wc(C, Y), O1.add(e)
                                    }
                                }
                                Om(e, C)
                            } catch {
                                Om(e, void 0)
                            }
                        }, e.context.handlers.open = () => {
                            e.props.expanded = !0
                        }, e.context.handlers.next = () => {
                            switch (e.props.panel) {
                                case "year":
                                    return void(e.props.renderedDate = fc(e.props.renderedDate, 10));
                                case "day":
                                    return void(e.props.renderedDate = co(e.props.renderedDate, 1))
                            }
                        }, e.context.handlers.prev = () => {
                            switch (e.props.panel) {
                                case "year":
                                    return void(e.props.renderedDate = fc(e.props.renderedDate, -10));
                                case "day":
                                    return void(e.props.renderedDate = co(e.props.renderedDate, -1))
                            }
                        }, e.context.handlers.setDate = $ => () => {
                            var k;
                            e.props.panel !== "month" && e.props.panel !== "year" || !e.props.activeDate || ($ = e.props.activeDate), !((k = e.context) === null || k === void 0) && k.fns.isDisabled($) || e.emit("dateSelected", $)
                        }, e.context.handlers.localTime = $ => {
                            const k = $.target;
                            if (!k.value) return;
                            const [C, O] = k.value.split(":");
                            e.props.localTime = k.value, e.props.activeDate.setHours(C, O), _d(e, e.props.activeDate)
                        }, e.context.handlers.keyDown = $ => {
                            switch (e.props.panel) {
                                case "day":
                                    return e.emit("calendarKeydown", $);
                                case "year":
                                    return e.emit("yearKeydown", $);
                                case "month":
                                    return e.emit("monthKeydown", $);
                                case "time":
                                    return e.emit("timeKeydown", $);
                                default:
                                    return
                            }
                        }, e.context.handlers.inputKeydown = $ => {
                            e.emit("keydown", $)
                        }, e.context.handlers.mouseEnter = $ => k => {
                            clearTimeout(v), k.target instanceof HTMLElement && k.target.getAttribute("tabindex") === "-1" && k.target.getAttribute("data-is-extra") !== "true" && (e.props.panel === "month" || e.props.panel === "year" ? e.props.activeDate = gd($, C => !e.props._isDisabled(C), e.props.panel) : e.props.activeDate = $)
                        }, e.context.handlers.mouseLeave = () => {
                            clearTimeout(v), v = setTimeout(() => {}, 100)
                        }, e.context.handlers.jumpTo = $ => () => {
                            e.props.panels.unshift(e.props.panel), e.props.panel = $
                        }, e.context.fns.sameDay = $ => {
                            var k;
                            return ((k = e.context) === null || k === void 0 ? void 0 : k.activeDate) instanceof Date && xO($, e.context.activeDate)
                        }, e.context.fns.sameMonth = $ => {
                            var k;
                            return ((k = e.context) === null || k === void 0 ? void 0 : k.activeDate) instanceof Date && $.getMonth() === e.context.activeDate.getMonth()
                        }, e.context.fns.sameYear = $ => {
                            var k, C;
                            return ((k = e.context) === null || k === void 0 ? void 0 : k.activeDate) instanceof Date && $.getFullYear() === ((C = e.context) === null || C === void 0 ? void 0 : C.activeDate.getFullYear())
                        }, e.context.fns.notInMonth = ($, k) => {
                            const C = function(O) {
                                const R = zt(O);
                                return R.setHours(0, 0, 0), R
                            }(k).getTime();
                            return C < kO($).getTime() || C > dy($).getTime() || void 0
                        }
                    }
                });
            const S = ppe.bind(null, e);
            e.on("prop:panel", ({
                payload: v
            }) => {
                e.props.showPagination = e.props.paginatedPanels.includes(v)
            }), e.on("dateSelected", ({
                payload: v
            }) => {
                v && e.props._isDisabled(v) || (Array.isArray(e.props.panels) && e.props.panels.length ? e.props.panel = e.props.panels.shift() : e.props.expanded = !1, Om(e, v))
            }), e.on("input", ({
                payload: v
            }) => {
                const $ = new Date,
                    k = v ? _d(e, Jl(typeof v == "string" ? oo(v, e.props.valueFormat, e.props.valueLocale) : v, e.props.offset)) : $;
                e.props.activeDate = !v && e.props.activeDate ? e.props.activeDate : k, e.props.renderedDate = !v && e.props.renderedDate ? e.props.renderedDate : k, e.props.localTime = Rr(k, "HH:mm"),
                    function(C) {
                        const O = pj.get(C);
                        if (C._value && O) {
                            const R = Up(C.props.activeDate);
                            if (O.length > R) O.splice(R, O.length - R);
                            else if (O.length < R)
                                for (let N = O.length + 1; N <= R; N++) O.push(String(N))
                        }
                    }(e)
            }), e.on("prop:renderedDate", AO.bind(null, e)), e.on("prop:expanded", ({
                payload: v
            }) => {
                var $;
                if (v) {
                    if ($f.delete(e), e.props.panels = RO(e), e.props.panel = e.props.panels.shift(), e.props.panel === "day") {
                        const k = e.props.activeDate;
                        e.props.activeDate = gd(e.props.activeDate, C => !e.props._isDisabled(C), "month") || k
                    }
                    AO(e), Ws(`${e.props.id}_panels`, k => {
                        const C = k.querySelector('[tabindex="0"]');
                        C && (C.focus(), function(O, R) {
                            const N = new MutationObserver(Y => {
                                for (const ie of Y) ie.type === "attributes" && ie.target instanceof HTMLElement && ie.target.getAttribute("tabindex") === "0" ? ie.target.focus() : ie.addedNodes.length && ie.addedNodes.forEach(ce => {
                                    var Ue;
                                    if (ce instanceof HTMLElement && ce.getAttribute("tabindex") === "0") ce.focus();
                                    else if (ce instanceof HTMLElement && ce.querySelector('[tabindex="0"]')) {
                                        const Kt = ce.querySelector('[tabindex="0"]');
                                        Kt instanceof HTMLElement && Kt.focus()
                                    } else ce instanceof HTMLElement && ce.querySelector('input[type="time"]') && ((Ue = ce.querySelector('input[type="time"]')) === null || Ue === void 0 || Ue.focus())
                                })
                            });
                            N.observe(R, {
                                attributes: !0,
                                attributeFilter: ["tabindex"],
                                childList: !0,
                                subtree: !0
                            });
                            const J = O.on("prop:expanded", ({
                                payload: Y
                            }) => {
                                Y || (O.off(J), N.disconnect())
                            })
                        }(e, k))
                    }), rD && setTimeout(() => {
                        document.addEventListener("click", S)
                    }, 10)
                } else {
                    if (e.props.panel === "time") e.emit("dateSelected", e.props.activeDate);
                    else if (e._value) {
                        rw.add(e);
                        const k = typeof e._value == "string" ? oo(e._value, e.props.valueFormat, e.props.valueLocale) : e._value;
                        _d(e, Jl(k, e.props.offset))
                    } else _d(e, void 0);
                    rD && (nw.add(e), document.removeEventListener("click", S), N1.has(e) || ($ = document.getElementById(`${e.props.id}`)) === null || $ === void 0 || $.focus(), N1.delete(e), setTimeout(() => nw.delete(e), 50))
                }
            }), e.on("prop:activeDate", ({
                payload: v
            }) => {
                if (Array.isArray(e.props.calendar) && e.props.calendar.length) {
                    if (e.props.panel === "day") {
                        const $ = e.props.calendar,
                            k = kO(e.props.renderedDate),
                            C = dy(co(e.props.renderedDate, $.length - 1));
                        v.getTime() < k.getTime() ? e.props.renderedDate = co(e.props.renderedDate, -1) : v.getTime() > C.getTime() && (e.props.renderedDate = co(e.props.renderedDate))
                    } else if (e.props.panel === "year") {
                        const $ = e.props.years,
                            k = $[0].getFullYear(),
                            C = $[$.length - 1].getFullYear(),
                            O = e.props.activeDate.getFullYear();
                        O > C ? e.props.renderedDate = fc(e.props.renderedDate, 10) : O < k && (e.props.renderedDate = fc(e.props.renderedDate, -10))
                    }
                }
                e.props.expanded && _d(e, e.props.activeDate)
            }), e.on("keydown", ({
                payload: v
            }) => {
                switch (v.key) {
                    case "ArrowDown":
                    case "ArrowUp":
                    case " ":
                        e.props.pickerOnly && (e.props.expanded = !0);
                        break;
                    case "Enter":
                    case "Return":
                        e.props.expanded || (e.props.expanded = !0);
                        break;
                    case "Escape":
                        e.props.expanded = !1
                }
            }), e.on("calendarKeydown", ({
                payload: v
            }) => {
                let $ = null,
                    k = 0;
                switch (v.key) {
                    case "ArrowRight":
                        k = 1;
                        break;
                    case "ArrowLeft":
                        k = -1;
                        break;
                    case "ArrowDown":
                        k = 7;
                        break;
                    case "ArrowUp":
                        k = -7;
                        break;
                    case "Return":
                    case "Enter":
                        e.emit("dateSelected", e.props.activeDate);
                        break;
                    case "Tab":
                        v.shiftKey || H0(e, v);
                        break;
                    case "Escape":
                        e.props.expanded = !1
                }
                if (k && (v.preventDefault(), $ = Wc(e.props.activeDate, k)), $ && !e.props._isDisabled($)) e.props.activeDate = $;
                else if ($ && e.props._isDisabled($)) {
                    const C = k > 0 ? 1 : -1;
                    Po(Number(e.props.maxScan), O => C * O).some(O => {
                        const R = Wc($, O);
                        return !e.props._isDisabled(R) && (e.props.activeDate = R, !0)
                    })
                }
            }), e.on("yearKeydown", ({
                payload: v
            }) => {
                let $;
                switch (v.key) {
                    case "ArrowDown":
                        $ = 5;
                        break;
                    case "ArrowRight":
                        $ = 1;
                        break;
                    case "ArrowUp":
                        $ = -5;
                        break;
                    case "ArrowLeft":
                        $ = -1;
                        break;
                    case "Tab":
                        v.shiftKey || H0(e, v);
                        break;
                    case "Return":
                    case "Enter":
                        e.emit("dateSelected", e.props.activeDate);
                        break;
                    case "Escape":
                        e.props.expanded = !1
                }
                const k = e.props.activeDate.getFullYear() + $ - e.props.renderedDate.getFullYear();
                e.props.activeDate = fc(e.props.renderedDate, k)
            }), e.on("monthKeydown", ({
                payload: v
            }) => {
                let $ = 0;
                switch (v.key) {
                    case "ArrowDown":
                        $ = 3;
                        break;
                    case "ArrowRight":
                        $ = 1;
                        break;
                    case "ArrowLeft":
                        $ = -1;
                        break;
                    case "ArrowUp":
                        $ = -3;
                        break;
                    case "Tab":
                        v.shiftKey || H0(e, v);
                        break;
                    case "Return":
                    case "Enter":
                        e.emit("dateSelected", e.props.activeDate);
                        break;
                    case "Escape":
                        e.props.expanded = !1
                }
                $ && v.preventDefault();
                let k = (e.props.activeDate.getMonth() + $) % 12;
                k = k < 0 ? 12 + k : k;
                const C = k - e.props.renderedDate.getMonth();
                let O = co(e.props.renderedDate, C);
                if (e.props._isDisabled(O)) {
                    const R = gd(O, N => !e.props._isDisabled(N), "month");
                    R && (O = R)
                }
                e.props.activeDate = O
            }), e.on("timeKeydown", ({
                payload: v
            }) => {
                switch (v.key) {
                    case "Return":
                    case "Enter":
                        v.preventDefault(), e.emit("dateSelected", e.props.activeDate)
                }
            }), e.on("prop:_isFocused", () => {
                _y.get(e) && ij(e)
            }), e.on("commit", () => {
                if (e.props.activeDate && e.props._isDisabled(e.props.activeDate)) {
                    const v = Nn({
                        blocking: !0,
                        key: "rule_invalidDate",
                        meta: {
                            messageKey: "invalidDate",
                            removeImmediately: !1,
                            localize: !0,
                            i18nArgs: [{
                                node: e,
                                name: ype(e),
                                args: []
                            }]
                        },
                        type: "validation",
                        value: "The selected date is invalid."
                    });
                    e.store.set(v)
                } else e.store.remove("rule_invalidDate")
            })
        }, Dt("next"), Dt("prev"), Dt("changeDate"), Dt("chooseDate"), tt("next", "right"), tt("prev", "left"), tt("calendar", "date")]
    },
    Ys = Hi("tl"),
    {
        outer: E_e,
        wrapper: S_e,
        inner: T_e,
        icon: bd,
        label: $_e,
        prefix: k_e,
        suffix: I_e,
        help: x_e,
        messages: C_e,
        message: A_e
    } = ji(Ys),
    R_e = Ys("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            id: "$id",
            type: "text",
            onClick: "$handlers.click",
            onBlur: "$handlers.blur",
            onKeydown: "$handlers.keydown",
            onInput: "$handlers.input",
            onFocus: "$handlers.focus",
            value: "$inputText",
            tabindex: "0",
            placeholder: "$isLoadingOption && $ui.isLoading.value || $placeholder || undefined",
            role: "combobox",
            autocomplete: "off",
            autocapitalize: "none",
            readonly: "$attrs.readonly || $isLoadingOption || undefined || $multiple && $max && $value && $value.length >= $max",
            disabled: "$disabled || undefined",
            onTouchmove: "$handlers.touchmove",
            onTouchstart: "$handlers.touchmove",
            onTouchend: "$handlers.touchend",
            "aria-autocomplete": "list",
            "aria-expanded": "$expanded",
            "aria-controls": '$expanded && $id + "_listbox" || undefined',
            "aria-describedBy": "$describedBy",
            "aria-activedescendant": "$expanded && $activeDescendant || undefined"
        }
    })),
    O_e = Ys("listboxButton", () => ({
        $el: "button",
        attrs: {
            style: "$visibilityStyles",
            id: '$id + "_listbox_button"',
            type: "button",
            onClick: "$handlers.toggleListbox",
            tabindex: "-1",
            disabled: "$disabled || undefined",
            "aria-haspopup": "true",
            "aria-expanded": "$expanded",
            "aria-controls": '$expanded && $id + "_listbox" || undefined'
        }
    })),
    D_e = Ys("tagWrapper", () => ({
        $el: "span",
        for: ["option", "index", "$selections"],
        attrs: {
            id: '$id + "_tag-wrapper_" + $index',
            key: "$option.value",
            "data-value": "$option.value",
            tabindex: "-1",
            onClick: "$handlers.selectTag($option)"
        }
    })),
    N_e = Ys("tag", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_tag_" + $index',
            role: "button"
        }
    })),
    P_e = Ys("removeSelection", () => ({
        $el: "button",
        if: "$_value !== undefined",
        attrs: {
            id: '$id + "_remove_selection_" + $index',
            tabindex: "-1",
            type: "button",
            onClick: "$disabled !== true && $handlers.removeSelection($option)",
            "aria-controls": "$id"
        }
    })),
    M_e = Ys("tagLabel", () => ({
        $el: "span"
    })),
    L_e = Ys("tags", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_selections"',
            "aria-live": "polite",
            onKeydown: "$handlers.keydown"
        }
    })),
    F_e = Ys("tagLoading", "span"),
    U_e = Rk(Ys),
    B_e = {
        schema: E_e(S_e($_e("$label"), T_e(bd("prefix"), k_e(), L_e(D_e(N_e(Mt("$state.loading", F_e("$ui.isLoading.value"), M_e("$option.label")), P_e(bd("close")))), R_e()), Mt("$state.loading", bd("loader")), O_e(bd("select")), U_e(), I_e(), bd("suffix"))), x_e("$help"), C_e(A_e("$message.value"))),
        type: "input",
        family: "dropdown",
        props: [],
        features: [Ul, VH, Ik(Ak, xk(OO, Lp)), BH(OO), tt("select", "select"), tt("close", "close"), tt("selected", "check"), tt("loader", "spinner"), Dt("isLoading"), Dt("loadMore")]
    },
    zk = Hi("mk"),
    {
        outer: V_e,
        wrapper: H_e,
        inner: j_e,
        label: z_e,
        prefix: W_e,
        suffix: G_e,
        help: q_e,
        messages: Y_e,
        message: K_e,
        icon: iD
    } = ji(zk),
    {
        overlayPlaceholder: X_e,
        overlayLiteral: Q_e,
        overlayChar: J_e,
        overlayEnum: Z_e,
        overlay: eye,
        overlayParts: tye,
        overlayInner: nye
    } = xH(zk),
    rye = zk("input", () => ({
        $el: "input",
        bind: "$attrs",
        attrs: {
            type: "$type",
            disabled: "$disabled",
            name: "$node.name",
            onBlur: "$handlers.blur",
            value: "$_maskValue",
            id: "$id",
            "aria-describedby": "$describedBy"
        }
    })),
    P1 = new WeakMap,
    M1 = new WeakMap,
    oD = new WeakMap,
    sye = {
        schema: V_e(H_e(z_e("$label"), j_e(iD("prefix"), W_e(), eye(nye(tye(X_e("$part.value"), Q_e("$part.value"), J_e("$part.value"), Z_e("$part.value")))), rye(), G_e(), iD("suffix"))), q_e("$help"), Y_e(K_e("$message.value"))),
        type: "input",
        props: ["allowIncomplete", "mask", "mode", "tokens", "showMask", "unmaskValue", "prefix", "suffix", "reverse", "overlay"],
        family: "text",
        features: [oj, function(e) {
            e.addProps(["_maskValue", "_overlayParts"]), e.on("created", () => {
                var t, n, r, s, i;
                const o = HH(typeof e._value == "string" ? e._value : "");
                M1.set(e, o), oD.set(e, o), e.props.allowIncomplete = Ye(e.props.allowIncomplete), e.props.overlay = Ye(e.props.overlay);
                const a = !(e.props.showMask !== void 0 && !Ye(e.props.showMask));
                e.props.unmaskValue = Ye(e.props.unmaskValue), e.hook.prop((c, u) => (c.prop === "unmaskValue" && (c.value = Ye(c)), u(c)));
                const l = {
                    placeholder: a,
                    pattern: (t = e.props.mask) !== null && t !== void 0 ? t : "",
                    mode: (n = e.props.mode) !== null && n !== void 0 ? n : "shift",
                    partOverrides: (r = e.props.tokens) !== null && r !== void 0 ? r : {},
                    prefix: (s = e.props.prefix) !== null && s !== void 0 ? s : void 0,
                    suffix: (i = e.props.suffix) !== null && i !== void 0 ? i : void 0,
                    reverse: Ye(e.props.reverse)
                };
                P1.set(e, l), e.hook.input((c, u) => u(function(d, f) {
                    const h = M1.get(d),
                        p = typeof f == "object" && "maskValue" in f;
                    f = typeof f == "string" ? f : p ? f.maskValue : "";
                    const m = oD.get(d);
                    m.value = Nk(m, f);
                    const g = yO(m, P1.get(d)),
                        y = JH(m, d.props.allowIncomplete);
                    return f === h.value ? d.props.unmaskValue ? y != null ? y : "" : y === null ? "" : typeof f == "string" ? f : "" : f === "" && h.value !== "" && !d.props.allowIncomplete ? f : (p || g === d.props._maskValue || (h.value = g, d.props._maskValue = g, d.props._overlayParts = kk(ZH(m) || [])), y === null ? "" : d.props.unmaskValue ? y : g)
                }(e, c))), e.props._maskValue = yO(o, l), e.input(e.props._maskValue, !1), Ws(`${e.props.id}`, bpe.bind(null, e))
            })
        }]
    },
    Je = Hi("tf"),
    {
        outer: iye,
        wrapper: oye,
        inner: jRe,
        icon: Qs,
        prefix: zRe,
        suffix: WRe,
        help: aye,
        messages: lye,
        message: cye
    } = ji(Je),
    uye = Je("fieldset", () => ({
        $el: "fieldset",
        attrs: {
            id: '$id + "_fieldset"',
            role: "presentation",
            "aria-describedby": {
                if: "$help",
                then: '$: "help-" + $id',
                else: void 0
            }
        }
    })),
    dye = Je("legend", () => ({
        if: "$label",
        $el: "legend"
    })),
    fye = Je("source", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_source"',
            class: '$classes.transferlist + " " + $classes.source'
        }
    })),
    hye = Je("sourceHeader", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_source_header"',
            role: "presentation",
            class: '$classes.transferlistHeader + " " + $classes.sourceHeader'
        }
    })),
    pye = Je("sourceHeaderLabel", () => ({
        if: "$sourceLabel",
        $el: "label",
        attrs: {
            id: '$id + "_source_header_label"',
            for: '$id + "_source_search_input"',
            class: '$classes.transferlistHeaderLabel + " " + $classes.sourceHeaderLabel'
        },
        children: "$sourceLabel || $label"
    })),
    mye = Je("sourceHeaderItemCount", () => ({
        $el: "span",
        attrs: {
            id: '$id + "_source_header_item_count"',
            role: "presentation",
            "aria-label": '$fns.getOptionCount() + " items"',
            class: '$classes.transferlistHeaderItemCount + " " + $classes.sourceHeaderItemCount'
        },
        children: "$fns.getOptionCount()"
    })),
    gye = Je("targetHeaderLabel", () => ({
        if: "$targetLabel",
        $el: "label",
        attrs: {
            id: '$id + "_target_header_label"',
            for: '$id + "_target_search_input"',
            class: '$classes.transferlistHeaderLabel + " " + $classes.targetHeaderLabel'
        },
        children: "$targetLabel || $label"
    })),
    _ye = Je("targetHeaderItemCount", () => ({
        $el: "span",
        attrs: {
            id: '$id + "_target_header_item_count"',
            role: "presentation",
            "aria-label": '$fns.getOptionCount(true) + " items"',
            class: '$classes.transferlistHeaderItemCount + " " + $classes.targetHeaderItemCount'
        },
        children: "$fns.getOptionCount(true)"
    })),
    yye = Je("sourceControls", () => ({
        $el: "div",
        if: "$searchable",
        attrs: {
            id: '$id + "_source_controls"',
            class: '$classes.transferlistControls + " " + $classes.sourceControls'
        }
    })),
    vye = Je("sourceSearch", () => ({
        if: "$searchable",
        $el: "div",
        attrs: {
            id: '$id + "_source_search"',
            class: '$classes.transferlistSearch + " " + $classes.sourceSearch'
        }
    })),
    bye = Je("sourceSearchInput", () => ({
        $el: "input",
        attrs: {
            id: '$id + "_source_search_input"',
            type: "text",
            placeholder: "$placeholder",
            onInput: "$handlers.onSearch",
            value: "$inputText",
            onKeydown: "$handlers.handleSourceSearchKeyDown",
            disabled: "$disabled",
            "aria-label": "Search",
            role: "searchbox",
            class: '$classes.transferlistSearchInput + " " + $classes.sourceSearchInput'
        }
    })),
    wye = Je("sourceSearchClear", () => ({
        $el: "button",
        if: "$inputText !== undefined",
        attrs: {
            id: '$id + "_source_search_clear"',
            type: "button",
            onClick: "$handlers.clearSearch",
            "aria-label": "Clear search",
            class: '$classes.transferlistSearchClear + " " + $classes.sourceSearchClear'
        }
    })),
    Eye = Je("sourceListItems", () => ({
        $el: "ul",
        attrs: {
            id: '$id + "_source_list_items"',
            "aria-activedescendant": "$activeDescendant",
            onMouseover: "$handlers.onMouseEnter(true)",
            onMouseout: "$handlers.onMouseLeave(true)",
            role: "listbox",
            "aria-multiselectable": "true",
            "aria-roledescription": "List of options to choose from.",
            class: '$classes.transferlistListItems + " " + $classes.sourceListItems',
            onKeydown: "$handlers.sourceKeyDown",
            tabindex: "0",
            onFocus: "$handlers.sourceFocused"
        }
    })),
    Sye = Je("sourceListItem", () => ({
        for: ["option", "index", "$sourceOptions"],
        $el: "li",
        attrs: {
            id: '$id + "_source_list_item_" + $index',
            "data-value": "$option.value",
            "aria-selected": "$selections && $selections.length > 0 && $fns.isSelected($option)",
            "data-is-active": "$fns.isActive($option)",
            "data-disabled": "$option.attrs.disabled",
            role: "option",
            onClick: "$option.attrs.disabled !== true && $handlers.selectOption($option, true)",
            key: "$option.value",
            class: '$classes.transferlistListItem + " " + $classes.sourceListItem'
        }
    })),
    Tye = Je("sourceOption", () => ({
        $el: "div",
        attrs: {
            "data-checked": "$selections && $selections.length > 0 && $fns.isSelected($option)",
            class: '$classes.transferlistOption + " " + $classes.sourceOption'
        }
    })),
    $ye = Je("sourceLoadMore", () => ({
        $el: "li",
        if: "$targetLoading !== true && $state.loading || $state.hasNextPage",
        attrs: {
            id: '$id + "_source_load_more"',
            key: "loadMore",
            "aria-selected": "false",
            class: '$classes.transferlistLoadMore + " " + $classes.sourceLoadMore'
        }
    })),
    aD = Je("loadMoreInner", "span"),
    kye = Je("target", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_target"',
            class: '$classes.transferlist + " " + $classes.target'
        }
    })),
    Iye = Je("targetHeader", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_target_header"',
            role: "presentation",
            class: '$classes.transferlistHeader + " " + $classes.targetHeader'
        }
    })),
    xye = Je("targetListItems", () => ({
        $el: "ul",
        attrs: {
            id: "$id",
            "aria-activedescendant": "$activeDescendant",
            onMouseover: "$handlers.onMouseEnter(false)",
            onMouseout: "$handlers.onMouseLeave(false)",
            class: '$classes.transferlistListItems + " " + $classes.targetListItems',
            tabindex: "0",
            onKeydown: "$handlers.targetKeyDown",
            onFocus: "$handlers.targetFocused"
        }
    })),
    Cye = Je("targetListItem", () => ({
        for: ["option", "index", "$targetOptions"],
        $el: "li",
        attrs: {
            id: '$id + "_target_list_item_" + $index',
            "data-disabled": "$option.attrs.disabled",
            "data-value": "$option.value",
            "aria-selected": "$selections && $selections.length && $fns.isSelected($option, $target)",
            "data-is-active": "$fns.isActive($option)",
            role: "option",
            onClick: "$option.attrs.disabled !== true && $handlers.selectOption($option, false)",
            key: "$option.value",
            class: '$classes.transferlistListItem + " " + $classes.targetListItem'
        }
    })),
    Aye = Je("targetOption", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_target_list_item_" + $index',
            class: '$classes.transferlistOption + " " + $classes.targetOption'
        }
    })),
    Rye = Je("targetLoadMore", () => ({
        $el: "li",
        if: "$targetLoading && $state.loading",
        attrs: {
            id: '$id + "_target_load_more"',
            key: "loadMore",
            "aria-selected": "false",
            class: '$classes.transferlistLoadMore + " " + $classes.targetLoadMore'
        }
    })),
    Oye = Je("transferControls", () => ({
        $el: "div",
        attrs: {
            id: '$id + "_transfer_controls"'
        }
    })),
    Dye = Je("transferButtonForward", () => ({
        if: "$transferOnSelect !== true",
        $el: "button",
        attrs: {
            id: '$id + "_transfer_button_forward"',
            type: "button",
            disabled: "$selections.length === 0 || $sourceSelected === false || $disabled || ($max && $value && $value.length >= $max)",
            onClick: "$handlers.transferForward",
            "aria-label": "$ui.addSelectedValues.value",
            title: "$ui.addSelectedValues.value",
            class: '$classes.transferlistButton + " " + $classes.transferButtonForward'
        }
    })),
    Nye = Je("transferButtonForwardAll", () => ({
        $el: "button",
        attrs: {
            id: '$id + "_transfer_button_forward_all"',
            type: "button",
            disabled: "$options.length === $targetOptions.length || $disabled || ($max && $value && $value.length >= $max)",
            onClick: "$handlers.transferForwardAll",
            "aria-label": "$ui.addAllValues.value",
            title: "$ui.addAllValues.value",
            class: '$classes.transferlistButton + " " + $classes.transferButtonForwardAll'
        }
    })),
    Pye = Je("transferButtonBackward", () => ({
        if: "$transferOnSelect !== true",
        $el: "button",
        attrs: {
            id: '$id + "_transfer_button_backward"',
            onClick: "$handlers.transferBackward",
            type: "button",
            disabled: "$selections.length === 0 || $sourceSelected === true || $disabled",
            "aria-label": "$ui.removeSelectedValues.value",
            title: "$ui.removeSelectedValues.value",
            class: '$classes.transferlistButton + " " + $classes.transferButtonBackward'
        }
    })),
    Mye = Je("transferButtonBackwardAll", () => ({
        $el: "button",
        attrs: {
            id: '$id + "_transfer_button_backward_all"',
            onClick: "$handlers.transferBackwardAll",
            type: "button",
            disabled: "$targetOptions.length === 0 || $disabled",
            "aria-label": "$ui.removeAllValues.value",
            title: "$ui.removeAllValues.value",
            class: '$classes.transferlistButton + " " + $classes.transferButtonBackwardAll'
        }
    })),
    Fm = Je("controlLabel", "span"),
    Lye = Je("sourceEmptyMessage", () => ({
        $el: "li",
        if: "$showSourceEmptyMessage && $sourceEmptyMessage && $state.loading !== true",
        attrs: {
            id: '$id + "_source_empty_message"',
            key: "$sourceEmptyMessage",
            role: "presentation"
        }
    })),
    Fye = Je("targetEmptyMessage", () => ({
        $el: "li",
        if: "$showTargetEmptyMessage && $targetEmptyMessage",
        attrs: {
            id: '$id + "_empty_message"',
            key: "$emptyMessage",
            role: "presentation"
        }
    })),
    lD = Je("emptyMessageInner", "span"),
    cs = new WeakMap,
    Sl = new WeakMap,
    L1 = new WeakMap,
    qc = new WeakMap,
    Wk = new WeakMap,
    cD = new WeakSet,
    wb = new WeakMap,
    Yc = new WeakMap,
    Uye = typeof window != "undefined";
let xe = null,
    na = [],
    Kc = !1,
    F1 = !1;
Uye && (document.addEventListener("dragover", function(e) {
    e.preventDefault()
}), document.addEventListener("dragend", () => {
    F1 ? F1 = !1 : function() {
        if (Lk(xe) && Fh(xe.parentNode)) {
            const e = wb.get(xe);
            xe.parentNode.dispatchEvent(new CustomEvent("dndDrop", {
                detail: e
            }))
        }
        lj()
    }()
}));
const wd = new WeakSet,
    Ed = new WeakSet,
    uD = new WeakMap,
    sw = new WeakMap,
    Sd = typeof window != "undefined",
    Bye = {
        schema: iye(uye(dye("$label"), aye("$help"), oye(fye(hye(pye(), mye()), yye(vye(bye(), wye(Qs("close")))), Eye(Lye(lD("$sourceEmptyMessage")), Sye(Mt("$transferOnSelect !== true && $fns.isSelected($option)", Qs("selected")), Tye("$option.label")), $ye(aD(Mt("$targetLoading !== true && $state.loading", Qs("loader")), "$state.loading && $ui.isLoading.value || $ui.loadMore.value")))), Oye(Nye(Fm("$ui.addAllValues.value"), Qs("fastForward")), Dye(Fm("$ui.addSelectedValues.value"), Qs("moveRight")), Pye(Fm("$ui.removeSelectedValues.value"), Qs("moveLeft")), Mye(Fm("$ui.removeAllValues.value"), Qs("rewind"))), kye(Iye(gye(), _ye()), xye(Fye(Mt("$state.loading !== true", lD("$targetEmptyMessage"))), Cye(Mt("$transferOnSelect !== true && $fns.isSelected($option)", Qs("selected")), Aye("$option.label")), Rye(aD(Mt("$targetLoading && $state.loading", Qs("loader")), "$state.loading && $ui.isLoading.value || $ui.loadMore.value"))))), lye(cye("$message.value")))),
        type: "input",
        props: ["options", "selections", "activeValue", "activeDescendant", "sourceSelected", "targetOptions", "sourceOptions", "target", "source", "optionLoader", "filterOptions", "inputText", "renderList", "search", "hasNextPage", "page", "targetOptionValues", "targetLoading", "searchable", "sourceLabel", "targetLabel", "transferOnSelect", "disabled", "placeholder", "filter", "showSourceEmptyMessage", "showTargetEmptyMessage", "sourceEmptyMessage", "targetEmptyMessage", "clearOnSelect", "max", "debounce"],
        features: [function(e) {
            function t(u, d) {
                d && (u.props.showTargetEmptyMessage = d.length === 0 || d === !1, d = d || [], u.props.newTargetValue && u.props.isSourceOption && !u.props.dropped && !u.props.forceUpdate || (u.props.sourceOptions = [...u.props.options.filter(f => !d.find(h => de(f) === de(h)))]), (!u.props.newSourceValue || u.props.isSourceOption || u.props.dropped || u.props.forceUpdate) && (u.props.targetOptions = d), u.props.targetOptionValues = d.map(f => de(f)), u.props.showSourceEmptyMessage = u.props.sourceOptions && u.props.sourceOptions.length === 0, u.props.selections = [], u.props.dropped = !1, u.props.forceUpdate = !1)
            }

            function n(u) {
                const d = Array.isArray(u.props.options) ? u.props.options : [],
                    f = Array.isArray(u.props.memoOptions) ? u.props.memoOptions : [],
                    h = Array.isArray(u.props.targetOptions) ? u.props.targetOptions : [];
                u.props.targetOptions.length === 0 && (u.props.showTargetEmptyMessage = !0);
                const p = f.concat(d).concat(h);
                return !!p.length && !!Array.isArray(u.value) && u.value.reduce((m, g) => {
                    const y = p.find(_ => Qe(g, de(_)));
                    if (y) m.push(y);
                    else {
                        const _ = E => typeof E == "string" ? {
                            label: E,
                            value: g
                        } : y1(E) ? E : Bs(E) ? Object.assign({
                            label: String(g),
                            value: g
                        }, E) : {
                            label: String(g),
                            value: g
                        };
                        m.push(_(g))
                    }
                    return m
                }, [])
            }

            function r(u, d, f, h) {
                function p() {
                    const _ = y.findIndex(S => de(S) === de(d)),
                        E = y.findIndex(S => de(S) === de(u.props.selections[0])),
                        b = Math.min(_, E),
                        w = Math.max(_, E),
                        T = y.slice(b, w + 1);
                    u.props.selections = T
                }
                if (u.props.disabled || (u.props.isSourceOption !== f && (u.props.isSourceOption = f, u.props.selections = []), u.props.isSourceOption && Array.isArray(u._value) && u._value.length >= u.props.max)) return;
                const m = !!h && h.shiftKey && u.props.selections.length;
                if (u.props.isSourceOption = f, u.props.selections.map(_ => de(_)).includes(de(d))) {
                    const _ = u.props.selections.findIndex(E => de(E) === de(d));
                    return u.props.selections.splice(_, 1), void(u.props.selections = [...u.props.selections])
                }
                const y = f ? u.props.sourceOptions : u.props.targetOptions;
                u.props.sourceSelected === !f ? m ? p() : (u.props.selections = [...u.props.selections, d], u.props.sourceSelected = f) : m ? p() : u.props.selections = [...u.props.selections, d], u.props.transferOnSelect && (f ? i(u) : o(u))
            }

            function s(u, d) {
                const f = d.map(h => de(h));
                if (Array.isArray(u._value)) {
                    const h = u._value.filter(p => !f.includes(p));
                    u.props.selections = [], u.input(h), u.props.activeValue = void 0
                }
            }

            function i(u) {
                if (Array.isArray(u._value)) {
                    u.props.optionsLoader || u.props.clearOnSelect === !1 || (u.props.inputText = void 0);
                    const d = u.props.selections.map(h => de(h)),
                        f = [...u._value, ...d];
                    u.props.forceUpdate = !0, u.input(f), u.props.selections = []
                }
            }

            function o(u) {
                if (Array.isArray(u._value)) {
                    const d = u.props.selections.map(h => de(h)),
                        f = u._value.filter(h => !d.includes(h));
                    if (u.props.forceUpdate = !0, u.input(f), u.props.optionsLoader) {
                        const h = [...u.props.options];
                        u.props.options = [...h]
                    }
                    u.props.selections = []
                }
            }

            function a(u) {
                let d = null,
                    f = "",
                    h = [];
                if (e.props.mouseOnSource) {
                    if (d = wd.has(e), f = `${e.props.id}_source_list_item`, h = [...e.props.sourceOptions], !h || !h.length || d) return h = [], f = "", void(d = null)
                } else if (e.props.mouseOnTarget && (d = Ed.has(e), f = `${e.props.id}_target_list_item`, h = [...e.props.targetOptions], !h || !h.length || d)) return h = [], f = "", void(d = null);
                const p = h.reduce((g, y, _) => {
                        var E;
                        if (!((E = y.attrs) === null || E === void 0) && E.disabled) return g;
                        const b = document.getElementById(f + `_${_}`);
                        return b && g.push([b, y]), g
                    }, []),
                    m = document.getElementById(`${e.props.id}_load_more`);
                m && p.push([m, e.props.loadMoreOption]), e.props.mouseOnSource && wd.add(e), e.props.mouseOnTarget && Ed.add(e), p.length && l(e, p, null, u)
            }

            function l(u, d, f, h) {
                var p, m, g;
                const y = h,
                    _ = y ? y.getBoundingClientRect() : {
                        top: 0,
                        bottom: 0
                    };
                if (f = null, u.props.trackHover) {
                    if (u.props.mouseY > _.top && u.props.mouseY < _.bottom) {
                        let E = f || 0,
                            b = f;
                        const w = (T, S) => {
                            var v;
                            const $ = S[0],
                                {
                                    y: k,
                                    height: C,
                                    x: O,
                                    width: R
                                } = $.getBoundingClientRect();
                            if (u.props.mouseX > O && u.props.mouseX < O + R && u.props.mouseY > k && u.props.mouseY < k + C) {
                                f = T;
                                const N = S[1];
                                return u.props.activeValue = N && !(!((v = N.attrs) === null || v === void 0) && v.disabled) ? de(N) : void 0, !0
                            }
                            return !1
                        };
                        do {
                            if (E !== null && w(E, d[E]) || b !== null && w(b, d[b])) break;
                            E !== null && (E++, E > d.length - 1 && (E = null)), b !== null && (b--, b < 0 && (b = null))
                        } while (E !== null || b !== null)
                    }
                    f === null && (u.props.activeValue = void 0)
                } else c(u);
                u.props.mouseOnSource || u.props.mouseOnTarget ? (y && !(!((p = u.store.loading) === null || p === void 0) && p.value) && ((m = u.store.hasNextPage) === null || m === void 0 ? void 0 : m.value) && y.scrollTop + y.offsetHeight > y.scrollHeight - 200 && u.props.mouseOnSource && (u.props.allowAppendOptions = !0, (g = u.context) === null || g === void 0 || g.handlers.loadMore(!1)), u.props.mouseOnSource && wd.has(u) || u.props.mouseOnTarget && Ed.has(u) ? requestAnimationFrame(l.bind(null, u, d, f, h)) : a(h)) : (wd.delete(u), Ed.delete(u))
            }

            function c(u) {
                const d = document.getElementById(u.props.activeDescendant);
                d && d.scrollIntoView({
                    block: "nearest",
                    inline: "start"
                })
            }
            e.props.memoOptions = [], e.props.targetOptions = [], e.props.targetOptionValues = [], e.props.multiple = !0, e.props.loadingCounter = 0, e.props.page = 1, e.props.hasNextPage = DH.bind(null, e), e.props.applyLoadedOptions = FH, e.on("created", () => {
                if (e._value || e.input([], !1), e.props.options || (e.props.options = []), e.props.disabled = Ye(e.props.disabled), e.props.searchable = Ye(e.props.searchable), e.props.clearOnSelect === void 0 ? e.props.clearOnSelect = !0 : e.props.clearOnSelect === "false" && (e.props.clearOnSelect = !1), e.props.transferOnSelect === void 0 ? e.props.transferOnSelect = !0 : e.props.transferOnSelect === "false" && (e.props.transferOnSelect = !1), e.props.targetOptions.length && (e.props.targetOptionValues = e.props.targetOptions.map(u => de(u))), e.props.initialOptions = [...e.props.options], e.props.max && (e.props.max = parseInt(e.props.max)), e.props.selections = [], e.props.sourceSelected = !1, typeof e.props.filter != "function" && (e.props.filter = (u, d) => u.label.toLowerCase().includes(d.toLowerCase())), e.props.optionsLoader && e.props.options.length === 0 ? zc(e) : e.props.optionsLoader || e.props.options.length !== 0 || (e.props.showSourceEmptyMessage = !0), e.context) {
                    let u = function(E) {
                            return E._value ? E._value : []
                        },
                        d = function(E) {
                            return E.props.options.map(b => de(b)).filter(b => !E.props.targetOptionValues.includes(b))
                        },
                        f = function(E) {
                            return Sd && p(E)
                        },
                        h = function(E) {
                            return Sd && p(E, !1)
                        },
                        p = function(E, b = !0) {
                            if (!E.props.selections) return [];
                            const w = E.props.selections.map(S => S.value),
                                T = [];
                            for (const S of w) {
                                const v = b ? ".formkit-source-list-items" : ".formkit-target-list-items",
                                    $ = document.querySelector(`[data-type="transferlist"] ${v} [data-value="${S}"]`);
                                $ && T.push($)
                            }
                            return T
                        },
                        m = function(E) {
                            E.stopImmediatePropagation(), E.detail, e.props.trackHover = !1
                        },
                        g = function(E) {
                            return E.getAttribute("data-disabled") !== "true" && !E.classList.contains("formkit-source-empty-message") && !E.classList.contains("formkit-target-empty-message") && !E.classList.contains("formkit-transferlist-load-more") && E.style.display !== "none"
                        },
                        y = function(E) {
                            return E.props.disabled || E.props.max && Array.isArray(E._value) && E._value.length >= E.props.max
                        },
                        _ = function(E) {
                            return E.props.disabled
                        };
                    if (e.context.handlers.loadMore = NH.bind(null, e), e.context.fns.isActive = E => Qe(e.props.activeValue, de(E)) || void 0, e.context.fns.optionValue = de, e.context.fns.isSelected = E => e.props.selections.map(b => de(b)).includes(de(E)), e.context.fns.getOptionCount = (E = !1) => {
                            const b = E ? e.props.targetOptions : e.props.options;
                            let w;
                            return w = E ? b.length : b.filter(T => !e.props.targetOptionValues.includes(de(T))).length, e.props.selections.length > 0 && E !== e.props.isSourceOption ? e.props.selections.length + "/" + w : w
                        }, e.context.handlers.clearSearch = () => {
                            e.props.inputText = void 0
                        }, e.context.handlers.selectOption = (E, b) => r.bind(null, e, E, b), e.context.handlers.transferForward = i.bind(null, e), e.context.handlers.transferForwardAll = () => {
                            if (Array.isArray(e._value)) {
                                const E = e.props.options.filter(w => !w.attrs || !w.attrs.disabled).map(w => de(w));
                                e.props.max && E.length > e.props.max && (E.length = e.props.max);
                                const b = [...E];
                                e.props.forceUpdate = !0, e.input(b), e.props.selections = []
                            }
                        }, e.context.handlers.transferBackward = o.bind(null, e), e.context.handlers.transferBackwardAll = () => {
                            Array.isArray(e._value) && (e.props.forceUpdate = !0, e.input([]), e.props.selections = [])
                        }, e.context.handlers.onSearch = E => {
                            const b = E.target;
                            e.props.inputText = b.value === "" ? void 0 : b.value,
                                function(w, T, S = !1) {
                                    if (typeof w.props.optionsLoader == "function") {
                                        if (S && (w.props.options = []), w.props.search = T, clearTimeout(uD.get(w)), w.props.skipNextFilter) return void(w.props.skipNextFilter = !1);
                                        uD.set(w, setTimeout(() => {
                                            var v;
                                            w.props.page = 1, (v = w.context) === null || v === void 0 || v.handlers.loadMore(!0)
                                        }, w.props.debounce || 200))
                                    } else if (Array.isArray(w.props.initialOptions) && typeof T == "string") {
                                        const v = [...w.props.initialOptions].filter($ => Array.isArray(w._value) && !w._value.includes(de($)));
                                        w.props.options = v.filter($ => w.props.filter($, T, w))
                                    }
                                }(e, b.value)
                        }, e.context.handlers.handleSourceSearchKeyDown = E => function(b, w) {
                            if (w.key === "ArrowDown" || w.key === "Tab") {
                                w.preventDefault();
                                const T = document.getElementById(`${b.props.id}_source_list_items`);
                                T && T.focus()
                            }
                        }(e, E), e.context.handlers.sourceKeyDown = E => function(b, w) {
                            var T;
                            if (b.props.trackHover = !1, !(w.currentTarget && w.currentTarget instanceof HTMLElement)) return;
                            const S = b.props.options.filter(v => !b.props.targetOptionValues.includes(de(v)));
                            if (["ArrowDown", "ArrowUp"].includes(w.key)) {
                                if (w.preventDefault(), !Array.isArray(S) || !S.length) return;
                                const v = S.reduce((k, C) => {
                                    var O;
                                    return !((O = C == null ? void 0 : C.attrs) === null || O === void 0) && O.disabled || k.push(de(C)), k
                                }, []);
                                !((T = b.store.hasNextPage) === null || T === void 0) && T.value && v.push(Xr);
                                const $ = v.indexOf(b.props.activeValue);
                                if ($ === -1 && v.length) b.props.activeValue = v[0];
                                else if (w.key === "ArrowDown" && v.length > $ + 1) b.props.activeValue = v[$ + 1];
                                else if (w.key === "Tab" && v.length <= $ + 1) {
                                    const k = document.getElementById(`${b.props.id}_transfer_button_forward_all`);
                                    if (k) k.focus();
                                    else if (b.props.targetOptionValues.length && document.getElementById(`${b.props.id}_target_list_item_0`)) {
                                        const C = document.getElementById(`${b.props.id}`);
                                        C && (C.focus(), setTimeout(() => {
                                            b.props.activeValue = b.props.targetOptionValues[0]
                                        }))
                                    }
                                    b.props.activeValue = void 0
                                } else if (w.key === "ArrowUp" && $ > 0) b.props.activeValue = v[$ - 1];
                                else if (w.key === "ArrowUp" && $ === 0) {
                                    const k = document.getElementById(`${b.props.id}_source_search_input`);
                                    k && k.focus(), b.props.activeValue = void 0
                                }
                                c(b)
                            } else if (w.key === "Enter") {
                                if (w.preventDefault(), b.props.activeValue) {
                                    const v = S.find($ => de($) === b.props.activeValue);
                                    v && r(b, v, !0)
                                }
                                b.props.transferOnSelect && (b.props.activeValue = void 0)
                            } else if (w.key === "Backspace") b.props.selections.length && s(b, b.props.selections);
                            else if (w.key === "Tab" && w.shiftKey) {
                                w.preventDefault();
                                const v = document.getElementById(`${b.props.id}_source_search_input`);
                                v && (v.focus(), b.props.activeValue = void 0)
                            } else if (w.key === "Tab") {
                                w.preventDefault();
                                const v = document.getElementById(`${b.props.id}_transfer_button_forward_all`);
                                if (v) v.focus();
                                else if (b.props.targetOptionValues.length && document.getElementById(`${b.props.id}_target_list_item_0`)) {
                                    const $ = document.getElementById(`${b.props.id}`);
                                    $ && ($.focus(), setTimeout(() => {
                                        b.props.activeValue = b.props.targetOptionValues[0]
                                    }))
                                }
                                b.props.activeValue = void 0
                            }
                        }(e, E), e.context.handlers.targetKeyDown = E => function(b, w) {
                            var T;
                            if (b.props.trackHover = !1, !(w.currentTarget && w.currentTarget instanceof HTMLElement)) return;
                            const S = b.props.targetOptions;
                            if (["ArrowDown", "ArrowUp"].includes(w.key)) {
                                if (w.preventDefault(), !Array.isArray(S) || !S.length) return;
                                const v = S.reduce((k, C) => {
                                    var O;
                                    return !((O = C == null ? void 0 : C.attrs) === null || O === void 0) && O.disabled || k.push(de(C)), k
                                }, []);
                                !((T = b.store.hasNextPage) === null || T === void 0) && T.value && v.push(Xr);
                                const $ = v.indexOf(b.props.activeValue);
                                $ === -1 && v.length ? b.props.activeValue = v[0] : w.key === "ArrowDown" && v.length > $ + 1 ? b.props.activeValue = v[$ + 1] : w.key === "ArrowUp" && $ > 0 && (b.props.activeValue = v[$ - 1]), c(b)
                            } else if (w.key === "Enter") {
                                if (w.preventDefault(), b.props.activeValue) {
                                    const v = S.find($ => de($) === b.props.activeValue);
                                    v && r(b, v, !1)
                                }
                                b.props.transferOnSelect && (b.props.activeValue = void 0)
                            } else if (w.key === "Backspace") b.props.selections.length && s(b, b.props.selections);
                            else if (w.key === "Tab" && w.shiftKey) {
                                w.preventDefault();
                                const v = document.getElementById(`${b.props.id}_source_list_items`);
                                v && (b.props.activeValue = void 0, v.focus())
                            } else w.key === "Tab" && w.preventDefault()
                        }(e, E), e.context.handlers.sourceFocused = () => {
                            const E = e.props.options.filter(w => {
                                    var T;
                                    return !e.props.targetOptionValues.includes(de(w)) && !(!((T = w.attrs) === null || T === void 0) && T.disabled)
                                }),
                                b = E[0];
                            b && (e.props.activeValue = de(b))
                        }, e.context.handlers.targetFocused = () => {
                            const E = e.props.targetOptions[0];
                            E && (e.props.activeValue = de(E))
                        }, e.context.handlers.onMouseEnter = E => () => {
                            E ? e.props.mouseOnSource = !0 : e.props.mouseOnTarget = !0
                        }, e.context.handlers.onMouseLeave = E => () => {
                            E ? e.props.mouseOnSource = !1 : e.props.mouseOnTarget = !1
                        }, Sd) {
                        Ws(e.props.id + "_source_list_items", b => {
                            Ws(`${e.props.id}`, w => {
                                b instanceof HTMLElement && w instanceof HTMLElement && (b.addEventListener("dndNewValue", T => {
                                    if (T.stopImmediatePropagation(), !Array.isArray(e._value)) return;
                                    e.props.newTargetValue = !1, e.props.newSourceValue = !0;
                                    const S = e._value.filter(v => !T.detail.includes(v));
                                    e.input([...S])
                                }), w.addEventListener("dndNewValue", T => {
                                    T.stopImmediatePropagation(), e.props.newSourceValue = !1, e.props.newTargetValue = !0, e.input([...T.detail])
                                }), b.addEventListener("dndDrop", T => {
                                    if (e.props.dropped = !0, !Array.isArray(e._value)) return;
                                    const S = e._value.filter(v => !T.detail.includes(v));
                                    e.input([...S])
                                }), w.addEventListener("dndDrop", T => {
                                    e.props.dropped = !0, e.input([...T.detail])
                                }), b.addEventListener("dndDragStart", T => {
                                    e.props.isSourceOption = !0, m(T)
                                }), w.addEventListener("dndDragStart", T => {
                                    e.props.isSourceOption = !1, m(T)
                                }), document.addEventListener("dndDrop", () => {
                                    e.props.selections = [], e.props.trackHover = !0
                                }), NO(b, d.bind(null, e), {
                                    accepts: [w],
                                    dropBehavior: "append",
                                    childIsDraggable: g,
                                    isDisabled: y.bind(null, e)
                                }, f.bind(null, e)), NO(w, u.bind(null, e), {
                                    accepts: [w, b],
                                    childIsDraggable: g,
                                    isDisabled: _.bind(null, e)
                                }, h.bind(null, e)))
                            })
                        });
                        const E = b => {
                            e.props.mouseX = b.clientX, e.props.mouseY = b.clientY;
                            const w = e.props.mouseOnSource ? `${e.props.id}_source_list_items` : `${e.props.id}`,
                                T = document.getElementById(w);
                            if (T) {
                                const S = T.getBoundingClientRect();
                                b.clientX > S.x && b.clientX < S.x + S.width && b.clientY > S.y && b.clientY < S.y + S.height && (e.props.trackHover = !0)
                            }
                        };
                        document.addEventListener("mousemove", E)
                    }
                }
            }), e.on("commit", ({
                payload: u
            }) => {
                if (u === sw.get(e) && sw.get(e) !== void 0) return;
                if (sw.set(e, u), e.props.options === void 0 && (e.props.options = []), e.props.sourceOptions === void 0 && (e.props.sourceOptions = [...e.props.options]), Sd && u !== void 0 && typeof e.props.optionLoader == "function") {
                    const f = n(e);
                    if (e.props.multiple && Array.isArray(u))
                        if (u.forEach(h => {
                                v1(e, h, Array.isArray(f) && f.find(p => Qe(de(p), h)))
                            }), e.props.loadingCounter) {
                            e.props.isLoadingOption = !0;
                            const h = e.on("prop:loadingCounter", () => {
                                e.props.loadingCounter || (e.props.isLoadingOption = !1, t(e, n(e)), e.off(h))
                            })
                        } else t(e, n(e));
                    return
                }
                const d = n(e);
                if (!Sd || d || u === void 0 || e.props.options && e.props.options.length || typeof e.props.optionsLoader != "function") t(e, d);
                else {
                    const f = zc(e);
                    t(e), f.then(() => {
                        t(e, n(e))
                    })
                }
            }), e.on("prop:options", ({
                payload: u
            }) => {
                e.props.sourceOptions = [...u].filter(d => !e.props.targetOptionValues.includes(de(d)))
            }), e.on("prop:inputText", ({
                payload: u
            }) => {
                u || (e.props.initialOptions.length && (e.props.options = [...e.props.initialOptions]), e.props.optionsLoader && (e.props.page = 1, e.props.options = [], e.props.search = void 0, zc(e)))
            }), e.on("prop:activeValue", ({
                payload: u
            }) => {
                if (u === Xr) return void(e.props.activeDescendant = `${e.props.id}_load_more`);
                const d = e.props.options.findIndex(f => Qe(de(f), u));
                if (d >= 0) e.props.activeDescendant = `${e.props.id}_source_list_item_${d}`;
                else {
                    const f = e.props.targetOptions.findIndex(h => Qe(de(h), u));
                    if (!f) return void(e.props.activeDescendant = void 0);
                    e.props.activeDescendant = f
                }
            }), e.on("prop:mouseOnSource", ({
                payload: u
            }) => {
                if (u && e.props.disabled !== !0) {
                    const d = document.getElementById(e.props.id + "_source_list_items");
                    if (!d) return;
                    e.props.mouseOnTarget = !1, wd.delete(e), a(d)
                }
            }), e.on("prop:mouseOnTarget", ({
                payload: u
            }) => {
                if (u && e.props.disabled !== !0) {
                    const d = document.getElementById(`${e.props.id}`);
                    if (!d) return;
                    e.props.mouseOnSource = !1, Ed.delete(e), a(d)
                }
            }), e.on("prop:loadingCounter", ({
                payload: u
            }) => {
                u === 0 && e.store.set(py)
            }), e.on("prop:loadingCounter", ({
                payload: u
            }) => {
                u === 0 && e.store.set(py)
            })
        }, Ul, tt("moveRight", "right"), tt("moveLeft", "left"), tt("fastForward", "fastForward"), tt("rewind", "rewind"), tt("close", "close"), tt("loader", "spinner"), tt("selected", "check"), Dt("isLoading"), Dt("loadMore"), Dt("addAllValues"), Dt("addSelectedValues"), Dt("removeSelectedValues"), Dt("removeAllValues")]
    };
var Vye = Object.freeze({
    __proto__: null,
    dropdown: cme,
    toggle: kme,
    repeater: Qme,
    rating: hge,
    autocomplete: kge,
    datepicker: w_e,
    taglist: B_e,
    mask: sye,
    transferlist: Bye
});
const Hye = setInterval,
    jye = 952679114,
    zye = 451228594,
    Wye = 32863693,
    Gye = 13919,
    dD = new WeakSet;
var qye = {
    global: {
        fieldset: "",
        form: "space-y-4",
        help: "text-xs text-gray-500",
        inner: "formkit-disabled:bg-gray-200 formkit-disabled:cursor-not-allowed formkit-disabled:pointer-events-none",
        input: "appearance-none bg-transparent focus:outline-none focus:ring-0 focus:shadow-none",
        label: "block mb-2 font-bold text-sm",
        legend: "font-bold text-sm",
        loaderIcon: "inline-flex items-center w-4 text-gray-600 animate-spin",
        message: "text-red-500 mb-1 text-xs",
        messages: "list-none p-0 mt-1 mb-0",
        outer: "mb-4 formkit-disabled:opacity-50",
        prefixIcon: "w-10 flex self-stretch grow-0 shrink-0 rounded-tl rounded-bl border-r border-gray-400 bg-white bg-gradient-to-b from-transparent to-gray-200 [&>svg]:w-full [&>svg]:max-w-[1em] [&>svg]:max-h-[1em] [&>svg]:m-auto",
        suffixIcon: "w-7 pr-3 flex self-stretch grow-0 shrink-0 [&>svg]:w-full [&>svg]:max-w-[1em] [&>svg]:max-h-[1em] [&>svg]:m-auto"
    },
    "family:box": {
        decorator: "block relative h-5 w-5 mr-2 rounded bg-white bg-gradient-to-b from-transparent to-gray-200 ring-1 ring-gray-400 peer-checked:ring-brand-primary text-transparent peer-checked:text-brand-primary",
        decoratorIcon: "flex p-[3px] w-full h-full absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2",
        help: "mb-2 mt-1.5",
        input: "fixed left-[999em] w-0 h-0 overflow-hidden opacity-0 pointer-events-none peer",
        label: "$reset text-sm text-gray-700 mt-1 select-none",
        wrapper: "flex items-center mb-1"
    },
    "family:button": {
        input: "$reset inline-flex items-center border-transparent rounded-md text-sm py-2 px-4 text-white bg-brand-primary shadow hover:bg-brand-secondary hover:text-yellow-800 focus:ring-2 focus:ring-brand-primary/75 focus:ring-offset-2 active:shadow-none font-semibold disabled:bg-slate-400 disabled:!text-white disabled:cursor-not-allowed",
        wrapper: "mb-1",
        prefixIcon: "$reset block w-4 -ml-2 mr-2 stretch",
        suffixIcon: "$reset block w-4 ml-2 stretch"
    },
    "family:dropdown": {
        dropdownWrapper: "my-2 w-full drop-shadow-lg rounded [&::-webkit-scrollbar]:hidden",
        inner: "max-w-md relative flex ring-1 ring-gray-400 focus-within:ring-brand-primary focus-within:ring-2 rounded mb-1 formkit-disabled:focus-within:ring-gray-400 formkit-disabled:focus-within:ring-1 [&>span:first-child]:focus-within:text-brand-primary",
        input: "w-full px-3 py-2",
        listbox: "bg-white drop-shadow-lg rounded overflow-hidden",
        listboxButton: "flex w-12 self-stretch justify-center mx-auto",
        listitem: 'pl-7 relative hover:bg-gray-300 data-[is-active="true"]:bg-gray-300 data-[is-active="true"]:aria-selected:bg-brand-primary aria-selected:bg-brand-primary aria-selected:text-white',
        loaderIcon: "ml-auto",
        loadMoreInner: "flex items-center justify-center text-sm p-2 text-center w-full text-brand-primary formkit-loading:text-gray-500 cursor-pointer [&>span]:mr-3 [&>span]:ml-0",
        option: "p-2.5",
        optionLoading: "text-gray-500",
        placeholder: "p-2.5 text-gray-400",
        selector: "flex w-full justify-between items-center [&u]",
        selectedIcon: "block absolute top-1/2 left-2 w-3 -translate-y-1/2",
        selectIcon: "flex box-content w-4 px-2 self-stretch grow-0 shrink-0"
    },
    "family:text": {
        inner: "flex items-center max-w-md ring-1 ring-gray-400 focus-within:ring-brand-primary focus-within:ring-2 [&>label:first-child]:focus-within:text-brand-primary rounded mb-1 overflow-hidden",
        input: "w-full bg-white px-3 py-2 border-none text-base text-gray-700 placeholder-gray-400"
    },
    color: {
        wrapper: "flex flex-col space-y-2",
        inner: "rounded-lg !max-w-[5.5em] flex w-full formkit-prefix-icon:max-w-[7.5em] formkit-suffix-icon:formkit-prefix-icon:max-w-[10em]",
        input: "$reset w-24 h-12 appearance-none cursor-pointer border border-slate-300 rounded-lg p-2 bg-white [&::-webkit-color-swatch-wrapper]:p-0 [&::-webkit-color-swatch]:border-slate-200 [&::-webkit-color-swatch]:rounded-md",
        suffixIcon: "min-w-[2.5em] pr-0 pl-0 m-auto"
    },
    file: {
        fileItem: "flex items-center text-gray-800 mb-1 last:mb-0",
        fileItemIcon: "w-4 mr-2 shrink-0",
        fileList: 'shrink grow peer px-3 py-2 formkit-multiple:data-[has-multiple="true"]:mb-6',
        fileName: "break-all grow text-ellipsis",
        fileRemove: "relative z-[2] ml-auto text-[0px] hover:text-red-500 pl-2 peer-data-[has-multiple=true]:text-sm peer-data-[has-multiple=true]:text-brand-primary peer-data-[has-multiple=true]:ml-3 peer-data-[has-multiple=true]:mb-2 formkit-multiple:bottom-[0.15em] formkit-multiple:pl-0 formkit-multiple:ml-0 formkit-multiple:left-[1em] formkit-multiple:formkit-prefix-icon:left-[3.75em]",
        fileRemoveIcon: "block text-base w-3 relative z-[2]",
        inner: "relative max-w-md cursor-pointer formkit-multiple:[&>button]:absolute",
        input: "cursor-pointer text-transparent absolute top-0 right-0 left-0 bottom-0 opacity-0 z-[2]",
        noFiles: "flex w-full items-center px-3 py-2 text-gray-400",
        noFilesIcon: "w-4 mr-2"
    },
    radio: {
        decorator: "rounded-full",
        decoratorIcon: "w-5 p-[5px]"
    },
    range: {
        inner: "$reset flex items-center max-w-md",
        input: "$reset w-full mb-1 h-2 p-0 rounded-full",
        prefixIcon: "$reset w-4 mr-1 flex self-stretch grow-0 shrink-0 [&>svg]:max-w-[1em] [&>svg]:max-h-[1em] [&>svg]:m-auto",
        suffixIcon: "$reset w-4 ml-1 flex self-stretch grow-0 shrink-0 [&>svg]:max-w-[1em] [&>svg]:max-h-[1em] [&>svg]:m-auto"
    },
    select: {
        inner: "flex relative items-center rounded mb-1 ring-1 ring-gray-400 focus-within:ring-brand-primary focus-within:ring-2 [&>span:first-child]:focus-within:text-brand-primary",
        input: 'w-full pl-3 pr-8 py-2 border-none text-base text-gray-700 placeholder-gray-400 formkit-multiple:p-0 data-[placeholder="true"]:text-gray-400 formkit-multiple:data-[placeholder="true"]:text-inherit',
        selectIcon: "flex p-[3px] shrink-0 w-5 mr-2 -ml-[1.5em] h-full pointer-events-none",
        option: "formkit-multiple:p-3 formkit-multiple:text-sm text-gray-700"
    },
    textarea: {
        inner: "flex rounded mb-1 ring-1 ring-gray-400 focus-within:ring-brand-primary [&>label:first-child]:focus-within:text-brand-primary overflow-hidden",
        input: "block w-full h-32 px-3 py-3 border-none text-base text-gray-700 placeholder-gray-400 focus:shadow-outline bg-white"
    },
    autocomplete: {
        closeIcon: "block grow-0 shrink-0 w-3 mr-3.5",
        inner: "[&>div>[data-value]]:absolute [&>div>[data-value]]:mb-0",
        option: "grow text-ellipsis",
        selection: "static flex left-0 top-0 right-0 bottom-0 mt-0 mb-2 rounded bg-gray-100"
    },
    mask: {
        inner: "flex items-center max-w-md ring-1 ring-gray-400 focus-within:ring-brand-primary focus-within:ring-2 [&>label:first-child]:focus-within:text-brand-primary rounded mb-1",
        input: "w-full px-3 py-2 border-none text-base text-gray-700 placeholder-gray-400"
    },
    rating: {
        inner: "relative flex items-center w-[8em] formkit-disabled:bg-transparent",
        itemsWrapper: "w-full",
        onItems: "text-yellow-400",
        onItemWrapper: "[&>*]:w-full [&>svg]:h-auto [&>svg]:max-w-none [&>svg]:max-h-none",
        offItems: "text-gray-500",
        offItemWrapper: "[&>*]:w-full [&>svg]:h-auto [&>svg]:max-w-none [&>svg]:max-h-none"
    },
    repeater: {
        content: "grow flex flex-col align-center",
        controlLabel: "absolute opacity-0 pointer-events-none",
        controls: "bg-white flex items-center items-center h-max gap-1 @sm:gap-2 rounded-lg border border-slate-300 px-2 py-1 text-slate-500 mt-[3px]",
        downControl: "hover:text-brand-primary disabled:hover:text-inherit disabled:opacity-25",
        fieldset: "",
        help: "mb-2 mt-1.5",
        items: "space-y-3",
        item: "flex w-full gap-2 @container",
        moveDownIcon: "block w-3",
        moveUpIcon: "block w-3",
        removeControl: "hover:text-brand-primary disabled:hover:text-inherit disabled:opacity-25",
        removeIcon: "block w-4",
        upControl: "hover:text-brand-primary disabled:hover:text-inherit disabled:opacity-25",
        addButton: "mt-4",
        up: "flex",
        down: "flex",
        remove: "flex"
    },
    taglist: {
        input: "px-1 py-1 w-[0%] grow",
        removeSelection: "w-2.5 mx-1 self-center text-black leading-none",
        tag: "flex items-center my-1 p-1 bg-gray-200 text-xs rounded-full",
        tagWrapper: "mr-1 focus:outline-none focus:text-white [&>div]:focus:bg-brand-primary [&>div>button]:focus:text-white",
        tagLabel: "pl-2 pr-1",
        tags: "flex items-center flex-wrap w-full py-1.5 px-2"
    },
    toggle: {
        altLabel: "block w-full mb-1 font-bold text-sm",
        inner: "$reset inline-block mr-2",
        input: "peer fixed left-[999em] opacity-0 pointer-events-none",
        innerLabel: "text-[10px] font-bold absolute left-full top-1/2 -translate-x-full -translate-y-1/2 px-1",
        thumb: "relative left-0 aspect-square rounded-full transition-all w-5 bg-gray-100",
        track: "p-0.5 min-w-[3em] relative rounded-full transition-all bg-gray-400 peer-checked:bg-brand-primary peer-checked:[&>div:last-child]:left-full peer-checked:[&>div:last-child]:-translate-x-full peer-checked:[&>div:first-child:not(:last-child)]:left-0 peer-checked:[&>div:first-child:not(:last-child)]:translate-x-0",
        valueLabel: "font-bold text-sm",
        wrapper: "flex flex-wrap items-center mb-1"
    }
};
const Yye = "modulepreload",
    fD = {},
    Kye = "/",
    at = function(t, n) {
        return !n || n.length === 0 ? t() : Promise.all(n.map(r => {
            if (r = `${Kye}${r}`, r in fD) return;
            fD[r] = !0;
            const s = r.endsWith(".css"),
                i = s ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${r}"]${i}`)) return;
            const o = document.createElement("link");
            if (o.rel = s ? "stylesheet" : Yye, s || (o.as = "script", o.crossOrigin = ""), o.href = r, document.head.appendChild(o), s) return new Promise((a, l) => {
                o.addEventListener("load", a), o.addEventListener("error", () => l(new Error(`Unable to preload CSS for ${r}`)))
            })
        })).then(() => t())
    },
    Xye = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 20 20",
        width: "1.2em",
        height: "1.2em"
    },
    Qye = K("path", {
        fill: "currentColor",
        d: "M10 1.6a8.4 8.4 0 1 0 0 16.8a8.4 8.4 0 0 0 0-16.8zm4.789 11.461L13.06 14.79L10 11.729l-3.061 3.06L5.21 13.06L8.272 10L5.211 6.939L6.94 5.211L10 8.271l3.061-3.061l1.729 1.729L11.728 10l3.061 3.061z"
    }, null, -1),
    Jye = [Qye];

function Zye(e, t) {
    return z(), Se("svg", Xye, Jye)
}
var eve = {
    name: "entypo-circle-with-cross",
    render: Zye
};
var bs = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [r, s] of t) n[r] = s;
    return n
};
const tve = {
        name: "UiLoader",
        props: {
            iconColorClass: {
                type: String,
                default: "text-brand-primary"
            },
            textColorClass: {
                type: String,
                default: "text-slate-800"
            },
            label: {
                type: String,
                default: "Loading..."
            },
            size: {
                type: String,
                default: "base"
            }
        },
        data() {
            return {
                classObject: {
                    [`ui-loader-${this.size}`]: this.size,
                    [this.textColorClass]: this.textColorClass
                }
            }
        }
    },
    nve = {
        key: 0
    };

function rve(e, t, n, r, s, i) {
    const o = eve;
    return z(), Se("div", {
        class: wn(["flex items-center font-extrabold animate-pulse", s.classObject])
    }, [ne(o, {
        class: wn(["animate-spin ui-loader-icon", n.iconColorClass])
    }, null, 8, ["class"]), Gn(e.$slots, "default", {}, () => [n.label ? (z(), Se("span", nve, xs(n.label), 1)) : Ve("", !0)])], 2)
}
var jl = bs(tve, [
    ["render", rve]
]);
const sve = {
    components: {
        UiLoader: jl
    },
    props: {
        danger: {
            type: Boolean,
            default: !1
        },
        disabled: {
            type: Boolean,
            default: !1
        },
        loading: {
            type: Boolean,
            default: !1
        },
        loadingLabel: {
            type: String,
            default: ""
        },
        loadingClass: {
            type: String,
            default: "text-white"
        },
        size: {
            type: String,
            default: "base"
        },
        theme: {
            type: String,
            default: "primary"
        },
        to: {
            type: String,
            default: ""
        }
    },
    data() {
        return {
            classObject: {
                [`ui-button-${this.size}`]: this.size,
                [`ui-button-${this.theme}`]: this.theme,
                "ui-button-danger": this.danger
            },
            loaderClassObject: {
                [`ui-loader-${this.theme}`]: this.theme
            }
        }
    },
    computed: {
        is() {
            var e, t;
            return (e = this == null ? void 0 : this.$attrs) != null && e.href ? "a" : (t = this == null ? void 0 : this.$props) != null && t.to ? "router-link" : "button"
        },
        type() {
            var e, t;
            return (e = this == null ? void 0 : this.$attrs) != null && e.type ? (t = this == null ? void 0 : this.$attrs) == null ? void 0 : t.type : (this == null ? void 0 : this.is) === "button" ? "button" : null
        }
    }
};

function ive(e, t, n, r, s, i) {
    const o = jl;
    return z(), ke(Ah(i.is), xi({
        to: n.to,
        class: ["ui-button", s.classObject]
    }, e.$attrs, {
        type: i.type,
        disabled: n.loading || n.disabled
    }), {
        default: Re(() => [n.loading ? (z(), ke(o, {
            key: 0,
            textColorClass: n.loadingClass,
            iconColorClass: n.loadingClass,
            label: n.loadingLabel,
            size: n.size,
            class: "!font-semibold"
        }, null, 8, ["textColorClass", "iconColorClass", "label", "size"])) : Gn(e.$slots, "default", {
            key: 1
        })]),
        _: 3
    }, 16, ["to", "class", "type", "disabled"])
}
var Eb = bs(sve, [
    ["render", ive]
]);
const ove = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    ave = K("path", {
        fill: "currentColor",
        d: "M17.75 3A3.25 3.25 0 0 1 21 6.25v11.5A3.25 3.25 0 0 1 17.75 21H6.25A3.25 3.25 0 0 1 3 17.75V6.25A3.25 3.25 0 0 1 6.25 3h11.5Zm.58 16.401l-5.805-5.686a.75.75 0 0 0-.966-.071l-.084.07l-5.807 5.687c.182.064.378.099.582.099h11.5c.203 0 .399-.035.58-.099l-5.805-5.686L18.33 19.4ZM17.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v11.5c0 .208.036.408.103.594l5.823-5.701a2.25 2.25 0 0 1 3.02-.116l.128.116l5.822 5.702c.067-.186.104-.386.104-.595V6.25a1.75 1.75 0 0 0-1.75-1.75Zm-2.498 2a2.252 2.252 0 1 1 0 4.504a2.252 2.252 0 0 1 0-4.504Zm0 1.5a.752.752 0 1 0 0 1.504a.752.752 0 0 0 0-1.504Z"
    }, null, -1),
    lve = [ave];

function cve(e, t) {
    return z(), Se("svg", ove, lve)
}
var uve = {
        name: "fluent-image24-regular",
        render: cve
    },
    dve = Object.defineProperty,
    fve = Object.defineProperties,
    hve = Object.getOwnPropertyDescriptors,
    hD = Object.getOwnPropertySymbols,
    pve = Object.prototype.hasOwnProperty,
    mve = Object.prototype.propertyIsEnumerable,
    pD = (e, t, n) => t in e ? dve(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    gve = (e, t) => {
        for (var n in t || (t = {})) pve.call(t, n) && pD(e, n, t[n]);
        if (hD)
            for (var n of hD(t)) mve.call(t, n) && pD(e, n, t[n]);
        return e
    },
    _ve = (e, t) => fve(e, hve(t));

function So(e, t) {
    var n;
    const r = yl();
    return sr(() => {
        r.value = e()
    }, _ve(gve({}, t), {
        flush: (n = t == null ? void 0 : t.flush) != null ? n : "sync"
    })), Zv(r)
}

function Gk(e) {
    return u5() ? (d5(e), !0) : !1
}
var mD;
const Bp = typeof window != "undefined",
    yve = e => typeof e == "string",
    Ag = () => {};
Bp && ((mD = window == null ? void 0 : window.navigator) == null ? void 0 : mD.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);

function vve(e, t) {
    function n(...r) {
        e(() => t.apply(this, r), {
            fn: t,
            thisArg: this,
            args: r
        })
    }
    return n
}
const mj = e => e();

function bve(e = mj) {
    const t = ae(!0);

    function n() {
        t.value = !1
    }

    function r() {
        t.value = !0
    }
    return {
        isActive: t,
        pause: n,
        resume: r,
        eventFilter: (...i) => {
            t.value && e(...i)
        }
    }
}

function wve(e, t) {
    var n;
    if (typeof e == "number") return e + t;
    const r = ((n = e.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : n[0]) || "",
        s = e.slice(r.length),
        i = parseFloat(r) + t;
    return Number.isNaN(i) ? e : i + s
}

function Eve(e, t = !0) {
    Qn() ? ak(e) : t ? e() : ln(e)
}

function gj(e, t = !0) {
    Qn() ? jr(e) : t ? e() : ln(e)
}

function Sve(e) {
    Qn() && Fl(e)
}

function Tve(e, t, n = {}) {
    const {
        immediate: r = !0
    } = n, s = ae(!1);
    let i = null;

    function o() {
        i && (clearTimeout(i), i = null)
    }

    function a() {
        s.value = !1, o()
    }

    function l(...c) {
        o(), s.value = !0, i = setTimeout(() => {
            s.value = !1, i = null, e(...c)
        }, fe(t))
    }
    return r && (s.value = !0, Bp && l()), Gk(a), {
        isPending: s,
        start: l,
        stop: a
    }
}

function _j(e = !1, t = {}) {
    const {
        truthyValue: n = !0,
        falsyValue: r = !1
    } = t, s = gt(e), i = ae(e);

    function o(a) {
        return arguments.length ? (i.value = a, i.value) : (i.value = i.value === fe(n) ? fe(r) : fe(n), i.value)
    }
    return s ? o : [i, o]
}
var gD = Object.getOwnPropertySymbols,
    $ve = Object.prototype.hasOwnProperty,
    kve = Object.prototype.propertyIsEnumerable,
    Ive = (e, t) => {
        var n = {};
        for (var r in e) $ve.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && gD)
            for (var r of gD(e)) t.indexOf(r) < 0 && kve.call(e, r) && (n[r] = e[r]);
        return n
    };

function xve(e, t, n = {}) {
    const r = n,
        {
            eventFilter: s = mj
        } = r,
        i = Ive(r, ["eventFilter"]);
    return $t(e, vve(s, t), i)
}
var Cve = Object.defineProperty,
    Ave = Object.defineProperties,
    Rve = Object.getOwnPropertyDescriptors,
    yy = Object.getOwnPropertySymbols,
    yj = Object.prototype.hasOwnProperty,
    vj = Object.prototype.propertyIsEnumerable,
    _D = (e, t, n) => t in e ? Cve(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    Ove = (e, t) => {
        for (var n in t || (t = {})) yj.call(t, n) && _D(e, n, t[n]);
        if (yy)
            for (var n of yy(t)) vj.call(t, n) && _D(e, n, t[n]);
        return e
    },
    Dve = (e, t) => Ave(e, Rve(t)),
    Nve = (e, t) => {
        var n = {};
        for (var r in e) yj.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && yy)
            for (var r of yy(e)) t.indexOf(r) < 0 && vj.call(e, r) && (n[r] = e[r]);
        return n
    };

function Pve(e, t, n = {}) {
    const r = n,
        {
            eventFilter: s
        } = r,
        i = Nve(r, ["eventFilter"]),
        {
            eventFilter: o,
            pause: a,
            resume: l,
            isActive: c
        } = bve(s);
    return {
        stop: xve(e, t, Dve(Ove({}, i), {
            eventFilter: o
        })),
        pause: a,
        resume: l,
        isActive: c
    }
}

function Mve(e) {
    var t;
    const n = fe(e);
    return (t = n == null ? void 0 : n.$el) != null ? t : n
}
const ra = Bp ? window : void 0,
    Lve = Bp ? window.document : void 0,
    Fve = Bp ? window.navigator : void 0;

function kf(...e) {
    let t, n, r, s;
    if (yve(e[0]) ? ([n, r, s] = e, t = ra) : [t, n, r, s] = e, !t) return Ag;
    let i = Ag;
    const o = $t(() => Mve(t), l => {
            i(), l && (l.addEventListener(n, r, s), i = () => {
                l.removeEventListener(n, r, s), i = Ag
            })
        }, {
            immediate: !0,
            flush: "post"
        }),
        a = () => {
            o(), i()
        };
    return Gk(a), a
}

function If(e, t = {}) {
    const {
        window: n = ra
    } = t, r = Boolean(n && "matchMedia" in n);
    let s;
    const i = ae(!1),
        o = () => {
            !r || (s || (s = n.matchMedia(e)), i.value = s.matches)
        };
    return Eve(() => {
        o(), s && ("addEventListener" in s ? s.addEventListener("change", o) : s.addListener(o), Gk(() => {
            "removeEventListener" in s ? s.removeEventListener("change", o) : s.removeListener(o)
        }))
    }), i
}
const GRe = {
    sm: 640,
    md: 768,
    lg: 1024,
    xl: 1280,
    "2xl": 1536
};
var Uve = Object.defineProperty,
    yD = Object.getOwnPropertySymbols,
    Bve = Object.prototype.hasOwnProperty,
    Vve = Object.prototype.propertyIsEnumerable,
    vD = (e, t, n) => t in e ? Uve(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    Hve = (e, t) => {
        for (var n in t || (t = {})) Bve.call(t, n) && vD(e, n, t[n]);
        if (yD)
            for (var n of yD(t)) Vve.call(t, n) && vD(e, n, t[n]);
        return e
    };

function qRe(e, t = {}) {
    function n(a, l) {
        let c = e[a];
        return l != null && (c = wve(c, l)), typeof c == "number" && (c = `${c}px`), c
    }
    const {
        window: r = ra
    } = t;

    function s(a) {
        return r ? r.matchMedia(a).matches : !1
    }
    const i = a => If(`(min-width: ${n(a)})`, t),
        o = Object.keys(e).reduce((a, l) => (Object.defineProperty(a, l, {
            get: () => i(l),
            enumerable: !0,
            configurable: !0
        }), a), {});
    return Hve({
        greater: i,
        smaller(a) {
            return If(`(max-width: ${n(a,-.1)})`, t)
        },
        between(a, l) {
            return If(`(min-width: ${n(a)}) and (max-width: ${n(l,-.1)})`, t)
        },
        isGreater(a) {
            return s(`(min-width: ${n(a)})`)
        },
        isSmaller(a) {
            return s(`(max-width: ${n(a,-.1)})`)
        },
        isInBetween(a, l) {
            return s(`(min-width: ${n(a)}) and (max-width: ${n(l,-.1)})`)
        }
    }, o)
}

function YRe(e = {}) {
    const {
        navigator: t = Fve,
        read: n = !1,
        source: r,
        copiedDuring: s = 1500
    } = e, i = ["copy", "cut"], o = Boolean(t && "clipboard" in t), a = ae(""), l = ae(!1), c = Tve(() => l.value = !1, s);

    function u() {
        t.clipboard.readText().then(f => {
            a.value = f
        })
    }
    if (o && n)
        for (const f of i) kf(f, u);
    async function d(f = fe(r)) {
        o && f != null && (await t.clipboard.writeText(f), a.value = f, l.value = !0, c.start())
    }
    return {
        isSupported: o,
        text: a,
        copied: l,
        copy: d
    }
}
const U1 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {},
    B1 = "__vueuse_ssr_handlers__";
U1[B1] = U1[B1] || {};
const jve = U1[B1];

function bj(e, t) {
    return jve[e] || t
}

function zve(e) {
    return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" || Array.isArray(e) ? "object" : Number.isNaN(e) ? "any" : "number"
}
const Wve = {
    boolean: {
        read: e => e === "true",
        write: e => String(e)
    },
    object: {
        read: e => JSON.parse(e),
        write: e => JSON.stringify(e)
    },
    number: {
        read: e => Number.parseFloat(e),
        write: e => String(e)
    },
    any: {
        read: e => e,
        write: e => String(e)
    },
    string: {
        read: e => e,
        write: e => String(e)
    },
    map: {
        read: e => new Map(JSON.parse(e)),
        write: e => JSON.stringify(Array.from(e.entries()))
    },
    set: {
        read: e => new Set(JSON.parse(e)),
        write: e => JSON.stringify(Array.from(e))
    },
    date: {
        read: e => new Date(e),
        write: e => e.toISOString()
    }
};

function Gve(e, t, n, r = {}) {
    var s;
    const {
        flush: i = "pre",
        deep: o = !0,
        listenToStorageChanges: a = !0,
        writeDefaults: l = !0,
        shallow: c,
        window: u = ra,
        eventFilter: d,
        onError: f = T => {
            console.error(T)
        }
    } = r, h = (c ? yl : ae)(t);
    if (!n) try {
        n = bj("getDefaultStorage", () => {
            var T;
            return (T = ra) == null ? void 0 : T.localStorage
        })()
    } catch (T) {
        f(T)
    }
    if (!n) return h;
    const p = fe(t),
        m = zve(p),
        g = (s = r.serializer) != null ? s : Wve[m],
        {
            pause: y,
            resume: _
        } = Pve(h, () => E(h.value), {
            flush: i,
            deep: o,
            eventFilter: d
        });
    return u && a && kf(u, "storage", w), w(), h;

    function E(T) {
        try {
            T == null ? n.removeItem(e) : n.setItem(e, g.write(T))
        } catch (S) {
            f(S)
        }
    }

    function b(T) {
        if (!(T && T.key !== e)) {
            y();
            try {
                const S = T ? T.newValue : n.getItem(e);
                return S == null ? (l && p !== null && n.setItem(e, g.write(p)), p) : typeof S != "string" ? S : g.read(S)
            } catch (S) {
                f(S)
            } finally {
                _()
            }
        }
    }

    function w(T) {
        T && T.key !== e || (h.value = b(T))
    }
}

function qk(e) {
    return If("(prefers-color-scheme: dark)", e)
}
var qve = Object.defineProperty,
    bD = Object.getOwnPropertySymbols,
    Yve = Object.prototype.hasOwnProperty,
    Kve = Object.prototype.propertyIsEnumerable,
    wD = (e, t, n) => t in e ? qve(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    Xve = (e, t) => {
        for (var n in t || (t = {})) Yve.call(t, n) && wD(e, n, t[n]);
        if (bD)
            for (var n of bD(t)) Kve.call(t, n) && wD(e, n, t[n]);
        return e
    };

function Qve(e = {}) {
    const {
        selector: t = "html",
        attribute: n = "class",
        window: r = ra,
        storage: s,
        storageKey: i = "vueuse-color-scheme",
        listenToStorageChanges: o = !0,
        storageRef: a
    } = e, l = Xve({
        auto: "",
        light: "light",
        dark: "dark"
    }, e.modes || {}), c = qk({
        window: r
    }), u = Fe(() => c.value ? "dark" : "light"), d = a || (i == null ? ae("auto") : Gve(i, "auto", s, {
        window: r,
        listenToStorageChanges: o
    })), f = Fe({
        get() {
            return d.value === "auto" ? u.value : d.value
        },
        set(g) {
            d.value = g
        }
    }), h = bj("updateHTMLAttrs", (g, y, _) => {
        const E = r == null ? void 0 : r.document.querySelector(g);
        if (!!E)
            if (y === "class") {
                const b = _.split(/\s/g);
                Object.values(l).flatMap(w => (w || "").split(/\s/g)).filter(Boolean).forEach(w => {
                    b.includes(w) ? E.classList.add(w) : E.classList.remove(w)
                })
            } else E.setAttribute(y, _)
    });

    function p(g) {
        var y;
        h(t, n, (y = l[g]) != null ? y : g)
    }

    function m(g) {
        e.onChanged ? e.onChanged(g, p) : p(g)
    }
    return $t(f, m, {
        flush: "post",
        immediate: !0
    }), gj(() => m(f.value)), f
}
var Jve = Object.defineProperty,
    Zve = Object.defineProperties,
    ebe = Object.getOwnPropertyDescriptors,
    ED = Object.getOwnPropertySymbols,
    tbe = Object.prototype.hasOwnProperty,
    nbe = Object.prototype.propertyIsEnumerable,
    SD = (e, t, n) => t in e ? Jve(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    rbe = (e, t) => {
        for (var n in t || (t = {})) tbe.call(t, n) && SD(e, n, t[n]);
        if (ED)
            for (var n of ED(t)) nbe.call(t, n) && SD(e, n, t[n]);
        return e
    },
    sbe = (e, t) => Zve(e, ebe(t));

function ibe(e = {}) {
    const {
        valueDark: t = "dark",
        valueLight: n = "",
        window: r = ra
    } = e, s = Qve(sbe(rbe({}, e), {
        onChanged: (a, l) => {
            var c;
            e.onChanged ? (c = e.onChanged) == null || c.call(e, a === "dark") : l(a)
        },
        modes: {
            dark: t,
            light: n
        }
    })), i = qk({
        window: r
    });
    return Fe({
        get() {
            return s.value === "dark"
        },
        set(a) {
            a === i.value ? s.value = "auto" : s.value = a ? "dark" : "light"
        }
    })
}

function obe(e = {}) {
    const {
        window: t = ra
    } = e, n = t == null ? void 0 : t.navigator, r = Boolean(n && "connection" in n), s = ae(!0), i = ae(!1), o = ae(void 0), a = ae(void 0), l = ae(void 0), c = ae(void 0), u = ae(void 0), d = ae(void 0), f = ae("unknown"), h = r && n.connection;

    function p() {
        !n || (s.value = n.onLine, o.value = s.value ? void 0 : Date.now(), a.value = s.value ? Date.now() : void 0, h && (l.value = h.downlink, c.value = h.downlinkMax, d.value = h.effectiveType, u.value = h.rtt, i.value = h.saveData, f.value = h.type))
    }
    return t && (kf(t, "offline", () => {
        s.value = !1, o.value = Date.now()
    }), kf(t, "online", () => {
        s.value = !0, a.value = Date.now()
    })), h && kf(h, "change", p, !1), p(), {
        isSupported: r,
        isOnline: s,
        saveData: i,
        offlineAt: o,
        onlineAt: a,
        downlink: l,
        downlinkMax: c,
        effectiveType: d,
        rtt: u,
        type: f
    }
}
var TD;
(function(e) {
    e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE"
})(TD || (TD = {}));

function KRe(e, t = Ag, n = {}) {
    const {
        immediate: r = !0,
        manual: s = !1,
        type: i = "text/javascript",
        async: o = !0,
        crossOrigin: a,
        referrerPolicy: l,
        noModule: c,
        defer: u,
        document: d = Lve,
        attrs: f = {}
    } = n, h = ae(null);
    let p = null;
    const m = _ => new Promise((E, b) => {
            const w = v => (h.value = v, E(v), v);
            if (!d) {
                E(!1);
                return
            }
            let T = !1,
                S = d.querySelector(`script[src="${e}"]`);
            S ? S.hasAttribute("data-loaded") && w(S) : (S = d.createElement("script"), S.type = i, S.async = o, S.src = fe(e), u && (S.defer = u), a && (S.crossOrigin = a), c && (S.noModule = c), l && (S.referrerPolicy = l), Object.entries(f).forEach(([v, $]) => S == null ? void 0 : S.setAttribute(v, $)), T = !0), S.addEventListener("error", v => b(v)), S.addEventListener("abort", v => b(v)), S.addEventListener("load", () => {
                S.setAttribute("data-loaded", "true"), t(S), w(S)
            }), T && (S = d.head.appendChild(S)), _ || w(S)
        }),
        g = (_ = !0) => (p || (p = m(_)), p),
        y = () => {
            if (!d) return;
            p = null, h.value && (h.value = null);
            const _ = d.querySelector(`script[src="${e}"]`);
            _ && d.head.removeChild(_)
        };
    return r && !s && gj(g), s || Sve(y), {
        scriptTag: h,
        load: g,
        unload: y
    }
}
const wj = Symbol("firebaseApp");

function Ej(e) {
    return Qn() && bt(wj, null) || Il(e)
}
const Um = new WeakMap;

function abe(e, t) {
    if (!Um.has(e)) {
        const n = l5(!0);
        Um.set(e, n);
        const {
            unmount: r
        } = t;
        t.unmount = () => {
            r.call(t), n.stop(), Um.delete(e)
        }
    }
    return Um.get(e)
}
const Sj = new WeakMap;

function Tj(e) {
    return Sj.get(Ej(e))
}
const Bm = new WeakMap;

function $j(e) {
    const t = Ej(e);
    if (!Bm.has(t)) {
        let n;
        const s = [new Promise(i => {
            n = i
        }), i => {
            Bm.set(t, i), n(i.value)
        }];
        Bm.set(t, s)
    }
    return Bm.get(t)
}

function kj(e) {
    const t = $j(e);
    return Array.isArray(t) ? t[0] : Promise.resolve(t.value)
}

function lbe(e, t) {
    const n = HB(t);
    AB(n, r => {
        const s = $j();
        e.value = r, Array.isArray(s) && s[1](e)
    })
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ij = "firebasestorage.googleapis.com",
    cbe = "storageBucket",
    ube = 2 * 60 * 1e3,
    dbe = 10 * 60 * 1e3;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ks extends zr {
    constructor(t, n, r = 0) {
        super(iw(t), `Firebase Storage: ${n} (${iw(t)})`), this.status_ = r, this.customData = {
            serverResponse: null
        }, this._baseMessage = this.message, Object.setPrototypeOf(this, Ks.prototype)
    }
    get status() {
        return this.status_
    }
    set status(t) {
        this.status_ = t
    }
    _codeEquals(t) {
        return iw(t) === this.code
    }
    get serverResponse() {
        return this.customData.serverResponse
    }
    set serverResponse(t) {
        this.customData.serverResponse = t, this.customData.serverResponse ? this.message = `${this._baseMessage}
${this.customData.serverResponse}` : this.message = this._baseMessage
    }
}
var Gs;
(function(e) {
    e.UNKNOWN = "unknown", e.OBJECT_NOT_FOUND = "object-not-found", e.BUCKET_NOT_FOUND = "bucket-not-found", e.PROJECT_NOT_FOUND = "project-not-found", e.QUOTA_EXCEEDED = "quota-exceeded", e.UNAUTHENTICATED = "unauthenticated", e.UNAUTHORIZED = "unauthorized", e.UNAUTHORIZED_APP = "unauthorized-app", e.RETRY_LIMIT_EXCEEDED = "retry-limit-exceeded", e.INVALID_CHECKSUM = "invalid-checksum", e.CANCELED = "canceled", e.INVALID_EVENT_NAME = "invalid-event-name", e.INVALID_URL = "invalid-url", e.INVALID_DEFAULT_BUCKET = "invalid-default-bucket", e.NO_DEFAULT_BUCKET = "no-default-bucket", e.CANNOT_SLICE_BLOB = "cannot-slice-blob", e.SERVER_FILE_WRONG_SIZE = "server-file-wrong-size", e.NO_DOWNLOAD_URL = "no-download-url", e.INVALID_ARGUMENT = "invalid-argument", e.INVALID_ARGUMENT_COUNT = "invalid-argument-count", e.APP_DELETED = "app-deleted", e.INVALID_ROOT_OPERATION = "invalid-root-operation", e.INVALID_FORMAT = "invalid-format", e.INTERNAL_ERROR = "internal-error", e.UNSUPPORTED_ENVIRONMENT = "unsupported-environment"
})(Gs || (Gs = {}));

function iw(e) {
    return "storage/" + e
}

function fbe() {
    const e = "An unknown error occurred, please check the error payload for server response.";
    return new Ks(Gs.UNKNOWN, e)
}

function hbe() {
    return new Ks(Gs.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again.")
}

function pbe() {
    return new Ks(Gs.CANCELED, "User canceled the upload/download.")
}

function mbe(e) {
    return new Ks(Gs.INVALID_URL, "Invalid URL '" + e + "'.")
}

function gbe(e) {
    return new Ks(Gs.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + e + "'.")
}

function $D(e) {
    return new Ks(Gs.INVALID_ARGUMENT, e)
}

function xj() {
    return new Ks(Gs.APP_DELETED, "The Firebase app was deleted.")
}

function _be(e) {
    return new Ks(Gs.INVALID_ROOT_OPERATION, "The operation '" + e + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class us {
    constructor(t, n) {
        this.bucket = t, this.path_ = n
    }
    get path() {
        return this.path_
    }
    get isRoot() {
        return this.path.length === 0
    }
    fullServerUrl() {
        const t = encodeURIComponent;
        return "/b/" + t(this.bucket) + "/o/" + t(this.path)
    }
    bucketOnlyServerUrl() {
        return "/b/" + encodeURIComponent(this.bucket) + "/o"
    }
    static makeFromBucketSpec(t, n) {
        let r;
        try {
            r = us.makeFromUrl(t, n)
        } catch {
            return new us(t, "")
        }
        if (r.path === "") return r;
        throw gbe(t)
    }
    static makeFromUrl(t, n) {
        let r = null;
        const s = "([A-Za-z0-9.\\-_]+)";

        function i(b) {
            b.path.charAt(b.path.length - 1) === "/" && (b.path_ = b.path_.slice(0, -1))
        }
        const o = "(/(.*))?$",
            a = new RegExp("^gs://" + s + o, "i"),
            l = {
                bucket: 1,
                path: 3
            };

        function c(b) {
            b.path_ = decodeURIComponent(b.path)
        }
        const u = "v[A-Za-z0-9_]+",
            d = n.replace(/[.]/g, "\\."),
            f = "(/([^?#]*).*)?$",
            h = new RegExp(`^https?://${d}/${u}/b/${s}/o${f}`, "i"),
            p = {
                bucket: 1,
                path: 3
            },
            m = n === Ij ? "(?:storage.googleapis.com|storage.cloud.google.com)" : n,
            g = "([^?#]*)",
            y = new RegExp(`^https?://${m}/${s}/${g}`, "i"),
            E = [{
                regex: a,
                indices: l,
                postModify: i
            }, {
                regex: h,
                indices: p,
                postModify: c
            }, {
                regex: y,
                indices: {
                    bucket: 1,
                    path: 2
                },
                postModify: c
            }];
        for (let b = 0; b < E.length; b++) {
            const w = E[b],
                T = w.regex.exec(t);
            if (T) {
                const S = T[w.indices.bucket];
                let v = T[w.indices.path];
                v || (v = ""), r = new us(S, v), w.postModify(r);
                break
            }
        }
        if (r == null) throw mbe(t);
        return r
    }
}
class ybe {
    constructor(t) {
        this.promise_ = Promise.reject(t)
    }
    getPromise() {
        return this.promise_
    }
    cancel(t = !1) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function vbe(e, t, n) {
    let r = 1,
        s = null,
        i = null,
        o = !1,
        a = 0;

    function l() {
        return a === 2
    }
    let c = !1;

    function u(...g) {
        c || (c = !0, t.apply(null, g))
    }

    function d(g) {
        s = setTimeout(() => {
            s = null, e(h, l())
        }, g)
    }

    function f() {
        i && clearTimeout(i)
    }

    function h(g, ...y) {
        if (c) {
            f();
            return
        }
        if (g) {
            f(), u.call(null, g, ...y);
            return
        }
        if (l() || o) {
            f(), u.call(null, g, ...y);
            return
        }
        r < 64 && (r *= 2);
        let E;
        a === 1 ? (a = 2, E = 0) : E = (r + Math.random()) * 1e3, d(E)
    }
    let p = !1;

    function m(g) {
        p || (p = !0, f(), !c && (s !== null ? (g || (a = 2), clearTimeout(s), d(0)) : g || (a = 1)))
    }
    return d(0), i = setTimeout(() => {
        o = !0, m(!0)
    }, n), m
}

function bbe(e) {
    e(!1)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function wbe(e) {
    return e !== void 0
}

function kD(e, t, n, r) {
    if (r < t) throw $D(`Invalid value for '${e}'. Expected ${t} or greater.`);
    if (r > n) throw $D(`Invalid value for '${e}'. Expected ${n} or less.`)
}

function Ebe(e) {
    const t = encodeURIComponent;
    let n = "?";
    for (const r in e)
        if (e.hasOwnProperty(r)) {
            const s = t(r) + "=" + t(e[r]);
            n = n + s + "&"
        }
    return n = n.slice(0, -1), n
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var vy;
(function(e) {
    e[e.NO_ERROR = 0] = "NO_ERROR", e[e.NETWORK_ERROR = 1] = "NETWORK_ERROR", e[e.ABORT = 2] = "ABORT"
})(vy || (vy = {}));
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Sbe(e, t) {
    const n = e >= 500 && e < 600,
        s = [408, 429].indexOf(e) !== -1,
        i = t.indexOf(e) !== -1;
    return n || s || i
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Tbe {
    constructor(t, n, r, s, i, o, a, l, c, u, d, f = !0) {
        this.url_ = t, this.method_ = n, this.headers_ = r, this.body_ = s, this.successCodes_ = i, this.additionalRetryCodes_ = o, this.callback_ = a, this.errorCallback_ = l, this.timeout_ = c, this.progressCallback_ = u, this.connectionFactory_ = d, this.retry = f, this.pendingConnection_ = null, this.backoffId_ = null, this.canceled_ = !1, this.appDelete_ = !1, this.promise_ = new Promise((h, p) => {
            this.resolve_ = h, this.reject_ = p, this.start_()
        })
    }
    start_() {
        const t = (r, s) => {
                if (s) {
                    r(!1, new Vm(!1, null, !0));
                    return
                }
                const i = this.connectionFactory_();
                this.pendingConnection_ = i;
                const o = a => {
                    const l = a.loaded,
                        c = a.lengthComputable ? a.total : -1;
                    this.progressCallback_ !== null && this.progressCallback_(l, c)
                };
                this.progressCallback_ !== null && i.addUploadProgressListener(o), i.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
                    this.progressCallback_ !== null && i.removeUploadProgressListener(o), this.pendingConnection_ = null;
                    const a = i.getErrorCode() === vy.NO_ERROR,
                        l = i.getStatus();
                    if (!a || Sbe(l, this.additionalRetryCodes_) && this.retry) {
                        const u = i.getErrorCode() === vy.ABORT;
                        r(!1, new Vm(!1, null, u));
                        return
                    }
                    const c = this.successCodes_.indexOf(l) !== -1;
                    r(!0, new Vm(c, i))
                })
            },
            n = (r, s) => {
                const i = this.resolve_,
                    o = this.reject_,
                    a = s.connection;
                if (s.wasSuccessCode) try {
                    const l = this.callback_(a, a.getResponse());
                    wbe(l) ? i(l) : i()
                } catch (l) {
                    o(l)
                } else if (a !== null) {
                    const l = fbe();
                    l.serverResponse = a.getErrorText(), this.errorCallback_ ? o(this.errorCallback_(a, l)) : o(l)
                } else if (s.canceled) {
                    const l = this.appDelete_ ? xj() : pbe();
                    o(l)
                } else {
                    const l = hbe();
                    o(l)
                }
            };
        this.canceled_ ? n(!1, new Vm(!1, null, !0)) : this.backoffId_ = vbe(t, n, this.timeout_)
    }
    getPromise() {
        return this.promise_
    }
    cancel(t) {
        this.canceled_ = !0, this.appDelete_ = t || !1, this.backoffId_ !== null && bbe(this.backoffId_), this.pendingConnection_ !== null && this.pendingConnection_.abort()
    }
}
class Vm {
    constructor(t, n, r) {
        this.wasSuccessCode = t, this.connection = n, this.canceled = !!r
    }
}

function $be(e, t) {
    t !== null && t.length > 0 && (e.Authorization = "Firebase " + t)
}

function kbe(e, t) {
    e["X-Firebase-Storage-Version"] = "webjs/" + (t != null ? t : "AppManager")
}

function Ibe(e, t) {
    t && (e["X-Firebase-GMPID"] = t)
}

function xbe(e, t) {
    t !== null && (e["X-Firebase-AppCheck"] = t)
}

function Cbe(e, t, n, r, s, i, o = !0) {
    const a = Ebe(e.urlParams),
        l = e.url + a,
        c = Object.assign({}, e.headers);
    return Ibe(c, t), $be(c, n), kbe(c, i), xbe(c, r), new Tbe(l, e.method, c, e.body, e.successCodes, e.additionalRetryCodes, e.handler, e.errorHandler, e.timeout, e.progressCallback, s, o)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Abe(e) {
    if (e.length === 0) return null;
    const t = e.lastIndexOf("/");
    return t === -1 ? "" : e.slice(0, t)
}

function Rbe(e) {
    const t = e.lastIndexOf("/", e.length - 2);
    return t === -1 ? e : e.slice(t + 1)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class by {
    constructor(t, n) {
        this._service = t, n instanceof us ? this._location = n : this._location = us.makeFromUrl(n, t.host)
    }
    toString() {
        return "gs://" + this._location.bucket + "/" + this._location.path
    }
    _newRef(t, n) {
        return new by(t, n)
    }
    get root() {
        const t = new us(this._location.bucket, "");
        return this._newRef(this._service, t)
    }
    get bucket() {
        return this._location.bucket
    }
    get fullPath() {
        return this._location.path
    }
    get name() {
        return Rbe(this._location.path)
    }
    get storage() {
        return this._service
    }
    get parent() {
        const t = Abe(this._location.path);
        if (t === null) return null;
        const n = new us(this._location.bucket, t);
        return new by(this._service, n)
    }
    _throwIfRoot(t) {
        if (this._location.path === "") throw _be(t)
    }
}

function ID(e, t) {
    const n = t == null ? void 0 : t[cbe];
    return n == null ? null : us.makeFromBucketSpec(n, e)
}
class Obe {
    constructor(t, n, r, s, i) {
        this.app = t, this._authProvider = n, this._appCheckProvider = r, this._url = s, this._firebaseVersion = i, this._bucket = null, this._host = Ij, this._protocol = "https", this._appId = null, this._deleted = !1, this._maxOperationRetryTime = ube, this._maxUploadRetryTime = dbe, this._requests = new Set, s != null ? this._bucket = us.makeFromBucketSpec(s, this._host) : this._bucket = ID(this._host, this.app.options)
    }
    get host() {
        return this._host
    }
    set host(t) {
        this._host = t, this._url != null ? this._bucket = us.makeFromBucketSpec(this._url, t) : this._bucket = ID(t, this.app.options)
    }
    get maxUploadRetryTime() {
        return this._maxUploadRetryTime
    }
    set maxUploadRetryTime(t) {
        kD("time", 0, Number.POSITIVE_INFINITY, t), this._maxUploadRetryTime = t
    }
    get maxOperationRetryTime() {
        return this._maxOperationRetryTime
    }
    set maxOperationRetryTime(t) {
        kD("time", 0, Number.POSITIVE_INFINITY, t), this._maxOperationRetryTime = t
    }
    async _getAuthToken() {
        if (this._overrideAuthToken) return this._overrideAuthToken;
        const t = this._authProvider.getImmediate({
            optional: !0
        });
        if (t) {
            const n = await t.getToken();
            if (n !== null) return n.accessToken
        }
        return null
    }
    async _getAppCheckToken() {
        const t = this._appCheckProvider.getImmediate({
            optional: !0
        });
        return t ? (await t.getToken()).token : null
    }
    _delete() {
        return this._deleted || (this._deleted = !0, this._requests.forEach(t => t.cancel()), this._requests.clear()), Promise.resolve()
    }
    _makeStorageReference(t) {
        return new by(this, t)
    }
    _makeRequest(t, n, r, s, i = !0) {
        if (this._deleted) return new ybe(xj()); {
            const o = Cbe(t, this._appId, r, s, n, this._firebaseVersion, i);
            return this._requests.add(o), o.getPromise().then(() => this._requests.delete(o), () => this._requests.delete(o)), o
        }
    }
    async makeRequestWithTokens(t, n) {
        const [r, s] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()]);
        return this._makeRequest(t, n, r, s).getPromise()
    }
}
const xD = "@firebase/storage",
    CD = "0.11.2";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Dbe = "storage";

function Nbe(e, {
    instanceIdentifier: t
}) {
    const n = e.getProvider("app").getImmediate(),
        r = e.getProvider("auth-internal"),
        s = e.getProvider("app-check-internal");
    return new Obe(n, r, s, t, ia)
}

function Pbe() {
    dr(new Kn(Dbe, Nbe, "PUBLIC").setMultipleInstances(!0)), cn(xD, CD, ""), cn(xD, CD, "esm2017")
}
Pbe();

function Mbe(e) {
    return (t, n) => {
        const r = abe(t, n).run(() => ae(e));
        Sj.set(t, r), lbe(r, t)
    }
}

function Lbe(e, {
    firebaseApp: t,
    modules: n = []
}) {
    e.provide(wj, t);
    for (const r of n) e.use(r.bind(null, t))
}
/*!
 * vue-router v4.1.6
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */
const hc = typeof window != "undefined";

function Fbe(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module"
}
const ht = Object.assign;

function ow(e, t) {
    const n = {};
    for (const r in t) {
        const s = t[r];
        n[r] = ys(s) ? s.map(e) : e(s)
    }
    return n
}
const xf = () => {},
    ys = Array.isArray,
    Ube = /\/$/,
    Bbe = e => e.replace(Ube, "");

function aw(e, t, n = "/") {
    let r, s = {},
        i = "",
        o = "";
    const a = t.indexOf("#");
    let l = t.indexOf("?");
    return a < l && a >= 0 && (l = -1), l > -1 && (r = t.slice(0, l), i = t.slice(l + 1, a > -1 ? a : t.length), s = e(i)), a > -1 && (r = r || t.slice(0, a), o = t.slice(a, t.length)), r = zbe(r != null ? r : t, n), {
        fullPath: r + (i && "?") + i + o,
        path: r,
        query: s,
        hash: o
    }
}

function Vbe(e, t) {
    const n = t.query ? e(t.query) : "";
    return t.path + (n && "?") + n + (t.hash || "")
}

function AD(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}

function Hbe(e, t, n) {
    const r = t.matched.length - 1,
        s = n.matched.length - 1;
    return r > -1 && r === s && Mu(t.matched[r], n.matched[s]) && Cj(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
}

function Mu(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}

function Cj(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length) return !1;
    for (const n in e)
        if (!jbe(e[n], t[n])) return !1;
    return !0
}

function jbe(e, t) {
    return ys(e) ? RD(e, t) : ys(t) ? RD(t, e) : e === t
}

function RD(e, t) {
    return ys(t) ? e.length === t.length && e.every((n, r) => n === t[r]) : e.length === 1 && e[0] === t
}

function zbe(e, t) {
    if (e.startsWith("/")) return e;
    if (!e) return t;
    const n = t.split("/"),
        r = e.split("/");
    let s = n.length - 1,
        i, o;
    for (i = 0; i < r.length; i++)
        if (o = r[i], o !== ".")
            if (o === "..") s > 1 && s--;
            else break;
    return n.slice(0, s).join("/") + "/" + r.slice(i - (i === r.length ? 1 : 0)).join("/")
}
var Lu;
(function(e) {
    e.pop = "pop", e.push = "push"
})(Lu || (Lu = {}));
var Xa;
(function(e) {
    e.back = "back", e.forward = "forward", e.unknown = ""
})(Xa || (Xa = {}));
const lw = "";

function Aj(e) {
    if (!e)
        if (hc) {
            const t = document.querySelector("base");
            e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "")
        } else e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), Bbe(e)
}
const Wbe = /^[^#]+#/;

function Rj(e, t) {
    return e.replace(Wbe, "#") + t
}

function Gbe(e, t) {
    const n = document.documentElement.getBoundingClientRect(),
        r = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: r.left - n.left - (t.left || 0),
        top: r.top - n.top - (t.top || 0)
    }
}
const Sb = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
});

function qbe(e) {
    let t;
    if ("el" in e) {
        const n = e.el,
            r = typeof n == "string" && n.startsWith("#"),
            s = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!s) return;
        t = Gbe(s, e)
    } else t = e;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.pageXOffset, t.top != null ? t.top : window.pageYOffset)
}

function OD(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const V1 = new Map;

function Ybe(e, t) {
    V1.set(e, t)
}

function Kbe(e) {
    const t = V1.get(e);
    return V1.delete(e), t
}
let Xbe = () => location.protocol + "//" + location.host;

function Oj(e, t) {
    const {
        pathname: n,
        search: r,
        hash: s
    } = t, i = e.indexOf("#");
    if (i > -1) {
        let a = s.includes(e.slice(i)) ? e.slice(i).length : 1,
            l = s.slice(a);
        return l[0] !== "/" && (l = "/" + l), AD(l, "")
    }
    return AD(n, e) + r + s
}

function Qbe(e, t, n, r) {
    let s = [],
        i = [],
        o = null;
    const a = ({
        state: f
    }) => {
        const h = Oj(e, location),
            p = n.value,
            m = t.value;
        let g = 0;
        if (f) {
            if (n.value = h, t.value = f, o && o === p) {
                o = null;
                return
            }
            g = m ? f.position - m.position : 0
        } else r(h);
        s.forEach(y => {
            y(n.value, p, {
                delta: g,
                type: Lu.pop,
                direction: g ? g > 0 ? Xa.forward : Xa.back : Xa.unknown
            })
        })
    };

    function l() {
        o = n.value
    }

    function c(f) {
        s.push(f);
        const h = () => {
            const p = s.indexOf(f);
            p > -1 && s.splice(p, 1)
        };
        return i.push(h), h
    }

    function u() {
        const {
            history: f
        } = window;
        !f.state || f.replaceState(ht({}, f.state, {
            scroll: Sb()
        }), "")
    }

    function d() {
        for (const f of i) f();
        i = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a), window.addEventListener("beforeunload", u), {
        pauseListeners: l,
        listen: c,
        destroy: d
    }
}

function DD(e, t, n, r = !1, s = !1) {
    return {
        back: e,
        current: t,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: s ? Sb() : null
    }
}

function Jbe(e) {
    const {
        history: t,
        location: n
    } = window, r = {
        value: Oj(e, n)
    }, s = {
        value: t.state
    };
    s.value || i(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);

    function i(l, c, u) {
        const d = e.indexOf("#"),
            f = d > -1 ? (n.host && document.querySelector("base") ? e : e.slice(d)) + l : Xbe() + e + l;
        try {
            t[u ? "replaceState" : "pushState"](c, "", f), s.value = c
        } catch (h) {
            console.error(h), n[u ? "replace" : "assign"](f)
        }
    }

    function o(l, c) {
        const u = ht({}, t.state, DD(s.value.back, l, s.value.forward, !0), c, {
            position: s.value.position
        });
        i(l, u, !0), r.value = l
    }

    function a(l, c) {
        const u = ht({}, s.value, t.state, {
            forward: l,
            scroll: Sb()
        });
        i(u.current, u, !0);
        const d = ht({}, DD(r.value, l, null), {
            position: u.position + 1
        }, c);
        i(l, d, !1), r.value = l
    }
    return {
        location: r,
        state: s,
        push: a,
        replace: o
    }
}

function Zbe(e) {
    e = Aj(e);
    const t = Jbe(e),
        n = Qbe(e, t.state, t.location, t.replace);

    function r(i, o = !0) {
        o || n.pauseListeners(), history.go(i)
    }
    const s = ht({
        location: "",
        base: e,
        go: r,
        createHref: Rj.bind(null, e)
    }, t, n);
    return Object.defineProperty(s, "location", {
        enumerable: !0,
        get: () => t.location.value
    }), Object.defineProperty(s, "state", {
        enumerable: !0,
        get: () => t.state.value
    }), s
}

function e0e(e = "") {
    let t = [],
        n = [lw],
        r = 0;
    e = Aj(e);

    function s(a) {
        r++, r === n.length || n.splice(r), n.push(a)
    }

    function i(a, l, {
        direction: c,
        delta: u
    }) {
        const d = {
            direction: c,
            delta: u,
            type: Lu.pop
        };
        for (const f of t) f(a, l, d)
    }
    const o = {
        location: lw,
        state: {},
        base: e,
        createHref: Rj.bind(null, e),
        replace(a) {
            n.splice(r--, 1), s(a)
        },
        push(a, l) {
            s(a)
        },
        listen(a) {
            return t.push(a), () => {
                const l = t.indexOf(a);
                l > -1 && t.splice(l, 1)
            }
        },
        destroy() {
            t = [], n = [lw], r = 0
        },
        go(a, l = !0) {
            const c = this.location,
                u = a < 0 ? Xa.back : Xa.forward;
            r = Math.max(0, Math.min(r + a, n.length - 1)), l && i(this.location, c, {
                direction: u,
                delta: a
            })
        }
    };
    return Object.defineProperty(o, "location", {
        enumerable: !0,
        get: () => n[r]
    }), o
}

function t0e(e) {
    return typeof e == "string" || e && typeof e == "object"
}

function Dj(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const ro = {
        path: "/",
        name: void 0,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: void 0
    },
    Nj = Symbol("");
var ND;
(function(e) {
    e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated"
})(ND || (ND = {}));

function Fu(e, t) {
    return ht(new Error, {
        type: e,
        [Nj]: !0
    }, t)
}

function Js(e, t) {
    return e instanceof Error && Nj in e && (t == null || !!(e.type & t))
}
const PD = "[^/]+?",
    n0e = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    },
    r0e = /[.+*?^${}()[\]/\\]/g;

function s0e(e, t) {
    const n = ht({}, n0e, t),
        r = [];
    let s = n.start ? "^" : "";
    const i = [];
    for (const c of e) {
        const u = c.length ? [] : [90];
        n.strict && !c.length && (s += "/");
        for (let d = 0; d < c.length; d++) {
            const f = c[d];
            let h = 40 + (n.sensitive ? .25 : 0);
            if (f.type === 0) d || (s += "/"), s += f.value.replace(r0e, "\\$&"), h += 40;
            else if (f.type === 1) {
                const {
                    value: p,
                    repeatable: m,
                    optional: g,
                    regexp: y
                } = f;
                i.push({
                    name: p,
                    repeatable: m,
                    optional: g
                });
                const _ = y || PD;
                if (_ !== PD) {
                    h += 10;
                    try {
                        new RegExp(`(${_})`)
                    } catch (b) {
                        throw new Error(`Invalid custom RegExp for param "${p}" (${_}): ` + b.message)
                    }
                }
                let E = m ? `((?:${_})(?:/(?:${_}))*)` : `(${_})`;
                d || (E = g && c.length < 2 ? `(?:/${E})` : "/" + E), g && (E += "?"), s += E, h += 20, g && (h += -8), m && (h += -20), _ === ".*" && (h += -50)
            }
            u.push(h)
        }
        r.push(u)
    }
    if (n.strict && n.end) {
        const c = r.length - 1;
        r[c][r[c].length - 1] += .7000000000000001
    }
    n.strict || (s += "/?"), n.end ? s += "$" : n.strict && (s += "(?:/|$)");
    const o = new RegExp(s, n.sensitive ? "" : "i");

    function a(c) {
        const u = c.match(o),
            d = {};
        if (!u) return null;
        for (let f = 1; f < u.length; f++) {
            const h = u[f] || "",
                p = i[f - 1];
            d[p.name] = h && p.repeatable ? h.split("/") : h
        }
        return d
    }

    function l(c) {
        let u = "",
            d = !1;
        for (const f of e) {
            (!d || !u.endsWith("/")) && (u += "/"), d = !1;
            for (const h of f)
                if (h.type === 0) u += h.value;
                else if (h.type === 1) {
                const {
                    value: p,
                    repeatable: m,
                    optional: g
                } = h, y = p in c ? c[p] : "";
                if (ys(y) && !m) throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
                const _ = ys(y) ? y.join("/") : y;
                if (!_)
                    if (g) f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : d = !0);
                    else throw new Error(`Missing required param "${p}"`);
                u += _
            }
        }
        return u || "/"
    }
    return {
        re: o,
        score: r,
        keys: i,
        parse: a,
        stringify: l
    }
}

function i0e(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length;) {
        const r = t[n] - e[n];
        if (r) return r;
        n++
    }
    return e.length < t.length ? e.length === 1 && e[0] === 40 + 40 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 40 + 40 ? 1 : -1 : 0
}

function o0e(e, t) {
    let n = 0;
    const r = e.score,
        s = t.score;
    for (; n < r.length && n < s.length;) {
        const i = i0e(r[n], s[n]);
        if (i) return i;
        n++
    }
    if (Math.abs(s.length - r.length) === 1) {
        if (MD(r)) return 1;
        if (MD(s)) return -1
    }
    return s.length - r.length
}

function MD(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const a0e = {
        type: 0,
        value: ""
    },
    l0e = /[a-zA-Z0-9_]/;

function c0e(e) {
    if (!e) return [
        []
    ];
    if (e === "/") return [
        [a0e]
    ];
    if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`);

    function t(h) {
        throw new Error(`ERR (${n})/"${c}": ${h}`)
    }
    let n = 0,
        r = n;
    const s = [];
    let i;

    function o() {
        i && s.push(i), i = []
    }
    let a = 0,
        l, c = "",
        u = "";

    function d() {
        !c || (n === 0 ? i.push({
            type: 0,
            value: c
        }) : n === 1 || n === 2 || n === 3 ? (i.length > 1 && (l === "*" || l === "+") && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), i.push({
            type: 1,
            value: c,
            regexp: u,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : t("Invalid state to consume buffer"), c = "")
    }

    function f() {
        c += l
    }
    for (; a < e.length;) {
        if (l = e[a++], l === "\\" && n !== 2) {
            r = n, n = 4;
            continue
        }
        switch (n) {
            case 0:
                l === "/" ? (c && d(), o()) : l === ":" ? (d(), n = 1) : f();
                break;
            case 4:
                f(), n = r;
                break;
            case 1:
                l === "(" ? n = 2 : l0e.test(l) ? f() : (d(), n = 0, l !== "*" && l !== "?" && l !== "+" && a--);
                break;
            case 2:
                l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : n = 3 : u += l;
                break;
            case 3:
                d(), n = 0, l !== "*" && l !== "?" && l !== "+" && a--, u = "";
                break;
            default:
                t("Unknown state");
                break
        }
    }
    return n === 2 && t(`Unfinished custom RegExp for param "${c}"`), d(), o(), s
}

function u0e(e, t, n) {
    const r = s0e(c0e(e.path), n),
        s = ht(r, {
            record: e,
            parent: t,
            children: [],
            alias: []
        });
    return t && !s.record.aliasOf == !t.record.aliasOf && t.children.push(s), s
}

function d0e(e, t) {
    const n = [],
        r = new Map;
    t = UD({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);

    function s(u) {
        return r.get(u)
    }

    function i(u, d, f) {
        const h = !f,
            p = f0e(u);
        p.aliasOf = f && f.record;
        const m = UD(t, u),
            g = [p];
        if ("alias" in u) {
            const E = typeof u.alias == "string" ? [u.alias] : u.alias;
            for (const b of E) g.push(ht({}, p, {
                components: f ? f.record.components : p.components,
                path: b,
                aliasOf: f ? f.record : p
            }))
        }
        let y, _;
        for (const E of g) {
            const {
                path: b
            } = E;
            if (d && b[0] !== "/") {
                const w = d.record.path,
                    T = w[w.length - 1] === "/" ? "" : "/";
                E.path = d.record.path + (b && T + b)
            }
            if (y = u0e(E, d, m), f ? f.alias.push(y) : (_ = _ || y, _ !== y && _.alias.push(y), h && u.name && !FD(y) && o(u.name)), p.children) {
                const w = p.children;
                for (let T = 0; T < w.length; T++) i(w[T], y, f && f.children[T])
            }
            f = f || y, (y.record.components && Object.keys(y.record.components).length || y.record.name || y.record.redirect) && l(y)
        }
        return _ ? () => {
            o(_)
        } : xf
    }

    function o(u) {
        if (Dj(u)) {
            const d = r.get(u);
            d && (r.delete(u), n.splice(n.indexOf(d), 1), d.children.forEach(o), d.alias.forEach(o))
        } else {
            const d = n.indexOf(u);
            d > -1 && (n.splice(d, 1), u.record.name && r.delete(u.record.name), u.children.forEach(o), u.alias.forEach(o))
        }
    }

    function a() {
        return n
    }

    function l(u) {
        let d = 0;
        for (; d < n.length && o0e(u, n[d]) >= 0 && (u.record.path !== n[d].record.path || !Pj(u, n[d]));) d++;
        n.splice(d, 0, u), u.record.name && !FD(u) && r.set(u.record.name, u)
    }

    function c(u, d) {
        let f, h = {},
            p, m;
        if ("name" in u && u.name) {
            if (f = r.get(u.name), !f) throw Fu(1, {
                location: u
            });
            m = f.record.name, h = ht(LD(d.params, f.keys.filter(_ => !_.optional).map(_ => _.name)), u.params && LD(u.params, f.keys.map(_ => _.name))), p = f.stringify(h)
        } else if ("path" in u) p = u.path, f = n.find(_ => _.re.test(p)), f && (h = f.parse(p), m = f.record.name);
        else {
            if (f = d.name ? r.get(d.name) : n.find(_ => _.re.test(d.path)), !f) throw Fu(1, {
                location: u,
                currentLocation: d
            });
            m = f.record.name, h = ht({}, d.params, u.params), p = f.stringify(h)
        }
        const g = [];
        let y = f;
        for (; y;) g.unshift(y.record), y = y.parent;
        return {
            name: m,
            path: p,
            params: h,
            matched: g,
            meta: p0e(g)
        }
    }
    return e.forEach(u => i(u)), {
        addRoute: i,
        resolve: c,
        removeRoute: o,
        getRoutes: a,
        getRecordMatcher: s
    }
}

function LD(e, t) {
    const n = {};
    for (const r of t) r in e && (n[r] = e[r]);
    return n
}

function f0e(e) {
    return {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: void 0,
        beforeEnter: e.beforeEnter,
        props: h0e(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in e ? e.components || null : e.component && {
            default: e.component
        }
    }
}

function h0e(e) {
    const t = {},
        n = e.props || !1;
    if ("component" in e) t.default = n;
    else
        for (const r in e.components) t[r] = typeof n == "boolean" ? n : n[r];
    return t
}

function FD(e) {
    for (; e;) {
        if (e.record.aliasOf) return !0;
        e = e.parent
    }
    return !1
}

function p0e(e) {
    return e.reduce((t, n) => ht(t, n.meta), {})
}

function UD(e, t) {
    const n = {};
    for (const r in e) n[r] = r in t ? t[r] : e[r];
    return n
}

function Pj(e, t) {
    return t.children.some(n => n === e || Pj(e, n))
}
const Mj = /#/g,
    m0e = /&/g,
    g0e = /\//g,
    _0e = /=/g,
    y0e = /\?/g,
    Lj = /\+/g,
    v0e = /%5B/g,
    b0e = /%5D/g,
    Fj = /%5E/g,
    w0e = /%60/g,
    Uj = /%7B/g,
    E0e = /%7C/g,
    Bj = /%7D/g,
    S0e = /%20/g;

function Yk(e) {
    return encodeURI("" + e).replace(E0e, "|").replace(v0e, "[").replace(b0e, "]")
}

function T0e(e) {
    return Yk(e).replace(Uj, "{").replace(Bj, "}").replace(Fj, "^")
}

function H1(e) {
    return Yk(e).replace(Lj, "%2B").replace(S0e, "+").replace(Mj, "%23").replace(m0e, "%26").replace(w0e, "`").replace(Uj, "{").replace(Bj, "}").replace(Fj, "^")
}

function $0e(e) {
    return H1(e).replace(_0e, "%3D")
}

function k0e(e) {
    return Yk(e).replace(Mj, "%23").replace(y0e, "%3F")
}

function I0e(e) {
    return e == null ? "" : k0e(e).replace(g0e, "%2F")
}

function wy(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}

function x0e(e) {
    const t = {};
    if (e === "" || e === "?") return t;
    const r = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let s = 0; s < r.length; ++s) {
        const i = r[s].replace(Lj, " "),
            o = i.indexOf("="),
            a = wy(o < 0 ? i : i.slice(0, o)),
            l = o < 0 ? null : wy(i.slice(o + 1));
        if (a in t) {
            let c = t[a];
            ys(c) || (c = t[a] = [c]), c.push(l)
        } else t[a] = l
    }
    return t
}

function BD(e) {
    let t = "";
    for (let n in e) {
        const r = e[n];
        if (n = $0e(n), r == null) {
            r !== void 0 && (t += (t.length ? "&" : "") + n);
            continue
        }(ys(r) ? r.map(i => i && H1(i)) : [r && H1(r)]).forEach(i => {
            i !== void 0 && (t += (t.length ? "&" : "") + n, i != null && (t += "=" + i))
        })
    }
    return t
}

function C0e(e) {
    const t = {};
    for (const n in e) {
        const r = e[n];
        r !== void 0 && (t[n] = ys(r) ? r.map(s => s == null ? null : "" + s) : r == null ? r : "" + r)
    }
    return t
}
const Vj = Symbol(""),
    VD = Symbol(""),
    Tb = Symbol(""),
    Kk = Symbol(""),
    j1 = Symbol("");

function Td() {
    let e = [];

    function t(r) {
        return e.push(r), () => {
            const s = e.indexOf(r);
            s > -1 && e.splice(s, 1)
        }
    }

    function n() {
        e = []
    }
    return {
        add: t,
        list: () => e,
        reset: n
    }
}

function A0e(e, t, n) {
    const r = () => {
        e[t].delete(n)
    };
    Fl(r), ab(r), ob(() => {
        e[t].add(n)
    }), e[t].add(n)
}

function XRe(e) {
    const t = bt(Vj, {}).value;
    !t || A0e(t, "leaveGuards", e)
}

function uo(e, t, n, r, s) {
    const i = r && (r.enterCallbacks[s] = r.enterCallbacks[s] || []);
    return () => new Promise((o, a) => {
        const l = d => {
                d === !1 ? a(Fu(4, {
                    from: n,
                    to: t
                })) : d instanceof Error ? a(d) : t0e(d) ? a(Fu(2, {
                    from: t,
                    to: d
                })) : (i && r.enterCallbacks[s] === i && typeof d == "function" && i.push(d), o())
            },
            c = e.call(r && r.instances[s], t, n, l);
        let u = Promise.resolve(c);
        e.length < 3 && (u = u.then(l)), u.catch(d => a(d))
    })
}

function cw(e, t, n, r) {
    const s = [];
    for (const i of e)
        for (const o in i.components) {
            let a = i.components[o];
            if (!(t !== "beforeRouteEnter" && !i.instances[o]))
                if (R0e(a)) {
                    const c = (a.__vccOpts || a)[t];
                    c && s.push(uo(c, n, r, i, o))
                } else {
                    let l = a();
                    s.push(() => l.then(c => {
                        if (!c) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${i.path}"`));
                        const u = Fbe(c) ? c.default : c;
                        i.components[o] = u;
                        const f = (u.__vccOpts || u)[t];
                        return f && uo(f, n, r, i, o)()
                    }))
                }
        }
    return s
}

function R0e(e) {
    return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e
}

function HD(e) {
    const t = bt(Tb),
        n = bt(Kk),
        r = Fe(() => t.resolve(fe(e.to))),
        s = Fe(() => {
            const {
                matched: l
            } = r.value, {
                length: c
            } = l, u = l[c - 1], d = n.matched;
            if (!u || !d.length) return -1;
            const f = d.findIndex(Mu.bind(null, u));
            if (f > -1) return f;
            const h = jD(l[c - 2]);
            return c > 1 && jD(u) === h && d[d.length - 1].path !== h ? d.findIndex(Mu.bind(null, l[c - 2])) : f
        }),
        i = Fe(() => s.value > -1 && P0e(n.params, r.value.params)),
        o = Fe(() => s.value > -1 && s.value === n.matched.length - 1 && Cj(n.params, r.value.params));

    function a(l = {}) {
        return N0e(l) ? t[fe(e.replace) ? "replace" : "push"](fe(e.to)).catch(xf) : Promise.resolve()
    }
    return {
        route: r,
        href: Fe(() => r.value.href),
        isActive: i,
        isExactActive: o,
        navigate: a
    }
}
const O0e = Ir({
        name: "RouterLink",
        compatConfig: {
            MODE: 3
        },
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
                type: String,
                default: "page"
            }
        },
        useLink: HD,
        setup(e, {
            slots: t
        }) {
            const n = Pr(HD(e)),
                {
                    options: r
                } = bt(Tb),
                s = Fe(() => ({
                    [zD(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
                    [zD(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
                }));
            return () => {
                const i = t.default && t.default(n);
                return e.custom ? i : Vs("a", {
                    "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                    href: n.href,
                    onClick: n.navigate,
                    class: s.value
                }, i)
            }
        }
    }),
    D0e = O0e;

function N0e(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t)) return
        }
        return e.preventDefault && e.preventDefault(), !0
    }
}

function P0e(e, t) {
    for (const n in t) {
        const r = t[n],
            s = e[n];
        if (typeof r == "string") {
            if (r !== s) return !1
        } else if (!ys(s) || s.length !== r.length || r.some((i, o) => i !== s[o])) return !1
    }
    return !0
}

function jD(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const zD = (e, t, n) => e != null ? e : t != null ? t : n,
    M0e = Ir({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(e, {
            attrs: t,
            slots: n
        }) {
            const r = bt(j1),
                s = Fe(() => e.route || r.value),
                i = bt(VD, 0),
                o = Fe(() => {
                    let c = fe(i);
                    const {
                        matched: u
                    } = s.value;
                    let d;
                    for (;
                        (d = u[c]) && !d.components;) c++;
                    return c
                }),
                a = Fe(() => s.value.matched[o.value]);
            fi(VD, Fe(() => o.value + 1)), fi(Vj, a), fi(j1, s);
            const l = ae();
            return $t(() => [l.value, a.value, e.name], ([c, u, d], [f, h, p]) => {
                u && (u.instances[d] = c, h && h !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards), u.updateGuards.size || (u.updateGuards = h.updateGuards))), c && u && (!h || !Mu(u, h) || !f) && (u.enterCallbacks[d] || []).forEach(m => m(c))
            }, {
                flush: "post"
            }), () => {
                const c = s.value,
                    u = e.name,
                    d = a.value,
                    f = d && d.components[u];
                if (!f) return WD(n.default, {
                    Component: f,
                    route: c
                });
                const h = d.props[u],
                    p = h ? h === !0 ? c.params : typeof h == "function" ? h(c) : h : null,
                    g = Vs(f, ht({}, p, t, {
                        onVnodeUnmounted: y => {
                            y.component.isUnmounted && (d.instances[u] = null)
                        },
                        ref: l
                    }));
                return WD(n.default, {
                    Component: g,
                    route: c
                }) || g
            }
        }
    });

function WD(e, t) {
    if (!e) return null;
    const n = e(t);
    return n.length === 1 ? n[0] : n
}
const L0e = M0e;

function F0e(e) {
    const t = d0e(e.routes, e),
        n = e.parseQuery || x0e,
        r = e.stringifyQuery || BD,
        s = e.history,
        i = Td(),
        o = Td(),
        a = Td(),
        l = yl(ro);
    let c = ro;
    hc && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const u = ow.bind(null, L => "" + L),
        d = ow.bind(null, I0e),
        f = ow.bind(null, wy);

    function h(L, se) {
        let D, V;
        return Dj(L) ? (D = t.getRecordMatcher(L), V = se) : V = L, t.addRoute(V, D)
    }

    function p(L) {
        const se = t.getRecordMatcher(L);
        se && t.removeRoute(se)
    }

    function m() {
        return t.getRoutes().map(L => L.record)
    }

    function g(L) {
        return !!t.getRecordMatcher(L)
    }

    function y(L, se) {
        if (se = ht({}, se || l.value), typeof L == "string") {
            const ee = aw(n, L, se.path),
                I = t.resolve({
                    path: ee.path
                }, se),
                A = s.createHref(ee.fullPath);
            return ht(ee, I, {
                params: f(I.params),
                hash: wy(ee.hash),
                redirectedFrom: void 0,
                href: A
            })
        }
        let D;
        if ("path" in L) D = ht({}, L, {
            path: aw(n, L.path, se.path).path
        });
        else {
            const ee = ht({}, L.params);
            for (const I in ee) ee[I] == null && delete ee[I];
            D = ht({}, L, {
                params: d(L.params)
            }), se.params = d(se.params)
        }
        const V = t.resolve(D, se),
            oe = L.hash || "";
        V.params = u(f(V.params));
        const we = Vbe(r, ht({}, L, {
                hash: T0e(oe),
                path: V.path
            })),
            ge = s.createHref(we);
        return ht({
            fullPath: we,
            hash: oe,
            query: r === BD ? C0e(L.query) : L.query || {}
        }, V, {
            redirectedFrom: void 0,
            href: ge
        })
    }

    function _(L) {
        return typeof L == "string" ? aw(n, L, l.value.path) : ht({}, L)
    }

    function E(L, se) {
        if (c !== L) return Fu(8, {
            from: se,
            to: L
        })
    }

    function b(L) {
        return S(L)
    }

    function w(L) {
        return b(ht(_(L), {
            replace: !0
        }))
    }

    function T(L) {
        const se = L.matched[L.matched.length - 1];
        if (se && se.redirect) {
            const {
                redirect: D
            } = se;
            let V = typeof D == "function" ? D(L) : D;
            return typeof V == "string" && (V = V.includes("?") || V.includes("#") ? V = _(V) : {
                path: V
            }, V.params = {}), ht({
                query: L.query,
                hash: L.hash,
                params: "path" in V ? {} : L.params
            }, V)
        }
    }

    function S(L, se) {
        const D = c = y(L),
            V = l.value,
            oe = L.state,
            we = L.force,
            ge = L.replace === !0,
            ee = T(D);
        if (ee) return S(ht(_(ee), {
            state: typeof ee == "object" ? ht({}, oe, ee.state) : oe,
            force: we,
            replace: ge
        }), se || D);
        const I = D;
        I.redirectedFrom = se;
        let A;
        return !we && Hbe(r, V, D) && (A = Fu(16, {
            to: I,
            from: V
        }), Kt(V, V, !0, !1)), (A ? Promise.resolve(A) : $(I, V)).catch(P => Js(P) ? Js(P, 2) ? P : Ue(P) : ie(P, I, V)).then(P => {
            if (P) {
                if (Js(P, 2)) return S(ht({
                    replace: ge
                }, _(P.to), {
                    state: typeof P.to == "object" ? ht({}, oe, P.to.state) : oe,
                    force: we
                }), se || I)
            } else P = C(I, V, !0, ge, oe);
            return k(I, V, P), P
        })
    }

    function v(L, se) {
        const D = E(L, se);
        return D ? Promise.reject(D) : Promise.resolve()
    }

    function $(L, se) {
        let D;
        const [V, oe, we] = U0e(L, se);
        D = cw(V.reverse(), "beforeRouteLeave", L, se);
        for (const ee of V) ee.leaveGuards.forEach(I => {
            D.push(uo(I, L, se))
        });
        const ge = v.bind(null, L, se);
        return D.push(ge), tc(D).then(() => {
            D = [];
            for (const ee of i.list()) D.push(uo(ee, L, se));
            return D.push(ge), tc(D)
        }).then(() => {
            D = cw(oe, "beforeRouteUpdate", L, se);
            for (const ee of oe) ee.updateGuards.forEach(I => {
                D.push(uo(I, L, se))
            });
            return D.push(ge), tc(D)
        }).then(() => {
            D = [];
            for (const ee of L.matched)
                if (ee.beforeEnter && !se.matched.includes(ee))
                    if (ys(ee.beforeEnter))
                        for (const I of ee.beforeEnter) D.push(uo(I, L, se));
                    else D.push(uo(ee.beforeEnter, L, se));
            return D.push(ge), tc(D)
        }).then(() => (L.matched.forEach(ee => ee.enterCallbacks = {}), D = cw(we, "beforeRouteEnter", L, se), D.push(ge), tc(D))).then(() => {
            D = [];
            for (const ee of o.list()) D.push(uo(ee, L, se));
            return D.push(ge), tc(D)
        }).catch(ee => Js(ee, 8) ? ee : Promise.reject(ee))
    }

    function k(L, se, D) {
        for (const V of a.list()) V(L, se, D)
    }

    function C(L, se, D, V, oe) {
        const we = E(L, se);
        if (we) return we;
        const ge = se === ro,
            ee = hc ? history.state : {};
        D && (V || ge ? s.replace(L.fullPath, ht({
            scroll: ge && ee && ee.scroll
        }, oe)) : s.push(L.fullPath, oe)), l.value = L, Kt(L, se, D, ge), Ue()
    }
    let O;

    function R() {
        O || (O = s.listen((L, se, D) => {
            if (!pr.listening) return;
            const V = y(L),
                oe = T(V);
            if (oe) {
                S(ht(oe, {
                    replace: !0
                }), V).catch(xf);
                return
            }
            c = V;
            const we = l.value;
            hc && Ybe(OD(we.fullPath, D.delta), Sb()), $(V, we).catch(ge => Js(ge, 12) ? ge : Js(ge, 2) ? (S(ge.to, V).then(ee => {
                Js(ee, 20) && !D.delta && D.type === Lu.pop && s.go(-1, !1)
            }).catch(xf), Promise.reject()) : (D.delta && s.go(-D.delta, !1), ie(ge, V, we))).then(ge => {
                ge = ge || C(V, we, !1), ge && (D.delta && !Js(ge, 8) ? s.go(-D.delta, !1) : D.type === Lu.pop && Js(ge, 20) && s.go(-1, !1)), k(V, we, ge)
            }).catch(xf)
        }))
    }
    let N = Td(),
        J = Td(),
        Y;

    function ie(L, se, D) {
        Ue(L);
        const V = J.list();
        return V.length ? V.forEach(oe => oe(L, se, D)) : console.error(L), Promise.reject(L)
    }

    function ce() {
        return Y && l.value !== ro ? Promise.resolve() : new Promise((L, se) => {
            N.add([L, se])
        })
    }

    function Ue(L) {
        return Y || (Y = !L, R(), N.list().forEach(([se, D]) => L ? D(L) : se()), N.reset()), L
    }

    function Kt(L, se, D, V) {
        const {
            scrollBehavior: oe
        } = e;
        if (!hc || !oe) return Promise.resolve();
        const we = !D && Kbe(OD(L.fullPath, 0)) || (V || !D) && history.state && history.state.scroll || null;
        return ln().then(() => oe(L, se, we)).then(ge => ge && qbe(ge)).catch(ge => ie(ge, L, se))
    }
    const Yt = L => s.go(L);
    let pn;
    const mn = new Set,
        pr = {
            currentRoute: l,
            listening: !0,
            addRoute: h,
            removeRoute: p,
            hasRoute: g,
            getRoutes: m,
            resolve: y,
            options: e,
            push: b,
            replace: w,
            go: Yt,
            back: () => Yt(-1),
            forward: () => Yt(1),
            beforeEach: i.add,
            beforeResolve: o.add,
            afterEach: a.add,
            onError: J.add,
            isReady: ce,
            install(L) {
                const se = this;
                L.component("RouterLink", D0e), L.component("RouterView", L0e), L.config.globalProperties.$router = se, Object.defineProperty(L.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: () => fe(l)
                }), hc && !pn && l.value === ro && (pn = !0, b(s.location).catch(oe => {}));
                const D = {};
                for (const oe in ro) D[oe] = Fe(() => l.value[oe]);
                L.provide(Tb, se), L.provide(Kk, Pr(D)), L.provide(j1, l);
                const V = L.unmount;
                mn.add(L), L.unmount = function() {
                    mn.delete(L), mn.size < 1 && (c = ro, O && O(), O = null, l.value = ro, pn = !1, Y = !1), V()
                }
            }
        };
    return pr
}

function tc(e) {
    return e.reduce((t, n) => t.then(() => n()), Promise.resolve())
}

function U0e(e, t) {
    const n = [],
        r = [],
        s = [],
        i = Math.max(t.matched.length, e.matched.length);
    for (let o = 0; o < i; o++) {
        const a = t.matched[o];
        a && (e.matched.find(c => Mu(c, a)) ? r.push(a) : n.push(a));
        const l = e.matched[o];
        l && (t.matched.find(c => Mu(c, l)) || s.push(l))
    }
    return [n, r, s]
}

function Xk() {
    return bt(Tb)
}

function Vp() {
    return bt(Kk)
}
const Hj = ibe();
_j(Hj);
const B0e = qk(),
    V0e = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    H0e = K("path", {
        fill: "currentColor",
        d: "m17.705 7.705l-1.41-1.41L12 10.59L7.705 6.295l-1.41 1.41L10.59 12l-4.295 4.295l1.41 1.41L12 13.41l4.295 4.295l1.41-1.41L13.41 12l4.295-4.295z"
    }, null, -1),
    j0e = [H0e];

function z0e(e, t) {
    return z(), Se("svg", V0e, j0e)
}
var W0e = {
    name: "gridicons-cross-small",
    render: z0e
};
const G0e = {
        name: "UiModal",
        inheritAttrs: !1,
        props: {
            actions: {
                type: Boolean,
                default: !1
            },
            clickToClose: {
                type: Boolean,
                default: !0
            },
            contentClasses: {
                type: String,
                default: ""
            },
            escToClose: {
                type: Boolean,
                default: !0
            },
            loading: {
                type: Boolean,
                default: !1
            },
            name: {
                type: String,
                required: !0
            },
            showClose: {
                type: Boolean,
                default: !0
            }
        },
        emits: ["confirm", "cancel"]
    },
    q0e = {
        key: 0,
        class: "mr-8 text-xl font-bold pt-1 px-1"
    },
    Y0e = {
        class: "flex-grow overflow-auto p-1"
    },
    K0e = {
        key: 1,
        class: "flex items-center justify-center flex-shrink-0 space-x-2 pb-1 px-1"
    },
    X0e = hn(" Confirm "),
    Q0e = hn(" Cancel "),
    J0e = ["onClick"];

function Z0e(e, t, n, r, s, i) {
    const o = Eb,
        a = W0e,
        l = Do("VueFinalModal");
    return z(), ke(l, xi(e.$attrs, {
        name: n.name,
        ssr: !1,
        "esc-to-close": n.escToClose,
        "click-to-close": n.clickToClose,
        classes: "flex justify-center items-center backdrop-blur-sm my-4",
        "content-class": `relative flex flex-col max-h-full p-4 md:p-6 mx-4 space-y-4 bg-white border border-slate-300 rounded-3xl shadow-md ${n.contentClasses}`
    }), {
        default: Re(({
            params: c,
            close: u
        }) => [e.$slots.title ? (z(), Se("span", q0e, [Gn(e.$slots, "title", {}, void 0, !0)])) : Ve("", !0), K("div", Y0e, [Gn(e.$slots, "default", {
            params: c
        }, void 0, !0)]), e.$slots.actions || n.actions ? (z(), Se("div", K0e, [Gn(e.$slots, "actions", {}, () => [ne(o, {
            size: "sm",
            theme: "primary",
            onClick: d => e.$emit("confirm", u)
        }, {
            default: Re(() => [X0e]),
            _: 2
        }, 1032, ["onClick"]), ne(o, {
            size: "sm",
            theme: "outline",
            onClick: d => e.$emit("cancel", u)
        }, {
            default: Re(() => [Q0e]),
            _: 2
        }, 1032, ["onClick"])], !0)])) : Ve("", !0), n.showClose ? (z(), Se("button", {
            key: 2,
            type: "button",
            class: "absolute top-2 !mt-0 right-3 text-slate-600 hover:text-red-800",
            onClick: u
        }, [ne(a)], 8, J0e)) : Ve("", !0)]),
        _: 3
    }, 16, ["name", "esc-to-close", "click-to-close", "content-class"])
}
var ewe = bs(G0e, [
    ["render", Z0e],
    ["__scopeId", "data-v-391ed836"]
]);
const Vh = async (e = {}, t = {}, n = {}) => {
    const {
        $vfm: r
    } = await at(() => Promise.resolve().then(function() {
        return aIe
    }), void 0);
    r == null || r.show({
        component: ewe,
        bind: e,
        on: G(x({
            confirm(s) {
                s()
            }
        }, n), {
            cancel(s) {
                s()
            }
        }),
        slots: t
    })
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Z = function() {
    return Z = Object.assign || function(t) {
        for (var n, r = 1, s = arguments.length; r < s; r++) {
            n = arguments[r];
            for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
        }
        return t
    }, Z.apply(this, arguments)
};

function Qk(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]]);
    return n
}

function Ke(e) {
    var t = typeof Symbol == "function" && Symbol.iterator,
        n = t && e[t],
        r = 0;
    if (n) return n.call(e);
    if (e && typeof e.length == "number") return {
        next: function() {
            return e && r >= e.length && (e = void 0), {
                value: e && e[r++],
                done: !e
            }
        }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function ct(e, t) {
    var n = typeof Symbol == "function" && e[Symbol.iterator];
    if (!n) return e;
    var r = n.call(e),
        s, i = [],
        o;
    try {
        for (;
            (t === void 0 || t-- > 0) && !(s = r.next()).done;) i.push(s.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (n = r.return) && n.call(r)
        } finally {
            if (o) throw o.error
        }
    }
    return i
}

function Ut(e, t, n) {
    if (n || arguments.length === 2)
        for (var r = 0, s = t.length, i; r < s; r++)(i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
    return e.concat(i || Array.prototype.slice.call(t))
}
var _t;
(function(e) {
    e.Start = "xstate.start", e.Stop = "xstate.stop", e.Raise = "xstate.raise", e.Send = "xstate.send", e.Cancel = "xstate.cancel", e.NullEvent = "", e.Assign = "xstate.assign", e.After = "xstate.after", e.DoneState = "done.state", e.DoneInvoke = "done.invoke", e.Log = "xstate.log", e.Init = "xstate.init", e.Invoke = "xstate.invoke", e.ErrorExecution = "error.execution", e.ErrorCommunication = "error.communication", e.ErrorPlatform = "error.platform", e.ErrorCustom = "xstate.error", e.Update = "xstate.update", e.Pure = "xstate.pure", e.Choose = "xstate.choose"
})(_t || (_t = {}));
var Hh;
(function(e) {
    e.Parent = "#_parent", e.Internal = "#_internal"
})(Hh || (Hh = {}));
var z1 = _t.Start,
    Jk = _t.Stop,
    $b = _t.Raise,
    kb = _t.Send,
    jj = _t.Cancel,
    twe = _t.NullEvent,
    W1 = _t.Assign;
_t.After;
_t.DoneState;
var zj = _t.Log,
    nwe = _t.Init,
    G1 = _t.Invoke;
_t.ErrorExecution;
var GD = _t.ErrorPlatform,
    rwe = _t.ErrorCustom,
    Wj = _t.Update,
    swe = _t.Choose,
    iwe = _t.Pure,
    Gj = ".",
    qD = {},
    q1 = "xstate.guard",
    owe = "",
    $d = !0,
    Hm;

function Zk(e, t, n) {
    n === void 0 && (n = Gj);
    var r = Cf(e, n),
        s = Cf(t, n);
    return ot(s) ? ot(r) ? s === r : !1 : ot(r) ? r in s : Object.keys(r).every(function(i) {
        return i in s ? Zk(r[i], s[i]) : !1
    })
}

function qj(e) {
    try {
        return ot(e) || typeof e == "number" ? "".concat(e) : e.type
    } catch {
        throw new Error("Events must be strings or objects with a string event.type property.")
    }
}

function Y1(e, t) {
    try {
        return ad(e) ? e : e.toString().split(t)
    } catch {
        throw new Error("'".concat(e, "' is not a valid state path."))
    }
}

function awe(e) {
    return typeof e == "object" && "value" in e && "context" in e && "event" in e && "_event" in e
}

function Cf(e, t) {
    if (awe(e)) return e.value;
    if (ad(e)) return Ey(e);
    if (typeof e != "string") return e;
    var n = Y1(e, t);
    return Ey(n)
}

function Ey(e) {
    if (e.length === 1) return e[0];
    for (var t = {}, n = t, r = 0; r < e.length - 1; r++) r === e.length - 2 ? n[e[r]] = e[r + 1] : (n[e[r]] = {}, n = n[e[r]]);
    return t
}

function jd(e, t) {
    for (var n = {}, r = Object.keys(e), s = 0; s < r.length; s++) {
        var i = r[s];
        n[i] = t(e[i], i, e, s)
    }
    return n
}

function YD(e, t, n) {
    var r, s, i = {};
    try {
        for (var o = Ke(Object.keys(e)), a = o.next(); !a.done; a = o.next()) {
            var l = a.value,
                c = e[l];
            !n(c) || (i[l] = t(c, l, e))
        }
    } catch (u) {
        r = {
            error: u
        }
    } finally {
        try {
            a && !a.done && (s = o.return) && s.call(o)
        } finally {
            if (r) throw r.error
        }
    }
    return i
}
var lwe = function(e) {
    return function(t) {
        var n, r, s = t;
        try {
            for (var i = Ke(e), o = i.next(); !o.done; o = i.next()) {
                var a = o.value;
                s = s[a]
            }
        } catch (l) {
            n = {
                error: l
            }
        } finally {
            try {
                o && !o.done && (r = i.return) && r.call(i)
            } finally {
                if (n) throw n.error
            }
        }
        return s
    }
};

function cwe(e, t) {
    return function(n) {
        var r, s, i = n;
        try {
            for (var o = Ke(e), a = o.next(); !a.done; a = o.next()) {
                var l = a.value;
                i = i[t][l]
            }
        } catch (c) {
            r = {
                error: c
            }
        } finally {
            try {
                a && !a.done && (s = o.return) && s.call(o)
            } finally {
                if (r) throw r.error
            }
        }
        return i
    }
}

function Rg(e) {
    if (!e) return [
        []
    ];
    if (ot(e)) return [
        [e]
    ];
    var t = Rt(Object.keys(e).map(function(n) {
        var r = e[n];
        return typeof r != "string" && (!r || !Object.keys(r).length) ? [
            [n]
        ] : Rg(e[n]).map(function(s) {
            return [n].concat(s)
        })
    }));
    return t
}

function Rt(e) {
    var t;
    return (t = []).concat.apply(t, Ut([], ct(e), !1))
}

function Yj(e) {
    return ad(e) ? e : [e]
}

function es(e) {
    return e === void 0 ? [] : Yj(e)
}

function Sy(e, t, n) {
    var r, s;
    if (pt(e)) return e(t, n.data);
    var i = {};
    try {
        for (var o = Ke(Object.keys(e)), a = o.next(); !a.done; a = o.next()) {
            var l = a.value,
                c = e[l];
            pt(c) ? i[l] = c(t, n.data) : i[l] = c
        }
    } catch (u) {
        r = {
            error: u
        }
    } finally {
        try {
            a && !a.done && (s = o.return) && s.call(o)
        } finally {
            if (r) throw r.error
        }
    }
    return i
}

function uwe(e) {
    return /^(done|error)\./.test(e)
}

function KD(e) {
    return !!(e instanceof Promise || e !== null && (pt(e) || typeof e == "object") && pt(e.then))
}

function dwe(e) {
    return e !== null && typeof e == "object" && "transition" in e && typeof e.transition == "function"
}

function Kj(e, t) {
    var n, r, s = ct([
            [],
            []
        ], 2),
        i = s[0],
        o = s[1];
    try {
        for (var a = Ke(e), l = a.next(); !l.done; l = a.next()) {
            var c = l.value;
            t(c) ? i.push(c) : o.push(c)
        }
    } catch (u) {
        n = {
            error: u
        }
    } finally {
        try {
            l && !l.done && (r = a.return) && r.call(a)
        } finally {
            if (n) throw n.error
        }
    }
    return [i, o]
}

function Xj(e, t) {
    return jd(e.states, function(n, r) {
        if (!!n) {
            var s = (ot(t) ? void 0 : t[r]) || (n ? n.current : void 0);
            if (!!s) return {
                current: s,
                states: Xj(n, s)
            }
        }
    })
}

function fwe(e, t) {
    return {
        current: t,
        states: Xj(e, t)
    }
}

function XD(e, t, n, r) {
    var s = e && n.reduce(function(i, o) {
        var a, l, c = o.assignment,
            u = {
                state: r,
                action: o,
                _event: t
            },
            d = {};
        if (pt(c)) d = c(i, t.data, u);
        else try {
            for (var f = Ke(Object.keys(c)), h = f.next(); !h.done; h = f.next()) {
                var p = h.value,
                    m = c[p];
                d[p] = pt(m) ? m(i, t.data, u) : m
            }
        } catch (g) {
            a = {
                error: g
            }
        } finally {
            try {
                h && !h.done && (l = f.return) && l.call(f)
            } finally {
                if (a) throw a.error
            }
        }
        return Object.assign({}, i, d)
    }, e);
    return s
}
var Af = function() {};

function ad(e) {
    return Array.isArray(e)
}

function pt(e) {
    return typeof e == "function"
}

function ot(e) {
    return typeof e == "string"
}

function Qj(e, t) {
    if (!!e) return ot(e) ? {
        type: q1,
        name: e,
        predicate: t ? t[e] : void 0
    } : pt(e) ? {
        type: q1,
        name: e.name,
        predicate: e
    } : e
}

function hwe(e) {
    try {
        return "subscribe" in e && pt(e.subscribe)
    } catch {
        return !1
    }
}
var _o = function() {
    return typeof Symbol == "function" && Symbol.observable || "@@observable"
}();
Hm = {}, Hm[_o] = function() {
    return this
}, Hm[Symbol.observable] = function() {
    return this
};

function Tl(e) {
    return !!e && "__xstatenode" in e
}

function pwe(e) {
    return !!e && typeof e.send == "function"
}

function eI(e, t) {
    return ot(e) || typeof e == "number" ? Z({
        type: e
    }, t) : e
}

function Ln(e, t) {
    if (!ot(e) && "$$type" in e && e.$$type === "scxml") return e;
    var n = eI(e);
    return Z({
        name: n.type,
        data: n,
        $$type: "scxml",
        type: "external"
    }, t)
}

function nc(e, t) {
    var n = Yj(t).map(function(r) {
        return typeof r == "undefined" || typeof r == "string" || Tl(r) ? {
            target: r,
            event: e
        } : Z(Z({}, r), {
            event: e
        })
    });
    return n
}

function mwe(e) {
    if (!(e === void 0 || e === owe)) return es(e)
}

function Jj(e, t, n, r, s) {
    var i = e.options.guards,
        o = {
            state: s,
            cond: t,
            _event: r
        };
    if (t.type === q1) return ((i == null ? void 0 : i[t.name]) || t.predicate)(n, r.data, o);
    var a = i == null ? void 0 : i[t.type];
    if (!a) throw new Error("Guard '".concat(t.type, "' is not implemented on machine '").concat(e.id, "'."));
    return a(n, r.data, o)
}

function Zj(e) {
    return typeof e == "string" ? {
        type: e
    } : e
}

function Ty(e, t, n) {
    if (typeof e == "object") return e;
    var r = function() {};
    return {
        next: e,
        error: t || r,
        complete: n || r
    }
}

function jm(e, t) {
    return "".concat(e, ":invocation[").concat(t, "]")
}
var $y = Ln({
    type: nwe
});

function K1(e, t) {
    return t && t[e] || void 0
}

function jh(e, t) {
    var n;
    if (ot(e) || typeof e == "number") {
        var r = K1(e, t);
        pt(r) ? n = {
            type: e,
            exec: r
        } : r ? n = r : n = {
            type: e,
            exec: void 0
        }
    } else if (pt(e)) n = {
        type: e.name || e.toString(),
        exec: e
    };
    else {
        var r = K1(e.type, t);
        if (pt(r)) n = Z(Z({}, e), {
            exec: r
        });
        else if (r) {
            var s = r.type || e.type;
            n = Z(Z(Z({}, r), e), {
                type: s
            })
        } else n = e
    }
    return n
}
var ky = function(e, t) {
    if (!e) return [];
    var n = ad(e) ? e : [e];
    return n.map(function(r) {
        return jh(r, t)
    })
};

function tI(e) {
    var t = jh(e);
    return Z(Z({
        id: ot(e) ? e : t.id
    }, t), {
        type: t.type
    })
}

function gwe(e) {
    return ot(e) ? {
        type: $b,
        event: e
    } : e3(e, {
        to: Hh.Internal
    })
}

function _we(e) {
    return {
        type: $b,
        _event: Ln(e.event)
    }
}

function e3(e, t) {
    return {
        to: t ? t.to : void 0,
        type: kb,
        event: pt(e) ? e : eI(e),
        delay: t ? t.delay : void 0,
        id: t && t.id !== void 0 ? t.id : pt(e) ? e.name : qj(e)
    }
}

function ywe(e, t, n, r) {
    var s = {
            _event: n
        },
        i = Ln(pt(e.event) ? e.event(t, n.data, s) : e.event),
        o;
    if (ot(e.delay)) {
        var a = r && r[e.delay];
        o = pt(a) ? a(t, n.data, s) : a
    } else o = pt(e.delay) ? e.delay(t, n.data, s) : e.delay;
    var l = pt(e.to) ? e.to(t, n.data, s) : e.to;
    return Z(Z({}, e), {
        to: l,
        _event: i,
        event: i.data,
        delay: o
    })
}
var vwe = function(e, t, n) {
        return Z(Z({}, e), {
            value: ot(e.expr) ? e.expr : e.expr(t, n.data, {
                _event: n
            })
        })
    },
    bwe = function(e) {
        return {
            type: jj,
            sendId: e
        }
    };

function wwe(e) {
    var t = tI(e);
    return {
        type: _t.Start,
        activity: t,
        exec: void 0
    }
}

function Ewe(e) {
    var t = pt(e) ? e : tI(e);
    return {
        type: _t.Stop,
        activity: t,
        exec: void 0
    }
}

function Swe(e, t, n) {
    var r = pt(e.activity) ? e.activity(t, n.data) : e.activity,
        s = typeof r == "string" ? {
            id: r
        } : r,
        i = {
            type: _t.Stop,
            activity: s
        };
    return i
}
var Twe = function(e) {
    return {
        type: W1,
        assignment: e
    }
};

function $we(e, t) {
    var n = t ? "#".concat(t) : "";
    return "".concat(_t.After, "(").concat(e, ")").concat(n)
}

function zm(e, t) {
    var n = "".concat(_t.DoneState, ".").concat(e),
        r = {
            type: n,
            data: t
        };
    return r.toString = function() {
        return n
    }, r
}

function Og(e, t) {
    var n = "".concat(_t.DoneInvoke, ".").concat(e),
        r = {
            type: n,
            data: t
        };
    return r.toString = function() {
        return n
    }, r
}

function zd(e, t) {
    var n = "".concat(_t.ErrorPlatform, ".").concat(e),
        r = {
            type: n,
            data: t
        };
    return r.toString = function() {
        return n
    }, r
}

function X1(e, t, n, r, s, i) {
    i === void 0 && (i = !1);
    var o = ct(i ? [
            [], s
        ] : Kj(s, function(f) {
            return f.type === W1
        }), 2),
        a = o[0],
        l = o[1],
        c = a.length ? XD(n, r, a, t) : n,
        u = i ? [n] : void 0,
        d = Rt(l.map(function(f) {
            var h;
            switch (f.type) {
                case $b:
                    return _we(f);
                case kb:
                    var p = ywe(f, c, r, e.options.delays);
                    return p;
                case zj:
                    return vwe(f, c, r);
                case swe:
                    {
                        var m = f,
                            g = (h = m.conds.find(function(k) {
                                var C = Qj(k.cond, e.options.guards);
                                return !C || Jj(e, C, c, r, t)
                            })) === null || h === void 0 ? void 0 : h.actions;
                        if (!g) return [];
                        var y = ct(X1(e, t, c, r, ky(es(g), e.options.actions), i), 2),
                            _ = y[0],
                            E = y[1];
                        return c = E,
                        u == null || u.push(c),
                        _
                    }
                case iwe:
                    {
                        var g = f.get(c, r.data);
                        if (!g) return [];
                        var b = ct(X1(e, t, c, r, ky(es(g), e.options.actions), i), 2),
                            w = b[0],
                            T = b[1];
                        return c = T,
                        u == null || u.push(c),
                        w
                    }
                case Jk:
                    return Swe(f, c, r);
                case W1:
                    {
                        c = XD(c, r, [f], t),
                        u == null || u.push(c);
                        break
                    }
                default:
                    var S = jh(f, e.options.actions),
                        v = S.exec;
                    if (v && u) {
                        var $ = u.length - 1;
                        S = Z(Z({}, S), {
                            exec: function(k) {
                                for (var C = [], O = 1; O < arguments.length; O++) C[O - 1] = arguments[O];
                                v.apply(void 0, Ut([u[$]], ct(C), !1))
                            }
                        })
                    }
                    return S
            }
        }).filter(function(f) {
            return !!f
        }));
    return [d, c]
}
var Wd = function(e, t) {
    var n = t(e);
    return n
};

function t3(e) {
    var t;
    return t = {
        id: e,
        send: function() {},
        subscribe: function() {
            return {
                unsubscribe: function() {}
            }
        },
        getSnapshot: function() {},
        toJSON: function() {
            return {
                id: e
            }
        }
    }, t[_o] = function() {
        return this
    }, t
}

function kwe(e, t, n, r) {
    var s, i = Zj(e.src),
        o = (s = t == null ? void 0 : t.options.services) === null || s === void 0 ? void 0 : s[i.type],
        a = e.data ? Sy(e.data, n, r) : void 0,
        l = o ? Iwe(o, e.id, a) : t3(e.id);
    return l.meta = e, l
}

function Iwe(e, t, n) {
    var r = t3(t);
    if (r.deferred = !0, Tl(e)) {
        var s = r.state = Wd(void 0, function() {
            return (n ? e.withContext(n) : e).initialState
        });
        r.getSnapshot = function() {
            return s
        }
    }
    return r
}

function xwe(e) {
    try {
        return typeof e.send == "function"
    } catch {
        return !1
    }
}

function Cwe(e) {
    return xwe(e) && "id" in e
}

function Awe(e) {
    var t;
    return Z((t = {
        subscribe: function() {
            return {
                unsubscribe: function() {}
            }
        },
        id: "anonymous",
        getSnapshot: function() {}
    }, t[_o] = function() {
        return this
    }, t), e)
}
var Iy = function(e) {
    return e.type === "atomic" || e.type === "final"
};

function Uu(e) {
    return Object.keys(e.states).map(function(t) {
        return e.states[t]
    }).filter(function(t) {
        return t.type !== "history"
    })
}

function n3(e) {
    var t = [e];
    return Iy(e) ? t : t.concat(Rt(Uu(e).map(n3)))
}

function pc(e, t) {
    var n, r, s, i, o, a, l, c, u = new Set(e),
        d = Q1(u),
        f = new Set(t);
    try {
        for (var h = Ke(f), p = h.next(); !p.done; p = h.next())
            for (var m = p.value, g = m.parent; g && !f.has(g);) f.add(g), g = g.parent
    } catch ($) {
        n = {
            error: $
        }
    } finally {
        try {
            p && !p.done && (r = h.return) && r.call(h)
        } finally {
            if (n) throw n.error
        }
    }
    var y = Q1(f);
    try {
        for (var _ = Ke(f), E = _.next(); !E.done; E = _.next()) {
            var m = E.value;
            if (m.type === "compound" && (!y.get(m) || !y.get(m).length)) d.get(m) ? d.get(m).forEach(function(k) {
                return f.add(k)
            }) : m.initialStateNodes.forEach(function(k) {
                return f.add(k)
            });
            else if (m.type === "parallel") try {
                for (var b = (o = void 0, Ke(Uu(m))), w = b.next(); !w.done; w = b.next()) {
                    var T = w.value;
                    f.has(T) || (f.add(T), d.get(T) ? d.get(T).forEach(function(k) {
                        return f.add(k)
                    }) : T.initialStateNodes.forEach(function(k) {
                        return f.add(k)
                    }))
                }
            } catch (k) {
                o = {
                    error: k
                }
            } finally {
                try {
                    w && !w.done && (a = b.return) && a.call(b)
                } finally {
                    if (o) throw o.error
                }
            }
        }
    } catch ($) {
        s = {
            error: $
        }
    } finally {
        try {
            E && !E.done && (i = _.return) && i.call(_)
        } finally {
            if (s) throw s.error
        }
    }
    try {
        for (var S = Ke(f), v = S.next(); !v.done; v = S.next())
            for (var m = v.value, g = m.parent; g && !f.has(g);) f.add(g), g = g.parent
    } catch ($) {
        l = {
            error: $
        }
    } finally {
        try {
            v && !v.done && (c = S.return) && c.call(S)
        } finally {
            if (l) throw l.error
        }
    }
    return f
}

function r3(e, t) {
    var n = t.get(e);
    if (!n) return {};
    if (e.type === "compound") {
        var r = n[0];
        if (r) {
            if (Iy(r)) return r.key
        } else return {}
    }
    var s = {};
    return n.forEach(function(i) {
        s[i.key] = r3(i, t)
    }), s
}

function Q1(e) {
    var t, n, r = new Map;
    try {
        for (var s = Ke(e), i = s.next(); !i.done; i = s.next()) {
            var o = i.value;
            r.has(o) || r.set(o, []), o.parent && (r.has(o.parent) || r.set(o.parent, []), r.get(o.parent).push(o))
        }
    } catch (a) {
        t = {
            error: a
        }
    } finally {
        try {
            i && !i.done && (n = s.return) && n.call(s)
        } finally {
            if (t) throw t.error
        }
    }
    return r
}

function Rwe(e, t) {
    var n = pc([e], t);
    return r3(e, Q1(n))
}

function Dg(e, t) {
    return Array.isArray(e) ? e.some(function(n) {
        return n === t
    }) : e instanceof Set ? e.has(t) : !1
}

function Owe(e) {
    return Ut([], ct(new Set(Rt(Ut([], ct(e.map(function(t) {
        return t.ownEvents
    })), !1)))), !1)
}

function Rf(e, t) {
    return t.type === "compound" ? Uu(t).some(function(n) {
        return n.type === "final" && Dg(e, n)
    }) : t.type === "parallel" ? Uu(t).every(function(n) {
        return Rf(e, n)
    }) : !1
}

function Dwe(e) {
    return e === void 0 && (e = []), e.reduce(function(t, n) {
        return n.meta !== void 0 && (t[n.id] = n.meta), t
    }, {})
}

function QD(e) {
    return new Set(Rt(e.map(function(t) {
        return t.tags
    })))
}

function s3(e, t) {
    if (e === t) return !0;
    if (e === void 0 || t === void 0) return !1;
    if (ot(e) || ot(t)) return e === t;
    var n = Object.keys(e),
        r = Object.keys(t);
    return n.length === r.length && n.every(function(s) {
        return s3(e[s], t[s])
    })
}

function Nwe(e) {
    return typeof e != "object" || e === null ? !1 : "value" in e && "_event" in e
}

function Pwe(e, t) {
    var n = e.exec,
        r = Z(Z({}, e), {
            exec: n !== void 0 ? function() {
                return n(t.context, t.event, {
                    action: e,
                    state: t,
                    _event: t._event
                })
            } : void 0
        });
    return r
}
var ts = function() {
        function e(t) {
            var n = this,
                r;
            this.actions = [], this.activities = qD, this.meta = {}, this.events = [], this.value = t.value, this.context = t.context, this._event = t._event, this._sessionid = t._sessionid, this.event = this._event.data, this.historyValue = t.historyValue, this.history = t.history, this.actions = t.actions || [], this.activities = t.activities || qD, this.meta = Dwe(t.configuration), this.events = t.events || [], this.matches = this.matches.bind(this), this.toStrings = this.toStrings.bind(this), this.configuration = t.configuration, this.transitions = t.transitions, this.children = t.children, this.done = !!t.done, this.tags = (r = Array.isArray(t.tags) ? new Set(t.tags) : t.tags) !== null && r !== void 0 ? r : new Set, this.machine = t.machine, Object.defineProperty(this, "nextEvents", {
                get: function() {
                    return Owe(n.configuration)
                }
            })
        }
        return e.from = function(t, n) {
            if (t instanceof e) return t.context !== n ? new e({
                value: t.value,
                context: n,
                _event: t._event,
                _sessionid: null,
                historyValue: t.historyValue,
                history: t.history,
                actions: [],
                activities: t.activities,
                meta: {},
                events: [],
                configuration: [],
                transitions: [],
                children: {}
            }) : t;
            var r = $y;
            return new e({
                value: t,
                context: n,
                _event: r,
                _sessionid: null,
                historyValue: void 0,
                history: void 0,
                actions: [],
                activities: void 0,
                meta: void 0,
                events: [],
                configuration: [],
                transitions: [],
                children: {}
            })
        }, e.create = function(t) {
            return new e(t)
        }, e.inert = function(t, n) {
            if (t instanceof e) {
                if (!t.actions.length) return t;
                var r = $y;
                return new e({
                    value: t.value,
                    context: n,
                    _event: r,
                    _sessionid: null,
                    historyValue: t.historyValue,
                    history: t.history,
                    activities: t.activities,
                    configuration: t.configuration,
                    transitions: [],
                    children: {}
                })
            }
            return e.from(t, n)
        }, e.prototype.toStrings = function(t, n) {
            var r = this;
            if (t === void 0 && (t = this.value), n === void 0 && (n = "."), ot(t)) return [t];
            var s = Object.keys(t);
            return s.concat.apply(s, Ut([], ct(s.map(function(i) {
                return r.toStrings(t[i], n).map(function(o) {
                    return i + n + o
                })
            })), !1))
        }, e.prototype.toJSON = function() {
            var t = this;
            t.configuration, t.transitions;
            var n = t.tags;
            t.machine;
            var r = Qk(t, ["configuration", "transitions", "tags", "machine"]);
            return Z(Z({}, r), {
                tags: Array.from(n)
            })
        }, e.prototype.matches = function(t) {
            return Zk(t, this.value)
        }, e.prototype.hasTag = function(t) {
            return this.tags.has(t)
        }, e.prototype.can = function(t) {
            var n;
            Af(!!this.machine);
            var r = (n = this.machine) === null || n === void 0 ? void 0 : n.getTransitionData(this, t);
            return !!(r != null && r.transitions.length) && r.transitions.some(function(s) {
                return s.target !== void 0 || s.actions.length
            })
        }, e
    }(),
    Mwe = {
        deferEvents: !1
    },
    JD = function() {
        function e(t) {
            this.processingEvent = !1, this.queue = [], this.initialized = !1, this.options = Z(Z({}, Mwe), t)
        }
        return e.prototype.initialize = function(t) {
            if (this.initialized = !0, t) {
                if (!this.options.deferEvents) {
                    this.schedule(t);
                    return
                }
                this.process(t)
            }
            this.flushEvents()
        }, e.prototype.schedule = function(t) {
            if (!this.initialized || this.processingEvent) {
                this.queue.push(t);
                return
            }
            if (this.queue.length !== 0) throw new Error("Event queue should be empty when it is not processing events");
            this.process(t), this.flushEvents()
        }, e.prototype.clear = function() {
            this.queue = []
        }, e.prototype.flushEvents = function() {
            for (var t = this.queue.shift(); t;) this.process(t), t = this.queue.shift()
        }, e.prototype.process = function(t) {
            this.processingEvent = !0;
            try {
                t()
            } catch (n) {
                throw this.clear(), n
            } finally {
                this.processingEvent = !1
            }
        }, e
    }(),
    uw = new Map,
    Lwe = 0,
    Wm = {
        bookId: function() {
            return "x:".concat(Lwe++)
        },
        register: function(e, t) {
            return uw.set(e, t), e
        },
        get: function(e) {
            return uw.get(e)
        },
        free: function(e) {
            uw.delete(e)
        }
    };

function nI() {
    if (typeof globalThis != "undefined") return globalThis;
    if (typeof self != "undefined") return self;
    if (typeof window != "undefined") return window;
    if (typeof global != "undefined") return global
}

function Fwe() {
    var e = nI();
    if (e && "__xstate__" in e) return e.__xstate__
}

function Uwe(e) {
    if (!!nI()) {
        var t = Fwe();
        t && t.register(e)
    }
}

function Bwe(e, t) {
    t === void 0 && (t = {});
    var n = e.initialState,
        r = new Set,
        s = [],
        i = !1,
        o = function() {
            if (!i) {
                for (i = !0; s.length > 0;) {
                    var c = s.shift();
                    n = e.transition(n, c, l), r.forEach(function(u) {
                        return u.next(n)
                    })
                }
                i = !1
            }
        },
        a = Awe({
            id: t.id,
            send: function(c) {
                s.push(c), o()
            },
            getSnapshot: function() {
                return n
            },
            subscribe: function(c, u, d) {
                var f = Ty(c, u, d);
                return r.add(f), f.next(n), {
                    unsubscribe: function() {
                        r.delete(f)
                    }
                }
            }
        }),
        l = {
            parent: t.parent,
            self: a,
            id: t.id || "anonymous",
            observers: r
        };
    return n = e.start ? e.start(l) : n, a
}
var Vwe = {
        sync: !1,
        autoForward: !1
    },
    tr;
(function(e) {
    e[e.NotStarted = 0] = "NotStarted", e[e.Running = 1] = "Running", e[e.Stopped = 2] = "Stopped"
})(tr || (tr = {}));
var Hwe = function() {
    function e(t, n) {
        var r = this;
        n === void 0 && (n = e.defaultOptions), this.machine = t, this.delayedEventsMap = {}, this.listeners = new Set, this.contextListeners = new Set, this.stopListeners = new Set, this.doneListeners = new Set, this.eventListeners = new Set, this.sendListeners = new Set, this.initialized = !1, this.status = tr.NotStarted, this.children = new Map, this.forwardTo = new Set, this.init = this.start, this.send = function(u, d) {
            if (ad(u)) return r.batch(u), r.state;
            var f = Ln(eI(u, d));
            if (r.status === tr.Stopped) return r.state;
            if (r.status !== tr.Running && !r.options.deferEvents) throw new Error('Event "'.concat(f.name, '" was sent to uninitialized service "').concat(r.machine.id, `". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.
Event: `).concat(JSON.stringify(f.data)));
            return r.scheduler.schedule(function() {
                r.forward(f);
                var h = r.nextState(f);
                r.update(h, f)
            }), r._state
        }, this.sendTo = function(u, d) {
            var f = r.parent && (d === Hh.Parent || r.parent.id === d),
                h = f ? r.parent : ot(d) ? r.children.get(d) || Wm.get(d) : pwe(d) ? d : void 0;
            if (!h) {
                if (!f) throw new Error("Unable to send event to child '".concat(d, "' from service '").concat(r.id, "'."));
                return
            }
            "machine" in h ? h.send(Z(Z({}, u), {
                name: u.name === rwe ? "".concat(zd(r.id)) : u.name,
                origin: r.sessionId
            })) : h.send(u.data)
        };
        var s = Z(Z({}, e.defaultOptions), n),
            i = s.clock,
            o = s.logger,
            a = s.parent,
            l = s.id,
            c = l !== void 0 ? l : t.id;
        this.id = c, this.logger = o, this.clock = i, this.parent = a, this.options = s, this.scheduler = new JD({
            deferEvents: this.options.deferEvents
        }), this.sessionId = Wm.bookId()
    }
    return Object.defineProperty(e.prototype, "initialState", {
        get: function() {
            var t = this;
            return this._initialState ? this._initialState : Wd(this, function() {
                return t._initialState = t.machine.initialState, t._initialState
            })
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(e.prototype, "state", {
        get: function() {
            return this._state
        },
        enumerable: !1,
        configurable: !0
    }), e.prototype.execute = function(t, n) {
        var r, s;
        try {
            for (var i = Ke(t.actions), o = i.next(); !o.done; o = i.next()) {
                var a = o.value;
                this.exec(a, t, n)
            }
        } catch (l) {
            r = {
                error: l
            }
        } finally {
            try {
                o && !o.done && (s = i.return) && s.call(i)
            } finally {
                if (r) throw r.error
            }
        }
    }, e.prototype.update = function(t, n) {
        var r, s, i, o, a, l, c, u, d = this;
        if (t._sessionid = this.sessionId, this._state = t, this.options.execute && this.execute(this.state), this.children.forEach(function($) {
                d.state.children[$.id] = $
            }), this.devTools && this.devTools.send(n.data, t), t.event) try {
            for (var f = Ke(this.eventListeners), h = f.next(); !h.done; h = f.next()) {
                var p = h.value;
                p(t.event)
            }
        } catch ($) {
            r = {
                error: $
            }
        } finally {
            try {
                h && !h.done && (s = f.return) && s.call(f)
            } finally {
                if (r) throw r.error
            }
        }
        try {
            for (var m = Ke(this.listeners), g = m.next(); !g.done; g = m.next()) {
                var p = g.value;
                p(t, t.event)
            }
        } catch ($) {
            i = {
                error: $
            }
        } finally {
            try {
                g && !g.done && (o = m.return) && o.call(m)
            } finally {
                if (i) throw i.error
            }
        }
        try {
            for (var y = Ke(this.contextListeners), _ = y.next(); !_.done; _ = y.next()) {
                var E = _.value;
                E(this.state.context, this.state.history ? this.state.history.context : void 0)
            }
        } catch ($) {
            a = {
                error: $
            }
        } finally {
            try {
                _ && !_.done && (l = y.return) && l.call(y)
            } finally {
                if (a) throw a.error
            }
        }
        var b = Rf(t.configuration || [], this.machine);
        if (this.state.configuration && b) {
            var w = t.configuration.find(function($) {
                    return $.type === "final" && $.parent === d.machine
                }),
                T = w && w.doneData ? Sy(w.doneData, t.context, n) : void 0;
            try {
                for (var S = Ke(this.doneListeners), v = S.next(); !v.done; v = S.next()) {
                    var p = v.value;
                    p(Og(this.id, T))
                }
            } catch ($) {
                c = {
                    error: $
                }
            } finally {
                try {
                    v && !v.done && (u = S.return) && u.call(S)
                } finally {
                    if (c) throw c.error
                }
            }
            this.stop()
        }
    }, e.prototype.onTransition = function(t) {
        return this.listeners.add(t), this.status === tr.Running && t(this.state, this.state.event), this
    }, e.prototype.subscribe = function(t, n, r) {
        var s = this;
        if (!t) return {
            unsubscribe: function() {}
        };
        var i, o = r;
        return typeof t == "function" ? i = t : (i = t.next.bind(t), o = t.complete.bind(t)), this.listeners.add(i), this.status !== tr.NotStarted && i(this.state), o && (this.status === tr.Stopped ? o() : this.onDone(o)), {
            unsubscribe: function() {
                i && s.listeners.delete(i), o && s.doneListeners.delete(o)
            }
        }
    }, e.prototype.onEvent = function(t) {
        return this.eventListeners.add(t), this
    }, e.prototype.onSend = function(t) {
        return this.sendListeners.add(t), this
    }, e.prototype.onChange = function(t) {
        return this.contextListeners.add(t), this
    }, e.prototype.onStop = function(t) {
        return this.stopListeners.add(t), this
    }, e.prototype.onDone = function(t) {
        return this.doneListeners.add(t), this
    }, e.prototype.off = function(t) {
        return this.listeners.delete(t), this.eventListeners.delete(t), this.sendListeners.delete(t), this.stopListeners.delete(t), this.doneListeners.delete(t), this.contextListeners.delete(t), this
    }, e.prototype.start = function(t) {
        var n = this;
        if (this.status === tr.Running) return this;
        this.machine._init(), Wm.register(this.sessionId, this), this.initialized = !0, this.status = tr.Running;
        var r = t === void 0 ? this.initialState : Wd(this, function() {
            return Nwe(t) ? n.machine.resolveState(t) : n.machine.resolveState(ts.from(t, n.machine.context))
        });
        return this.options.devTools && this.attachDev(), this.scheduler.initialize(function() {
            n.update(r, $y)
        }), this
    }, e.prototype.stop = function() {
        var t, n, r, s, i, o, a, l, c, u, d = this;
        try {
            for (var f = Ke(this.listeners), h = f.next(); !h.done; h = f.next()) {
                var p = h.value;
                this.listeners.delete(p)
            }
        } catch (v) {
            t = {
                error: v
            }
        } finally {
            try {
                h && !h.done && (n = f.return) && n.call(f)
            } finally {
                if (t) throw t.error
            }
        }
        try {
            for (var m = Ke(this.stopListeners), g = m.next(); !g.done; g = m.next()) {
                var p = g.value;
                p(), this.stopListeners.delete(p)
            }
        } catch (v) {
            r = {
                error: v
            }
        } finally {
            try {
                g && !g.done && (s = m.return) && s.call(m)
            } finally {
                if (r) throw r.error
            }
        }
        try {
            for (var y = Ke(this.contextListeners), _ = y.next(); !_.done; _ = y.next()) {
                var p = _.value;
                this.contextListeners.delete(p)
            }
        } catch (v) {
            i = {
                error: v
            }
        } finally {
            try {
                _ && !_.done && (o = y.return) && o.call(y)
            } finally {
                if (i) throw i.error
            }
        }
        try {
            for (var E = Ke(this.doneListeners), b = E.next(); !b.done; b = E.next()) {
                var p = b.value;
                this.doneListeners.delete(p)
            }
        } catch (v) {
            a = {
                error: v
            }
        } finally {
            try {
                b && !b.done && (l = E.return) && l.call(E)
            } finally {
                if (a) throw a.error
            }
        }
        if (!this.initialized) return this;
        Ut([], ct(this.state.configuration), !1).sort(function(v, $) {
            return $.order - v.order
        }).forEach(function(v) {
            var $, k;
            try {
                for (var C = Ke(v.definition.exit), O = C.next(); !O.done; O = C.next()) {
                    var R = O.value;
                    d.exec(R, d.state)
                }
            } catch (N) {
                $ = {
                    error: N
                }
            } finally {
                try {
                    O && !O.done && (k = C.return) && k.call(C)
                } finally {
                    if ($) throw $.error
                }
            }
        }), this.children.forEach(function(v) {
            pt(v.stop) && v.stop()
        }), this.children.clear();
        try {
            for (var w = Ke(Object.keys(this.delayedEventsMap)), T = w.next(); !T.done; T = w.next()) {
                var S = T.value;
                this.clock.clearTimeout(this.delayedEventsMap[S])
            }
        } catch (v) {
            c = {
                error: v
            }
        } finally {
            try {
                T && !T.done && (u = w.return) && u.call(w)
            } finally {
                if (c) throw c.error
            }
        }
        return this.scheduler.clear(), this.scheduler = new JD({
            deferEvents: this.options.deferEvents
        }), this.initialized = !1, this.status = tr.Stopped, this._initialState = void 0, Wm.free(this.sessionId), this
    }, e.prototype.batch = function(t) {
        var n = this;
        if (!(this.status === tr.NotStarted && this.options.deferEvents)) {
            if (this.status !== tr.Running) throw new Error("".concat(t.length, ' event(s) were sent to uninitialized service "').concat(this.machine.id, '". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.'))
        }
        this.scheduler.schedule(function() {
            var r, s, i = n.state,
                o = !1,
                a = [],
                l = function(f) {
                    var h = Ln(f);
                    n.forward(h), i = Wd(n, function() {
                        return n.machine.transition(i, h)
                    }), a.push.apply(a, Ut([], ct(i.actions.map(function(p) {
                        return Pwe(p, i)
                    })), !1)), o = o || !!i.changed
                };
            try {
                for (var c = Ke(t), u = c.next(); !u.done; u = c.next()) {
                    var d = u.value;
                    l(d)
                }
            } catch (f) {
                r = {
                    error: f
                }
            } finally {
                try {
                    u && !u.done && (s = c.return) && s.call(c)
                } finally {
                    if (r) throw r.error
                }
            }
            i.changed = o, i.actions = a, n.update(i, Ln(t[t.length - 1]))
        })
    }, e.prototype.sender = function(t) {
        return this.send.bind(this, t)
    }, e.prototype.nextState = function(t) {
        var n = this,
            r = Ln(t);
        if (r.name.indexOf(GD) === 0 && !this.state.nextEvents.some(function(i) {
                return i.indexOf(GD) === 0
            })) throw r.data.data;
        var s = Wd(this, function() {
            return n.machine.transition(n.state, r)
        });
        return s
    }, e.prototype.forward = function(t) {
        var n, r;
        try {
            for (var s = Ke(this.forwardTo), i = s.next(); !i.done; i = s.next()) {
                var o = i.value,
                    a = this.children.get(o);
                if (!a) throw new Error("Unable to forward event '".concat(t, "' from interpreter '").concat(this.id, "' to nonexistant child '").concat(o, "'."));
                a.send(t)
            }
        } catch (l) {
            n = {
                error: l
            }
        } finally {
            try {
                i && !i.done && (r = s.return) && r.call(s)
            } finally {
                if (n) throw n.error
            }
        }
    }, e.prototype.defer = function(t) {
        var n = this;
        this.delayedEventsMap[t.id] = this.clock.setTimeout(function() {
            t.to ? n.sendTo(t._event, t.to) : n.send(t._event)
        }, t.delay)
    }, e.prototype.cancel = function(t) {
        this.clock.clearTimeout(this.delayedEventsMap[t]), delete this.delayedEventsMap[t]
    }, e.prototype.exec = function(t, n, r) {
        r === void 0 && (r = this.machine.options.actions);
        var s = n.context,
            i = n._event,
            o = t.exec || K1(t.type, r),
            a = pt(o) ? o : o ? o.exec : t.exec;
        if (a) try {
            return a(s, i.data, {
                action: t,
                state: this.state,
                _event: i
            })
        } catch (b) {
            throw this.parent && this.parent.send({
                type: "xstate.error",
                data: b
            }), b
        }
        switch (t.type) {
            case kb:
                var l = t;
                if (typeof l.delay == "number") {
                    this.defer(l);
                    return
                } else l.to ? this.sendTo(l._event, l.to) : this.send(l._event);
                break;
            case jj:
                this.cancel(t.sendId);
                break;
            case z1:
                {
                    if (this.status !== tr.Running) return;
                    var c = t.activity;
                    if (!this.state.activities[c.id || c.type]) break;
                    if (c.type === _t.Invoke) {
                        var u = Zj(c.src),
                            d = this.machine.options.services ? this.machine.options.services[u.type] : void 0,
                            f = c.id,
                            h = c.data,
                            p = "autoForward" in c ? c.autoForward : !!c.forward;
                        if (!d) return;
                        var m = h ? Sy(h, s, i) : void 0;
                        if (typeof d == "string") return;
                        var g = pt(d) ? d(s, i.data, {
                            data: m,
                            src: u,
                            meta: c.meta
                        }) : d;
                        if (!g) return;
                        var y = void 0;
                        Tl(g) && (g = m ? g.withContext(m) : g, y = {
                            autoForward: p
                        }), this.spawn(g, f, y)
                    } else this.spawnActivity(c);
                    break
                }
            case Jk:
                {
                    this.stopChild(t.activity.id);
                    break
                }
            case zj:
                var _ = t.label,
                    E = t.value;
                _ ? this.logger(_, E) : this.logger(E);
                break
        }
    }, e.prototype.removeChild = function(t) {
        var n;
        this.children.delete(t), this.forwardTo.delete(t), (n = this.state) === null || n === void 0 || delete n.children[t]
    }, e.prototype.stopChild = function(t) {
        var n = this.children.get(t);
        !n || (this.removeChild(t), pt(n.stop) && n.stop())
    }, e.prototype.spawn = function(t, n, r) {
        if (KD(t)) return this.spawnPromise(Promise.resolve(t), n);
        if (pt(t)) return this.spawnCallback(t, n);
        if (Cwe(t)) return this.spawnActor(t, n);
        if (hwe(t)) return this.spawnObservable(t, n);
        if (Tl(t)) return this.spawnMachine(t, Z(Z({}, r), {
            id: n
        }));
        if (dwe(t)) return this.spawnBehavior(t, n);
        throw new Error('Unable to spawn entity "'.concat(n, '" of type "').concat(typeof t, '".'))
    }, e.prototype.spawnMachine = function(t, n) {
        var r = this;
        n === void 0 && (n = {});
        var s = new e(t, Z(Z({}, this.options), {
                parent: this,
                id: n.id || t.id
            })),
            i = Z(Z({}, Vwe), n);
        i.sync && s.onTransition(function(a) {
            r.send(Wj, {
                state: a,
                id: s.id
            })
        });
        var o = s;
        return this.children.set(s.id, o), i.autoForward && this.forwardTo.add(s.id), s.onDone(function(a) {
            r.removeChild(s.id), r.send(Ln(a, {
                origin: s.id
            }))
        }).start(), o
    }, e.prototype.spawnBehavior = function(t, n) {
        var r = Bwe(t, {
            id: n,
            parent: this
        });
        return this.children.set(n, r), r
    }, e.prototype.spawnPromise = function(t, n) {
        var r, s = this,
            i = !1,
            o;
        t.then(function(l) {
            i || (o = l, s.removeChild(n), s.send(Ln(Og(n, l), {
                origin: n
            })))
        }, function(l) {
            if (!i) {
                s.removeChild(n);
                var c = zd(n, l);
                try {
                    s.send(Ln(c, {
                        origin: n
                    }))
                } catch {
                    s.devTools && s.devTools.send(c, s.state), s.machine.strict && s.stop()
                }
            }
        });
        var a = (r = {
            id: n,
            send: function() {},
            subscribe: function(l, c, u) {
                var d = Ty(l, c, u),
                    f = !1;
                return t.then(function(h) {
                    f || (d.next(h), !f && d.complete())
                }, function(h) {
                    f || d.error(h)
                }), {
                    unsubscribe: function() {
                        return f = !0
                    }
                }
            },
            stop: function() {
                i = !0
            },
            toJSON: function() {
                return {
                    id: n
                }
            },
            getSnapshot: function() {
                return o
            }
        }, r[_o] = function() {
            return this
        }, r);
        return this.children.set(n, a), a
    }, e.prototype.spawnCallback = function(t, n) {
        var r, s = this,
            i = !1,
            o = new Set,
            a = new Set,
            l, c = function(f) {
                l = f, a.forEach(function(h) {
                    return h(f)
                }), !i && s.send(Ln(f, {
                    origin: n
                }))
            },
            u;
        try {
            u = t(c, function(f) {
                o.add(f)
            })
        } catch (f) {
            this.send(zd(n, f))
        }
        if (KD(u)) return this.spawnPromise(u, n);
        var d = (r = {
            id: n,
            send: function(f) {
                return o.forEach(function(h) {
                    return h(f)
                })
            },
            subscribe: function(f) {
                var h = Ty(f);
                return a.add(h.next), {
                    unsubscribe: function() {
                        a.delete(h.next)
                    }
                }
            },
            stop: function() {
                i = !0, pt(u) && u()
            },
            toJSON: function() {
                return {
                    id: n
                }
            },
            getSnapshot: function() {
                return l
            }
        }, r[_o] = function() {
            return this
        }, r);
        return this.children.set(n, d), d
    }, e.prototype.spawnObservable = function(t, n) {
        var r, s = this,
            i, o = t.subscribe(function(l) {
                i = l, s.send(Ln(l, {
                    origin: n
                }))
            }, function(l) {
                s.removeChild(n), s.send(Ln(zd(n, l), {
                    origin: n
                }))
            }, function() {
                s.removeChild(n), s.send(Ln(Og(n), {
                    origin: n
                }))
            }),
            a = (r = {
                id: n,
                send: function() {},
                subscribe: function(l, c, u) {
                    return t.subscribe(l, c, u)
                },
                stop: function() {
                    return o.unsubscribe()
                },
                getSnapshot: function() {
                    return i
                },
                toJSON: function() {
                    return {
                        id: n
                    }
                }
            }, r[_o] = function() {
                return this
            }, r);
        return this.children.set(n, a), a
    }, e.prototype.spawnActor = function(t, n) {
        return this.children.set(n, t), t
    }, e.prototype.spawnActivity = function(t) {
        var n = this.machine.options && this.machine.options.activities ? this.machine.options.activities[t.type] : void 0;
        if (!!n) {
            var r = n(this.state.context, t);
            this.spawnEffect(t.id, r)
        }
    }, e.prototype.spawnEffect = function(t, n) {
        var r;
        this.children.set(t, (r = {
            id: t,
            send: function() {},
            subscribe: function() {
                return {
                    unsubscribe: function() {}
                }
            },
            stop: n || void 0,
            getSnapshot: function() {},
            toJSON: function() {
                return {
                    id: t
                }
            }
        }, r[_o] = function() {
            return this
        }, r))
    }, e.prototype.attachDev = function() {
        var t = nI();
        if (this.options.devTools && t) {
            if (t.__REDUX_DEVTOOLS_EXTENSION__) {
                var n = typeof this.options.devTools == "object" ? this.options.devTools : void 0;
                this.devTools = t.__REDUX_DEVTOOLS_EXTENSION__.connect(Z(Z({
                    name: this.id,
                    autoPause: !0,
                    stateSanitizer: function(r) {
                        return {
                            value: r.value,
                            context: r.context,
                            actions: r.actions
                        }
                    }
                }, n), {
                    features: Z({
                        jump: !1,
                        skip: !1
                    }, n ? n.features : void 0)
                }), this.machine), this.devTools.init(this.state)
            }
            Uwe(this)
        }
    }, e.prototype.toJSON = function() {
        return {
            id: this.id
        }
    }, e.prototype[_o] = function() {
        return this
    }, e.prototype.getSnapshot = function() {
        return this.status === tr.NotStarted ? this.initialState : this._state
    }, e.defaultOptions = {
        execute: !0,
        deferEvents: !0,
        clock: {
            setTimeout: function(t, n) {
                return setTimeout(t, n)
            },
            clearTimeout: function(t) {
                return clearTimeout(t)
            }
        },
        logger: console.log.bind(console),
        devTools: !1
    }, e.interpret = i3, e
}();

function i3(e, t) {
    var n = new Hwe(e, t);
    return n
}

function jwe(e) {
    if (typeof e == "string") {
        var t = {
            type: e
        };
        return t.toString = function() {
            return e
        }, t
    }
    return e
}

function Gm(e) {
    return Z(Z({
        type: G1
    }, e), {
        toJSON: function() {
            e.onDone, e.onError;
            var t = Qk(e, ["onDone", "onError"]);
            return Z(Z({}, t), {
                type: G1,
                src: jwe(e.src)
            })
        }
    })
}
var mc = "",
    J1 = "#",
    kd = "*",
    rc = {},
    sc = function(e) {
        return e[0] === J1
    },
    zwe = function() {
        return {
            actions: {},
            guards: {},
            services: {},
            activities: {},
            delays: {}
        }
    },
    Wwe = function(e, t, n) {
        var r = n.slice(0, -1).some(function(i) {
                return !("cond" in i) && !("in" in i) && (ot(i.target) || Tl(i.target))
            }),
            s = t === mc ? "the transient event" : "event '".concat(t, "'");
        Af(!r, "One or more transitions for ".concat(s, " on state '").concat(e.id, "' are unreachable. ") + "Make sure that the default transition is the last one defined.")
    },
    Gwe = function() {
        function e(t, n, r, s) {
            var i = this;
            r === void 0 && (r = "context" in t ? t.context : void 0);
            var o;
            this.config = t, this._context = r, this.order = -1, this.__xstatenode = !0, this.__cache = {
                events: void 0,
                relativeValue: new Map,
                initialStateValue: void 0,
                initialState: void 0,
                on: void 0,
                transitions: void 0,
                candidates: {},
                delayedTransitions: void 0
            }, this.idMap = {}, this.tags = [], this.options = Object.assign(zwe(), n), this.parent = s == null ? void 0 : s.parent, this.key = this.config.key || (s == null ? void 0 : s.key) || this.config.id || "(machine)", this.machine = this.parent ? this.parent.machine : this, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : Gj), this.id = this.config.id || Ut([this.machine.key], ct(this.path), !1).join(this.delimiter), this.version = this.parent ? this.parent.version : this.config.version, this.type = this.config.type || (this.config.parallel ? "parallel" : this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.schema = this.parent ? this.machine.schema : (o = this.config.schema) !== null && o !== void 0 ? o : {}, this.description = this.config.description, this.initial = this.config.initial, this.states = this.config.states ? jd(this.config.states, function(c, u) {
                var d, f = new e(c, {}, void 0, {
                    parent: i,
                    key: u
                });
                return Object.assign(i.idMap, Z((d = {}, d[f.id] = f, d), f.idMap)), f
            }) : rc;
            var a = 0;

            function l(c) {
                var u, d;
                c.order = a++;
                try {
                    for (var f = Ke(Uu(c)), h = f.next(); !h.done; h = f.next()) {
                        var p = h.value;
                        l(p)
                    }
                } catch (m) {
                    u = {
                        error: m
                    }
                } finally {
                    try {
                        h && !h.done && (d = f.return) && d.call(f)
                    } finally {
                        if (u) throw u.error
                    }
                }
            }
            l(this), this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this._transient = !!this.config.always || (this.config.on ? Array.isArray(this.config.on) ? this.config.on.some(function(c) {
                var u = c.event;
                return u === mc
            }) : mc in this.config.on : !1), this.strict = !!this.config.strict, this.onEntry = es(this.config.entry || this.config.onEntry).map(function(c) {
                return jh(c)
            }), this.onExit = es(this.config.exit || this.config.onExit).map(function(c) {
                return jh(c)
            }), this.meta = this.config.meta, this.doneData = this.type === "final" ? this.config.data : void 0, this.invoke = es(this.config.invoke).map(function(c, u) {
                var d, f;
                if (Tl(c)) {
                    var h = jm(i.id, u);
                    return i.machine.options.services = Z((d = {}, d[h] = c, d), i.machine.options.services), Gm({
                        src: h,
                        id: h
                    })
                } else if (ot(c.src)) {
                    var h = c.id || jm(i.id, u);
                    return Gm(Z(Z({}, c), {
                        id: h,
                        src: c.src
                    }))
                } else if (Tl(c.src) || pt(c.src)) {
                    var h = c.id || jm(i.id, u);
                    return i.machine.options.services = Z((f = {}, f[h] = c.src, f), i.machine.options.services), Gm(Z(Z({
                        id: h
                    }, c), {
                        src: h
                    }))
                } else {
                    var p = c.src;
                    return Gm(Z(Z({
                        id: jm(i.id, u)
                    }, c), {
                        src: p
                    }))
                }
            }), this.activities = es(this.config.activities).concat(this.invoke).map(function(c) {
                return tI(c)
            }), this.transition = this.transition.bind(this), this.tags = es(this.config.tags)
        }
        return e.prototype._init = function() {
            this.__cache.transitions || n3(this).forEach(function(t) {
                return t.on
            })
        }, e.prototype.withConfig = function(t, n) {
            var r = this.options,
                s = r.actions,
                i = r.activities,
                o = r.guards,
                a = r.services,
                l = r.delays;
            return new e(this.config, {
                actions: Z(Z({}, s), t.actions),
                activities: Z(Z({}, i), t.activities),
                guards: Z(Z({}, o), t.guards),
                services: Z(Z({}, a), t.services),
                delays: Z(Z({}, l), t.delays)
            }, n != null ? n : this.context)
        }, e.prototype.withContext = function(t) {
            return new e(this.config, this.options, t)
        }, Object.defineProperty(e.prototype, "context", {
            get: function() {
                return pt(this._context) ? this._context() : this._context
            },
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(e.prototype, "definition", {
            get: function() {
                return {
                    id: this.id,
                    key: this.key,
                    version: this.version,
                    context: this.context,
                    type: this.type,
                    initial: this.initial,
                    history: this.history,
                    states: jd(this.states, function(t) {
                        return t.definition
                    }),
                    on: this.on,
                    transitions: this.transitions,
                    entry: this.onEntry,
                    exit: this.onExit,
                    activities: this.activities || [],
                    meta: this.meta,
                    order: this.order || -1,
                    data: this.doneData,
                    invoke: this.invoke,
                    description: this.description,
                    tags: this.tags
                }
            },
            enumerable: !1,
            configurable: !0
        }), e.prototype.toJSON = function() {
            return this.definition
        }, Object.defineProperty(e.prototype, "on", {
            get: function() {
                if (this.__cache.on) return this.__cache.on;
                var t = this.transitions;
                return this.__cache.on = t.reduce(function(n, r) {
                    return n[r.eventType] = n[r.eventType] || [], n[r.eventType].push(r), n
                }, {})
            },
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(e.prototype, "after", {
            get: function() {
                return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions)
            },
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(e.prototype, "transitions", {
            get: function() {
                return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions)
            },
            enumerable: !1,
            configurable: !0
        }), e.prototype.getCandidates = function(t) {
            if (this.__cache.candidates[t]) return this.__cache.candidates[t];
            var n = t === mc,
                r = this.transitions.filter(function(s) {
                    var i = s.eventType === t;
                    return n ? i : i || s.eventType === kd
                });
            return this.__cache.candidates[t] = r, r
        }, e.prototype.getDelayedTransitions = function() {
            var t = this,
                n = this.config.after;
            if (!n) return [];
            var r = function(i, o) {
                    var a = pt(i) ? "".concat(t.id, ":delay[").concat(o, "]") : i,
                        l = $we(a, t.id);
                    return t.onEntry.push(e3(l, {
                        delay: i
                    })), t.onExit.push(bwe(l)), l
                },
                s = ad(n) ? n.map(function(i, o) {
                    var a = r(i.delay, o);
                    return Z(Z({}, i), {
                        event: a
                    })
                }) : Rt(Object.keys(n).map(function(i, o) {
                    var a = n[i],
                        l = ot(a) ? {
                            target: a
                        } : a,
                        c = isNaN(+i) ? i : +i,
                        u = r(c, o);
                    return es(l).map(function(d) {
                        return Z(Z({}, d), {
                            event: u,
                            delay: c
                        })
                    })
                }));
            return s.map(function(i) {
                var o = i.delay;
                return Z(Z({}, t.formatTransition(i)), {
                    delay: o
                })
            })
        }, e.prototype.getStateNodes = function(t) {
            var n, r = this;
            if (!t) return [];
            var s = t instanceof ts ? t.value : Cf(t, this.delimiter);
            if (ot(s)) {
                var i = this.getStateNode(s).initial;
                return i !== void 0 ? this.getStateNodes((n = {}, n[s] = i, n)) : [this, this.states[s]]
            }
            var o = Object.keys(s),
                a = [this];
            return a.push.apply(a, Ut([], ct(Rt(o.map(function(l) {
                return r.getStateNode(l).getStateNodes(s[l])
            }))), !1)), a
        }, e.prototype.handles = function(t) {
            var n = qj(t);
            return this.events.includes(n)
        }, e.prototype.resolveState = function(t) {
            var n = t instanceof ts ? t : ts.create(t),
                r = Array.from(pc([], this.getStateNodes(n.value)));
            return new ts(Z(Z({}, n), {
                value: this.resolve(n.value),
                configuration: r,
                done: Rf(r, this),
                tags: QD(r),
                machine: this.machine
            }))
        }, e.prototype.transitionLeafNode = function(t, n, r) {
            var s = this.getStateNode(t),
                i = s.next(n, r);
            return !i || !i.transitions.length ? this.next(n, r) : i
        }, e.prototype.transitionCompoundNode = function(t, n, r) {
            var s = Object.keys(t),
                i = this.getStateNode(s[0]),
                o = i._transition(t[s[0]], n, r);
            return !o || !o.transitions.length ? this.next(n, r) : o
        }, e.prototype.transitionParallelNode = function(t, n, r) {
            var s, i, o = {};
            try {
                for (var a = Ke(Object.keys(t)), l = a.next(); !l.done; l = a.next()) {
                    var c = l.value,
                        u = t[c];
                    if (!!u) {
                        var d = this.getStateNode(c),
                            f = d._transition(u, n, r);
                        f && (o[c] = f)
                    }
                }
            } catch (_) {
                s = {
                    error: _
                }
            } finally {
                try {
                    l && !l.done && (i = a.return) && i.call(a)
                } finally {
                    if (s) throw s.error
                }
            }
            var h = Object.keys(o).map(function(_) {
                    return o[_]
                }),
                p = Rt(h.map(function(_) {
                    return _.transitions
                })),
                m = h.some(function(_) {
                    return _.transitions.length > 0
                });
            if (!m) return this.next(n, r);
            var g = Rt(h.map(function(_) {
                    return _.entrySet
                })),
                y = Rt(Object.keys(o).map(function(_) {
                    return o[_].configuration
                }));
            return {
                transitions: p,
                entrySet: g,
                exitSet: Rt(h.map(function(_) {
                    return _.exitSet
                })),
                configuration: y,
                source: n,
                actions: Rt(Object.keys(o).map(function(_) {
                    return o[_].actions
                }))
            }
        }, e.prototype._transition = function(t, n, r) {
            return ot(t) ? this.transitionLeafNode(t, n, r) : Object.keys(t).length === 1 ? this.transitionCompoundNode(t, n, r) : this.transitionParallelNode(t, n, r)
        }, e.prototype.getTransitionData = function(t, n) {
            return this._transition(t.value, t, Ln(n))
        }, e.prototype.next = function(t, n) {
            var r, s, i = this,
                o = n.name,
                a = [],
                l = [],
                c;
            try {
                for (var u = Ke(this.getCandidates(o)), d = u.next(); !d.done; d = u.next()) {
                    var f = d.value,
                        h = f.cond,
                        p = f.in,
                        m = t.context,
                        g = p ? ot(p) && sc(p) ? t.matches(Cf(this.getStateNodeById(p).path, this.delimiter)) : Zk(Cf(p, this.delimiter), lwe(this.path.slice(0, -2))(t.value)) : !0,
                        y = !1;
                    try {
                        y = !h || Jj(this.machine, h, m, n, t)
                    } catch (w) {
                        throw new Error("Unable to evaluate guard '".concat(h.name || h.type, "' in transition for event '").concat(o, "' in state node '").concat(this.id, `':
`).concat(w.message))
                    }
                    if (y && g) {
                        f.target !== void 0 && (l = f.target), a.push.apply(a, Ut([], ct(f.actions), !1)), c = f;
                        break
                    }
                }
            } catch (w) {
                r = {
                    error: w
                }
            } finally {
                try {
                    d && !d.done && (s = u.return) && s.call(u)
                } finally {
                    if (r) throw r.error
                }
            }
            if (!!c) {
                if (!l.length) return {
                    transitions: [c],
                    entrySet: [],
                    exitSet: [],
                    configuration: t.value ? [this] : [],
                    source: t,
                    actions: a
                };
                var _ = Rt(l.map(function(w) {
                        return i.getRelativeStateNodes(w, t.historyValue)
                    })),
                    E = !!c.internal,
                    b = E ? [] : Rt(_.map(function(w) {
                        return i.nodesFromChild(w)
                    }));
                return {
                    transitions: [c],
                    entrySet: b,
                    exitSet: E ? [] : [this],
                    configuration: _,
                    source: t,
                    actions: a
                }
            }
        }, e.prototype.nodesFromChild = function(t) {
            if (t.escapes(this)) return [];
            for (var n = [], r = t; r && r !== this;) n.push(r), r = r.parent;
            return n.push(this), n
        }, e.prototype.escapes = function(t) {
            if (this === t) return !1;
            for (var n = this.parent; n;) {
                if (n === t) return !1;
                n = n.parent
            }
            return !0
        }, e.prototype.getActions = function(t, n, r, s) {
            var i, o, a, l, c = pc([], s ? this.getStateNodes(s.value) : [this]),
                u = t.configuration.length ? pc(c, t.configuration) : c;
            try {
                for (var d = Ke(u), f = d.next(); !f.done; f = d.next()) {
                    var h = f.value;
                    Dg(c, h) || t.entrySet.push(h)
                }
            } catch (S) {
                i = {
                    error: S
                }
            } finally {
                try {
                    f && !f.done && (o = d.return) && o.call(d)
                } finally {
                    if (i) throw i.error
                }
            }
            try {
                for (var p = Ke(c), m = p.next(); !m.done; m = p.next()) {
                    var h = m.value;
                    (!Dg(u, h) || Dg(t.exitSet, h.parent)) && t.exitSet.push(h)
                }
            } catch (S) {
                a = {
                    error: S
                }
            } finally {
                try {
                    m && !m.done && (l = p.return) && l.call(p)
                } finally {
                    if (a) throw a.error
                }
            }
            var g = Rt(t.entrySet.map(function(S) {
                var v = [];
                if (S.type !== "final") return v;
                var $ = S.parent;
                if (!$.parent) return v;
                v.push(zm(S.id, S.doneData), zm($.id, S.doneData ? Sy(S.doneData, n, r) : void 0));
                var k = $.parent;
                return k.type === "parallel" && Uu(k).every(function(C) {
                    return Rf(t.configuration, C)
                }) && v.push(zm(k.id)), v
            }));
            t.exitSet.sort(function(S, v) {
                return v.order - S.order
            }), t.entrySet.sort(function(S, v) {
                return S.order - v.order
            });
            var y = new Set(t.entrySet),
                _ = new Set(t.exitSet),
                E = ct([Rt(Array.from(y).map(function(S) {
                    return Ut(Ut([], ct(S.activities.map(function(v) {
                        return wwe(v)
                    })), !1), ct(S.onEntry), !1)
                })).concat(g.map(gwe)), Rt(Array.from(_).map(function(S) {
                    return Ut(Ut([], ct(S.onExit), !1), ct(S.activities.map(function(v) {
                        return Ewe(v)
                    })), !1)
                }))], 2),
                b = E[0],
                w = E[1],
                T = ky(w.concat(t.actions).concat(b), this.machine.options.actions);
            return T
        }, e.prototype.transition = function(t, n, r) {
            t === void 0 && (t = this.initialState);
            var s = Ln(n),
                i;
            if (t instanceof ts) i = r === void 0 ? t : this.resolveState(ts.from(t, r));
            else {
                var o = ot(t) ? this.resolve(Ey(this.getResolvedPath(t))) : this.resolve(t),
                    a = r != null ? r : this.machine.context;
                i = this.resolveState(ts.from(o, a))
            }
            if (!$d && s.name === kd) throw new Error("An event cannot have the wildcard type ('".concat(kd, "')"));
            if (this.strict && !this.events.includes(s.name) && !uwe(s.name)) throw new Error("Machine '".concat(this.id, "' does not accept event '").concat(s.name, "'"));
            var l = this._transition(i.value, i, s) || {
                    transitions: [],
                    configuration: [],
                    entrySet: [],
                    exitSet: [],
                    source: i,
                    actions: []
                },
                c = pc([], this.getStateNodes(i.value)),
                u = l.configuration.length ? pc(c, l.configuration) : c;
            return l.configuration = Ut([], ct(u), !1), this.resolveTransition(l, i, i.context, s)
        }, e.prototype.resolveRaisedTransition = function(t, n, r) {
            var s, i = t.actions;
            return t = this.transition(t, n), t._event = r, t.event = r.data, (s = t.actions).unshift.apply(s, Ut([], ct(i), !1)), t
        }, e.prototype.resolveTransition = function(t, n, r, s) {
            var i, o, a = this;
            s === void 0 && (s = $y);
            var l = t.configuration,
                c = !n || t.transitions.length > 0,
                u = c ? Rwe(this.machine, l) : void 0,
                d = n ? n.historyValue ? n.historyValue : t.source ? this.machine.historyValue(n.value) : void 0 : void 0,
                f = this.getActions(t, r, s, n),
                h = n ? Z({}, n.activities) : {};
            try {
                for (var p = Ke(f), m = p.next(); !m.done; m = p.next()) {
                    var g = m.value;
                    g.type === z1 ? h[g.activity.id || g.activity.type] = g : g.type === Jk && (h[g.activity.id || g.activity.type] = !1)
                }
            } catch (ce) {
                i = {
                    error: ce
                }
            } finally {
                try {
                    m && !m.done && (o = p.return) && o.call(p)
                } finally {
                    if (i) throw i.error
                }
            }
            var y = ct(X1(this, n, r, s, f, this.machine.config.preserveActionOrder), 2),
                _ = y[0],
                E = y[1],
                b = ct(Kj(_, function(ce) {
                    return ce.type === $b || ce.type === kb && ce.to === Hh.Internal
                }), 2),
                w = b[0],
                T = b[1],
                S = _.filter(function(ce) {
                    var Ue;
                    return ce.type === z1 && ((Ue = ce.activity) === null || Ue === void 0 ? void 0 : Ue.type) === G1
                }),
                v = S.reduce(function(ce, Ue) {
                    return ce[Ue.activity.id] = kwe(Ue.activity, a.machine, E, s), ce
                }, n ? Z({}, n.children) : {}),
                $ = c ? t.configuration : n ? n.configuration : [],
                k = Rf($, this),
                C = new ts({
                    value: u || n.value,
                    context: E,
                    _event: s,
                    _sessionid: n ? n._sessionid : null,
                    historyValue: u ? d ? fwe(d, u) : void 0 : n ? n.historyValue : void 0,
                    history: !u || t.source ? n : void 0,
                    actions: u ? T : [],
                    activities: u ? h : n ? n.activities : {},
                    events: [],
                    configuration: $,
                    transitions: t.transitions,
                    children: v,
                    done: k,
                    tags: QD($),
                    machine: this
                }),
                O = r !== E;
            C.changed = s.name === Wj || O;
            var R = C.history;
            R && delete R.history;
            var N = !k && (this._transient || l.some(function(ce) {
                return ce._transient
            }));
            if (!c && (!N || s.name === mc)) return C;
            var J = C;
            if (!k)
                for (N && (J = this.resolveRaisedTransition(J, {
                        type: twe
                    }, s)); w.length;) {
                    var Y = w.shift();
                    J = this.resolveRaisedTransition(J, Y._event, s)
                }
            var ie = J.changed || (R ? !!J.actions.length || O || typeof R.value != typeof J.value || !s3(J.value, R.value) : void 0);
            return J.changed = ie, J.history = R, J
        }, e.prototype.getStateNode = function(t) {
            if (sc(t)) return this.machine.getStateNodeById(t);
            if (!this.states) throw new Error("Unable to retrieve child state '".concat(t, "' from '").concat(this.id, "'; no child states exist."));
            var n = this.states[t];
            if (!n) throw new Error("Child state '".concat(t, "' does not exist on '").concat(this.id, "'"));
            return n
        }, e.prototype.getStateNodeById = function(t) {
            var n = sc(t) ? t.slice(J1.length) : t;
            if (n === this.id) return this;
            var r = this.machine.idMap[n];
            if (!r) throw new Error("Child state node '#".concat(n, "' does not exist on machine '").concat(this.id, "'"));
            return r
        }, e.prototype.getStateNodeByPath = function(t) {
            if (typeof t == "string" && sc(t)) try {
                return this.getStateNodeById(t.slice(1))
            } catch {}
            for (var n = Y1(t, this.delimiter).slice(), r = this; n.length;) {
                var s = n.shift();
                if (!s.length) break;
                r = r.getStateNode(s)
            }
            return r
        }, e.prototype.resolve = function(t) {
            var n, r = this;
            if (!t) return this.initialStateValue || rc;
            switch (this.type) {
                case "parallel":
                    return jd(this.initialStateValue, function(i, o) {
                        return i ? r.getStateNode(o).resolve(t[o] || i) : rc
                    });
                case "compound":
                    if (ot(t)) {
                        var s = this.getStateNode(t);
                        return s.type === "parallel" || s.type === "compound" ? (n = {}, n[t] = s.initialStateValue, n) : t
                    }
                    return Object.keys(t).length ? jd(t, function(i, o) {
                        return i ? r.getStateNode(o).resolve(i) : rc
                    }) : this.initialStateValue || {};
                default:
                    return t || rc
            }
        }, e.prototype.getResolvedPath = function(t) {
            if (sc(t)) {
                var n = this.machine.idMap[t.slice(J1.length)];
                if (!n) throw new Error("Unable to find state node '".concat(t, "'"));
                return n.path
            }
            return Y1(t, this.delimiter)
        }, Object.defineProperty(e.prototype, "initialStateValue", {
            get: function() {
                var t;
                if (this.__cache.initialStateValue) return this.__cache.initialStateValue;
                var n;
                if (this.type === "parallel") n = YD(this.states, function(r) {
                    return r.initialStateValue || rc
                }, function(r) {
                    return r.type !== "history"
                });
                else if (this.initial !== void 0) {
                    if (!this.states[this.initial]) throw new Error("Initial state '".concat(this.initial, "' not found on '").concat(this.key, "'"));
                    n = Iy(this.states[this.initial]) ? this.initial : (t = {}, t[this.initial] = this.states[this.initial].initialStateValue, t)
                } else n = {};
                return this.__cache.initialStateValue = n, this.__cache.initialStateValue
            },
            enumerable: !1,
            configurable: !0
        }), e.prototype.getInitialState = function(t, n) {
            this._init();
            var r = this.getStateNodes(t);
            return this.resolveTransition({
                configuration: r,
                entrySet: r,
                exitSet: [],
                transitions: [],
                source: void 0,
                actions: []
            }, void 0, n != null ? n : this.machine.context, void 0)
        }, Object.defineProperty(e.prototype, "initialState", {
            get: function() {
                var t = this.initialStateValue;
                if (!t) throw new Error("Cannot retrieve initial state from simple state '".concat(this.id, "'."));
                return this.getInitialState(t)
            },
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(e.prototype, "target", {
            get: function() {
                var t;
                if (this.type === "history") {
                    var n = this.config;
                    ot(n.target) ? t = sc(n.target) ? Ey(this.machine.getStateNodeById(n.target).path.slice(this.path.length - 1)) : n.target : t = n.target
                }
                return t
            },
            enumerable: !1,
            configurable: !0
        }), e.prototype.getRelativeStateNodes = function(t, n, r) {
            return r === void 0 && (r = !0), r ? t.type === "history" ? t.resolveHistory(n) : t.initialStateNodes : [t]
        }, Object.defineProperty(e.prototype, "initialStateNodes", {
            get: function() {
                var t = this;
                if (Iy(this)) return [this];
                if (this.type === "compound" && !this.initial) return $d || Af(!1, "Compound state node '".concat(this.id, "' has no initial state.")), [this];
                var n = Rg(this.initialStateValue);
                return Rt(n.map(function(r) {
                    return t.getFromRelativePath(r)
                }))
            },
            enumerable: !1,
            configurable: !0
        }), e.prototype.getFromRelativePath = function(t) {
            if (!t.length) return [this];
            var n = ct(t),
                r = n[0],
                s = n.slice(1);
            if (!this.states) throw new Error("Cannot retrieve subPath '".concat(r, "' from node with no states"));
            var i = this.getStateNode(r);
            if (i.type === "history") return i.resolveHistory();
            if (!this.states[r]) throw new Error("Child state '".concat(r, "' does not exist on '").concat(this.id, "'"));
            return this.states[r].getFromRelativePath(s)
        }, e.prototype.historyValue = function(t) {
            if (!!Object.keys(this.states).length) return {
                current: t || this.initialStateValue,
                states: YD(this.states, function(n, r) {
                    if (!t) return n.historyValue();
                    var s = ot(t) ? void 0 : t[r];
                    return n.historyValue(s || n.initialStateValue)
                }, function(n) {
                    return !n.history
                })
            }
        }, e.prototype.resolveHistory = function(t) {
            var n = this;
            if (this.type !== "history") return [this];
            var r = this.parent;
            if (!t) {
                var s = this.target;
                return s ? Rt(Rg(s).map(function(o) {
                    return r.getFromRelativePath(o)
                })) : r.initialStateNodes
            }
            var i = cwe(r.path, "states")(t).current;
            return ot(i) ? [r.getStateNode(i)] : Rt(Rg(i).map(function(o) {
                return n.history === "deep" ? r.getFromRelativePath(o) : [r.states[o[0]]]
            }))
        }, Object.defineProperty(e.prototype, "stateIds", {
            get: function() {
                var t = this,
                    n = Rt(Object.keys(this.states).map(function(r) {
                        return t.states[r].stateIds
                    }));
                return [this.id].concat(n)
            },
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(e.prototype, "events", {
            get: function() {
                var t, n, r, s;
                if (this.__cache.events) return this.__cache.events;
                var i = this.states,
                    o = new Set(this.ownEvents);
                if (i) try {
                    for (var a = Ke(Object.keys(i)), l = a.next(); !l.done; l = a.next()) {
                        var c = l.value,
                            u = i[c];
                        if (u.states) try {
                            for (var d = (r = void 0, Ke(u.events)), f = d.next(); !f.done; f = d.next()) {
                                var h = f.value;
                                o.add("".concat(h))
                            }
                        } catch (p) {
                            r = {
                                error: p
                            }
                        } finally {
                            try {
                                f && !f.done && (s = d.return) && s.call(d)
                            } finally {
                                if (r) throw r.error
                            }
                        }
                    }
                } catch (p) {
                    t = {
                        error: p
                    }
                } finally {
                    try {
                        l && !l.done && (n = a.return) && n.call(a)
                    } finally {
                        if (t) throw t.error
                    }
                }
                return this.__cache.events = Array.from(o)
            },
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(e.prototype, "ownEvents", {
            get: function() {
                var t = new Set(this.transitions.filter(function(n) {
                    return !(!n.target && !n.actions.length && n.internal)
                }).map(function(n) {
                    return n.eventType
                }));
                return Array.from(t)
            },
            enumerable: !1,
            configurable: !0
        }), e.prototype.resolveTarget = function(t) {
            var n = this;
            if (t !== void 0) return t.map(function(r) {
                if (!ot(r)) return r;
                var s = r[0] === n.delimiter;
                if (s && !n.parent) return n.getStateNodeByPath(r.slice(1));
                var i = s ? n.key + r : r;
                if (n.parent) try {
                    var o = n.parent.getStateNodeByPath(i);
                    return o
                } catch (a) {
                    throw new Error("Invalid transition definition for state node '".concat(n.id, `':
`).concat(a.message))
                } else return n.getStateNodeByPath(i)
            })
        }, e.prototype.formatTransition = function(t) {
            var n = this,
                r = mwe(t.target),
                s = "internal" in t ? t.internal : r ? r.some(function(l) {
                    return ot(l) && l[0] === n.delimiter
                }) : !0,
                i = this.machine.options.guards,
                o = this.resolveTarget(r),
                a = Z(Z({}, t), {
                    actions: ky(es(t.actions)),
                    cond: Qj(t.cond, i),
                    target: o,
                    source: this,
                    internal: s,
                    eventType: t.event,
                    toJSON: function() {
                        return Z(Z({}, a), {
                            target: a.target ? a.target.map(function(l) {
                                return "#".concat(l.id)
                            }) : void 0,
                            source: "#".concat(n.id)
                        })
                    }
                });
            return a
        }, e.prototype.formatTransitions = function() {
            var t, n, r = this,
                s;
            if (!this.config.on) s = [];
            else if (Array.isArray(this.config.on)) s = this.config.on;
            else {
                var i = this.config.on,
                    o = kd,
                    a = i[o],
                    l = a === void 0 ? [] : a,
                    c = Qk(i, [typeof o == "symbol" ? o : o + ""]);
                s = Rt(Object.keys(c).map(function(_) {
                    !$d && _ === mc && Af(!1, "Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. " + 'Please check the `on` configuration for "#'.concat(r.id, '".'));
                    var E = nc(_, c[_]);
                    return $d || Wwe(r, _, E), E
                }).concat(nc(kd, l)))
            }
            var u = this.config.always ? nc("", this.config.always) : [],
                d = this.config.onDone ? nc(String(zm(this.id)), this.config.onDone) : [];
            $d || Af(!(this.config.onDone && !this.parent), 'Root nodes cannot have an ".onDone" transition. Please check the config of "'.concat(this.id, '".'));
            var f = Rt(this.invoke.map(function(_) {
                    var E = [];
                    return _.onDone && E.push.apply(E, Ut([], ct(nc(String(Og(_.id)), _.onDone)), !1)), _.onError && E.push.apply(E, Ut([], ct(nc(String(zd(_.id)), _.onError)), !1)), E
                })),
                h = this.after,
                p = Rt(Ut(Ut(Ut(Ut([], ct(d), !1), ct(f), !1), ct(s), !1), ct(u), !1).map(function(_) {
                    return es(_).map(function(E) {
                        return r.formatTransition(E)
                    })
                }));
            try {
                for (var m = Ke(h), g = m.next(); !g.done; g = m.next()) {
                    var y = g.value;
                    p.push(y)
                }
            } catch (_) {
                t = {
                    error: _
                }
            } finally {
                try {
                    g && !g.done && (n = m.return) && n.call(m)
                } finally {
                    if (t) throw t.error
                }
            }
            return p
        }, e
    }();

function qwe(e, t) {
    return new Gwe(e, t)
}
var Of = Twe,
    xy = globalThis && globalThis.__assign || function() {
        return xy = Object.assign || function(e) {
            for (var t, n = 1, r = arguments.length; n < r; n++) {
                t = arguments[n];
                for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s])
            }
            return e
        }, xy.apply(this, arguments)
    },
    Ywe = globalThis && globalThis.__rest || function(e, t) {
        var n = {};
        for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && typeof Object.getOwnPropertySymbols == "function")
            for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]]);
        return n
    },
    Kwe = globalThis && globalThis.__read || function(e, t) {
        var n = typeof Symbol == "function" && e[Symbol.iterator];
        if (!n) return e;
        var r = n.call(e),
            s, i = [],
            o;
        try {
            for (;
                (t === void 0 || t-- > 0) && !(s = r.next()).done;) i.push(s.value)
        } catch (a) {
            o = {
                error: a
            }
        } finally {
            try {
                s && !s.done && (n = r.return) && n.call(r)
            } finally {
                if (o) throw o.error
            }
        }
        return i
    };

function Xwe(e) {
    for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
    var r = Kwe(t, 2),
        s = r[0],
        i = s === void 0 ? {} : s,
        o = r[1],
        a = typeof e == "function" ? e() : e,
        l = i.context,
        c = i.guards,
        u = i.actions,
        d = i.activities,
        f = i.services,
        h = i.delays,
        p = i.state,
        m = Ywe(i, ["context", "guards", "actions", "activities", "services", "delays", "state"]),
        g = {
            context: l,
            guards: c,
            actions: u,
            activities: d,
            services: f,
            delays: h
        },
        y = a.withConfig(g, function() {
            return xy(xy({}, a.context), l)
        }),
        _ = i3(y, m).start(p ? ts.create(p) : void 0),
        E;
    return jr(function() {
        o && (E = _.subscribe(Ty(o)))
    }), pa(function() {
        _.stop(), E == null || E.unsubscribe()
    }), _
}
var Qwe = globalThis && globalThis.__read || function(e, t) {
    var n = typeof Symbol == "function" && e[Symbol.iterator];
    if (!n) return e;
    var r = n.call(e),
        s, i = [],
        o;
    try {
        for (;
            (t === void 0 || t-- > 0) && !(s = r.next()).done;) i.push(s.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (n = r.return) && n.call(r)
        } finally {
            if (o) throw o.error
        }
    }
    return i
};

function Jwe(e) {
    for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
    var r = Qwe(t, 1),
        s = r[0],
        i = s === void 0 ? {} : s;

    function o(u) {
        var d = u.changed === void 0 && Object.keys(u.children).length;
        (u.changed || d) && (c.value = u)
    }
    var a = Xwe(e, i, o),
        l = a.machine.initialState,
        c = yl(i.state ? ts.create(i.state) : l);
    return {
        state: c,
        send: a.send,
        service: a
    }
}

function Zwe(e) {
    return "state" in e
}
var ZD = function() {};

function eEe(e) {
    return "getSnapshot" in e ? e.getSnapshot() : Zwe(e) ? e.state : void 0
}

function tEe(e, t) {
    t === void 0 && (t = eEe);
    var n = gt(e) ? e : yl(e),
        r = yl(t(n.value)),
        s = function(i) {
            n.value.send(i)
        };
    return $t(n, function(i, o, a) {
        r.value = t(i);
        var l = i.subscribe({
            next: function(c) {
                return r.value = c
            },
            error: ZD,
            complete: ZD
        }).unsubscribe;
        a(function() {
            return l()
        })
    }, {
        immediate: !0
    }), {
        state: r,
        send: s
    }
}
const {
    VITE_APP_ENV: eN
} = {
    VITE_ENTRI_APPLICATION_ID: "mixo",
    VITE_FIREBASE_MESSAGING_SENDER_ID: "725498859830",
    VITE_APP_URL: "https://app.mixo.io",
    VITE_RECAPTCHA_SITE_KEY: "6LdaL8EfAAAAAPAgV1G_36iCuh49y7cuNDqZpAl5",
    VITE_FUNCTIONS_URL: "https://us-west2-mixo-app.cloudfunctions.net",
    VITE_FIREBASE_RTDB_URL: "https://mixo-app-default-rtdb.firebaseio.com",
    VITE_GITHUB_SHA: "c2b884bd636dacf90f8c9e821e20a3fb3390e571",
    VITE_FIREBASE_MEASUREMENT_ID: "G-JHGL8M7FHL",
    VITE_FIREBASE_STORAGE_BUCKET: "mixo-app.appspot.com",
    VITE_FIREBASE_AUTH_DOMAIN: "mixo-app.firebaseapp.com",
    VITE_TRACKJS_APP: "mixo-prod",
    VITE_MIXO_DOMAIN: "mixo.io",
    VITE_LOGROCKET_KEY: "qg9d5c/mixo",
    VITE_UNSPLASH_ACCESS_KEY: "2Z53wBSWJVEmkXRa81cfNdjIQazdP-K9wf_X_m5DIzQ",
    VITE_FIREBASE_PROJECT_ID: "mixo-app",
    VITE_TRACKJS_KEY: "e1e034d6f3034ee397ffa1d1eb75c73e",
    VITE_FIREBASE_APP_ID: "1:725498859830:web:6421f91ef9f6e95c056397",
    VITE_APP_ENV: "production",
    VITE_FIREBASE_API_KEY: "AIzaSyAVslymxdABi7BdNzjT1quXFZduuyz6EhE",
    BASE_URL: "/",
    MODE: "production",
    DEV: !1,
    PROD: !0
}, Ua = {};
var JN, ZN, eP;
Ua.error = (e, t) => {
    eN === "production" ? (l$(t), dl(e)) : (console.group("\u{1F468}\u200D\u{1F4BB}:", (e == null ? void 0 : e.label) || "Error"), console.info(t), e && console.error(e), console.groupEnd())
}, Ua.log = eN === "production" ? () => {} : (JN = window == null ? void 0 : window.console) == null ? void 0 : JN.log, Ua.info = (ZN = window == null ? void 0 : window.console) == null ? void 0 : ZN.info, Ua.warn = (eP = window == null ? void 0 : window.console) == null ? void 0 : eP.warn;
var nEe = typeof global == "object" && global && global.Object === Object && global,
    o3 = nEe,
    rEe = typeof self == "object" && self && self.Object === Object && self,
    sEe = o3 || rEe || Function("return this")(),
    Xs = sEe,
    iEe = Xs.Symbol,
    qs = iEe,
    a3 = Object.prototype,
    oEe = a3.hasOwnProperty,
    aEe = a3.toString,
    Id = qs ? qs.toStringTag : void 0;

function lEe(e) {
    var t = oEe.call(e, Id),
        n = e[Id];
    try {
        e[Id] = void 0;
        var r = !0
    } catch {}
    var s = aEe.call(e);
    return r && (t ? e[Id] = n : delete e[Id]), s
}
var cEe = Object.prototype,
    uEe = cEe.toString;

function dEe(e) {
    return uEe.call(e)
}
var fEe = "[object Null]",
    hEe = "[object Undefined]",
    tN = qs ? qs.toStringTag : void 0;

function zl(e) {
    return e == null ? e === void 0 ? hEe : fEe : tN && tN in Object(e) ? lEe(e) : dEe(e)
}

function $l(e) {
    return e != null && typeof e == "object"
}
var pEe = "[object Symbol]";

function Bu(e) {
    return typeof e == "symbol" || $l(e) && zl(e) == pEe
}

function Xc(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, s = Array(r); ++n < r;) s[n] = t(e[n], n, e);
    return s
}
var mEe = Array.isArray,
    hr = mEe,
    gEe = 1 / 0,
    nN = qs ? qs.prototype : void 0,
    rN = nN ? nN.toString : void 0;

function l3(e) {
    if (typeof e == "string") return e;
    if (hr(e)) return Xc(e, l3) + "";
    if (Bu(e)) return rN ? rN.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -gEe ? "-0" : t
}
var _Ee = /\s/;

function yEe(e) {
    for (var t = e.length; t-- && _Ee.test(e.charAt(t)););
    return t
}
var vEe = /^\s+/;

function bEe(e) {
    return e && e.slice(0, yEe(e) + 1).replace(vEe, "")
}

function Vu(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function")
}
var sN = 0 / 0,
    wEe = /^[-+]0x[0-9a-f]+$/i,
    EEe = /^0b[01]+$/i,
    SEe = /^0o[0-7]+$/i,
    TEe = parseInt;

function c3(e) {
    if (typeof e == "number") return e;
    if (Bu(e)) return sN;
    if (Vu(e)) {
        var t = typeof e.valueOf == "function" ? e.valueOf() : e;
        e = Vu(t) ? t + "" : t
    }
    if (typeof e != "string") return e === 0 ? e : +e;
    e = bEe(e);
    var n = EEe.test(e);
    return n || SEe.test(e) ? TEe(e.slice(2), n ? 2 : 8) : wEe.test(e) ? sN : +e
}
var iN = 1 / 0,
    $Ee = 17976931348623157e292;

function kEe(e) {
    if (!e) return e === 0 ? e : 0;
    if (e = c3(e), e === iN || e === -iN) {
        var t = e < 0 ? -1 : 1;
        return t * $Ee
    }
    return e === e ? e : 0
}

function rI(e) {
    var t = kEe(e),
        n = t % 1;
    return t === t ? n ? t - n : t : 0
}

function Hp(e) {
    return e
}
var IEe = "[object AsyncFunction]",
    xEe = "[object Function]",
    CEe = "[object GeneratorFunction]",
    AEe = "[object Proxy]";

function u3(e) {
    if (!Vu(e)) return !1;
    var t = zl(e);
    return t == xEe || t == CEe || t == IEe || t == AEe
}
var REe = Xs["__core-js_shared__"],
    dw = REe,
    oN = function() {
        var e = /[^.]+$/.exec(dw && dw.keys && dw.keys.IE_PROTO || "");
        return e ? "Symbol(src)_1." + e : ""
    }();

function OEe(e) {
    return !!oN && oN in e
}
var DEe = Function.prototype,
    NEe = DEe.toString;

function Wl(e) {
    if (e != null) {
        try {
            return NEe.call(e)
        } catch {}
        try {
            return e + ""
        } catch {}
    }
    return ""
}
var PEe = /[\\^$.*+?()[\]{}|]/g,
    MEe = /^\[object .+?Constructor\]$/,
    LEe = Function.prototype,
    FEe = Object.prototype,
    UEe = LEe.toString,
    BEe = FEe.hasOwnProperty,
    VEe = RegExp("^" + UEe.call(BEe).replace(PEe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function HEe(e) {
    if (!Vu(e) || OEe(e)) return !1;
    var t = u3(e) ? VEe : MEe;
    return t.test(Wl(e))
}

function jEe(e, t) {
    return e == null ? void 0 : e[t]
}

function Gl(e, t) {
    var n = jEe(e, t);
    return HEe(n) ? n : void 0
}
var zEe = Gl(Xs, "WeakMap"),
    Z1 = zEe;

function WEe(e, t, n) {
    switch (n.length) {
        case 0:
            return e.call(t);
        case 1:
            return e.call(t, n[0]);
        case 2:
            return e.call(t, n[0], n[1]);
        case 3:
            return e.call(t, n[0], n[1], n[2])
    }
    return e.apply(t, n)
}
var GEe = 800,
    qEe = 16,
    YEe = Date.now;

function KEe(e) {
    var t = 0,
        n = 0;
    return function() {
        var r = YEe(),
            s = qEe - (r - n);
        if (n = r, s > 0) {
            if (++t >= GEe) return arguments[0]
        } else t = 0;
        return e.apply(void 0, arguments)
    }
}

function XEe(e) {
    return function() {
        return e
    }
}
var QEe = function() {
        try {
            var e = Gl(Object, "defineProperty");
            return e({}, "", {}), e
        } catch {}
    }(),
    aN = QEe,
    JEe = aN ? function(e, t) {
        return aN(e, "toString", {
            configurable: !0,
            enumerable: !1,
            value: XEe(t),
            writable: !0
        })
    } : Hp,
    ZEe = JEe,
    e1e = KEe(ZEe),
    t1e = e1e;

function n1e(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1;);
    return e
}

function d3(e, t, n, r) {
    for (var s = e.length, i = n + (r ? 1 : -1); r ? i-- : ++i < s;)
        if (t(e[i], i, e)) return i;
    return -1
}

function r1e(e) {
    return e !== e
}

function s1e(e, t, n) {
    for (var r = n - 1, s = e.length; ++r < s;)
        if (e[r] === t) return r;
    return -1
}

function i1e(e, t, n) {
    return t === t ? s1e(e, t, n) : d3(e, r1e, n)
}
var o1e = 9007199254740991,
    a1e = /^(?:0|[1-9]\d*)$/;

function sI(e, t) {
    var n = typeof e;
    return t = t == null ? o1e : t, !!t && (n == "number" || n != "symbol" && a1e.test(e)) && e > -1 && e % 1 == 0 && e < t
}

function iI(e, t) {
    return e === t || e !== e && t !== t
}
var lN = Math.max;

function l1e(e, t, n) {
    return t = lN(t === void 0 ? e.length - 1 : t, 0),
        function() {
            for (var r = arguments, s = -1, i = lN(r.length - t, 0), o = Array(i); ++s < i;) o[s] = r[t + s];
            s = -1;
            for (var a = Array(t + 1); ++s < t;) a[s] = r[s];
            return a[t] = n(o), WEe(e, this, a)
        }
}

function c1e(e, t) {
    return t1e(l1e(e, t, Hp), e + "")
}
var u1e = 9007199254740991;

function oI(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= u1e
}

function ql(e) {
    return e != null && oI(e.length) && !u3(e)
}

function cN(e, t, n) {
    if (!Vu(n)) return !1;
    var r = typeof t;
    return (r == "number" ? ql(n) && sI(t, n.length) : r == "string" && t in n) ? iI(n[t], e) : !1
}
var d1e = Object.prototype;

function f3(e) {
    var t = e && e.constructor,
        n = typeof t == "function" && t.prototype || d1e;
    return e === n
}

function f1e(e, t) {
    for (var n = -1, r = Array(e); ++n < e;) r[n] = t(n);
    return r
}
var h1e = "[object Arguments]";

function uN(e) {
    return $l(e) && zl(e) == h1e
}
var h3 = Object.prototype,
    p1e = h3.hasOwnProperty,
    m1e = h3.propertyIsEnumerable,
    g1e = uN(function() {
        return arguments
    }()) ? uN : function(e) {
        return $l(e) && p1e.call(e, "callee") && !m1e.call(e, "callee")
    },
    Ib = g1e;

function _1e() {
    return !1
}
var p3 = typeof exports == "object" && exports && !exports.nodeType && exports,
    dN = p3 && typeof module == "object" && module && !module.nodeType && module,
    y1e = dN && dN.exports === p3,
    fN = y1e ? Xs.Buffer : void 0,
    v1e = fN ? fN.isBuffer : void 0,
    b1e = v1e || _1e,
    Cy = b1e,
    w1e = "[object Arguments]",
    E1e = "[object Array]",
    S1e = "[object Boolean]",
    T1e = "[object Date]",
    $1e = "[object Error]",
    k1e = "[object Function]",
    I1e = "[object Map]",
    x1e = "[object Number]",
    C1e = "[object Object]",
    A1e = "[object RegExp]",
    R1e = "[object Set]",
    O1e = "[object String]",
    D1e = "[object WeakMap]",
    N1e = "[object ArrayBuffer]",
    P1e = "[object DataView]",
    M1e = "[object Float32Array]",
    L1e = "[object Float64Array]",
    F1e = "[object Int8Array]",
    U1e = "[object Int16Array]",
    B1e = "[object Int32Array]",
    V1e = "[object Uint8Array]",
    H1e = "[object Uint8ClampedArray]",
    j1e = "[object Uint16Array]",
    z1e = "[object Uint32Array]",
    kt = {};
kt[M1e] = kt[L1e] = kt[F1e] = kt[U1e] = kt[B1e] = kt[V1e] = kt[H1e] = kt[j1e] = kt[z1e] = !0;
kt[w1e] = kt[E1e] = kt[N1e] = kt[S1e] = kt[P1e] = kt[T1e] = kt[$1e] = kt[k1e] = kt[I1e] = kt[x1e] = kt[C1e] = kt[A1e] = kt[R1e] = kt[O1e] = kt[D1e] = !1;

function W1e(e) {
    return $l(e) && oI(e.length) && !!kt[zl(e)]
}

function m3(e) {
    return function(t) {
        return e(t)
    }
}
var g3 = typeof exports == "object" && exports && !exports.nodeType && exports,
    Df = g3 && typeof module == "object" && module && !module.nodeType && module,
    G1e = Df && Df.exports === g3,
    fw = G1e && o3.process,
    q1e = function() {
        try {
            var e = Df && Df.require && Df.require("util").types;
            return e || fw && fw.binding && fw.binding("util")
        } catch {}
    }(),
    hN = q1e,
    pN = hN && hN.isTypedArray,
    Y1e = pN ? m3(pN) : W1e,
    aI = Y1e,
    K1e = Object.prototype,
    X1e = K1e.hasOwnProperty;

function Q1e(e, t) {
    var n = hr(e),
        r = !n && Ib(e),
        s = !n && !r && Cy(e),
        i = !n && !r && !s && aI(e),
        o = n || r || s || i,
        a = o ? f1e(e.length, String) : [],
        l = a.length;
    for (var c in e)(t || X1e.call(e, c)) && !(o && (c == "length" || s && (c == "offset" || c == "parent") || i && (c == "buffer" || c == "byteLength" || c == "byteOffset") || sI(c, l))) && a.push(c);
    return a
}

function J1e(e, t) {
    return function(n) {
        return e(t(n))
    }
}
var Z1e = J1e(Object.keys, Object),
    eSe = Z1e,
    tSe = Object.prototype,
    nSe = tSe.hasOwnProperty;

function _3(e) {
    if (!f3(e)) return eSe(e);
    var t = [];
    for (var n in Object(e)) nSe.call(e, n) && n != "constructor" && t.push(n);
    return t
}

function jp(e) {
    return ql(e) ? Q1e(e) : _3(e)
}
var rSe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    sSe = /^\w*$/;

function lI(e, t) {
    if (hr(e)) return !1;
    var n = typeof e;
    return n == "number" || n == "symbol" || n == "boolean" || e == null || Bu(e) ? !0 : sSe.test(e) || !rSe.test(e) || t != null && e in Object(t)
}
var iSe = Gl(Object, "create"),
    zh = iSe;

function oSe() {
    this.__data__ = zh ? zh(null) : {}, this.size = 0
}

function aSe(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t
}
var lSe = "__lodash_hash_undefined__",
    cSe = Object.prototype,
    uSe = cSe.hasOwnProperty;

function dSe(e) {
    var t = this.__data__;
    if (zh) {
        var n = t[e];
        return n === lSe ? void 0 : n
    }
    return uSe.call(t, e) ? t[e] : void 0
}
var fSe = Object.prototype,
    hSe = fSe.hasOwnProperty;

function pSe(e) {
    var t = this.__data__;
    return zh ? t[e] !== void 0 : hSe.call(t, e)
}
var mSe = "__lodash_hash_undefined__";

function gSe(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1, n[e] = zh && t === void 0 ? mSe : t, this
}

function kl(e) {
    var t = -1,
        n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n;) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
kl.prototype.clear = oSe;
kl.prototype.delete = aSe;
kl.prototype.get = dSe;
kl.prototype.has = pSe;
kl.prototype.set = gSe;

function _Se() {
    this.__data__ = [], this.size = 0
}

function xb(e, t) {
    for (var n = e.length; n--;)
        if (iI(e[n][0], t)) return n;
    return -1
}
var ySe = Array.prototype,
    vSe = ySe.splice;

function bSe(e) {
    var t = this.__data__,
        n = xb(t, e);
    if (n < 0) return !1;
    var r = t.length - 1;
    return n == r ? t.pop() : vSe.call(t, n, 1), --this.size, !0
}

function wSe(e) {
    var t = this.__data__,
        n = xb(t, e);
    return n < 0 ? void 0 : t[n][1]
}

function ESe(e) {
    return xb(this.__data__, e) > -1
}

function SSe(e, t) {
    var n = this.__data__,
        r = xb(n, e);
    return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this
}

function Gi(e) {
    var t = -1,
        n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n;) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
Gi.prototype.clear = _Se;
Gi.prototype.delete = bSe;
Gi.prototype.get = wSe;
Gi.prototype.has = ESe;
Gi.prototype.set = SSe;
var TSe = Gl(Xs, "Map"),
    Wh = TSe;

function $Se() {
    this.size = 0, this.__data__ = {
        hash: new kl,
        map: new(Wh || Gi),
        string: new kl
    }
}

function kSe(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null
}

function Cb(e, t) {
    var n = e.__data__;
    return kSe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map
}

function ISe(e) {
    var t = Cb(this, e).delete(e);
    return this.size -= t ? 1 : 0, t
}

function xSe(e) {
    return Cb(this, e).get(e)
}

function CSe(e) {
    return Cb(this, e).has(e)
}

function ASe(e, t) {
    var n = Cb(this, e),
        r = n.size;
    return n.set(e, t), this.size += n.size == r ? 0 : 1, this
}

function qi(e) {
    var t = -1,
        n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n;) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
qi.prototype.clear = $Se;
qi.prototype.delete = ISe;
qi.prototype.get = xSe;
qi.prototype.has = CSe;
qi.prototype.set = ASe;
var RSe = "Expected a function";

function cI(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function") throw new TypeError(RSe);
    var n = function() {
        var r = arguments,
            s = t ? t.apply(this, r) : r[0],
            i = n.cache;
        if (i.has(s)) return i.get(s);
        var o = e.apply(this, r);
        return n.cache = i.set(s, o) || i, o
    };
    return n.cache = new(cI.Cache || qi), n
}
cI.Cache = qi;
var OSe = 500;

function DSe(e) {
    var t = cI(e, function(r) {
            return n.size === OSe && n.clear(), r
        }),
        n = t.cache;
    return t
}
var NSe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    PSe = /\\(\\)?/g,
    MSe = DSe(function(e) {
        var t = [];
        return e.charCodeAt(0) === 46 && t.push(""), e.replace(NSe, function(n, r, s, i) {
            t.push(s ? i.replace(PSe, "$1") : r || n)
        }), t
    }),
    LSe = MSe;

function Ay(e) {
    return e == null ? "" : l3(e)
}

function y3(e, t) {
    return hr(e) ? e : lI(e, t) ? [e] : LSe(Ay(e))
}
var FSe = 1 / 0;

function Ab(e) {
    if (typeof e == "string" || Bu(e)) return e;
    var t = e + "";
    return t == "0" && 1 / e == -FSe ? "-0" : t
}

function uI(e, t) {
    t = y3(t, e);
    for (var n = 0, r = t.length; e != null && n < r;) e = e[Ab(t[n++])];
    return n && n == r ? e : void 0
}

function mt(e, t, n) {
    var r = e == null ? void 0 : uI(e, t);
    return r === void 0 ? n : r
}

function v3(e, t) {
    for (var n = -1, r = t.length, s = e.length; ++n < r;) e[s + n] = t[n];
    return e
}
var mN = qs ? qs.isConcatSpreadable : void 0;

function USe(e) {
    return hr(e) || Ib(e) || !!(mN && e && e[mN])
}

function b3(e, t, n, r, s) {
    var i = -1,
        o = e.length;
    for (n || (n = USe), s || (s = []); ++i < o;) {
        var a = e[i];
        t > 0 && n(a) ? t > 1 ? b3(a, t - 1, n, r, s) : v3(s, a) : r || (s[s.length] = a)
    }
    return s
}
var BSe = Xs.isFinite,
    VSe = Math.min;

function HSe(e) {
    var t = Math[e];
    return function(n, r) {
        if (n = c3(n), r = r == null ? 0 : VSe(rI(r), 292), r && BSe(n)) {
            var s = (Ay(n) + "e").split("e"),
                i = t(s[0] + "e" + (+s[1] + r));
            return s = (Ay(i) + "e").split("e"), +(s[0] + "e" + (+s[1] - r))
        }
        return t(n)
    }
}

function jSe() {
    this.__data__ = new Gi, this.size = 0
}

function zSe(e) {
    var t = this.__data__,
        n = t.delete(e);
    return this.size = t.size, n
}

function WSe(e) {
    return this.__data__.get(e)
}

function GSe(e) {
    return this.__data__.has(e)
}
var qSe = 200;

function YSe(e, t) {
    var n = this.__data__;
    if (n instanceof Gi) {
        var r = n.__data__;
        if (!Wh || r.length < qSe - 1) return r.push([e, t]), this.size = ++n.size, this;
        n = this.__data__ = new qi(r)
    }
    return n.set(e, t), this.size = n.size, this
}

function yi(e) {
    var t = this.__data__ = new Gi(e);
    this.size = t.size
}
yi.prototype.clear = jSe;
yi.prototype.delete = zSe;
yi.prototype.get = WSe;
yi.prototype.has = GSe;
yi.prototype.set = YSe;

function KSe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, s = 0, i = []; ++n < r;) {
        var o = e[n];
        t(o, n, e) && (i[s++] = o)
    }
    return i
}

function XSe() {
    return []
}
var QSe = Object.prototype,
    JSe = QSe.propertyIsEnumerable,
    gN = Object.getOwnPropertySymbols,
    ZSe = gN ? function(e) {
        return e == null ? [] : (e = Object(e), KSe(gN(e), function(t) {
            return JSe.call(e, t)
        }))
    } : XSe,
    eTe = ZSe;

function tTe(e, t, n) {
    var r = t(e);
    return hr(e) ? r : v3(r, n(e))
}

function _N(e) {
    return tTe(e, jp, eTe)
}
var nTe = Gl(Xs, "DataView"),
    eS = nTe,
    rTe = Gl(Xs, "Promise"),
    tS = rTe,
    sTe = Gl(Xs, "Set"),
    nS = sTe,
    yN = "[object Map]",
    iTe = "[object Object]",
    vN = "[object Promise]",
    bN = "[object Set]",
    wN = "[object WeakMap]",
    EN = "[object DataView]",
    oTe = Wl(eS),
    aTe = Wl(Wh),
    lTe = Wl(tS),
    cTe = Wl(nS),
    uTe = Wl(Z1),
    Ta = zl;
(eS && Ta(new eS(new ArrayBuffer(1))) != EN || Wh && Ta(new Wh) != yN || tS && Ta(tS.resolve()) != vN || nS && Ta(new nS) != bN || Z1 && Ta(new Z1) != wN) && (Ta = function(e) {
    var t = zl(e),
        n = t == iTe ? e.constructor : void 0,
        r = n ? Wl(n) : "";
    if (r) switch (r) {
        case oTe:
            return EN;
        case aTe:
            return yN;
        case lTe:
            return vN;
        case cTe:
            return bN;
        case uTe:
            return wN
    }
    return t
});
var rS = Ta,
    dTe = Xs.Uint8Array,
    SN = dTe,
    fTe = "__lodash_hash_undefined__";

function hTe(e) {
    return this.__data__.set(e, fTe), this
}

function pTe(e) {
    return this.__data__.has(e)
}

function Ry(e) {
    var t = -1,
        n = e == null ? 0 : e.length;
    for (this.__data__ = new qi; ++t < n;) this.add(e[t])
}
Ry.prototype.add = Ry.prototype.push = hTe;
Ry.prototype.has = pTe;

function mTe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r;)
        if (t(e[n], n, e)) return !0;
    return !1
}

function gTe(e, t) {
    return e.has(t)
}
var _Te = 1,
    yTe = 2;

function w3(e, t, n, r, s, i) {
    var o = n & _Te,
        a = e.length,
        l = t.length;
    if (a != l && !(o && l > a)) return !1;
    var c = i.get(e),
        u = i.get(t);
    if (c && u) return c == t && u == e;
    var d = -1,
        f = !0,
        h = n & yTe ? new Ry : void 0;
    for (i.set(e, t), i.set(t, e); ++d < a;) {
        var p = e[d],
            m = t[d];
        if (r) var g = o ? r(m, p, d, t, e, i) : r(p, m, d, e, t, i);
        if (g !== void 0) {
            if (g) continue;
            f = !1;
            break
        }
        if (h) {
            if (!mTe(t, function(y, _) {
                    if (!gTe(h, _) && (p === y || s(p, y, n, r, i))) return h.push(_)
                })) {
                f = !1;
                break
            }
        } else if (!(p === m || s(p, m, n, r, i))) {
            f = !1;
            break
        }
    }
    return i.delete(e), i.delete(t), f
}

function vTe(e) {
    var t = -1,
        n = Array(e.size);
    return e.forEach(function(r, s) {
        n[++t] = [s, r]
    }), n
}

function bTe(e) {
    var t = -1,
        n = Array(e.size);
    return e.forEach(function(r) {
        n[++t] = r
    }), n
}
var wTe = 1,
    ETe = 2,
    STe = "[object Boolean]",
    TTe = "[object Date]",
    $Te = "[object Error]",
    kTe = "[object Map]",
    ITe = "[object Number]",
    xTe = "[object RegExp]",
    CTe = "[object Set]",
    ATe = "[object String]",
    RTe = "[object Symbol]",
    OTe = "[object ArrayBuffer]",
    DTe = "[object DataView]",
    TN = qs ? qs.prototype : void 0,
    hw = TN ? TN.valueOf : void 0;

function NTe(e, t, n, r, s, i, o) {
    switch (n) {
        case DTe:
            if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
            e = e.buffer, t = t.buffer;
        case OTe:
            return !(e.byteLength != t.byteLength || !i(new SN(e), new SN(t)));
        case STe:
        case TTe:
        case ITe:
            return iI(+e, +t);
        case $Te:
            return e.name == t.name && e.message == t.message;
        case xTe:
        case ATe:
            return e == t + "";
        case kTe:
            var a = vTe;
        case CTe:
            var l = r & wTe;
            if (a || (a = bTe), e.size != t.size && !l) return !1;
            var c = o.get(e);
            if (c) return c == t;
            r |= ETe, o.set(e, t);
            var u = w3(a(e), a(t), r, s, i, o);
            return o.delete(e), u;
        case RTe:
            if (hw) return hw.call(e) == hw.call(t)
    }
    return !1
}
var PTe = 1,
    MTe = Object.prototype,
    LTe = MTe.hasOwnProperty;

function FTe(e, t, n, r, s, i) {
    var o = n & PTe,
        a = _N(e),
        l = a.length,
        c = _N(t),
        u = c.length;
    if (l != u && !o) return !1;
    for (var d = l; d--;) {
        var f = a[d];
        if (!(o ? f in t : LTe.call(t, f))) return !1
    }
    var h = i.get(e),
        p = i.get(t);
    if (h && p) return h == t && p == e;
    var m = !0;
    i.set(e, t), i.set(t, e);
    for (var g = o; ++d < l;) {
        f = a[d];
        var y = e[f],
            _ = t[f];
        if (r) var E = o ? r(_, y, f, t, e, i) : r(y, _, f, e, t, i);
        if (!(E === void 0 ? y === _ || s(y, _, n, r, i) : E)) {
            m = !1;
            break
        }
        g || (g = f == "constructor")
    }
    if (m && !g) {
        var b = e.constructor,
            w = t.constructor;
        b != w && "constructor" in e && "constructor" in t && !(typeof b == "function" && b instanceof b && typeof w == "function" && w instanceof w) && (m = !1)
    }
    return i.delete(e), i.delete(t), m
}
var UTe = 1,
    $N = "[object Arguments]",
    kN = "[object Array]",
    qm = "[object Object]",
    BTe = Object.prototype,
    IN = BTe.hasOwnProperty;

function VTe(e, t, n, r, s, i) {
    var o = hr(e),
        a = hr(t),
        l = o ? kN : rS(e),
        c = a ? kN : rS(t);
    l = l == $N ? qm : l, c = c == $N ? qm : c;
    var u = l == qm,
        d = c == qm,
        f = l == c;
    if (f && Cy(e)) {
        if (!Cy(t)) return !1;
        o = !0, u = !1
    }
    if (f && !u) return i || (i = new yi), o || aI(e) ? w3(e, t, n, r, s, i) : NTe(e, t, l, n, r, s, i);
    if (!(n & UTe)) {
        var h = u && IN.call(e, "__wrapped__"),
            p = d && IN.call(t, "__wrapped__");
        if (h || p) {
            var m = h ? e.value() : e,
                g = p ? t.value() : t;
            return i || (i = new yi), s(m, g, n, r, i)
        }
    }
    return f ? (i || (i = new yi), FTe(e, t, n, r, s, i)) : !1
}

function dI(e, t, n, r, s) {
    return e === t ? !0 : e == null || t == null || !$l(e) && !$l(t) ? e !== e && t !== t : VTe(e, t, n, r, dI, s)
}
var HTe = 1,
    jTe = 2;

function zTe(e, t, n, r) {
    var s = n.length,
        i = s,
        o = !r;
    if (e == null) return !i;
    for (e = Object(e); s--;) {
        var a = n[s];
        if (o && a[2] ? a[1] !== e[a[0]] : !(a[0] in e)) return !1
    }
    for (; ++s < i;) {
        a = n[s];
        var l = a[0],
            c = e[l],
            u = a[1];
        if (o && a[2]) {
            if (c === void 0 && !(l in e)) return !1
        } else {
            var d = new yi;
            if (r) var f = r(c, u, l, e, t, d);
            if (!(f === void 0 ? dI(u, c, HTe | jTe, r, d) : f)) return !1
        }
    }
    return !0
}

function E3(e) {
    return e === e && !Vu(e)
}

function WTe(e) {
    for (var t = jp(e), n = t.length; n--;) {
        var r = t[n],
            s = e[r];
        t[n] = [r, s, E3(s)]
    }
    return t
}

function S3(e, t) {
    return function(n) {
        return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n))
    }
}

function GTe(e) {
    var t = WTe(e);
    return t.length == 1 && t[0][2] ? S3(t[0][0], t[0][1]) : function(n) {
        return n === e || zTe(n, e, t)
    }
}

function qTe(e, t) {
    return e != null && t in Object(e)
}

function YTe(e, t, n) {
    t = y3(t, e);
    for (var r = -1, s = t.length, i = !1; ++r < s;) {
        var o = Ab(t[r]);
        if (!(i = e != null && n(e, o))) break;
        e = e[o]
    }
    return i || ++r != s ? i : (s = e == null ? 0 : e.length, !!s && oI(s) && sI(o, s) && (hr(e) || Ib(e)))
}

function KTe(e, t) {
    return e != null && YTe(e, t, qTe)
}
var XTe = 1,
    QTe = 2;

function JTe(e, t) {
    return lI(e) && E3(t) ? S3(Ab(e), t) : function(n) {
        var r = mt(n, e);
        return r === void 0 && r === t ? KTe(n, e) : dI(t, r, XTe | QTe)
    }
}

function ZTe(e) {
    return function(t) {
        return t == null ? void 0 : t[e]
    }
}

function e$e(e) {
    return function(t) {
        return uI(t, e)
    }
}

function t$e(e) {
    return lI(e) ? ZTe(Ab(e)) : e$e(e)
}

function Rb(e) {
    return typeof e == "function" ? e : e == null ? Hp : typeof e == "object" ? hr(e) ? JTe(e[0], e[1]) : GTe(e) : t$e(e)
}

function n$e(e) {
    return function(t, n, r) {
        for (var s = -1, i = Object(t), o = r(t), a = o.length; a--;) {
            var l = o[e ? a : ++s];
            if (n(i[l], l, i) === !1) break
        }
        return t
    }
}
var r$e = n$e(),
    s$e = r$e;

function i$e(e, t) {
    return e && s$e(e, t, jp)
}

function o$e(e, t) {
    return function(n, r) {
        if (n == null) return n;
        if (!ql(n)) return e(n, r);
        for (var s = n.length, i = t ? s : -1, o = Object(n);
            (t ? i-- : ++i < s) && r(o[i], i, o) !== !1;);
        return n
    }
}
var a$e = o$e(i$e),
    T3 = a$e;

function l$e(e) {
    return typeof e == "function" ? e : Hp
}

function Oy(e, t) {
    var n = hr(e) ? n1e : T3;
    return n(e, l$e(t))
}

function c$e(e) {
    return function(t, n, r) {
        var s = Object(t);
        if (!ql(t)) {
            var i = Rb(n);
            t = jp(t), n = function(a) {
                return i(s[a], a, s)
            }
        }
        var o = e(t, n, r);
        return o > -1 ? s[i ? t[o] : o] : void 0
    }
}
var u$e = Math.max;

function d$e(e, t, n) {
    var r = e == null ? 0 : e.length;
    if (!r) return -1;
    var s = n == null ? 0 : rI(n);
    return s < 0 && (s = u$e(r + s, 0)), d3(e, Rb(t), s)
}
var f$e = c$e(d$e),
    h$e = f$e;

function $3(e) {
    return e && e.length ? e[0] : void 0
}

function k3(e, t) {
    var n = -1,
        r = ql(e) ? Array(e.length) : [];
    return T3(e, function(s, i, o) {
        r[++n] = t(s, i, o)
    }), r
}

function I3(e, t) {
    var n = hr(e) ? Xc : k3;
    return n(e, Rb(t))
}
var p$e = "[object String]";

function m$e(e) {
    return typeof e == "string" || !hr(e) && $l(e) && zl(e) == p$e
}

function g$e(e, t) {
    return Xc(t, function(n) {
        return e[n]
    })
}

function _$e(e) {
    return e == null ? [] : g$e(e, jp(e))
}
var y$e = Math.max;

function Dy(e, t, n, r) {
    e = ql(e) ? e : _$e(e), n = n && !r ? rI(n) : 0;
    var s = e.length;
    return n < 0 && (n = y$e(s + n, 0)), m$e(e) ? n <= s && e.indexOf(t, n) > -1 : !!s && i1e(e, t, n) > -1
}
var v$e = "[object Map]",
    b$e = "[object Set]",
    w$e = Object.prototype,
    E$e = w$e.hasOwnProperty;

function fI(e) {
    if (e == null) return !0;
    if (ql(e) && (hr(e) || typeof e == "string" || typeof e.splice == "function" || Cy(e) || aI(e) || Ib(e))) return !e.length;
    var t = rS(e);
    if (t == v$e || t == b$e) return !e.size;
    if (f3(e)) return !_3(e).length;
    for (var n in e)
        if (E$e.call(e, n)) return !1;
    return !0
}

function Ob(e) {
    return e === void 0
}

function S$e(e, t) {
    var n = e.length;
    for (e.sort(t); n--;) e[n] = e[n].value;
    return e
}

function T$e(e, t) {
    if (e !== t) {
        var n = e !== void 0,
            r = e === null,
            s = e === e,
            i = Bu(e),
            o = t !== void 0,
            a = t === null,
            l = t === t,
            c = Bu(t);
        if (!a && !c && !i && e > t || i && o && l && !a && !c || r && o && l || !n && l || !s) return 1;
        if (!r && !i && !c && e < t || c && n && s && !r && !i || a && n && s || !o && s || !l) return -1
    }
    return 0
}

function $$e(e, t, n) {
    for (var r = -1, s = e.criteria, i = t.criteria, o = s.length, a = n.length; ++r < o;) {
        var l = T$e(s[r], i[r]);
        if (l) {
            if (r >= a) return l;
            var c = n[r];
            return l * (c == "desc" ? -1 : 1)
        }
    }
    return e.index - t.index
}

function k$e(e, t, n) {
    t.length ? t = Xc(t, function(i) {
        return hr(i) ? function(o) {
            return uI(o, i.length === 1 ? i[0] : i)
        } : i
    }) : t = [Hp];
    var r = -1;
    t = Xc(t, m3(Rb));
    var s = k3(e, function(i, o, a) {
        var l = Xc(t, function(c) {
            return c(i)
        });
        return {
            criteria: l,
            index: ++r,
            value: i
        }
    });
    return S$e(s, function(i, o) {
        return $$e(i, o, n)
    })
}

function I$e() {
    var e = arguments,
        t = Ay(e[0]);
    return e.length < 3 ? t : t.replace(e[1], e[2])
}
var x$e = Array.prototype,
    C$e = x$e.reverse;

function A$e(e) {
    return e == null ? e : C$e.call(e)
}
var R$e = HSe("round"),
    O$e = R$e,
    D$e = c1e(function(e, t) {
        if (e == null) return [];
        var n = t.length;
        return n > 1 && cN(e, t[0], t[1]) ? t = [] : n > 2 && cN(t[0], t[1], t[2]) && (t = [t[0]]), k$e(e, b3(t, 1), [])
    }),
    N$e = D$e;
const P$e = async () => {
        try {
            const e = [],
                t = [],
                n = il(Br, "plans"),
                r = oh(n, ef("active", "==", !0), ef("metadata.inPlanSelector", "==", "true")),
                s = await ah(r),
                i = [];
            return s.forEach(a => {
                e.push(x({
                    id: a.id
                }, a.data()));
                const l = il(Br, "plans", a.id, "prices"),
                    c = oh(l, ef("active", "==", !0));
                i.push(ah(c))
            }), (await Promise.all(i)).forEach(a => {
                a.forEach(l => {
                    t.push(x({
                        id: l.id
                    }, l.data()))
                })
            }), e.map(a => G(x({}, a), {
                prices: t.filter(l => l.product === a.id)
            }))
        } catch (e) {
            console.error(e)
        }
    },
    M$e = async e => {
        try {
            const t = ed(Br, "plans", e),
                n = await zT(t);
            return n.exists() ? n.data() : {}
        } catch (t) {
            console.error(t)
        }
    },
    L$e = async (e, t) => {
        try {
            const n = ed(Br, "plans", e, "prices", t),
                r = await zT(n);
            return r.exists() ? r.data() : {}
        } catch (n) {
            console.error(n)
        }
    },
    x3 = {
        OnboardingStart: "onboarding_start",
        OnboardingComplete: "onboarding_complete",
        NewCustomer: "new_customer",
        Publish: "site_publish",
        ViewPlans: "view_plans",
        Checkout: "begin_checkout",
        Purchase: "purchase"
    },
    C3 = (e, t = {}) => {
        bh != null && $F(bh, e, t, {})
    },
    QRe = (e, t) => {
        bh != null && w7(bh, {
            [e]: t
        })
    },
    JRe = async (e, t, n) => {
        const r = await M$e(t),
            s = await L$e(t, n),
            i = O$e((s == null ? void 0 : s.unit_amount) / 100, 2),
            o = `${s==null?void 0:s.interval_count} ${s==null?void 0:s.interval}`,
            a = {
                transaction_id: `${e}-${n}`,
                currency: s == null ? void 0 : s.currency,
                plan: `${r==null?void 0:r.name} - ${o}`,
                value: i,
                tax: 0,
                shipping: 0,
                items: [{
                    item_id: s == null ? void 0 : s.product,
                    quantity: 1,
                    item_name: r == null ? void 0 : r.name,
                    item_category: `${s==null?void 0:s.interval_count} ${s==null?void 0:s.interval}`,
                    price: i
                }]
            };
        C3(x3.Purchase, a)
    },
    {
        VITE_APP_ENV: F$e
    } = {
        VITE_ENTRI_APPLICATION_ID: "mixo",
        VITE_FIREBASE_MESSAGING_SENDER_ID: "725498859830",
        VITE_APP_URL: "https://app.mixo.io",
        VITE_RECAPTCHA_SITE_KEY: "6LdaL8EfAAAAAPAgV1G_36iCuh49y7cuNDqZpAl5",
        VITE_FUNCTIONS_URL: "https://us-west2-mixo-app.cloudfunctions.net",
        VITE_FIREBASE_RTDB_URL: "https://mixo-app-default-rtdb.firebaseio.com",
        VITE_GITHUB_SHA: "c2b884bd636dacf90f8c9e821e20a3fb3390e571",
        VITE_FIREBASE_MEASUREMENT_ID: "G-JHGL8M7FHL",
        VITE_FIREBASE_STORAGE_BUCKET: "mixo-app.appspot.com",
        VITE_FIREBASE_AUTH_DOMAIN: "mixo-app.firebaseapp.com",
        VITE_TRACKJS_APP: "mixo-prod",
        VITE_MIXO_DOMAIN: "mixo.io",
        VITE_LOGROCKET_KEY: "qg9d5c/mixo",
        VITE_UNSPLASH_ACCESS_KEY: "2Z53wBSWJVEmkXRa81cfNdjIQazdP-K9wf_X_m5DIzQ",
        VITE_FIREBASE_PROJECT_ID: "mixo-app",
        VITE_TRACKJS_KEY: "e1e034d6f3034ee397ffa1d1eb75c73e",
        VITE_FIREBASE_APP_ID: "1:725498859830:web:6421f91ef9f6e95c056397",
        VITE_APP_ENV: "production",
        VITE_FIREBASE_API_KEY: "AIzaSyAVslymxdABi7BdNzjT1quXFZduuyz6EhE",
        BASE_URL: "/",
        MODE: "production",
        DEV: !1,
        PROD: !0
    };
let pw;
const A3 = (e, t) => {
        var r;
        const n = "\u{1F514} " + ((r = e == null ? void 0 : e.event) == null ? void 0 : r.type) + " \u{1F5D2} " + JSON.stringify(e == null ? void 0 : e.value, null, 0);
        return console.groupCollapsed(t ? `\u274E%c ${t}:` : "State Service:", "color: #bada55", n)
    },
    R3 = e => {
        var t, n;
        if ((t = e == null ? void 0 : e.event) != null && t.type) {
            console.groupCollapsed("\u{1F514}%c Event:", "color: #fbbf24", (n = e == null ? void 0 : e.event) == null ? void 0 : n.type), console.group("Event Payload:");
            for (const [r, s] of Object.entries(e == null ? void 0 : e.event))
                if (s && typeof s == "object") {
                    if (console.group(`${r} (${typeof s})`), Object.entries(s).length < 3)
                        for (const [i, o] of Object.entries(s)) i && o && console.log(i, o);
                    else console.log(s);
                    console.groupEnd()
                } else console.log(`${r}: ${s} (${typeof s})`);
            console.groupEnd(), console.groupEnd()
        }
    },
    U$e = e => {
        for (const [t, n] of Object.entries(e))
            if (n && typeof n == "object") {
                if (console.groupCollapsed(`${t} (${typeof n})`), Object.entries(n).length < 3)
                    for (const [r, s] of Object.entries(n)) r && s && console.log(r, s);
                else console.log(n);
                console.groupEnd()
            } else console.log(`${t}: ${n} (${typeof n})`)
    },
    O3 = e => {
        console.group("\u{1FAD9}%c Context", "color: #17D3C8"), e != null && e.context && U$e(e == null ? void 0 : e.context), console.groupEnd()
    },
    B$e = e => {
        var t;
        if (e != null && e.children) {
            console.group("\u{1F6B8}%c Child Services", "color: #F5F0D9");
            for (const [n, r] of Object.entries(e.children))
                if (r && typeof r == "object") {
                    console.group(`${n} (${typeof r})`);
                    const s = (t = e.children[n]) == null ? void 0 : t.state;
                    A3(s, n), R3(s), O3(s), console.groupEnd(), console.groupEnd()
                } else console.log(`${n}: ${r} (${typeof r})`);
            console.groupEnd()
        }
    },
    D3 = (e, t = "") => {
        if (!e) return console.error(`watchService can't init for ${t}`), !1;
        F$e !== "production" && e.onTransition(n => {
            A3(n, t), R3(n), O3(n), B$e(n), console.groupEnd()
        })
    },
    V$e = {
        analyticsTrackEvent: (e, t, {
            action: n
        }) => (n == null ? void 0 : n.analyticsEvent) && C3(x3[n.analyticsEvent]),
        assignErrors: Of({
            errorMessage: (e, {
                data: t,
                error: n,
                errorMessage: r
            }) => {
                let s = r || (n == null ? void 0 : n.message) || (t == null ? void 0 : t.message) || "Unknown error";
                return s = s == null ? void 0 : s.replace("FirebaseError: ", ""), s === "internal" && (s = "Please try again or contact support."), s
            },
            errors: (e, {
                error: t,
                errors: n
            }) => {
                const s = [t].map(i => {
                    var o;
                    return i != null && i.message ? (o = i == null ? void 0 : i.message) == null ? void 0 : o.replace("FirebaseError: ", "") : i
                });
                return s.length > 0 ? s : ["Unknown error"]
            }
        }),
        redirectToCheckoutUrl: (e, {
            url: t
        }) => window.location.assign(t),
        resetErrors: Of({
            errorMessage: "",
            errors: []
        }),
        resetState: Of({}),
        showToast: ({
            toast: e
        }, t, {
            action: n
        }) => {
            e == null || e.open(x({
                message: (n == null ? void 0 : n.message) || "",
                type: (n == null ? void 0 : n.toastType) || "default"
            }, (n == null ? void 0 : n.toastOptions) || {}))
        },
        trackErrors: (e, t, {
            state: n
        }) => {
            var r, s;
            Ua.error((t == null ? void 0 : t.data) || (t == null ? void 0 : t.error), {
                label: "Machine Error",
                event: t == null ? void 0 : t.type,
                machine: (r = n == null ? void 0 : n.machine) == null ? void 0 : r.id,
                errorEventType: ((s = t == null ? void 0 : t.data) == null ? void 0 : s.type) || (t == null ? void 0 : t.errorEventType),
                state: n == null ? void 0 : n.value,
                context: e
            })
        },
        updatePreviewFrame: async (e, t, {
            state: n
        }) => {
            var l, c;
            pw || (pw = await at(() =>
                import ("./index.afe06d62.js").then(function(u) {
                    return u.i
                }), []).then(u => u.default));
            const {
                previewFrame: r,
                reselectingImages: s,
                siteId: i
            } = e, o = (l = r == null ? void 0 : r.value) == null ? void 0 : l.contentWindow, a = (e == null ? void 0 : e.siteData) || ((c = e == null ? void 0 : e.idea) == null ? void 0 : c.siteData);
            o ? await pw.send(o, "updatePage", {
                reselectingImages: s,
                siteData: a,
                siteId: i
            }).catch(u => {
                var d, f;
                (t == null ? void 0 : t.type) !== "UPDATE_SITE_DATA" && Ua.error(u, {
                    label: "Post Robot Error",
                    event: t == null ? void 0 : t.type,
                    machine: (d = n == null ? void 0 : n.machine) == null ? void 0 : d.id,
                    errorEventType: ((f = t == null ? void 0 : t.data) == null ? void 0 : f.type) || (t == null ? void 0 : t.errorEventType),
                    state: n == null ? void 0 : n.value
                })
            }) : console.log(`No frame found for ${t.type} in ${n.machine.id}`)
        }
    },
    ZRe = e => ({
        type: "parallel",
        states: e.reduce((t, {
            src: n,
            actions: r
        }) => G(x({}, t), {
            [n]: {
                initial: "run",
                states: {
                    run: {
                        invoke: {
                            src: n,
                            onDone: {
                                actions: r,
                                target: "done"
                            }
                        }
                    },
                    done: {
                        type: "final"
                    }
                }
            }
        }), {})
    }),
    H$e = (e, t = "", n = {}, r = !0) => {
        if (!e) return console.error(`setupMachine can't init for ${t}`), !1;
        const {
            state: s,
            send: i,
            service: o
        } = Jwe(e, n);
        return r && D3(o, t), {
            state: s,
            send: i,
            service: o
        }
    },
    eOe = (e, t = "", n = !1) => {
        if (!e) return console.error(`setupActor can't init for ${t}`), !1;
        const {
            state: r,
            send: s
        } = tEe(e);
        return n && D3(e, t), {
            state: r,
            send: s
        }
    },
    tOe = If("(min-width: 640px)");
const j$e = {
        name: "UiCenter"
    },
    z$e = {
        class: "flex justify-center items-center",
        "data-testid": "ui-center"
    };

function W$e(e, t, n, r, s, i) {
    return z(), Se("div", z$e, [Gn(e.$slots, "default", {}, void 0, !0)])
}
var N3 = bs(j$e, [
    ["render", W$e],
    ["__scopeId", "data-v-ceaf43ca"]
]);
const G$e = {
    name: "UiLoader",
    props: {
        iconColorClass: {
            type: String,
            default: "text-brand-primary"
        },
        label: {
            type: String,
            default: "Loading..."
        }
    }
};

function q$e(e, t, n, r, s, i) {
    const o = jl,
        a = N3;
    return z(), ke(a, null, {
        default: Re(() => [ne(o, {
            iconColorClass: n.iconColorClass,
            label: n.label
        }, null, 8, ["iconColorClass", "label"])]),
        _: 1
    })
}
var P3 = bs(G$e, [
        ["render", q$e]
    ]),
    Y$e = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: P3
    }, Symbol.toStringTag, {
        value: "Module"
    }));
const K$e = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    X$e = K("path", {
        fill: "currentColor",
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10s10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"
    }, null, -1),
    Q$e = [X$e];

function J$e(e, t) {
    return z(), Se("svg", K$e, Q$e)
}
var M3 = {
    name: "ic-baseline-error",
    render: J$e
};
const Z$e = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    eke = K("path", {
        fill: "currentColor",
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10s10-4.48 10-10S17.52 2 12 2zm0 15c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1zm1-8h-2V7h2v2z"
    }, null, -1),
    tke = [eke];

function nke(e, t) {
    return z(), Se("svg", Z$e, tke)
}
var rke = {
    name: "ic-round-info",
    render: nke
};
const ske = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    ike = K("path", {
        fill: "currentColor",
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10s10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5l1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
    }, null, -1),
    oke = [ike];

function ake(e, t) {
    return z(), Se("svg", ske, oke)
}
var lke = {
    name: "ic-baseline-check-circle",
    render: ake
};
const cke = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    uke = K("path", {
        fill: "currentColor",
        d: "M4.47 21h15.06c1.54 0 2.5-1.67 1.73-3L13.73 4.99c-.77-1.33-2.69-1.33-3.46 0L2.74 18c-.77 1.33.19 3 1.73 3zM12 14c-.55 0-1-.45-1-1v-2c0-.55.45-1 1-1s1 .45 1 1v2c0 .55-.45 1-1 1zm1 4h-2v-2h2v2z"
    }, null, -1),
    dke = [uke];

function fke(e, t) {
    return z(), Se("svg", cke, dke)
}
var hke = {
    name: "ic-round-warning",
    render: fke
};
const pke = {
        name: "UiAlert",
        props: {
            buttonAction: {
                type: Function,
                default: null
            },
            buttonLabel: {
                type: String,
                default: "Retry?"
            },
            messages: {
                type: Array,
                default: () => []
            },
            title: {
                type: String,
                default: ""
            },
            type: {
                type: String,
                default: ""
            }
        }
    },
    mke = e => (tk("data-v-9171a6e8"), e = e(), nk(), e),
    gke = {
        class: "flex"
    },
    _ke = {
        class: "flex-shrink-0"
    },
    yke = {
        class: "ml-3 space-y-2"
    },
    vke = {
        key: 0,
        class: "text-base font-bold ui-alert-title"
    },
    bke = {
        key: 1,
        class: "space-y-2 ui-alert-content"
    },
    wke = {
        class: "space-y-4"
    },
    Eke = {
        class: "flex items-center gap-2"
    },
    Ske = {
        key: 0,
        class: "text-sm ui-alert-details pt-1 max-w-sm"
    },
    Tke = mke(() => K("summary", null, [K("em", null, "Boring Technical Details")], -1)),
    $ke = {
        role: "list",
        class: "pl-5 space-y-1 list-disc"
    };

function kke(e, t, n, r, s, i) {
    const o = hke,
        a = lke,
        l = rke,
        c = M3,
        u = Eb;
    return z(), Se("div", {
        class: wn(["p-4 rounded-md shadow", `ui-alert-${n.type}`])
    }, [K("div", gke, [K("div", _ke, [n.type === "warning" ? (z(), ke(o, {
        key: 0,
        class: "w-6 h-6 ui-alert-icon"
    })) : Ve("", !0), n.type === "success" ? (z(), ke(a, {
        key: 1,
        class: "w-6 h-6 ui-alert-icon"
    })) : Ve("", !0), n.type === "info" ? (z(), ke(l, {
        key: 2,
        class: "w-6 h-6 ui-alert-icon"
    })) : Ve("", !0), n.type === "error" ? (z(), ke(c, {
        key: 3,
        class: "w-6 h-6 ui-alert-icon"
    })) : Ve("", !0)]), K("div", yke, [n.title ? (z(), Se("h3", vke, xs(n.title), 1)) : Ve("", !0), e.$slots.default || n.buttonAction || n.messages.length ? (z(), Se("div", bke, [K("div", wke, [K("div", null, [Gn(e.$slots, "default", {}, void 0, !0)]), K("div", Eke, [Gn(e.$slots, "controls", {}, void 0, !0), n.buttonAction ? (z(), ke(u, {
        key: 0,
        size: "xs",
        theme: "tertiary",
        onClick: n.buttonAction
    }, {
        default: Re(() => [hn(xs(n.buttonLabel), 1)]),
        _: 1
    }, 8, ["onClick"])) : Ve("", !0)])]), n.messages.length && n.messages[0] ? (z(), Se("details", Ske, [Tke, K("ul", $ke, [(z(!0), Se(Ht, null, $u(n.messages, (d, f) => (z(), Se("li", {
        key: f
    }, xs(d), 1))), 128))])])) : Ve("", !0)])) : Ve("", !0)])])], 2)
}
var L3 = bs(pke, [
    ["render", kke],
    ["__scopeId", "data-v-9171a6e8"]
]);
const Ike = {},
    xke = hn(" Sorry it looks like there was an issue loading this component. Please refresh your page to try again. ");

function Cke(e, t) {
    const n = L3;
    return z(), ke(n, {
        type: "error",
        title: "Could not load component \u{1F648}"
    }, {
        default: Re(() => [xke]),
        _: 1
    })
}
var Ake = bs(Ike, [
    ["render", Cke]
]);
const Gh = {
        loadingComponent: P3,
        delay: 200,
        errorComponent: Ake,
        timeout: 5e3,
        onError: (e, t, n, r) => {
            var s;
            console.log(e, t, n, r), ((s = e == null ? void 0 : e.message) == null ? void 0 : s.match(/fetch/)) && r <= 3 ? t() : n()
        }
    },
    Rke = {
        class: "formkit-outer formkit-disabled:opacity-50",
        "data-testid": "media-input"
    },
    Oke = {
        class: "formkit-wrapper flex flex-col space-y-4"
    },
    Dke = {
        key: 0,
        class: "formkit-inner max-w-md formkit-invalid:border-red-500 mb-1 flex flex-col items-start space-y-2"
    },
    Nke = ["src", "alt"],
    Pke = K("span", null, "Add", -1),
    Mke = {
        name: "MediaInput",
        props: {
            context: {
                type: Object,
                default: () => ({})
            }
        },
        emits: ["input"],
        setup(e, {
            emit: t
        }) {
            const n = e,
                r = bt("$vfm"),
                s = bt("openAuthModal"),
                [i, o] = _j(),
                a = Tu(G(x({}, Gh), {
                    loader: () => at(() =>
                        import ("./MediaLibrary.97c81614.js"), ["assets/MediaLibrary.97c81614.js", "assets/UiHeading.6d814843.js", "assets/index.907e950c.js", "assets/access-machine.349d1b5c.js"])
                })),
                l = So(() => {
                    var p, m, g, y, _;
                    const h = (p = n == null ? void 0 : n.context) == null ? void 0 : p._value;
                    return typeof h == "string" ? h : (m = h == null ? void 0 : h.image) != null && m.src ? (g = h == null ? void 0 : h.image) == null ? void 0 : g.src : (y = h == null ? void 0 : h.video) != null && y.thumbnailUrl ? (_ = h == null ? void 0 : h.video) == null ? void 0 : _.thumbnailUrl : null
                }),
                c = h => {
                    var p, m;
                    i.value = !0, (m = (p = n == null ? void 0 : n.context) == null ? void 0 : p.node) == null || m.input(h), r.hide("media-library")
                },
                u = () => {
                    var h, p, m, g;
                    Vh({
                        name: "media-library",
                        clickToClose: !1,
                        contentClasses: "w-full max-w-4xl"
                    }, {
                        default: {
                            component: a,
                            bind: {
                                enableUnsplash: (h = n == null ? void 0 : n.context) == null ? void 0 : h.enableUnsplash,
                                enableUploader: (p = n == null ? void 0 : n.context) == null ? void 0 : p.enableUploader,
                                enableVideo: (m = n == null ? void 0 : n.context) == null ? void 0 : m.enableVideo,
                                returnImagePathAsString: (g = n == null ? void 0 : n.context) == null ? void 0 : g.returnImagePathAsString,
                                openAuthModal: s
                            },
                            on: {
                                input: c
                            }
                        }
                    })
                },
                d = () => {
                    i.value = !1
                },
                f = () => {
                    var h, p;
                    (p = (h = n == null ? void 0 : n.context) == null ? void 0 : h.node) == null || p.input()
                };
            return (h, p) => {
                var _, E, b, w;
                const m = jl,
                    g = uve,
                    y = Eb;
                return z(), Se("div", Rke, [K("div", Oke, [(_ = e.context) != null && _._value ? (z(), Se("div", Dke, [K("button", {
                    class: "appearance-none cursor-pointer border border-slate-300 rounded-lg p-2 bg-white",
                    type: "button",
                    onClick: u
                }, [fe(i) ? (z(), ke(m, {
                    key: 0
                })) : Ve("", !0), H_((z(), Se("img", {
                    key: (E = e.context) == null ? void 0 : E._value,
                    src: fe(l),
                    alt: (b = e.context) == null ? void 0 : b.label,
                    onload: d,
                    class: "w-full max-w-[8rem]"
                }, null, 8, Nke)), [
                    [Rh, !fe(i)]
                ])]), fe(i) ? Ve("", !0) : (z(), Se("button", {
                    key: 0,
                    class: "text-xs text-red-700",
                    type: "button",
                    onClick: f
                }, " (remove) "))])) : Ve("", !0), (w = e.context) != null && w._value ? Ve("", !0) : (z(), ke(y, {
                    key: 1,
                    type: "button",
                    theme: "brand-secondary",
                    size: "sm",
                    class: "self-start",
                    onClick: u
                }, {
                    default: Re(() => [ne(g, {
                        class: "w-4"
                    }), Pke]),
                    _: 1
                }))])])
            }
        }
    },
    Lke = e => {
        var t;
        return e ? !((t = e == null ? void 0 : e.value) != null && t.includes("www.")) : !1
    },
    Fke = e => e ? /^[a-zA-Z0-9][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9]{0,1}\.([a-zA-Z]{1,15}|[a-zA-Z0-9-]{1,30}\.[a-zA-Z]{2,15})$/.test(e == null ? void 0 : e.value) : !1,
    Uke = Ipe("fk-7dc794d0af2", Vye),
    Bke = {
        config: {
            classes: vde(qye)
        },
        icons: {
            arrowDown: ofe,
            arrowUp: afe,
            close: tO,
            checkboxDecorator: tfe,
            fileItem: nO,
            fileRemove: tO,
            noFiles: nO,
            radioDecorator: nfe,
            spinner: rfe,
            star: sfe,
            trash: ife
        },
        rules: {
            checkNakedUrl: Lke,
            checkValidDomain: Fke
        },
        plugins: [Uke],
        inputs: {
            mediaInput: Kde(Mke, {
                props: ["label", "value", "enableVideo", "enableUnsplash", "enableUploader", "returnImagePathAsString"]
            })
        }
    },
    Vke = ({
        app: e
    }) => {
        e.use(Vde, efe(Bke))
    };
var Hke = Object.freeze(Object.defineProperty({
    __proto__: null,
    install: Vke
}, Symbol.toStringTag, {
    value: "Module"
}));
const jke = ({
    app: e
}) => {};
var zke = Object.freeze(Object.defineProperty({
        __proto__: null,
        install: jke
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    F3 = {
        exports: {}
    };
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function(e, t) {
    (function(n, r) {
        e.exports = r()
    })(N_, function() {
        var n = {};
        n.version = "0.2.0";
        var r = n.settings = {
            minimum: .08,
            easing: "ease",
            positionUsing: "",
            speed: 200,
            trickle: !0,
            trickleRate: .02,
            trickleSpeed: 800,
            showSpinner: !0,
            barSelector: '[role="bar"]',
            spinnerSelector: '[role="spinner"]',
            parent: "body",
            template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
        };
        n.configure = function(p) {
                var m, g;
                for (m in p) g = p[m], g !== void 0 && p.hasOwnProperty(m) && (r[m] = g);
                return this
            }, n.status = null, n.set = function(p) {
                var m = n.isStarted();
                p = s(p, r.minimum, 1), n.status = p === 1 ? null : p;
                var g = n.render(!m),
                    y = g.querySelector(r.barSelector),
                    _ = r.speed,
                    E = r.easing;
                return g.offsetWidth, a(function(b) {
                    r.positionUsing === "" && (r.positionUsing = n.getPositioningCSS()), l(y, o(p, _, E)), p === 1 ? (l(g, {
                        transition: "none",
                        opacity: 1
                    }), g.offsetWidth, setTimeout(function() {
                        l(g, {
                            transition: "all " + _ + "ms linear",
                            opacity: 0
                        }), setTimeout(function() {
                            n.remove(), b()
                        }, _)
                    }, _)) : setTimeout(b, _)
                }), this
            }, n.isStarted = function() {
                return typeof n.status == "number"
            }, n.start = function() {
                n.status || n.set(0);
                var p = function() {
                    setTimeout(function() {
                        !n.status || (n.trickle(), p())
                    }, r.trickleSpeed)
                };
                return r.trickle && p(), this
            }, n.done = function(p) {
                return !p && !n.status ? this : n.inc(.3 + .5 * Math.random()).set(1)
            }, n.inc = function(p) {
                var m = n.status;
                return m ? (typeof p != "number" && (p = (1 - m) * s(Math.random() * m, .1, .95)), m = s(m + p, 0, .994), n.set(m)) : n.start()
            }, n.trickle = function() {
                return n.inc(Math.random() * r.trickleRate)
            },
            function() {
                var p = 0,
                    m = 0;
                n.promise = function(g) {
                    return !g || g.state() === "resolved" ? this : (m === 0 && n.start(), p++, m++, g.always(function() {
                        m--, m === 0 ? (p = 0, n.done()) : n.set((p - m) / p)
                    }), this)
                }
            }(), n.render = function(p) {
                if (n.isRendered()) return document.getElementById("nprogress");
                u(document.documentElement, "nprogress-busy");
                var m = document.createElement("div");
                m.id = "nprogress", m.innerHTML = r.template;
                var g = m.querySelector(r.barSelector),
                    y = p ? "-100" : i(n.status || 0),
                    _ = document.querySelector(r.parent),
                    E;
                return l(g, {
                    transition: "all 0 linear",
                    transform: "translate3d(" + y + "%,0,0)"
                }), r.showSpinner || (E = m.querySelector(r.spinnerSelector), E && h(E)), _ != document.body && u(_, "nprogress-custom-parent"), _.appendChild(m), m
            }, n.remove = function() {
                d(document.documentElement, "nprogress-busy"), d(document.querySelector(r.parent), "nprogress-custom-parent");
                var p = document.getElementById("nprogress");
                p && h(p)
            }, n.isRendered = function() {
                return !!document.getElementById("nprogress")
            }, n.getPositioningCSS = function() {
                var p = document.body.style,
                    m = "WebkitTransform" in p ? "Webkit" : "MozTransform" in p ? "Moz" : "msTransform" in p ? "ms" : "OTransform" in p ? "O" : "";
                return m + "Perspective" in p ? "translate3d" : m + "Transform" in p ? "translate" : "margin"
            };

        function s(p, m, g) {
            return p < m ? m : p > g ? g : p
        }

        function i(p) {
            return (-1 + p) * 100
        }

        function o(p, m, g) {
            var y;
            return r.positionUsing === "translate3d" ? y = {
                transform: "translate3d(" + i(p) + "%,0,0)"
            } : r.positionUsing === "translate" ? y = {
                transform: "translate(" + i(p) + "%,0)"
            } : y = {
                "margin-left": i(p) + "%"
            }, y.transition = "all " + m + "ms " + g, y
        }
        var a = function() {
                var p = [];

                function m() {
                    var g = p.shift();
                    g && g(m)
                }
                return function(g) {
                    p.push(g), p.length == 1 && m()
                }
            }(),
            l = function() {
                var p = ["Webkit", "O", "Moz", "ms"],
                    m = {};

                function g(b) {
                    return b.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(w, T) {
                        return T.toUpperCase()
                    })
                }

                function y(b) {
                    var w = document.body.style;
                    if (b in w) return b;
                    for (var T = p.length, S = b.charAt(0).toUpperCase() + b.slice(1), v; T--;)
                        if (v = p[T] + S, v in w) return v;
                    return b
                }

                function _(b) {
                    return b = g(b), m[b] || (m[b] = y(b))
                }

                function E(b, w, T) {
                    w = _(w), b.style[w] = T
                }
                return function(b, w) {
                    var T = arguments,
                        S, v;
                    if (T.length == 2)
                        for (S in w) v = w[S], v !== void 0 && w.hasOwnProperty(S) && E(b, S, v);
                    else E(b, T[1], T[2])
                }
            }();

        function c(p, m) {
            var g = typeof p == "string" ? p : f(p);
            return g.indexOf(" " + m + " ") >= 0
        }

        function u(p, m) {
            var g = f(p),
                y = g + m;
            c(g, m) || (p.className = y.substring(1))
        }

        function d(p, m) {
            var g = f(p),
                y;
            !c(p, m) || (y = g.replace(" " + m + " ", " "), p.className = y.substring(1, y.length - 1))
        }

        function f(p) {
            return (" " + (p.className || "") + " ").replace(/\s+/gi, " ")
        }

        function h(p) {
            p && p.parentNode && p.parentNode.removeChild(p)
        }
        return n
    })
})(F3);
var xN = F3.exports;
const Wke = ({
    isClient: e,
    router: t
}) => {
    e && (t.beforeEach((n, r) => {
        n.path !== r.path && xN.start()
    }), t.afterEach(() => {
        xN.done()
    }))
};
var Gke = Object.freeze(Object.defineProperty({
    __proto__: null,
    install: Wke
}, Symbol.toStringTag, {
    value: "Module"
}));
const qke = ({
    isClient: e,
    router: t
}) => {
    !e || t.isReady().then(async () => {
        const {
            registerSW: n
        } = await at(() =>
            import ("./virtual_pwa-register.a5cf61fc.js"), []);
        n({
            immediate: !0
        })
    })
};
var Yke = Object.freeze(Object.defineProperty({
    __proto__: null,
    install: qke
}, Symbol.toStringTag, {
    value: "Module"
}));

function hI(e) {
    return (hI = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    })(e)
}

function CN(e, t, n, r, s, i, o) {
    try {
        var a = e[i](o),
            l = a.value
    } catch (c) {
        return void n(c)
    }
    a.done ? t(l) : Promise.resolve(l).then(r, s)
}

function Kke(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
    }
}

function Qc(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function AN(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(s) {
            return Object.getOwnPropertyDescriptor(e, s).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function _r(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? AN(Object(n), !0).forEach(function(r) {
            Qc(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AN(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function Qa(e) {
    return function(t) {
        if (Array.isArray(t)) return mw(t)
    }(e) || function(t) {
        if (typeof Symbol != "undefined" && Symbol.iterator in Object(t)) return Array.from(t)
    }(e) || function(t, n) {
        if (!!t) {
            if (typeof t == "string") return mw(t, n);
            var r = Object.prototype.toString.call(t).slice(8, -1);
            if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
            if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return mw(t, n)
        }
    }(e) || function() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }()
}

function mw(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}
var Xke = function(e) {
        return function(t, n) {
            return Qa(t.querySelectorAll(n) || [])
        }(e, 'button:not([disabled]), select:not([disabled]), a[href]:not([disabled]), area[href]:not([disabled]), [contentEditable=""]:not([disabled]), [contentEditable="true"]:not([disabled]), [contentEditable="TRUE"]:not([disabled]), textarea:not([disabled]), iframe:not([disabled]), input:not([disabled]), summary:not([disabled]), [tabindex]:not([tabindex="-1"])')
    },
    RN = function(e) {
        return e == document.activeElement
    },
    Qke = function() {
        function e() {
            (function(r, s) {
                if (!(r instanceof s)) throw new TypeError("Cannot call a class as a function")
            })(this, e), this.root = null, this.elements = [], this.onKeyDown = this.onKeyDown.bind(this), this.enable = this.enable.bind(this), this.disable = this.disable.bind(this), this.firstElement = this.firstElement.bind(this), this.lastElement = this.lastElement.bind(this)
        }
        var t, n;
        return t = e, (n = [{
            key: "lastElement",
            value: function() {
                return this.elements[this.elements.length - 1] || null
            }
        }, {
            key: "firstElement",
            value: function() {
                return this.elements[0] || null
            }
        }, {
            key: "onKeyDown",
            value: function(r) {
                if (function(s) {
                        return s.key === "Tab" || s.keyCode === 9
                    }(r)) {
                    if (!r.shiftKey) return !document.activeElement || RN(this.lastElement()) ? (this.firstElement().focus(), void r.preventDefault()) : void 0;
                    RN(this.firstElement()) && (this.lastElement().focus(), r.preventDefault())
                }
            }
        }, {
            key: "enabled",
            value: function() {
                return !!this.root
            }
        }, {
            key: "enable",
            value: function(r) {
                r && (this.root = r, this.elements = Xke(this.root), this.root.addEventListener("keydown", this.onKeyDown))
            }
        }, {
            key: "disable",
            value: function() {
                this.root.removeEventListener("keydown", this.onKeyDown), this.root = null
            }
        }]) && Kke(t.prototype, n), e
    }(),
    ON = function(e) {
        var t = e.targetTouches ? e.targetTouches[0] : e;
        return {
            x: t.clientX,
            y: t.clientY
        }
    },
    Ym = function(e, t, n) {
        return typeof e != "number" && (e = Math.min(t, n) || t), typeof n != "number" && (n = Math.max(t, e)), Math.min(Math.max(t, e), n)
    },
    DN = function(e) {
        return e && Number(e.replace(/px$/, "")) || 0
    },
    Ny = {
        down: {
            pc: "mousedown",
            m: "touchstart"
        },
        move: {
            pc: "mousemove",
            m: "touchmove"
        },
        up: {
            pc: "mouseup",
            m: "touchend"
        }
    },
    Km = function(e, t, n) {
        t && t.addEventListener(Ny[e].pc, n), t && t.addEventListener(Ny[e].m, n, {
            passive: !1
        })
    },
    Xm = function(e, t, n) {
        t && t.removeEventListener(Ny[e].pc, n), t && t.removeEventListener(Ny[e].m, n)
    },
    pI = !1;
if (typeof window != "undefined") {
    var NN = {
        get passive() {
            pI = !0
        }
    };
    window.addEventListener("testPassive", null, NN), window.removeEventListener("testPassive", null, NN)
}
var Nf, Pf, U3 = typeof window != "undefined" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1),
    To = [],
    Py = !1,
    Ng = 0,
    PN = -1,
    Jke = function(e, t) {
        var n = !1;
        return function(r) {
            for (var s = []; r;) {
                if (s.push(r), r.classList.contains("vfm")) return s;
                r = r.parentElement
            }
            return s
        }(e).forEach(function(r) {
            (function(s) {
                if (!s || s.nodeType !== Node.ELEMENT_NODE) return !1;
                var i = window.getComputedStyle(s);
                return ["auto", "scroll"].includes(i.overflowY) && s.scrollHeight > s.clientHeight
            })(r) && function(s, i) {
                return !(s.scrollTop === 0 && i < 0 || s.scrollTop + s.clientHeight + i >= s.scrollHeight && i > 0)
            }(r, t) && (n = !0)
        }), n
    },
    B3 = function(e) {
        return To.some(function() {
            return Jke(e, -Ng)
        })
    },
    sS = function(e) {
        var t = e || window.event;
        return !!B3(t.target) || t.touches.length > 1 || (t.preventDefault && t.preventDefault(), !1)
    },
    Zke = function(e, t) {
        if (e) {
            if (!To.some(function(r) {
                    return r.targetElement === e
                })) {
                var n = {
                    targetElement: e,
                    options: t || {}
                };
                To = [].concat(Qa(To), [n]), U3 ? (e.ontouchstart = function(r) {
                    r.targetTouches.length === 1 && (PN = r.targetTouches[0].clientY)
                }, e.ontouchmove = function(r) {
                    r.targetTouches.length === 1 && function(s, i) {
                        Ng = s.targetTouches[0].clientY - PN, !B3(s.target) && (i && i.scrollTop === 0 && Ng > 0 || function(o) {
                            return !!o && o.scrollHeight - o.scrollTop <= o.clientHeight
                        }(i) && Ng < 0 ? sS(s) : s.stopPropagation())
                    }(r, e)
                }, Py || (document.addEventListener("touchmove", sS, pI ? {
                    passive: !1
                } : void 0), Py = !0)) : function(r) {
                    if (Pf === void 0) {
                        var s = !!r && r.reserveScrollBarGap === !0,
                            i = window.innerWidth - document.documentElement.clientWidth;
                        if (s && i > 0) {
                            var o = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
                            Pf = document.body.style.paddingRight, document.body.style.paddingRight = "".concat(o + i, "px")
                        }
                    }
                    Nf === void 0 && (Nf = document.body.style.overflow, document.body.style.overflow = "hidden")
                }(t)
            }
        } else console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.")
    },
    gw = function(e) {
        e ? (To = To.filter(function(t) {
            return t.targetElement !== e
        }), U3 ? (e.ontouchstart = null, e.ontouchmove = null, Py && To.length === 0 && (document.removeEventListener("touchmove", sS, pI ? {
            passive: !1
        } : void 0), Py = !1)) : To.length || (Pf !== void 0 && (document.body.style.paddingRight = Pf, Pf = void 0), Nf !== void 0 && (document.body.style.overflow = Nf, Nf = void 0))) : console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.")
    },
    Qm = function() {},
    MN = "enter",
    LN = "entering",
    Jm = "leave",
    FN = "leavng",
    eIe = {
        t: "ns-resize",
        tr: "nesw-resize",
        r: "ew-resize",
        br: "nwse-resize",
        b: "ns-resize",
        bl: "nesw-resize",
        l: "ew-resize",
        tl: "nwse-resize"
    },
    Pg = {
        props: {
            name: {
                type: String,
                default: null
            },
            modelValue: {
                type: Boolean,
                default: !1
            },
            ssr: {
                type: Boolean,
                default: !0
            },
            classes: {
                type: [String, Object, Array],
                default: ""
            },
            overlayClass: {
                type: [String, Object, Array],
                default: ""
            },
            contentClass: {
                type: [String, Object, Array],
                default: ""
            },
            styles: {
                type: [Object, Array],
                default: function() {
                    return {}
                }
            },
            overlayStyle: {
                type: [Object, Array],
                default: function() {
                    return {}
                }
            },
            contentStyle: {
                type: [Object, Array],
                default: function() {
                    return {}
                }
            },
            lockScroll: {
                type: Boolean,
                default: !0
            },
            hideOverlay: {
                type: Boolean,
                default: !1
            },
            clickToClose: {
                type: Boolean,
                default: !0
            },
            escToClose: {
                type: Boolean,
                default: !1
            },
            preventClick: {
                type: Boolean,
                default: !1
            },
            attach: {
                type: null,
                default: !1,
                validator: function(e) {
                    var t = hI(e);
                    return t === "boolean" || t === "string" || e.nodeType === Node.ELEMENT_NODE
                }
            },
            transition: {
                type: [String, Object],
                default: "vfm"
            },
            overlayTransition: {
                type: [String, Object],
                default: "vfm"
            },
            keepOverlay: {
                type: Boolean,
                default: !1
            },
            zIndexAuto: {
                type: Boolean,
                default: !0
            },
            zIndexBase: {
                type: [String, Number],
                default: 1e3
            },
            zIndex: {
                type: [Boolean, String, Number],
                default: !1
            },
            focusRetain: {
                type: Boolean,
                default: !0
            },
            focusTrap: {
                type: Boolean,
                default: !1
            },
            fitParent: {
                type: Boolean,
                default: !0
            },
            drag: {
                type: Boolean,
                default: !1
            },
            dragSelector: {
                type: String,
                default: ""
            },
            keepChangedStyle: {
                type: Boolean,
                default: !1
            },
            resize: {
                type: Boolean,
                default: !1
            },
            resizeDirections: {
                type: Array,
                default: function() {
                    return ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                },
                validator: function(e) {
                    return ["t", "tr", "r", "br", "b", "bl", "l", "tl"].filter(function(t) {
                        return e.indexOf(t) !== -1
                    }).length === e.length
                }
            },
            minWidth: {
                type: Number,
                default: 0
            },
            minHeight: {
                type: Number,
                default: 0
            },
            maxWidth: {
                type: Number,
                default: 1 / 0
            },
            maxHeight: {
                type: Number,
                default: 1 / 0
            }
        },
        emits: ["update:modelValue", "click-outside", "before-open", "opened", "before-close", "closed", "_before-open", "_opened", "_closed", "drag:start", "drag:move", "drag:end", "resize:start", "resize:move", "resize:end"],
        setup: function(e, t) {
            var n = t.emit,
                r = Symbol("vfm"),
                s = ae(null),
                i = ae(null),
                o = ae(null),
                a = ae(null),
                l = ae(null),
                c = ae(null),
                u = ae(null),
                d = new Qke,
                f = ae(!1),
                h = Pr({
                    modal: !1,
                    overlay: !1,
                    resize: !1
                }),
                p = ae(null),
                m = ae(null),
                g = ae(!1),
                y = ae({}),
                _ = ae({}),
                E = ae(null),
                b = ae(null),
                w = Qm,
                T = Qm,
                S = Fe(function() {
                    return typeof e.overlayTransition == "string" ? {
                        name: e.overlayTransition
                    } : _r({}, e.overlayTransition)
                }),
                v = Fe(function() {
                    return typeof e.transition == "string" ? {
                        name: e.transition
                    } : _r({}, e.transition)
                }),
                $ = Fe(function() {
                    return (e.hideOverlay || p.value === Jm) && m.value === Jm
                }),
                k = Fe(function() {
                    return e.zIndex === !1 ? !!e.zIndexAuto && +e.zIndexBase + 2 * (u.value || 0) : e.zIndex
                }),
                C = Fe(function() {
                    return _r({}, k.value !== !1 && {
                        zIndex: k.value
                    })
                }),
                O = Fe(function() {
                    var D = [_.value];
                    return Array.isArray(e.contentStyle) ? D.push.apply(D, Qa(e.contentStyle)) : D.push(e.contentStyle), D
                });

            function R() {
                return {
                    uid: r,
                    props: e,
                    emit: n,
                    vfmContainer: i,
                    vfmContent: o,
                    vfmResize: a,
                    vfmOverlayTransition: l,
                    vfmTransition: c,
                    getAttachElement: ie,
                    modalStackIndex: u,
                    visibility: h,
                    handleLockScroll: Y,
                    $focusTrap: d,
                    toggle: Yt,
                    params: y
                }
            }

            function N() {
                if (e.modelValue) {
                    if (n("_before-open", ce({
                            type: "_before-open"
                        })), Ue("before-open", !1)) return void T("show");
                    var D = ie();
                    if (D || e.attach === !1) {
                        if (e.attach !== !1) {
                            if (!s.value) return f.value = !0, void ln(function() {
                                N()
                            });
                            D.appendChild(s.value)
                        }
                        var V = e.api.openedModals.findIndex(function(oe) {
                            return oe.uid === r
                        });
                        V !== -1 && e.api.openedModals.splice(V, 1), e.api.openedModals.push(R()), u.value = e.api.openedModals.length - 1, Y(), e.api.openedModals.filter(function(oe) {
                            return oe.uid !== r
                        }).forEach(function(oe, we) {
                            oe.getAttachElement() === D && (oe.modalStackIndex.value = we, !oe.props.keepOverlay && (oe.visibility.overlay = !1))
                        }), f.value = !0, h.overlay = !0, h.modal = !0
                    } else D !== !1 && console.warn("Unable to locate target ".concat(e.attach))
                }
            }

            function J() {
                var D = e.api.openedModals.findIndex(function(oe) {
                    return oe.uid === r
                });
                if (D !== -1 && e.api.openedModals.splice(D, 1), e.api.openedModals.length > 0) {
                    var V = e.api.openedModals[e.api.openedModals.length - 1];
                    V.props.focusTrap && V.$focusTrap.firstElement().focus(), (V.props.focusRetain || V.props.focusTrap) && V.vfmContainer.value.focus(), !V.props.hideOverlay && (V.visibility.overlay = !0)
                }
                e.drag && pr(), e.resize && se(), E.value = null, h.overlay = !1, h.modal = !1
            }

            function Y() {
                e.modelValue && ln(function() {
                    e.lockScroll ? Zke(i.value, {
                        reserveScrollBarGap: !0
                    }) : gw(i.value)
                })
            }

            function ie() {
                return e.attach !== !1 && (typeof e.attach == "string" ? !!window && window.document.querySelector(e.attach) : e.attach)
            }

            function ce() {
                var D = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                return _r({
                    ref: R()
                }, D)
            }

            function Ue(D, V) {
                var oe = !1,
                    we = ce({
                        type: D,
                        stop: function() {
                            oe = !0
                        }
                    });
                return n(D, we), !!oe && (g.value = !0, ln(function() {
                    n("update:modelValue", V)
                }), !0)
            }

            function Kt(D, V, oe) {
                E.value = "".concat(V, ":").concat(oe), n(E.value, D)
            }

            function Yt(D, V) {
                var oe = arguments;
                return new Promise(function(we, ge) {
                    w = function(I) {
                        we(I), w = Qm
                    }, T = function(I) {
                        ge(I), T = Qm
                    };
                    var ee = typeof D == "boolean" ? D : !e.modelValue;
                    ee && oe.length === 2 && (y.value = V), n("update:modelValue", ee)
                })
            }

            function pn(D) {
                D.stopPropagation();
                var V, oe = "resize",
                    we = "drag",
                    ge = D.target.getAttribute("direction");
                if (ge) V = oe;
                else {
                    if (! function(le, ye, Ae) {
                            return Ae === "" || Qa(ye.querySelectorAll(Ae)).includes(le.target)
                        }(D, o.value, e.dragSelector)) return;
                    V = we
                }
                Kt(D, V, "start");
                var ee, I, A, P, B = ON(D),
                    F = i.value.getBoundingClientRect(),
                    j = o.value.getBoundingClientRect(),
                    te = window.getComputedStyle(o.value).position === "absolute",
                    q = DN(_.value.top),
                    Q = DN(_.value.left),
                    H = function() {
                        if (e.fitParent) {
                            var le = {
                                absolute: function() {
                                    return {
                                        minTop: 0,
                                        minLeft: 0,
                                        maxTop: F.height - j.height,
                                        maxLeft: F.width - j.width
                                    }
                                },
                                relative: function() {
                                    return {
                                        minTop: q + F.top - j.top,
                                        minLeft: Q + F.left - j.left,
                                        maxTop: q + F.bottom - j.bottom,
                                        maxLeft: Q + F.right - j.right
                                    }
                                }
                            };
                            return te ? le.absolute() : le.relative()
                        }
                        return {}
                    }(),
                    _e = V === oe && (ee = document.body, I = "cursor", A = eIe[ge], P = ee.style[I], ee.style[I] = A, function() {
                        ee.style[I] = P
                    }),
                    ue = function(le) {
                        le.stopPropagation(), Kt(le, V, "move");
                        var ye, Ae, lt = ON(le),
                            Me = {
                                x: lt.x - B.x,
                                y: lt.y - B.y
                            };
                        V === oe && (Me = function(xr, Yi, zp, ws, Wp) {
                            var Jn = function(mr) {
                                    var Jr, Ki = Yi[mr.axis];
                                    Ki = e.fitParent ? Ym(mr.min, Ki, mr.max) : Ki;
                                    var Xi = Ym(mr.minEdge, mr.getEdge(Ki), mr.maxEdge);
                                    return Ki = mr.getOffsetAxis(Xi, Wp), Qc(Jr = {}, mr.edgeName, Xi), Qc(Jr, mr.axis, Ki), Jr
                                },
                                Wr = function(mr, Jr, Ki, Xi) {
                                    var SI, TI = ws[Jr],
                                        $I = zp[mr] - ws[mr],
                                        kI = (SI = Jr).charAt(0).toUpperCase() + SI.slice(1);
                                    return {
                                        axis: Ki,
                                        edgeName: Jr,
                                        min: Xi ? $I : -TI,
                                        max: Xi ? TI : $I,
                                        minEdge: e["min".concat(kI)],
                                        maxEdge: e["max".concat(kI)],
                                        getEdge: function(Fb) {
                                            return ws[Jr] - Fb * (Xi ? 1 : -1)
                                        },
                                        getOffsetAxis: function(Fb, cz) {
                                            var II = ws[Jr] - Fb;
                                            return cz ? Xi ? II : 0 : (Xi ? 1 : -1) * II / 2
                                        }
                                    }
                                },
                                Gp = {
                                    t: ["top", "height", "y", !0],
                                    b: ["bottom", "height", "y", !1],
                                    l: ["left", "width", "x", !0],
                                    r: ["right", "width", "x", !1]
                                },
                                Lb = {
                                    x: 0,
                                    y: 0
                                };
                            return xr.split("").forEach(function(mr) {
                                var Jr = Wr.apply(void 0, Qa(Gp[mr]));
                                Lb = _r(_r({}, Lb), Jn(Jr))
                            }), Lb
                        }(ge, Me, F, j, te)), te ? (ye = j.top - F.top + Me.y, Ae = j.left - F.left + Me.x) : (ye = q + Me.y, Ae = Q + Me.x), V === we && e.fitParent && (ye = Ym(H.minTop, ye, H.maxTop), Ae = Ym(H.minLeft, Ae, H.maxLeft));
                        var yt = _r(_r(_r({
                            position: "relative",
                            top: ye + "px",
                            left: Ae + "px",
                            margin: "unset",
                            touchAction: "none"
                        }, te && {
                            position: "absolute",
                            transform: "unset",
                            width: j.width + "px",
                            height: j.height + "px"
                        }), Me.width && {
                            width: Me.width + "px"
                        }), Me.height && {
                            height: Me.height + "px"
                        });
                        _.value = _r(_r({}, _.value), yt)
                    };
                Km("move", document, ue), Km("up", document, function le(ye) {
                    ye.stopPropagation(), V === oe && _e && _e(), setTimeout(function() {
                        Kt(ye, V, "end")
                    }), Xm("move", document, ue), Xm("up", document, le)
                })
            }

            function mn() {
                Km("down", o.value, pn), _.value.touchAction = "none"
            }

            function pr() {
                Xm("down", o.value, pn)
            }

            function L() {
                h.resize = !0, ln(function() {
                    Km("down", a.value, pn)
                })
            }

            function se() {
                Xm("down", a.value, pn), h.resize = !1
            }
            return $t(function() {
                return e.modelValue
            }, function(D) {
                if (g.value) g.value = !1;
                else if (N(), !D) {
                    if (Ue("before-close", !0)) return void T("hide");
                    J()
                }
            }), $t(function() {
                return e.lockScroll
            }, Y), $t(function() {
                return e.hideOverlay
            }, function(D) {
                e.modelValue && !D && (h.overlay = !0)
            }), $t(function() {
                return e.attach
            }, N), $t($, function(D) {
                D && (f.value = !1, i.value.style.display = "none")
            }, {
                flush: "post"
            }), $t(function() {
                return e.drag
            }, function(D) {
                f.value && (D ? mn() : pr())
            }), $t(function() {
                return e.resize
            }, function(D) {
                f.value && (D ? L() : se())
            }), $t(function() {
                return e.keepChangedStyle
            }, function(D) {
                D || (_.value = {})
            }), e.api.modals.push(R()), jr(function() {
                N()
            }), pa(function() {
                var D;
                J(), e.lockScroll && i.value && gw(i.value), s == null || (D = s.value) === null || D === void 0 || D.remove();
                var V = e.api.modals.findIndex(function(oe) {
                    return oe.uid === r
                });
                e.api.modals.splice(V, 1)
            }), {
                root: s,
                vfmContainer: i,
                vfmContent: o,
                vfmResize: a,
                vfmOverlayTransition: l,
                vfmTransition: c,
                computedOverlayTransition: S,
                computedTransition: v,
                visible: f,
                visibility: h,
                params: y,
                calculateZIndex: k,
                bindStyle: C,
                bindContentStyle: O,
                beforeOverlayEnter: function() {
                    p.value = LN
                },
                afterOverlayEnter: function() {
                    p.value = MN
                },
                beforeOverlayLeave: function() {
                    p.value = FN
                },
                afterOverlayLeave: function() {
                    p.value = Jm
                },
                beforeModalEnter: function() {
                    m.value = LN
                },
                afterModalEnter: function() {
                    m.value = MN, (e.focusRetain || e.focusTrap) && i.value.focus(), e.focusTrap && d.enable(i.value), e.drag && mn(), e.resize && L(), n("_opened"), n("opened", ce({
                        type: "opened"
                    })), w("show")
                },
                beforeModalLeave: function() {
                    m.value = FN, d.enabled() && d.disable()
                },
                afterModalLeave: function() {
                    m.value = Jm, u.value = null, e.lockScroll && gw(i.value), e.keepChangedStyle || (_.value = {});
                    var D = !1,
                        V = ce({
                            type: "closed",
                            stop: function() {
                                D = !0
                            }
                        });
                    n("_closed"), n("closed", V), w("hide"), D || (y.value = {})
                },
                onMousedown: function(D) {
                    b.value = D == null ? void 0 : D.target
                },
                onMouseupContainer: function() {
                    b.value === i.value && E.value !== "resize:move" && (n("click-outside", ce({
                        type: "click-outside"
                    })), e.clickToClose && n("update:modelValue", !1))
                },
                onEsc: function() {
                    f.value && e.escToClose && n("update:modelValue", !1)
                }
            }
        }
    },
    _w = D5();
tk("data-v-2836fdb5");
var tIe = {
    key: 0,
    ref: "vfmResize",
    class: "vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none"
};
nk();
var nIe = _w(function(e, t, n, r, s, i) {
    return n.ssr || r.visible ? H_((z(), ke("div", {
        key: 0,
        ref: "root",
        style: r.bindStyle,
        class: ["vfm vfm--inset", [n.attach === !1 ? "vfm--fixed" : "vfm--absolute", {
            "vfm--prevent-none": n.preventClick
        }]],
        onKeydown: t[4] || (t[4] = RV(function() {
            return r.onEsc && r.onEsc.apply(r, arguments)
        }, ["esc"]))
    }, [ne(Zo, xi(r.computedOverlayTransition, {
        onBeforeEnter: r.beforeOverlayEnter,
        onAfterEnter: r.afterOverlayEnter,
        onBeforeLeave: r.beforeOverlayLeave,
        onAfterLeave: r.afterOverlayLeave
    }), {
        default: _w(function() {
            return [!n.hideOverlay && r.visibility.overlay ? (z(), ke("div", {
                key: 0,
                class: ["vfm__overlay vfm--overlay vfm--absolute vfm--inset", n.overlayClass],
                style: n.overlayStyle
            }, null, 6)) : Ve("v-if", !0)]
        }),
        _: 1
    }, 16, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]), ne(Zo, xi(r.computedTransition, {
        onBeforeEnter: r.beforeModalEnter,
        onAfterEnter: r.afterModalEnter,
        onBeforeLeave: r.beforeModalLeave,
        onAfterLeave: r.afterModalLeave
    }), {
        default: _w(function() {
            return [H_(ne("div", {
                ref: "vfmContainer",
                class: ["vfm__container vfm--absolute vfm--inset vfm--outline-none", n.classes],
                style: n.styles,
                "aria-expanded": r.visibility.modal.toString(),
                role: "dialog",
                "aria-modal": "true",
                tabindex: "-1",
                onMouseup: t[2] || (t[2] = u1(function() {
                    return r.onMouseupContainer && r.onMouseupContainer.apply(r, arguments)
                }, ["self"])),
                onMousedown: t[3] || (t[3] = u1(function() {
                    return r.onMousedown && r.onMousedown.apply(r, arguments)
                }, ["self"]))
            }, [ne("div", {
                ref: "vfmContent",
                class: ["vfm__content", [n.contentClass, {
                    "vfm--prevent-auto": n.preventClick
                }]],
                style: r.bindContentStyle,
                onMousedown: t[1] || (t[1] = function(o) {
                    return r.onMousedown(null)
                })
            }, [Gn(e.$slots, "default", {
                params: r.params,
                close: function() {
                    return e.$emit("update:modelValue", !1)
                }
            }), r.visibility.resize && r.visibility.modal ? (z(), ke("div", tIe, [(z(!0), ke(Ht, null, $u(n.resizeDirections, function(o) {
                return z(), ke("div", {
                    key: o,
                    direction: o,
                    class: ["vfm--resize-".concat(o), "vfm--absolute vfm--prevent-auto"]
                }, null, 10, ["direction"])
            }), 128))], 512)) : Ve("v-if", !0)], 38)], 46, ["aria-expanded"]), [
                [Rh, r.visibility.modal]
            ])]
        }),
        _: 3
    }, 16, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])], 38)), [
        [Rh, !n.ssr || r.visible]
    ]) : Ve("v-if", !0)
});
(function(e, t) {
    t === void 0 && (t = {});
    var n = t.insertAt;
    if (e && typeof document != "undefined") {
        var r = document.head || document.getElementsByTagName("head")[0],
            s = document.createElement("style");
        s.type = "text/css", n === "top" && r.firstChild ? r.insertBefore(s, r.firstChild) : r.appendChild(s), s.styleSheet ? s.styleSheet.cssText = e : s.appendChild(document.createTextNode(e))
    }
})(`
.vfm--fixed[data-v-2836fdb5] {
  position: fixed;
}
.vfm--absolute[data-v-2836fdb5] {
  position: absolute;
}
.vfm--inset[data-v-2836fdb5] {
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.vfm--overlay[data-v-2836fdb5] {
  background-color: rgba(0, 0, 0, 0.5);
}
.vfm--prevent-none[data-v-2836fdb5] {
  pointer-events: none;
}
.vfm--prevent-auto[data-v-2836fdb5] {
  pointer-events: auto;
}
.vfm--outline-none[data-v-2836fdb5]:focus {
  outline: none;
}
.vfm-enter-active[data-v-2836fdb5],
.vfm-leave-active[data-v-2836fdb5] {
  transition: opacity 0.2s;
}
.vfm-enter-from[data-v-2836fdb5],
.vfm-leave-to[data-v-2836fdb5] {
  opacity: 0;
}
.vfm--touch-none[data-v-2836fdb5] {
  touch-action: none;
}
.vfm--select-none[data-v-2836fdb5] {
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}
.vfm--resize-tr[data-v-2836fdb5],
.vfm--resize-br[data-v-2836fdb5],
.vfm--resize-bl[data-v-2836fdb5],
.vfm--resize-tl[data-v-2836fdb5] {
  width: 12px;
  height: 12px;
  z-index: 10;
}
.vfm--resize-t[data-v-2836fdb5] {
  top: -6px;
  left: 0;
  width: 100%;
  height: 12px;
  cursor: ns-resize;
}
.vfm--resize-tr[data-v-2836fdb5] {
  top: -6px;
  right: -6px;
  cursor: nesw-resize;
}
.vfm--resize-r[data-v-2836fdb5] {
  top: 0;
  right: -6px;
  width: 12px;
  height: 100%;
  cursor: ew-resize;
}
.vfm--resize-br[data-v-2836fdb5] {
  bottom: -6px;
  right: -6px;
  cursor: nwse-resize;
}
.vfm--resize-b[data-v-2836fdb5] {
  bottom: -6px;
  left: 0;
  width: 100%;
  height: 12px;
  cursor: ns-resize;
}
.vfm--resize-bl[data-v-2836fdb5] {
  bottom: -6px;
  left: -6px;
  cursor: nesw-resize;
}
.vfm--resize-l[data-v-2836fdb5] {
  top: 0;
  left: -6px;
  width: 12px;
  height: 100%;
  cursor: ew-resize;
}
.vfm--resize-tl[data-v-2836fdb5] {
  top: -6px;
  left: -6px;
  cursor: nwse-resize;
}
`), Pg.render = nIe, Pg.__scopeId = "data-v-2836fdb5", Pg.__file = "lib/VueFinalModal.vue";
var iS = {
        props: {},
        methods: {
            slice: function(e) {
                this.api.dynamicModals.splice(e, 1)
            },
            beforeOpen: function(e, t, n) {
                var r, s = this;
                return (r = function*() {
                    e.ref.params.value = t.params, yield s.$nextTick(), yield s.$nextTick(), t.value || (s.slice(n), t.reject("show"))
                }, function() {
                    var i = this,
                        o = arguments;
                    return new Promise(function(a, l) {
                        var c = r.apply(i, o);

                        function u(f) {
                            CN(c, a, l, u, d, "next", f)
                        }

                        function d(f) {
                            CN(c, a, l, u, d, "throw", f)
                        }
                        u(void 0)
                    })
                })()
            },
            isString: function(e) {
                return typeof e == "string"
            }
        }
    },
    rIe = {
        class: "modals-container"
    };

function UN(e, t) {
    var n = _r(_r({}, e), {}, {
        props: _r({}, e.props)
    });
    return Object.assign(n.props, {
        api: {
            type: Object,
            default: function() {
                return t
            }
        }
    }), n
}
iS.render = function(e, t, n, r, s, i) {
    return z(), ke("div", rIe, [(z(!0), ke(Ht, null, $u(e.api.dynamicModals, function(o, a) {
        return z(), ke(Ah(o.component), xi({
            key: o.id
        }, o.bind, {
            modelValue: o.value,
            "onUpdate:modelValue": function(l) {
                return o.value = l
            }
        }, QE(o.on), {
            on_closed: function(l) {
                return i.slice(a)
            },
            on_beforeOpen: function(l) {
                return i.beforeOpen(l, o)
            },
            on_opened: o.opened
        }), q5({
            _: 2
        }, [$u(o.slots, function(l, c) {
            return {
                name: c,
                fn: Re(function() {
                    return [Ve(" eslint-disable vue/no-v-html "), i.isString(l) ? (z(), ke("div", {
                        key: 0,
                        innerHTML: l
                    }, null, 8, ["innerHTML"])) : (z(), ke(Ah(l.component), xi({
                        key: 1
                    }, l.bind, QE(l.on || {})), null, 16))]
                })
            }
        })]), 1040, ["modelValue", "onUpdate:modelValue", "on_closed", "on_beforeOpen", "on_opened"])
    }), 128))])
}, iS.__file = "lib/ModalsContainer.vue";
var BN = 0,
    mI = function() {
        var e, t, n = (t = null, {
            show: function(r) {
                for (var s = this, i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) o[a - 1] = arguments[a];
                switch (hI(r)) {
                    case "string":
                        return this.toggle.apply(this, [r, !0].concat(o));
                    case "object":
                        return Promise.allSettled([new Promise(function(l, c) {
                            var u = {
                                value: !0,
                                id: Symbol("dynamicModal"),
                                component: t,
                                bind: {},
                                slots: {},
                                on: {},
                                params: o[0],
                                reject: c,
                                opened: function() {
                                    l("show")
                                }
                            };
                            s.dynamicModals.push(F_(Object.assign(u, r)))
                        })])
                }
            },
            hide: function() {
                for (var r = arguments.length, s = new Array(r), i = 0; i < r; i++) s[i] = arguments[i];
                return this.toggle(s, !1)
            },
            hideAll: function() {
                return this.hide.apply(this, Qa(this.openedModals.map(function(r) {
                    return r.props.name
                })))
            },
            toggle: function(r) {
                for (var s = arguments.length, i = new Array(s > 1 ? s - 1 : 0), o = 1; o < s; o++) i[o - 1] = arguments[o];
                var a = Array.isArray(r) ? this.get.apply(this, Qa(r)) : this.get(r);
                return Promise.allSettled(a.map(function(l) {
                    return l.toggle.apply(l, i)
                }))
            },
            get: function() {
                for (var r = arguments.length, s = new Array(r), i = 0; i < r; i++) s[i] = arguments[i];
                return this.modals.filter(function(o) {
                    return s.includes(o.props.name)
                })
            },
            dynamicModals: F_([]),
            openedModals: [],
            modals: [],
            _setDefaultModal: function(r) {
                t = r
            }
        });
        return Qc(e = {}, "$vfm", n), Qc(e, "VueFinalModal", function(r) {
            var s = UN(Pg, r);
            return r._setDefaultModal(s), s
        }(n)), Qc(e, "ModalsContainer", function(r) {
            return UN(iS, r)
        }(n)), e
    },
    Db = mI(),
    sIe = Db.$vfm,
    iIe = Db.VueFinalModal,
    oIe = Db.ModalsContainer,
    V3 = function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            n = BN === 0 ? Db : mI(),
            r = n.$vfm,
            s = n.VueFinalModal,
            i = n.ModalsContainer;
        BN += 1;
        var o = t.key || "$vfm",
            a = t.componentName || "VueFinalModal",
            l = t.dynamicContainerName || "ModalsContainer";
        Object.defineProperty(e.config.globalProperties, o, {
            get: function() {
                return r
            }
        }), e.provide(o, r), e.component(a, s), e.component(l, i)
    },
    qh = function(e) {
        return {
            install: function(t, n) {
                var r = Object.assign({}, e, n);
                V3(t, r)
            }
        }
    };
qh.install = V3;
var aIe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: qh,
    $vfm: sIe,
    ModalsContainer: oIe,
    VueFinalModal: iIe,
    defineVfm: mI,
    vfmPlugin: qh
}, Symbol.toStringTag, {
    value: "Module"
}));
const lIe = async ({
    app: e
}) => {
    e.use(qh)
};
var cIe = Object.freeze(Object.defineProperty({
    __proto__: null,
    install: lIe
}, Symbol.toStringTag, {
    value: "Module"
}));
const uIe = async ({
    app: e
}) => {
    e.use(Lbe, {
        firebaseApp: fa,
        modules: [Mbe()]
    })
};
var dIe = Object.freeze(Object.defineProperty({
        __proto__: null,
        install: uIe
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    H3 = {
        exports: {}
    },
    fIe = cie(Hce);
(function(e, t) {
    (function(n, r) {
        e.exports = r(fIe)
    })(N_, n => (() => {
        var r = {
                831: (a, l) => {
                    Object.defineProperty(l, "__esModule", {
                        value: !0
                    }), l.default = (c, u) => {
                        const d = c.__vccOpts || c;
                        for (const [f, h] of u) d[f] = h;
                        return d
                    }
                },
                976: a => {
                    a.exports = n
                }
            },
            s = {};

        function i(a) {
            var l = s[a];
            if (l !== void 0) return l.exports;
            var c = s[a] = {
                exports: {}
            };
            return r[a](c, c.exports, i), c.exports
        }
        i.d = (a, l) => {
            for (var c in l) i.o(l, c) && !i.o(a, c) && Object.defineProperty(a, c, {
                enumerable: !0,
                get: l[c]
            })
        }, i.o = (a, l) => Object.prototype.hasOwnProperty.call(a, l), i.r = a => {
            typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(a, "__esModule", {
                value: !0
            })
        };
        var o = {};
        return (() => {
            i.r(o), i.d(o, {
                ToastComponent: () => y,
                ToastPlugin: () => E,
                ToastPositions: () => h,
                default: () => b,
                useToast: () => _
            });
            var a = i(976);
            const l = (0, a.createElementVNode)("div", {
                    class: "v-toast__icon"
                }, null, -1),
                c = ["innerHTML"];

            function u(w) {
                var T;
                w.remove !== void 0 ? w.remove() : (T = w.parentNode) === null || T === void 0 || T.removeChild(w)
            }

            function d(w, T, S) {
                let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                const $ = (0, a.h)(w, T, v),
                    k = document.createElement("div");
                return k.classList.add("v-toast--pending"), S.appendChild(k), (0, a.render)($, k), $.component
            }
            class f {
                constructor(T, S) {
                    this.startedAt = Date.now(), this.callback = T, this.delay = S, this.timer = setTimeout(T, S)
                }
                pause() {
                    this.stop(), this.delay -= Date.now() - this.startedAt
                }
                resume() {
                    this.stop(), this.startedAt = Date.now(), this.timer = setTimeout(this.callback, this.delay)
                }
                stop() {
                    clearTimeout(this.timer)
                }
            }
            const h = Object.freeze({
                TOP_RIGHT: "top-right",
                TOP: "top",
                TOP_LEFT: "top-left",
                BOTTOM_RIGHT: "bottom-right",
                BOTTOM: "bottom",
                BOTTOM_LEFT: "bottom-left"
            });
            var p;
            const m = {
                    all: p = p || new Map,
                    on: function(w, T) {
                        var S = p.get(w);
                        S ? S.push(T) : p.set(w, [T])
                    },
                    off: function(w, T) {
                        var S = p.get(w);
                        S && (T ? S.splice(S.indexOf(T) >>> 0, 1) : p.set(w, []))
                    },
                    emit: function(w, T) {
                        var S = p.get(w);
                        S && S.slice().map(function(v) {
                            v(T)
                        }), (S = p.get("*")) && S.slice().map(function(v) {
                            v(w, T)
                        })
                    }
                },
                g = (0, a.defineComponent)({
                    name: "Toast",
                    props: {
                        message: {
                            type: String,
                            required: !0
                        },
                        type: {
                            type: String,
                            default: "success"
                        },
                        position: {
                            type: String,
                            default: h.BOTTOM_RIGHT,
                            validator: w => Object.values(h).includes(w)
                        },
                        duration: {
                            type: Number,
                            default: 3e3
                        },
                        dismissible: {
                            type: Boolean,
                            default: !0
                        },
                        onDismiss: {
                            type: Function,
                            default: () => {}
                        },
                        onClick: {
                            type: Function,
                            default: () => {}
                        },
                        queue: Boolean,
                        pauseOnHover: {
                            type: Boolean,
                            default: !0
                        }
                    },
                    data: () => ({
                        isActive: !1,
                        parentTop: null,
                        parentBottom: null,
                        isHovered: !1
                    }),
                    beforeMount() {
                        this.setupContainer()
                    },
                    mounted() {
                        this.showNotice(), m.on("toast-clear", this.dismiss)
                    },
                    methods: {
                        setupContainer() {
                            if (this.parentTop = document.querySelector(".v-toast.v-toast--top"), this.parentBottom = document.querySelector(".v-toast.v-toast--bottom"), this.parentTop && this.parentBottom) return;
                            this.parentTop || (this.parentTop = document.createElement("div"), this.parentTop.className = "v-toast v-toast--top"), this.parentBottom || (this.parentBottom = document.createElement("div"), this.parentBottom.className = "v-toast v-toast--bottom");
                            const w = document.body;
                            w.appendChild(this.parentTop), w.appendChild(this.parentBottom)
                        },
                        shouldQueue() {
                            return !!this.queue && (this.parentTop.childElementCount > 0 || this.parentBottom.childElementCount > 0)
                        },
                        dismiss() {
                            this.timer && this.timer.stop(), clearTimeout(this.queueTimer), this.isActive = !1, setTimeout(() => {
                                this.onDismiss.apply(null, arguments);
                                const w = this.$refs.root;
                                (0, a.render)(null, w), u(w)
                            }, 150)
                        },
                        showNotice() {
                            if (this.shouldQueue()) return void(this.queueTimer = setTimeout(this.showNotice, 250));
                            const w = this.$refs.root.parentElement;
                            this.correctParent.insertAdjacentElement("afterbegin", this.$refs.root), u(w), this.isActive = !0, this.duration && (this.timer = new f(this.dismiss, this.duration))
                        },
                        whenClicked() {
                            this.dismissible && (this.onClick.apply(null, arguments), this.dismiss())
                        },
                        toggleTimer(w) {
                            this.pauseOnHover && this.timer && (w ? this.timer.pause() : this.timer.resume())
                        }
                    },
                    computed: {
                        correctParent() {
                            switch (this.position) {
                                case h.TOP:
                                case h.TOP_RIGHT:
                                case h.TOP_LEFT:
                                    return this.parentTop;
                                case h.BOTTOM:
                                case h.BOTTOM_RIGHT:
                                case h.BOTTOM_LEFT:
                                    return this.parentBottom
                            }
                        },
                        transition() {
                            switch (this.position) {
                                case h.TOP:
                                case h.TOP_RIGHT:
                                case h.TOP_LEFT:
                                    return {
                                        enter: "v-toast--fade-in-down",
                                        leave: "v-toast--fade-out"
                                    };
                                case h.BOTTOM:
                                case h.BOTTOM_RIGHT:
                                case h.BOTTOM_LEFT:
                                    return {
                                        enter: "v-toast--fade-in-up",
                                        leave: "v-toast--fade-out"
                                    }
                            }
                        }
                    },
                    beforeUnmount() {
                        m.off("toast-clear", this.dismiss)
                    }
                }),
                y = (0, i(831).default)(g, [
                    ["render", function(w, T, S, v, $, k) {
                        return (0, a.openBlock)(), (0, a.createBlock)(a.Transition, {
                            "enter-active-class": w.transition.enter,
                            "leave-active-class": w.transition.leave
                        }, {
                            default: (0, a.withCtx)(() => [(0, a.withDirectives)((0, a.createElementVNode)("div", {
                                ref: "root",
                                role: "alert",
                                class: (0, a.normalizeClass)(["v-toast__item", ["v-toast__item--".concat(w.type), "v-toast__item--".concat(w.position)]]),
                                onMouseover: T[0] || (T[0] = C => w.toggleTimer(!0)),
                                onMouseleave: T[1] || (T[1] = C => w.toggleTimer(!1)),
                                onClick: T[2] || (T[2] = function() {
                                    return w.whenClicked && w.whenClicked(...arguments)
                                })
                            }, [l, (0, a.createElementVNode)("p", {
                                class: "v-toast__text",
                                innerHTML: w.message
                            }, null, 8, c)], 34), [
                                [a.vShow, w.isActive]
                            ])]),
                            _: 1
                        }, 8, ["enter-active-class", "leave-active-class"])
                    }]
                ]),
                _ = function() {
                    let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    return {
                        open(T) {
                            let S = null;
                            typeof T == "string" && (S = T);
                            const v = {
                                    message: S
                                },
                                $ = Object.assign({}, v, w, T);
                            return {
                                dismiss: d(y, $, document.body).ctx.dismiss
                            }
                        },
                        clear() {
                            m.emit("toast-clear")
                        },
                        success(T) {
                            let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            return this.open(Object.assign({}, {
                                message: T,
                                type: "success"
                            }, S))
                        },
                        error(T) {
                            let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            return this.open(Object.assign({}, {
                                message: T,
                                type: "error"
                            }, S))
                        },
                        info(T) {
                            let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            return this.open(Object.assign({}, {
                                message: T,
                                type: "info"
                            }, S))
                        },
                        warning(T) {
                            let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            return this.open(Object.assign({}, {
                                message: T,
                                type: "warning"
                            }, S))
                        },
                        default (T) {
                            let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            return this.open(Object.assign({}, {
                                message: T,
                                type: "default"
                            }, S))
                        }
                    }
                },
                E = {
                    install: function(w) {
                        let T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                            S = _(T);
                        w.config.globalProperties.$toast = S, w.provide("$toast", S)
                    }
                },
                b = E
        })(), o
    })())
})(H3);
var hIe = lie(H3.exports);
const j3 = {
        delay: 2e3,
        position: "top"
    },
    pIe = ({
        app: e
    }) => {
        e.use(hIe, j3)
    };
var mIe = Object.freeze(Object.defineProperty({
    __proto__: null,
    defaultToastOptions: j3,
    install: pIe
}, Symbol.toStringTag, {
    value: "Module"
}));

function oS(e, t = {}, n) {
    for (const r in e) {
        const s = e[r],
            i = n ? `${n}:${r}` : r;
        typeof s == "object" && s !== null ? oS(s, t, i) : typeof s == "function" && (t[i] = s)
    }
    return t
}
const gIe = {
        run: e => e()
    },
    _Ie = () => gIe,
    z3 = typeof console.createTask != "undefined" ? console.createTask : _Ie;

function yIe(e, t) {
    const n = t.shift(),
        r = z3(n);
    return e.reduce((s, i) => s.then(() => r.run(() => i(...t))), Promise.resolve())
}

function vIe(e, t) {
    const n = t.shift(),
        r = z3(n);
    return Promise.all(e.map(s => r.run(() => s(...t))))
}

function yw(e, t) {
    for (const n of [...e]) n(t)
}
class bIe {
    constructor() {
        this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this)
    }
    hook(t, n, r = {}) {
        if (!t || typeof n != "function") return () => {};
        const s = t;
        let i;
        for (; this._deprecatedHooks[t];) i = this._deprecatedHooks[t], t = i.to;
        if (i && !r.allowDeprecated) {
            let o = i.message;
            o || (o = `${s} hook has been deprecated` + (i.to ? `, please use ${i.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(o) || (console.warn(o), this._deprecatedMessages.add(o))
        }
        if (!n.name) try {
            Object.defineProperty(n, "name", {
                get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb",
                configurable: !0
            })
        } catch {}
        return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(n), () => {
            n && (this.removeHook(t, n), n = void 0)
        }
    }
    hookOnce(t, n) {
        let r, s = (...i) => (typeof r == "function" && r(), r = void 0, s = void 0, n(...i));
        return r = this.hook(t, s), r
    }
    removeHook(t, n) {
        if (this._hooks[t]) {
            const r = this._hooks[t].indexOf(n);
            r !== -1 && this._hooks[t].splice(r, 1), this._hooks[t].length === 0 && delete this._hooks[t]
        }
    }
    deprecateHook(t, n) {
        this._deprecatedHooks[t] = typeof n == "string" ? {
            to: n
        } : n;
        const r = this._hooks[t] || [];
        delete this._hooks[t];
        for (const s of r) this.hook(t, s)
    }
    deprecateHooks(t) {
        Object.assign(this._deprecatedHooks, t);
        for (const n in t) this.deprecateHook(n, t[n])
    }
    addHooks(t) {
        const n = oS(t),
            r = Object.keys(n).map(s => this.hook(s, n[s]));
        return () => {
            for (const s of r.splice(0, r.length)) s()
        }
    }
    removeHooks(t) {
        const n = oS(t);
        for (const r in n) this.removeHook(r, n[r])
    }
    removeAllHooks() {
        for (const t in this._hooks) delete this._hooks[t]
    }
    callHook(t, ...n) {
        return n.unshift(t), this.callHookWith(yIe, t, ...n)
    }
    callHookParallel(t, ...n) {
        return n.unshift(t), this.callHookWith(vIe, t, ...n)
    }
    callHookWith(t, n, ...r) {
        const s = this._before || this._after ? {
            name: n,
            args: r,
            context: {}
        } : void 0;
        this._before && yw(this._before, s);
        const i = t(n in this._hooks ? [...this._hooks[n]] : [], r);
        return i instanceof Promise ? i.finally(() => {
            this._after && s && yw(this._after, s)
        }) : (this._after && s && yw(this._after, s), i)
    }
    beforeEach(t) {
        return this._before = this._before || [], this._before.push(t), () => {
            if (this._before !== void 0) {
                const n = this._before.indexOf(t);
                n !== -1 && this._before.splice(n, 1)
            }
        }
    }
    afterEach(t) {
        return this._after = this._after || [], this._after.push(t), () => {
            if (this._after !== void 0) {
                const n = this._after.indexOf(t);
                n !== -1 && this._after.splice(n, 1)
            }
        }
    }
}

function wIe() {
    return new bIe
}

function EIe(e) {
    return Array.isArray(e) ? e : [e]
}
const W3 = ["title", "script", "style", "noscript"],
    G3 = ["base", "meta", "link", "style", "script", "noscript"],
    SIe = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"],
    TIe = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"],
    $Ie = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "innerHTML", "textContent"];

function q3(e) {
    let t = 9;
    for (let n = 0; n < e.length;) t = Math.imul(t ^ e.charCodeAt(n++), 9 ** 9);
    return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}

function aS(e) {
    return q3(`${e.tag}:${e.textContent||e.innerHTML||""}:${Object.entries(e.props).map(([t,n])=>`${t}:${String(n)}`).join(",")}`)
}

function kIe(e) {
    let t = 9;
    for (const n of e)
        for (let r = 0; r < n.length;) t = Math.imul(t ^ n.charCodeAt(r++), 9 ** 9);
    return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}

function Y3(e, t) {
    const {
        props: n,
        tag: r
    } = e;
    if (TIe.includes(r)) return r;
    if (r === "link" && n.rel === "canonical") return "canonical";
    if (n.charset) return "charset";
    const s = ["id"];
    r === "meta" && s.push("name", "property", "http-equiv");
    for (const i of s)
        if (typeof n[i] != "undefined") {
            const o = String(n[i]);
            return t && !t(o) ? !1 : `${r}:${i}:${o}`
        }
    return !1
}

function VN(e, t) {
    return e == null ? t || null : typeof e == "function" ? e(t) : e
}

function Zm(e, t = !1, n) {
    const {
        tag: r,
        $el: s
    } = e;
    !s || (Object.entries(r.props).forEach(([i, o]) => {
        o = String(o);
        const a = `attr:${i}`;
        if (i === "class") {
            if (!o) return;
            for (const l of o.split(" ")) {
                const c = `${a}:${l}`;
                n && n(e, c, () => s.classList.remove(l)), s.classList.contains(l) || s.classList.add(l)
            }
            return
        }
        n && !i.startsWith("data-h-") && n(e, a, () => s.removeAttribute(i)), (t || s.getAttribute(i) !== o) && s.setAttribute(i, o)
    }), W3.includes(r.tag) && (r.textContent && r.textContent !== s.textContent ? s.textContent = r.textContent : r.innerHTML && r.innerHTML !== s.innerHTML && (s.innerHTML = r.innerHTML)))
}
let xd = !1;
async function K3(e, t = {}) {
    var f, h;
    const n = {
        shouldRender: !0
    };
    if (await e.hooks.callHook("dom:beforeRender", n), !n.shouldRender) return;
    const r = t.document || e.resolvedOptions.document || window.document,
        s = (await e.resolveTags()).map(a);
    if (e.resolvedOptions.experimentalHashHydration && (xd = xd || e._hash || !1, xd)) {
        const p = kIe(s.map(m => m.tag._h));
        if (xd === p) return;
        xd = p
    }
    const i = e._popSideEffectQueue();
    e.headEntries().map(p => p._sde).forEach(p => {
        Object.entries(p).forEach(([m, g]) => {
            i[m] = g
        })
    });
    const o = (p, m, g) => {
        m = `${p.renderId}:${m}`, p.entry && (p.entry._sde[m] = g), delete i[m]
    };

    function a(p) {
        const m = e.headEntries().find(y => y._i === p._e),
            g = {
                renderId: p._d || aS(p),
                $el: null,
                shouldRender: !0,
                tag: p,
                entry: m,
                markSideEffect: (y, _) => o(g, y, _)
            };
        return g
    }
    const l = [],
        c = {
            body: [],
            head: []
        },
        u = p => {
            e._elMap[p.renderId] = p.$el, l.push(p), o(p, "el", () => {
                var m;
                (m = p.$el) == null || m.remove(), delete e._elMap[p.renderId]
            })
        };
    for (const p of s) {
        if (await e.hooks.callHook("dom:beforeRenderTag", p), !p.shouldRender) continue;
        const {
            tag: m
        } = p;
        if (m.tag === "title") {
            r.title = m.textContent || "", l.push(p);
            continue
        }
        if (m.tag === "htmlAttrs" || m.tag === "bodyAttrs") {
            p.$el = r[m.tag === "htmlAttrs" ? "documentElement" : "body"], Zm(p, !1, o), l.push(p);
            continue
        }
        if (p.$el = e._elMap[p.renderId], !p.$el && m.key && (p.$el = r.querySelector(`${(f=m.tagPosition)!=null&&f.startsWith("body")?"body":"head"} > ${m.tag}[data-h-${m._h}]`)), p.$el) {
            p.tag._d && Zm(p), u(p);
            continue
        }
        c[(h = m.tagPosition) != null && h.startsWith("body") ? "body" : "head"].push(p)
    }
    const d = {
        bodyClose: void 0,
        bodyOpen: void 0,
        head: void 0
    };
    Object.entries(c).forEach(([p, m]) => {
        var y;
        if (!m.length) return;
        const g = (y = r == null ? void 0 : r[p]) == null ? void 0 : y.children;
        if (!!g) {
            for (const _ of [...g].reverse()) {
                const E = _.tagName.toLowerCase();
                if (!G3.includes(E)) continue;
                const b = _.getAttributeNames().reduce((v, $) => G(x({}, v), {
                        [$]: _.getAttribute($)
                    }), {}),
                    w = {
                        tag: E,
                        props: b
                    };
                _.innerHTML && (w.innerHTML = _.innerHTML);
                const T = aS(w);
                let S = m.findIndex(v => (v == null ? void 0 : v.renderId) === T);
                if (S === -1) {
                    const v = Y3(w);
                    S = m.findIndex($ => ($ == null ? void 0 : $.tag._d) && $.tag._d === v)
                }
                if (S !== -1) {
                    const v = m[S];
                    v.$el = _, Zm(v), u(v), delete m[S]
                }
            }
            m.forEach(_ => {
                const E = _.tag.tagPosition || "head";
                d[E] = d[E] || r.createDocumentFragment(), _.$el || (_.$el = r.createElement(_.tag.tag), Zm(_, !0)), d[E].appendChild(_.$el), u(_)
            })
        }
    }), d.head && r.head.appendChild(d.head), d.bodyOpen && r.body.insertBefore(d.bodyOpen, r.body.firstChild), d.bodyClose && r.body.appendChild(d.bodyClose);
    for (const p of l) await e.hooks.callHook("dom:renderTag", p);
    Object.values(i).forEach(p => p())
}
let vw = null;
async function X3(e, t = {}) {
    function n() {
        return vw = null, K3(e, t)
    }
    const r = t.delayFn || (s => setTimeout(s, 10));
    return vw = vw || new Promise(s => r(() => s(n())))
}

function IIe(e) {
    return {
        hooks: {
            "entries:updated": function(t) {
                if (typeof(e == null ? void 0 : e.document) == "undefined" && typeof window == "undefined") return;
                let n = e == null ? void 0 : e.delayFn;
                !n && typeof requestAnimationFrame != "undefined" && (n = requestAnimationFrame), X3(t, {
                    document: (e == null ? void 0 : e.document) || window.document,
                    delayFn: n
                })
            }
        }
    }
}

function xIe(e) {
    var t;
    return ((t = e == null ? void 0 : e.head.querySelector('meta[name="unhead:ssr"]')) == null ? void 0 : t.getAttribute("content")) || !1
}
const HN = {
    critical: 2,
    high: 9,
    low: 12,
    base: -1,
    title: 1,
    meta: 10
};

function jN(e) {
    if (typeof e.tagPriority == "number") return e.tagPriority;
    if (e.tag === "meta") {
        if (e.props.charset) return -2;
        if (e.props["http-equiv"] === "content-security-policy") return 0
    }
    const t = e.tagPriority || e.tag;
    return t in HN ? HN[t] : 10
}
const CIe = [{
    prefix: "before:",
    offset: -1
}, {
    prefix: "after:",
    offset: 1
}];

function AIe() {
    return {
        hooks: {
            "tags:resolve": e => {
                const t = n => {
                    var r;
                    return (r = e.tags.find(s => s._d === n)) == null ? void 0 : r._p
                };
                for (const {
                        prefix: n,
                        offset: r
                    } of CIe)
                    for (const s of e.tags.filter(i => typeof i.tagPriority == "string" && i.tagPriority.startsWith(n))) {
                        const i = t(s.tagPriority.replace(n, ""));
                        typeof i != "undefined" && (s._p = i + r)
                    }
                e.tags.sort((n, r) => n._p - r._p).sort((n, r) => jN(n) - jN(r))
            }
        }
    }
}

function RIe() {
    return {
        hooks: {
            "tags:resolve": e => {
                const {
                    tags: t
                } = e;
                let n = t.findIndex(s => s.tag === "titleTemplate");
                const r = t.findIndex(s => s.tag === "title");
                if (r !== -1 && n !== -1) {
                    const s = VN(t[n].textContent, t[r].textContent);
                    s !== null ? t[r].textContent = s || t[r].textContent : delete t[r]
                } else if (n !== -1) {
                    const s = VN(t[n].textContent);
                    s !== null && (t[n].textContent = s, t[n].tag = "title", n = -1)
                }
                n !== -1 && delete t[n], e.tags = t.filter(Boolean)
            }
        }
    }
}

function OIe() {
    return {
        hooks: {
            "tag:normalise": function({
                tag: e
            }) {
                typeof e.props.body != "undefined" && (e.tagPosition = "bodyClose", delete e.props.body)
            }
        }
    }
}
const DIe = ["link", "style", "script", "noscript"];

function NIe() {
    return {
        hooks: {
            "tag:normalise": ({
                tag: e,
                resolvedOptions: t
            }) => {
                t.experimentalHashHydration === !0 && (e._h = aS(e)), e.key && DIe.includes(e.tag) && (e._h = q3(e.key), e.props[`data-h-${e._h}`] = "")
            }
        }
    }
}
const zN = ["script", "link", "bodyAttrs"];

function PIe() {
    const e = (t, n) => {
        const r = {},
            s = {};
        Object.entries(n.props).forEach(([o, a]) => {
            o.startsWith("on") && typeof a == "function" ? s[o] = a : r[o] = a
        });
        let i;
        return t === "dom" && n.tag === "script" && typeof r.src == "string" && typeof s.onload != "undefined" && (i = r.src, delete r.src), {
            props: r,
            eventHandlers: s,
            delayedSrc: i
        }
    };
    return {
        hooks: {
            "ssr:render": function(t) {
                t.tags = t.tags.map(n => (!zN.includes(n.tag) || !Object.entries(n.props).find(([r, s]) => r.startsWith("on") && typeof s == "function") || (n.props = e("ssr", n).props), n))
            },
            "dom:beforeRenderTag": function(t) {
                if (!zN.includes(t.tag.tag) || !Object.entries(t.tag.props).find(([i, o]) => i.startsWith("on") && typeof o == "function")) return;
                const {
                    props: n,
                    eventHandlers: r,
                    delayedSrc: s
                } = e("dom", t.tag);
                !Object.keys(r).length || (t.tag.props = n, t.tag._eventHandlers = r, t.tag._delayedSrc = s)
            },
            "dom:renderTag": function(t) {
                const n = t.$el;
                if (!t.tag._eventHandlers || !n) return;
                const r = t.tag.tag === "bodyAttrs" && typeof window != "undefined" ? window : n;
                Object.entries(t.tag._eventHandlers).forEach(([s, i]) => {
                    const o = `${t.tag._d||t.tag._p}:${s}`,
                        a = s.slice(2).toLowerCase(),
                        l = `data-h-${a}`;
                    if (t.markSideEffect(o, () => {}), n.hasAttribute(l)) return;
                    const c = i;
                    n.setAttribute(l, ""), r.addEventListener(a, c), t.entry && (t.entry._sde[o] = () => {
                        r.removeEventListener(a, c), n.removeAttribute(l)
                    })
                }), t.tag._delayedSrc && n.setAttribute("src", t.tag._delayedSrc)
            }
        }
    }
}
const MIe = ["templateParams", "htmlAttrs", "bodyAttrs"];

function LIe() {
    return {
        hooks: {
            "tag:normalise": function({
                tag: e
            }) {
                ["hid", "vmid", "key"].forEach(r => {
                    e.props[r] && (e.key = e.props[r], delete e.props[r])
                });
                const n = Y3(e) || (e.key ? `${e.tag}:${e.key}` : !1);
                n && (e._d = n)
            },
            "tags:resolve": function(e) {
                const t = {};
                e.tags.forEach(r => {
                    const s = (r.key ? `${r.tag}:${r.key}` : r._d) || r._p,
                        i = t[s];
                    if (i) {
                        let a = r == null ? void 0 : r.tagDuplicateStrategy;
                        if (!a && MIe.includes(r.tag) && (a = "merge"), a === "merge") {
                            const l = i.props;
                            ["class", "style"].forEach(c => {
                                r.props[c] && l[c] && (c === "style" && !l[c].endsWith(";") && (l[c] += ";"), r.props[c] = `${l[c]} ${r.props[c]}`)
                            }), t[s].props = x(x({}, l), r.props);
                            return
                        } else if (r._e === i._e) {
                            i._duped = i._duped || [], r._d = `${i._d}:${i._duped.length+1}`, i._duped.push(r);
                            return
                        }
                    }
                    const o = Object.keys(r.props).length + (r.innerHTML ? 1 : 0) + (r.textContent ? 1 : 0);
                    if (G3.includes(r.tag) && o === 0) {
                        delete t[s];
                        return
                    }
                    t[s] = r
                });
                const n = [];
                Object.values(t).forEach(r => {
                    const s = r._duped;
                    delete r._duped, n.push(r), s && n.push(...s)
                }), e.tags = n
            }
        }
    }
}

function eg(e, t) {
    function n(i) {
        if (["s", "pageTitle"].includes(i)) return t.pageTitle;
        let o;
        return i.includes(".") ? o = i.split(".").reduce((a, l) => a && a[l] || void 0, t) : o = t[i], typeof o != "undefined" ? o || "" : !1
    }
    let r = e;
    try {
        r = decodeURI(e)
    } catch {}
    return (r.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach(i => {
        const o = n(i.slice(1));
        typeof o == "string" && (e = e.replaceAll(new RegExp(`\\${i}(\\W|$)`, "g"), `${o}$1`).trim())
    }), t.separator && (e.endsWith(t.separator) && (e = e.slice(0, -t.separator.length).trim()), e.startsWith(t.separator) && (e = e.slice(t.separator.length).trim()), e = e.replace(new RegExp(`\\${t.separator}\\s*\\${t.separator}`, "g"), t.separator)), e
}

function FIe() {
    return {
        hooks: {
            "tags:resolve": e => {
                var i;
                const {
                    tags: t
                } = e, n = (i = t.find(o => o.tag === "title")) == null ? void 0 : i.textContent, r = t.findIndex(o => o.tag === "templateParams"), s = r !== -1 ? t[r].props : {};
                s.pageTitle = s.pageTitle || n || "";
                for (const o of t)
                    if (["titleTemplate", "title"].includes(o.tag) && typeof o.textContent == "string") o.textContent = eg(o.textContent, s);
                    else if (o.tag === "meta" && typeof o.props.content == "string") o.props.content = eg(o.props.content, s);
                else if (o.tag === "link" && typeof o.props.href == "string") o.props.href = eg(o.props.href, s);
                else if (o.tag === "script" && ["application/json", "application/ld+json"].includes(o.props.type) && typeof o.innerHTML == "string") try {
                    o.innerHTML = JSON.stringify(JSON.parse(o.innerHTML), (a, l) => typeof l == "string" ? eg(l, s) : l)
                } catch {}
                e.tags = t.filter(o => o.tag !== "templateParams")
            }
        }
    }
}
const UIe = typeof window != "undefined";
let Q3;

function BIe(e) {
    return Q3 = e
}

function VIe() {
    return Q3
}
async function HIe(e, t) {
    const n = {
        tag: e,
        props: {}
    };
    return e === "templateParams" ? (n.props = t, n) : ["title", "titleTemplate"].includes(e) ? (n.textContent = t instanceof Promise ? await t : t, n) : typeof t == "string" ? ["script", "noscript", "style"].includes(e) ? (e === "script" && (/^(https?:)?\/\//.test(t) || t.startsWith("/")) ? n.props.src = t : n.innerHTML = t, n) : !1 : (n.props = await zIe(e, x({}, t)), n.props.children && (n.props.innerHTML = n.props.children), delete n.props.children, Object.keys(n.props).filter(r => $Ie.includes(r)).forEach(r => {
        (!["innerHTML", "textContent"].includes(r) || W3.includes(n.tag)) && (n[r] = n.props[r]), delete n.props[r]
    }), ["innerHTML", "textContent"].forEach(r => {
        if (n.tag === "script" && typeof n[r] == "string" && ["application/ld+json", "application/json"].includes(n.props.type)) try {
            n[r] = JSON.parse(n[r])
        } catch {
            n[r] = ""
        }
        typeof n[r] == "object" && (n[r] = JSON.stringify(n[r]))
    }), n.props.class && (n.props.class = jIe(n.props.class)), n.props.content && Array.isArray(n.props.content) ? n.props.content.map(r => G(x({}, n), {
        props: G(x({}, n.props), {
            content: r
        })
    })) : n)
}

function jIe(e) {
    return typeof e == "object" && !Array.isArray(e) && (e = Object.keys(e).filter(t => e[t])), (Array.isArray(e) ? e.join(" ") : e).split(" ").filter(t => t.trim()).filter(Boolean).join(" ")
}
async function zIe(e, t) {
    for (const n of Object.keys(t)) {
        const r = n.startsWith("data-");
        t[n] instanceof Promise && (t[n] = await t[n]), String(t[n]) === "true" ? t[n] = r ? "true" : "" : String(t[n]) === "false" && (r ? t[n] = "false" : delete t[n])
    }
    return t
}
const WIe = 10;
async function GIe(e) {
    const t = [];
    return Object.entries(e.resolvedInput).filter(([n, r]) => typeof r != "undefined" && SIe.includes(n)).forEach(([n, r]) => {
        const s = EIe(r);
        t.push(...s.map(i => HIe(n, i)).flat())
    }), (await Promise.all(t)).flat().filter(Boolean).map((n, r) => (n._e = e._i, n._p = (e._i << WIe) + r, n))
}

function qIe() {
    return [LIe(), AIe(), FIe(), RIe(), NIe(), PIe(), OIe()]
}

function YIe(e = {}) {
    return [IIe({
        document: e == null ? void 0 : e.document,
        delayFn: e == null ? void 0 : e.domDelayFn
    })]
}

function KIe(e = {}) {
    const t = XIe(G(x({}, e), {
        plugins: [...YIe(e), ...(e == null ? void 0 : e.plugins) || []]
    }));
    return e.experimentalHashHydration && t.resolvedOptions.document && (t._hash = xIe(t.resolvedOptions.document)), BIe(t), t
}

function XIe(e = {}) {
    let t = [],
        n = {},
        r = 0;
    const s = wIe();
    e != null && e.hooks && s.addHooks(e.hooks), e.plugins = [...qIe(), ...(e == null ? void 0 : e.plugins) || []], e.plugins.forEach(a => a.hooks && s.addHooks(a.hooks)), e.document = e.document || (UIe ? document : void 0);
    const i = () => s.callHook("entries:updated", o),
        o = {
            resolvedOptions: e,
            headEntries() {
                return t
            },
            get hooks() {
                return s
            },
            use(a) {
                a.hooks && s.addHooks(a.hooks)
            },
            push(a, l) {
                const c = {
                    _i: r++,
                    input: a,
                    _sde: {}
                };
                return l != null && l.mode && (c._m = l == null ? void 0 : l.mode), l != null && l.transform && (c._t = l == null ? void 0 : l.transform), t.push(c), i(), {
                    dispose() {
                        t = t.filter(u => u._i !== c._i ? !0 : (n = x(x({}, n), u._sde || {}), u._sde = {}, i(), !1))
                    },
                    patch(u) {
                        t = t.map(d => (d._i === c._i && (c.input = d.input = u, i()), d))
                    }
                }
            },
            async resolveTags() {
                const a = {
                    tags: [],
                    entries: [...t]
                };
                await s.callHook("entries:resolve", a);
                for (const l of a.entries) {
                    const c = l._t || (u => u);
                    if (l.resolvedInput = c(l.resolvedInput || l.input), l.resolvedInput)
                        for (const u of await GIe(l)) {
                            const d = {
                                tag: u,
                                entry: l,
                                resolvedOptions: o.resolvedOptions
                            };
                            await s.callHook("tag:normalise", d), a.tags.push(d.tag)
                        }
                }
                return await s.callHook("tags:resolve", a), a.tags
            },
            _popSideEffectQueue() {
                const a = x({}, n);
                return n = {}, a
            },
            _elMap: {}
        };
    return o.hooks.callHook("init", o), o
}
const QIe = ["useHead", "useSeoMeta", "useHeadSafe", "useServerHead", "useServerSeoMeta", "useServerHeadSafe", "useTagTitle", "useTagBase", "useTagMeta", "useTagMetaFlat", "useTagLink", "useTagScript", "useTagStyle", "useTagNoscript", "useHtmlAttrs", "useBodyAttrs", "useTitleTemplate", "useServerTagTitle", "useServerTagBase", "useServerTagMeta", "useServerTagMetaFlat", "useServerTagLink", "useServerTagScript", "useServerTagStyle", "useServerTagNoscript", "useServerHtmlAttrs", "useServerBodyAttrs", "useServerTitleTemplate"];

function JIe(e) {
    return typeof e == "function" ? e() : fe(e)
}

function My(e, t = "") {
    if (e instanceof Promise) return e;
    const n = JIe(e);
    return !e || !n ? n : Array.isArray(n) ? n.map(r => My(r, t)) : typeof n == "object" ? Object.fromEntries(Object.entries(n).map(([r, s]) => r === "titleTemplate" || r.startsWith("on") ? [r, fe(s)] : [r, My(s, r)])) : n
}
const ZIe = fb.startsWith("3"),
    exe = typeof window != "undefined",
    J3 = "usehead";

function gI() {
    return Qn() && bt(J3) || VIe()
}

function txe(e) {
    return {
        install(n) {
            ZIe && (n.config.globalProperties.$unhead = e, n.config.globalProperties.$head = e, n.provide(J3, e))
        }
    }.install
}

function nxe(e = {}) {
    const t = KIe(G(x({}, e), {
        domDelayFn: n => setTimeout(() => ln(() => n()), 10),
        plugins: [rxe(), ...(e == null ? void 0 : e.plugins) || []]
    }));
    return t.install = txe(t), t
}

function rxe() {
    return {
        hooks: {
            "entries:resolve": function(e) {
                for (const t of e.entries) t.resolvedInput = My(t.input)
            }
        }
    }
}

function sxe(e, t = {}) {
    const n = gI(),
        r = ae(!1),
        s = ae({});
    sr(() => {
        s.value = r.value ? {} : My(e)
    });
    const i = n.push(s.value, t);
    return $t(s, a => {
        i.patch(a)
    }), Qn() && (pa(() => {
        i.dispose()
    }), ab(() => {
        r.value = !0
    }), ob(() => {
        r.value = !1
    })), i
}

function ixe(e, t = {}) {
    return gI().push(e, t)
}

function _I(e, t = {}) {
    var r;
    const n = gI();
    if (n) {
        const s = exe || !!((r = n.resolvedOptions) != null && r.document);
        return t.mode === "server" && s || t.mode === "client" && !s ? void 0 : s ? sxe(e, t) : ixe(e, t)
    }
}
const oxe = ["injectHead"];
[...oxe, ...QIe];

function axe(e, t) {
    const n = nxe(t || {}),
        r = {
            unhead: n,
            install(s) {
                fb.startsWith("3") && (s.config.globalProperties.$head = n, s.provide("usehead", n))
            },
            use(s) {
                n.use(s)
            },
            resolveTags() {
                return n.resolveTags()
            },
            headEntries() {
                return n.headEntries()
            },
            headTags() {
                return n.resolveTags()
            },
            push(s, i) {
                return n.push(s, i)
            },
            addEntry(s, i) {
                return n.push(s, i)
            },
            addHeadObjs(s, i) {
                return n.push(s, i)
            },
            addReactiveEntry(s, i) {
                const o = _I(s, i);
                return typeof o != "undefined" ? o.dispose : () => {}
            },
            removeHeadObjs() {},
            updateDOM(s, i) {
                i ? K3(n, {
                    document: s
                }) : X3(n, {
                    delayFn: o => setTimeout(() => o(), 50),
                    document: s
                })
            },
            internalHooks: n.hooks,
            hooks: {
                "before:dom": [],
                "resolved:tags": [],
                "resolved:entries": []
            }
        };
    return n.addHeadObjs = r.addHeadObjs, n.updateDOM = r.updateDOM, n.hooks.hook("dom:beforeRender", s => {
        for (const i of r.hooks["before:dom"]) i() === !1 && (s.shouldRender = !1)
    }), e && r.addHeadObjs(e), r
}

function lxe(e) {
    try {
        return JSON.parse(e || "{}")
    } catch (t) {
        return console.error("[SSG] On state deserialization -", t, e), {}
    }
}

function cxe(e) {
    return document.readyState === "loading" ? new Promise(t => {
        document.addEventListener("DOMContentLoaded", () => t(e))
    }) : Promise.resolve(e)
}
const uxe = Ir({
    setup(e, {
        slots: t
    }) {
        const n = ae(!1);
        return jr(() => n.value = !0), () => n.value ? t.default && t.default({}) : t.placeholder && t.placeholder({})
    }
});

function dxe(e, t, n, r = {}) {
    const {
        transformState: s,
        registerComponents: i = !0,
        useHead: o = !0,
        rootContainer: a = "#app"
    } = r, l = typeof window != "undefined";
    async function c(u = !1, d) {
        var S;
        const f = u ? MV(e) : LV(e);
        let h;
        o && (h = axe(), f.use(h));
        const p = F0e(x({
                history: u ? Zbe(t.base) : e0e(t.base)
            }, t)),
            {
                routes: m
            } = t;
        i && f.component("ClientOnly", uxe);
        const g = [],
            E = {
                app: f,
                head: h,
                isClient: l,
                router: p,
                routes: m,
                onSSRAppRendered: u ? () => {} : v => g.push(v),
                triggerOnSSRAppRendered: () => Promise.all(g.map(v => v())),
                initialState: {},
                transformState: s,
                routePath: d
            };
        u && (await cxe(), E.initialState = (s == null ? void 0 : s(window.__INITIAL_STATE__ || {})) || lxe(window.__INITIAL_STATE__)), await (n == null ? void 0 : n(E)), f.use(p);
        let b, w = !0;
        if (p.beforeEach((v, $, k) => {
                (w || b && b === v.path) && (w = !1, b = v.path, v.meta.state = E.initialState), k()
            }), !u) {
            const v = (S = E.routePath) != null ? S : "/";
            p.push(v), await p.isReady(), E.initialState = p.currentRoute.value.meta.state || {}
        }
        const T = E.initialState;
        return G(x({}, E), {
            initialState: T
        })
    }
    return l && (async () => {
        const {
            app: u,
            router: d
        } = await c(!0);
        await d.isReady(), u.mount(a, !0)
    })(), c
}
const fxe = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    hxe = K("path", {
        fill: "currentColor",
        d: "m14.43 10l-1.47-4.84c-.29-.95-1.63-.95-1.91 0L9.57 10H5.12c-.97 0-1.37 1.25-.58 1.81l3.64 2.6l-1.43 4.61c-.29.93.79 1.68 1.56 1.09l3.69-2.8l3.69 2.81c.77.59 1.85-.16 1.56-1.09l-1.43-4.61l3.64-2.6c.79-.57.39-1.81-.58-1.81h-4.45z"
    }, null, -1),
    pxe = [hxe];

function mxe(e, t) {
    return z(), Se("svg", fxe, pxe)
}
var gxe = {
    name: "ic-round-star-rate",
    render: mxe
};
const _xe = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    yxe = K("path", {
        fill: "currentColor",
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10s10-4.48 10-10S17.52 2 12 2zm0 4c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm0 14c-2.03 0-4.43-.82-6.14-2.88a9.947 9.947 0 0 1 12.28 0C16.43 19.18 14.03 20 12 20z"
    }, null, -1),
    vxe = [yxe];

function bxe(e, t) {
    return z(), Se("svg", _xe, vxe)
}
var wxe = {
    name: "ic-round-account-circle",
    render: bxe
};

function Nb(e, t, ...n) {
    if (e in t) {
        let s = t[e];
        return typeof s == "function" ? s(...n) : s
    }
    let r = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map(s=>`"${s}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Nb), r
}
var lS = (e => (e[e.None = 0] = "None", e[e.RenderStrategy = 1] = "RenderStrategy", e[e.Static = 2] = "Static", e))(lS || {}),
    Exe = (e => (e[e.Unmount = 0] = "Unmount", e[e.Hidden = 1] = "Hidden", e))(Exe || {});

function Pb(r) {
    var s = r,
        {
            visible: e = !0,
            features: t = 0
        } = s,
        n = Gr(s, ["visible", "features"]);
    var i;
    if (e || t & 2 && n.props.static) return bw(n);
    if (t & 1) {
        let o = (i = n.props.unmount) == null || i ? 0 : 1;
        return Nb(o, {
            [0]() {
                return null
            },
            [1]() {
                return bw(G(x({}, n), {
                    props: G(x({}, n.props), {
                        hidden: !0,
                        style: {
                            display: "none"
                        }
                    })
                }))
            }
        })
    }
    return bw(n)
}

function bw({
    props: e,
    attrs: t,
    slots: n,
    slot: r,
    name: s
}) {
    var i;
    let u = Sxe(e, ["unmount", "static"]),
        {
            as: o
        } = u,
        a = Gr(u, ["as"]),
        l = (i = n.default) == null ? void 0 : i.call(n, r),
        c = {};
    if (o === "template") {
        if (Object.keys(a).length > 0 || Object.keys(t).length > 0) {
            let [d, ...f] = l != null ? l : [];
            if (!Txe(d) || f.length > 0) throw new Error(['Passing props on "template"!', "", `The current component <${s} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(a).concat(Object.keys(t)).map(h => `  - ${h}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map(h => `  - ${h}`).join(`
`)].join(`
`));
            return _s(d, Object.assign({}, a, c))
        }
        return Array.isArray(l) && l.length === 1 ? l[0] : l
    }
    return Vs(o, Object.assign({}, a, c), l)
}

function nOe(e) {
    let t = Object.assign({}, e);
    for (let n in t) t[n] === void 0 && delete t[n];
    return t
}

function Sxe(e, t = []) {
    let n = Object.assign({}, e);
    for (let r of t) r in n && delete n[r];
    return n
}

function Txe(e) {
    return e == null ? !1 : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function"
}
let $xe = 0;

function kxe() {
    return ++$xe
}

function yI() {
    return kxe()
}
var Cn = (e => (e.Space = " ", e.Enter = "Enter", e.Escape = "Escape", e.Backspace = "Backspace", e.Delete = "Delete", e.ArrowLeft = "ArrowLeft", e.ArrowUp = "ArrowUp", e.ArrowRight = "ArrowRight", e.ArrowDown = "ArrowDown", e.Home = "Home", e.End = "End", e.PageUp = "PageUp", e.PageDown = "PageDown", e.Tab = "Tab", e))(Cn || {});

function Ixe(e) {
    throw new Error("Unexpected object: " + e)
}
var Mr = (e => (e[e.First = 0] = "First", e[e.Previous = 1] = "Previous", e[e.Next = 2] = "Next", e[e.Last = 3] = "Last", e[e.Specific = 4] = "Specific", e[e.Nothing = 5] = "Nothing", e))(Mr || {});

function xxe(e, t) {
    let n = t.resolveItems();
    if (n.length <= 0) return null;
    let r = t.resolveActiveIndex(),
        s = r != null ? r : -1,
        i = (() => {
            switch (e.focus) {
                case 0:
                    return n.findIndex(o => !t.resolveDisabled(o));
                case 1:
                    {
                        let o = n.slice().reverse().findIndex((a, l, c) => s !== -1 && c.length - l - 1 >= s ? !1 : !t.resolveDisabled(a));
                        return o === -1 ? o : n.length - 1 - o
                    }
                case 2:
                    return n.findIndex((o, a) => a <= s ? !1 : !t.resolveDisabled(o));
                case 3:
                    {
                        let o = n.slice().reverse().findIndex(a => !t.resolveDisabled(a));
                        return o === -1 ? o : n.length - 1 - o
                    }
                case 4:
                    return n.findIndex(o => t.resolveId(o) === e.id);
                case 5:
                    return null;
                default:
                    Ixe(e)
            }
        })();
    return i === -1 ? r : i
}

function Zt(e) {
    return e == null || e.value == null ? null : "$el" in e.value ? e.value.$el : e.value
}
let Z3 = Symbol("Context");
var Ly = (e => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(Ly || {});

function rOe() {
    return ez() !== null
}

function ez() {
    return bt(Z3, null)
}

function Cxe(e) {
    fi(Z3, e)
}

function WN(e, t) {
    if (e) return e;
    let n = t != null ? t : "button";
    if (typeof n == "string" && n.toLowerCase() === "button") return "button"
}

function Axe(e, t) {
    let n = ae(WN(e.value.type, e.value.as));
    return jr(() => {
        n.value = WN(e.value.type, e.value.as)
    }), sr(() => {
        var r;
        n.value || !Zt(t) || Zt(t) instanceof HTMLButtonElement && !((r = Zt(t)) != null && r.hasAttribute("type")) && (n.value = "button")
    }), n
}

function tz(e) {
    if (typeof window == "undefined") return null;
    if (e instanceof Node) return e.ownerDocument;
    if (e != null && e.hasOwnProperty("value")) {
        let t = Zt(e);
        if (t) return t.ownerDocument
    }
    return document
}

function Rxe({
    container: e,
    accept: t,
    walk: n,
    enabled: r
}) {
    sr(() => {
        let s = e.value;
        if (!s || r !== void 0 && !r.value) return;
        let i = tz(e);
        if (!i) return;
        let o = Object.assign(l => t(l), {
                acceptNode: t
            }),
            a = i.createTreeWalker(s, NodeFilter.SHOW_ELEMENT, o, !1);
        for (; a.nextNode();) n(a.currentNode)
    })
}
let GN = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(e => `${e}:not([tabindex='-1'])`).join(",");
var Oxe = (e => (e[e.First = 1] = "First", e[e.Previous = 2] = "Previous", e[e.Next = 4] = "Next", e[e.Last = 8] = "Last", e[e.WrapAround = 16] = "WrapAround", e[e.NoScroll = 32] = "NoScroll", e))(Oxe || {}),
    Dxe = (e => (e[e.Error = 0] = "Error", e[e.Overflow = 1] = "Overflow", e[e.Success = 2] = "Success", e[e.Underflow = 3] = "Underflow", e))(Dxe || {}),
    Nxe = (e => (e[e.Previous = -1] = "Previous", e[e.Next = 1] = "Next", e))(Nxe || {}),
    nz = (e => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(nz || {});

function Pxe(e, t = 0) {
    var n;
    return e === ((n = tz(e)) == null ? void 0 : n.body) ? !1 : Nb(t, {
        [0]() {
            return e.matches(GN)
        },
        [1]() {
            let r = e;
            for (; r !== null;) {
                if (r.matches(GN)) return !0;
                r = r.parentElement
            }
            return !1
        }
    })
}

function Mxe(e, t = n => n) {
    return e.slice().sort((n, r) => {
        let s = t(n),
            i = t(r);
        if (s === null || i === null) return 0;
        let o = s.compareDocumentPosition(i);
        return o & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : o & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
    })
}

function qN(e, t, n) {
    typeof window != "undefined" && sr(r => {
        window.addEventListener(e, t, n), r(() => window.removeEventListener(e, t, n))
    })
}

function Lxe(e) {
    typeof queueMicrotask == "function" ? queueMicrotask(e) : Promise.resolve().then(e).catch(t => setTimeout(() => {
        throw t
    }))
}
var Fxe = (e => (e[e.None = 1] = "None", e[e.IgnoreScrollbars = 2] = "IgnoreScrollbars", e))(Fxe || {});

function Uxe(e, t, n = 1) {
    let r = !1;

    function s(i) {
        if (r) return;
        r = !0, Lxe(() => {
            r = !1
        });
        let o = i.target;
        if (!o.ownerDocument.documentElement.contains(o)) return;
        let a = function l(c) {
            return typeof c == "function" ? l(c()) : Array.isArray(c) || c instanceof Set ? c : [c]
        }(e);
        if ((n & 2) === 2) {
            let l = 20,
                c = o.ownerDocument.documentElement;
            if (i.clientX > c.clientWidth - l || i.clientX < l || i.clientY > c.clientHeight - l || i.clientY < l) return
        }
        for (let l of a) {
            if (l === null) continue;
            let c = l instanceof HTMLElement ? l : Zt(l);
            if (c != null && c.contains(o)) return
        }
        t(i, o)
    }
    qN("pointerdown", s), qN("mousedown", s)
}
var Bxe = (e => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(Bxe || {}),
    Vxe = (e => (e[e.Pointer = 0] = "Pointer", e[e.Other = 1] = "Other", e))(Vxe || {});

function Hxe(e) {
    requestAnimationFrame(() => requestAnimationFrame(e))
}
let rz = Symbol("MenuContext");

function Mb(e) {
    let t = bt(rz, null);
    if (t === null) {
        let n = new Error(`<${e} /> is missing a parent <Menu /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(n, Mb), n
    }
    return t
}
let vI = Ir({
        name: "Menu",
        props: {
            as: {
                type: [Object, String],
                default: "template"
            }
        },
        setup(e, {
            slots: t,
            attrs: n
        }) {
            let r = ae(1),
                s = ae(null),
                i = ae(null),
                o = ae([]),
                a = ae(""),
                l = ae(null),
                c = ae(1);

            function u(f = h => h) {
                let h = l.value !== null ? o.value[l.value] : null,
                    p = Mxe(f(o.value.slice()), g => Zt(g.dataRef.domRef)),
                    m = h ? p.indexOf(h) : null;
                return m === -1 && (m = null), {
                    items: p,
                    activeItemIndex: m
                }
            }
            let d = {
                menuState: r,
                buttonRef: s,
                itemsRef: i,
                items: o,
                searchQuery: a,
                activeItemIndex: l,
                activationTrigger: c,
                closeMenu: () => {
                    r.value = 1, l.value = null
                },
                openMenu: () => r.value = 0,
                goToItem(f, h, p) {
                    let m = u(),
                        g = xxe(f === Mr.Specific ? {
                            focus: Mr.Specific,
                            id: h
                        } : {
                            focus: f
                        }, {
                            resolveItems: () => m.items,
                            resolveActiveIndex: () => m.activeItemIndex,
                            resolveId: y => y.id,
                            resolveDisabled: y => y.dataRef.disabled
                        });
                    a.value = "", l.value = g, c.value = p != null ? p : 1, o.value = m.items
                },
                search(f) {
                    let h = a.value !== "" ? 0 : 1;
                    a.value += f.toLowerCase();
                    let p = (l.value !== null ? o.value.slice(l.value + h).concat(o.value.slice(0, l.value + h)) : o.value).find(g => g.dataRef.textValue.startsWith(a.value) && !g.dataRef.disabled),
                        m = p ? o.value.indexOf(p) : -1;
                    m === -1 || m === l.value || (l.value = m, c.value = 1)
                },
                clearSearch() {
                    a.value = ""
                },
                registerItem(f, h) {
                    let p = u(m => [...m, {
                        id: f,
                        dataRef: h
                    }]);
                    o.value = p.items, l.value = p.activeItemIndex, c.value = 1
                },
                unregisterItem(f) {
                    let h = u(p => {
                        let m = p.findIndex(g => g.id === f);
                        return m !== -1 && p.splice(m, 1), p
                    });
                    o.value = h.items, l.value = h.activeItemIndex, c.value = 1
                }
            };
            return Uxe([s, i], (f, h) => {
                var p;
                r.value === 0 && (d.closeMenu(), Pxe(h, nz.Loose) || (f.preventDefault(), (p = Zt(s)) == null || p.focus()))
            }), fi(rz, d), Cxe(Fe(() => Nb(r.value, {
                [0]: Ly.Open,
                [1]: Ly.Closed
            }))), () => {
                let f = {
                    open: r.value === 0
                };
                return Pb({
                    props: e,
                    slot: f,
                    slots: t,
                    attrs: n,
                    name: "Menu"
                })
            }
        }
    }),
    bI = Ir({
        name: "MenuButton",
        props: {
            disabled: {
                type: Boolean,
                default: !1
            },
            as: {
                type: [Object, String],
                default: "button"
            }
        },
        setup(e, {
            attrs: t,
            slots: n,
            expose: r
        }) {
            let s = Mb("MenuButton"),
                i = `headlessui-menu-button-${yI()}`;
            r({
                el: s.buttonRef,
                $el: s.buttonRef
            });

            function o(u) {
                switch (u.key) {
                    case Cn.Space:
                    case Cn.Enter:
                    case Cn.ArrowDown:
                        u.preventDefault(), u.stopPropagation(), s.openMenu(), ln(() => {
                            var d;
                            (d = Zt(s.itemsRef)) == null || d.focus({
                                preventScroll: !0
                            }), s.goToItem(Mr.First)
                        });
                        break;
                    case Cn.ArrowUp:
                        u.preventDefault(), u.stopPropagation(), s.openMenu(), ln(() => {
                            var d;
                            (d = Zt(s.itemsRef)) == null || d.focus({
                                preventScroll: !0
                            }), s.goToItem(Mr.Last)
                        });
                        break
                }
            }

            function a(u) {
                switch (u.key) {
                    case Cn.Space:
                        u.preventDefault();
                        break
                }
            }

            function l(u) {
                e.disabled || (s.menuState.value === 0 ? (s.closeMenu(), ln(() => {
                    var d;
                    return (d = Zt(s.buttonRef)) == null ? void 0 : d.focus({
                        preventScroll: !0
                    })
                })) : (u.preventDefault(), u.stopPropagation(), s.openMenu(), Hxe(() => {
                    var d;
                    return (d = Zt(s.itemsRef)) == null ? void 0 : d.focus({
                        preventScroll: !0
                    })
                })))
            }
            let c = Axe(Fe(() => ({
                as: e.as,
                type: t.type
            })), s.buttonRef);
            return () => {
                var u;
                let d = {
                        open: s.menuState.value === 0
                    },
                    f = {
                        ref: s.buttonRef,
                        id: i,
                        type: c.value,
                        "aria-haspopup": !0,
                        "aria-controls": (u = Zt(s.itemsRef)) == null ? void 0 : u.id,
                        "aria-expanded": e.disabled ? void 0 : s.menuState.value === 0,
                        onKeydown: o,
                        onKeyup: a,
                        onClick: l
                    };
                return Pb({
                    props: x(x({}, e), f),
                    slot: d,
                    attrs: t,
                    slots: n,
                    name: "MenuButton"
                })
            }
        }
    }),
    wI = Ir({
        name: "MenuItems",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            static: {
                type: Boolean,
                default: !1
            },
            unmount: {
                type: Boolean,
                default: !0
            }
        },
        setup(e, {
            attrs: t,
            slots: n,
            expose: r
        }) {
            let s = Mb("MenuItems"),
                i = `headlessui-menu-items-${yI()}`,
                o = ae(null);
            r({
                el: s.itemsRef,
                $el: s.itemsRef
            }), Rxe({
                container: Fe(() => Zt(s.itemsRef)),
                enabled: Fe(() => s.menuState.value === 0),
                accept(d) {
                    return d.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : d.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT
                },
                walk(d) {
                    d.setAttribute("role", "none")
                }
            });

            function a(d) {
                var f;
                switch (o.value && clearTimeout(o.value), d.key) {
                    case Cn.Space:
                        if (s.searchQuery.value !== "") return d.preventDefault(), d.stopPropagation(), s.search(d.key);
                    case Cn.Enter:
                        if (d.preventDefault(), d.stopPropagation(), s.activeItemIndex.value !== null) {
                            let h = s.items.value[s.activeItemIndex.value];
                            (f = Zt(h.dataRef.domRef)) == null || f.click()
                        }
                        s.closeMenu(), ln(() => {
                            var h;
                            return (h = Zt(s.buttonRef)) == null ? void 0 : h.focus({
                                preventScroll: !0
                            })
                        });
                        break;
                    case Cn.ArrowDown:
                        return d.preventDefault(), d.stopPropagation(), s.goToItem(Mr.Next);
                    case Cn.ArrowUp:
                        return d.preventDefault(), d.stopPropagation(), s.goToItem(Mr.Previous);
                    case Cn.Home:
                    case Cn.PageUp:
                        return d.preventDefault(), d.stopPropagation(), s.goToItem(Mr.First);
                    case Cn.End:
                    case Cn.PageDown:
                        return d.preventDefault(), d.stopPropagation(), s.goToItem(Mr.Last);
                    case Cn.Escape:
                        d.preventDefault(), d.stopPropagation(), s.closeMenu(), ln(() => {
                            var h;
                            return (h = Zt(s.buttonRef)) == null ? void 0 : h.focus({
                                preventScroll: !0
                            })
                        });
                        break;
                    case Cn.Tab:
                        d.preventDefault(), d.stopPropagation();
                        break;
                    default:
                        d.key.length === 1 && (s.search(d.key), o.value = setTimeout(() => s.clearSearch(), 350));
                        break
                }
            }

            function l(d) {
                switch (d.key) {
                    case Cn.Space:
                        d.preventDefault();
                        break
                }
            }
            let c = ez(),
                u = Fe(() => c !== null ? c.value === Ly.Open : s.menuState.value === 0);
            return () => {
                var d, f;
                let h = {
                        open: s.menuState.value === 0
                    },
                    p = {
                        "aria-activedescendant": s.activeItemIndex.value === null || (d = s.items.value[s.activeItemIndex.value]) == null ? void 0 : d.id,
                        "aria-labelledby": (f = Zt(s.buttonRef)) == null ? void 0 : f.id,
                        id: i,
                        onKeydown: a,
                        onKeyup: l,
                        role: "menu",
                        tabIndex: 0,
                        ref: s.itemsRef
                    };
                return Pb({
                    props: x(x({}, e), p),
                    slot: h,
                    attrs: t,
                    slots: n,
                    features: lS.RenderStrategy | lS.Static,
                    visible: u.value,
                    name: "MenuItems"
                })
            }
        }
    }),
    Ja = Ir({
        name: "MenuItem",
        props: {
            as: {
                type: [Object, String],
                default: "template"
            },
            disabled: {
                type: Boolean,
                default: !1
            }
        },
        setup(e, {
            slots: t,
            attrs: n,
            expose: r
        }) {
            let s = Mb("MenuItem"),
                i = `headlessui-menu-item-${yI()}`,
                o = ae(null);
            r({
                el: o,
                $el: o
            });
            let a = Fe(() => s.activeItemIndex.value !== null ? s.items.value[s.activeItemIndex.value].id === i : !1),
                l = Fe(() => ({
                    disabled: e.disabled,
                    textValue: "",
                    domRef: o
                }));
            jr(() => {
                var h, p;
                let m = (p = (h = Zt(o)) == null ? void 0 : h.textContent) == null ? void 0 : p.toLowerCase().trim();
                m !== void 0 && (l.value.textValue = m)
            }), jr(() => s.registerItem(i, l)), Fl(() => s.unregisterItem(i)), sr(() => {
                s.menuState.value === 0 && (!a.value || s.activationTrigger.value !== 0 && ln(() => {
                    var h, p;
                    return (p = (h = Zt(o)) == null ? void 0 : h.scrollIntoView) == null ? void 0 : p.call(h, {
                        block: "nearest"
                    })
                }))
            });

            function c(h) {
                if (e.disabled) return h.preventDefault();
                s.closeMenu(), ln(() => {
                    var p;
                    return (p = Zt(s.buttonRef)) == null ? void 0 : p.focus({
                        preventScroll: !0
                    })
                })
            }

            function u() {
                if (e.disabled) return s.goToItem(Mr.Nothing);
                s.goToItem(Mr.Specific, i)
            }

            function d() {
                e.disabled || a.value || s.goToItem(Mr.Specific, i, 0)
            }

            function f() {
                e.disabled || !a.value || s.goToItem(Mr.Nothing)
            }
            return () => {
                let {
                    disabled: h
                } = e, p = {
                    active: a.value,
                    disabled: h
                };
                return Pb({
                    props: G(x({}, e), {
                        id: i,
                        ref: o,
                        role: "menuitem",
                        tabIndex: h === !0 ? void 0 : -1,
                        "aria-disabled": h === !0 ? !0 : void 0,
                        onClick: c,
                        onFocus: u,
                        onPointermove: d,
                        onMousemove: d,
                        onPointerleave: f,
                        onMouseleave: f
                    }),
                    slot: p,
                    attrs: n,
                    slots: t,
                    name: "MenuItem"
                })
            }
        }
    });
const jxe = () => {
        var e;
        return (window == null ? void 0 : window.Rewardful) && ((e = window.Rewardful) == null ? void 0 : e.referral) || "checkout_" + new Date().getTime()
    },
    sOe = async ({
        hostUrl: e = `${window.location.protocol}//${window.location.host}`,
        planId: t,
        priceId: n,
        snapShotCallback: r,
        mode: s = "subscription",
        discounts: i = []
    }) => {
        try {
            const o = {
                    price: n,
                    mode: s,
                    allow_promotion_codes: !0,
                    success_url: `${e}/checkout/success?uid=${Vt.currentUser.uid}&planId=${t}&pid=${n}`,
                    cancel_url: `${window.location.href}`,
                    discounts: i
                },
                a = jxe();
            a && (o.client_reference_id = a);
            const l = await eF(il(Br, "users", Vt.currentUser.uid, "checkout_sessions"), o);
            return tF(l, r)
        } catch (o) {
            console.error(o)
        }
    },
    zxe = async () => {
        const e = il(Br, "users", Vt.currentUser.uid, "subscriptions"),
            t = oh(e, ef("status", "in", ["trialing", "active"])),
            n = await ah(t),
            r = [];
        return n.forEach(s => {
            r.push(x({}, s.data()))
        }), r
    },
    Zn = {
        customDomain: "customDomain",
        exportLeads: "exportLeads",
        customAnalytics: "customAnalytics",
        removeBranding: "removeBranding",
        addVideos: "addVideos"
    },
    Wxe = {
        basicPlan: {
            sites: 1,
            features: [Zn.customDomain, Zn.exportLeads, Zn.customAnalytics, Zn.removeBranding, Zn.addVideos]
        },
        starterPlan: {
            sites: 3,
            features: [Zn.customDomain, Zn.exportLeads, Zn.customAnalytics, Zn.removeBranding, Zn.addVideos]
        },
        proPlan: {
            sites: 15,
            features: [Zn.customDomain, Zn.exportLeads, Zn.customAnalytics, Zn.removeBranding, Zn.addVideos]
        }
    },
    Gxe = async () => {
        var t, n;
        if (mt(Vt, "currentUser", null) === null) throw new Error("No auth user available to get custom claims");
        await ((t = Vt == null ? void 0 : Vt.currentUser) == null ? void 0 : t.getIdToken(!0));
        const e = await ((n = Vt == null ? void 0 : Vt.currentUser) == null ? void 0 : n.getIdTokenResult());
        return mt(e, "claims.stripeRole", "")
    },
    qxe = e => {
        const t = [];
        return Oy(Wxe, (n, r) => {
            Dy(n.features, e) && t.push(r)
        }), t
    },
    iOe = async e => {
        var s;
        let t = !1;
        if (fI(e) || ((s = Vt == null ? void 0 : Vt.currentUser) == null ? void 0 : s.uid) === void 0) return !1;
        const n = qxe(e),
            r = await zxe();
        return Oy(r, i => {
            const o = i.role;
            Oy(n, a => {
                Dy(o, a) && (t = !0)
            })
        }), t
    },
    Yxe = async () => {
        try {
            const e = await Gxe();
            return !fI(e)
        } catch {
            return !1
        }
    },
    Kxe = async e => {
        const t = ca(Fi, "ext-firestore-stripe-payments-createPortalLink"),
            {
                data: n
            } = await t({
                returnUrl: e,
                locale: "auto"
            });
        return n.url
    },
    oOe = async () => await P$e(),
    Xxe = {
        class: "flex items-center h-full"
    },
    Qxe = hn(" Login "),
    Jxe = {
        key: 0,
        class: "py-1"
    },
    Zxe = {
        class: "px-4 py-3"
    },
    eCe = K("p", {
        class: "text-slate-400 text-sm"
    }, "Signed in as", -1),
    tCe = {
        class: "font-medium text-gray-900 truncate"
    },
    nCe = {
        key: 0,
        class: "inline-flex items-center px-1 py-1 rounded-full text-xs font-medium bg-brand-primary text-white"
    },
    rCe = {
        class: "py-1"
    },
    sCe = {
        name: "AccountDropdown",
        setup(e) {
            const t = Tu(G(x({}, Gh), {
                    loader: () => at(() =>
                        import ("./PlanSelector.4a86a2ca.js"), ["assets/PlanSelector.4a86a2ca.js", "assets/check.a548b91d.js", "assets/planet-ring2-line.eb2bb610.js", "assets/UiHeading.6d814843.js", "assets/index.907e950c.js"])
                })),
                n = Tu(G(x({}, Gh), {
                    loader: () => at(() => Promise.resolve().then(function() {
                        return Y$e
                    }), void 0)
                })),
                r = bt("firebaseAuth"),
                s = bt("openAuthModal"),
                i = bt("$vfm"),
                o = Tj(),
                a = Xk(),
                l = Pr({
                    paid: !1
                }),
                c = async () => {
                    Vh({
                        name: "plan-selector"
                    }, {
                        default: {
                            component: t,
                            bind: {
                                openAuthModal: s
                            }
                        }
                    })
                },
                u = async () => {
                    var h, p;
                    if (Vh({
                            name: "loader",
                            clickToClose: !1,
                            showClose: !1
                        }, {
                            default: {
                                component: n
                            }
                        }), typeof window != "undefined") {
                        const m = await Kxe((h = window == null ? void 0 : window.location) == null ? void 0 : h.origin);
                        m ? (p = window == null ? void 0 : window.location) == null || p.assign(m) : i.hide("loader")
                    }
                },
                d = () => {
                    s()
                },
                f = async () => {
                    await Qre(r), a == null || a.push("/login")
                };
            return r.onAuthStateChanged(async h => {
                h && (l.isPaid = await Yxe())
            }), (h, p) => {
                const m = jl,
                    g = Eb,
                    y = wxe,
                    _ = gxe;
                return z(), ke(fe(vI), {
                    as: "div",
                    class: "ml-3 relative z-10"
                }, {
                    default: Re(() => [K("div", Xxe, [fe(o) === void 0 ? (z(), ke(m, {
                        key: 0
                    })) : Ve("", !0), fe(o) === null ? (z(), ke(g, {
                        key: 1,
                        theme: "brand-link",
                        onClick: d
                    }, {
                        default: Re(() => [Qxe]),
                        _: 1
                    })) : Ve("", !0), fe(o) ? (z(), ke(fe(bI), {
                        key: 2,
                        class: "max-w-xs flex items-center focus:outline-none rounded-full focus:text-slate-500 hover:text-slate-500 text-slate-400"
                    }, {
                        default: Re(() => [ne(y, {
                            class: "h-8 w-8"
                        })]),
                        _: 1
                    })) : Ve("", !0)]), ne(Zo, {
                        "enter-active-class": "transition ease-out duration-100",
                        "enter-from-class": "transform opacity-0 scale-95",
                        "enter-to-class": "transform opacity-100 scale-100",
                        "leave-active-class": "transition ease-in duration-75",
                        "leave-from-class": "transform opacity-100 scale-100",
                        "leave-to-class": "transform opacity-0 scale-95"
                    }, {
                        default: Re(() => [ne(fe(wI), {
                            class: "origin-top-right border border-light-100 absolute right-0 mt-2 w-56 rounded-lg shadow-lg bg-white ring-1 ring-black ring-opacity-5 divide-y divide-gray-100 focus:outline-none"
                        }, {
                            default: Re(() => [fe(o) ? (z(), Se("div", Jxe, [K("div", Zxe, [eCe, K("p", tCe, [hn(xs(fe(o).email) + " ", 1), l.isPaid ? (z(), Se("span", nCe, [ne(_)])) : Ve("", !0)])])])) : Ve("", !0), K("div", rCe, [l.isPaid ? (z(), ke(fe(Ja), {
                                key: 0
                            }, {
                                default: Re(() => [K("a", {
                                    href: "#",
                                    title: "Payment Settings",
                                    class: "block px-4 py-2 hover:bg-gray-100 hover:text-gray-900",
                                    onClick: u
                                }, " Payment Settings ")]),
                                _: 1
                            })) : Ve("", !0), fe(o) && !l.isPaid ? (z(), ke(fe(Ja), {
                                key: 1
                            }, {
                                default: Re(() => [K("a", {
                                    href: "#",
                                    title: "Upgrade",
                                    class: "block px-4 py-2 hover:bg-gray-100 hover:text-gray-900",
                                    onClick: c
                                }, " Upgrade ")]),
                                _: 1
                            })) : Ve("", !0), fe(o) ? (z(), ke(fe(Ja), {
                                key: 2
                            }, {
                                default: Re(() => [K("a", {
                                    href: "#",
                                    title: "Logout",
                                    class: "block px-4 py-2 hover:bg-gray-100 hover:text-gray-900",
                                    onClick: f
                                }, " Logout ")]),
                                _: 1
                            })) : Ve("", !0)])]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })
            }
        }
    },
    iCe = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    oCe = K("g", {
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "1.5"
    }, [K("path", {
        d: "M2 19V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2Z"
    }), K("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M2 7h20M9 14h3m3 0h-3m0 0v-3m0 3v3"
    })], -1),
    aCe = [oCe];

function lCe(e, t) {
    return z(), Se("svg", iCe, aCe)
}
var cCe = {
    name: "iconoir-new-tab",
    render: lCe
};
const uCe = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    dCe = K("g", {
        fill: "none",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2"
    }, [K("path", {
        d: "M0 0h24v24H0z"
    }), K("path", {
        fill: "currentColor",
        d: "M20 6a1 1 0 0 1 .117 1.993L20 8h-.081L19 19a3 3 0 0 1-2.824 2.995L16 22H8c-1.598 0-2.904-1.249-2.992-2.75l-.005-.167L4.08 8H4a1 1 0 0 1-.117-1.993L4 6h16zm-9.489 5.14a1 1 0 0 0-1.218 1.567L10.585 14l-1.292 1.293l-.083.094a1 1 0 0 0 1.497 1.32L12 15.415l1.293 1.292l.094.083a1 1 0 0 0 1.32-1.497L13.415 14l1.292-1.293l.083-.094a1 1 0 0 0-1.497-1.32L12 12.585l-1.293-1.292l-.094-.083zM14 2a2 2 0 0 1 2 2a1 1 0 0 1-1.993.117L14 4h-4l-.007.117A1 1 0 0 1 8 4a2 2 0 0 1 1.85-1.995L10 2h4z"
    })], -1),
    fCe = [dCe];

function hCe(e, t) {
    return z(), Se("svg", uCe, fCe)
}
var pCe = {
    name: "tabler-trash-x-filled",
    render: hCe
};
const mCe = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    gCe = K("g", {
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2"
    }, [K("path", {
        d: "M8 10a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2z"
    }), K("path", {
        d: "M16 8V6a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h2"
    })], -1),
    _Ce = [gCe];

function yCe(e, t) {
    return z(), Se("svg", mCe, _Ce)
}
var vCe = {
    name: "tabler-copy",
    render: yCe
};
const bCe = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    wCe = K("path", {
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m6 15l6-6l6 6"
    }, null, -1),
    ECe = [wCe];

function SCe(e, t) {
    return z(), Se("svg", bCe, ECe)
}
var TCe = {
    name: "tabler-chevron-up",
    render: SCe
};
const $Ce = {
        class: "text-right"
    },
    kCe = K("span", null, "More", -1),
    ICe = {
        class: "p-1"
    },
    xCe = hn(" Duplicate "),
    CCe = {
        class: "px-1 py-1"
    },
    ACe = hn(" Delete "),
    RCe = {
        name: "SiteSelectorMoreMenu",
        props: {
            siteId: {
                type: String,
                required: !0
            }
        },
        emits: ["duplicate-click", "delete-click"],
        setup(e, {
            emit: t
        }) {
            return (n, r) => {
                const s = TCe,
                    i = vCe,
                    o = pCe;
                return z(), Se("div", $Ce, [ne(fe(vI), {
                    as: "div",
                    class: "relative"
                }, {
                    default: Re(({
                        open: a
                    }) => [K("div", null, [ne(fe(bI), {
                        class: "flex w-full items-center text-slate-400 hover:text-brand-secondary"
                    }, {
                        default: Re(() => [ne(s, {
                            class: wn([a ? "" : "rotate-180 transform", ""])
                        }, null, 8, ["class"]), kCe]),
                        _: 2
                    }, 1024)]), ne(Zo, {
                        "enter-active-class": "transition duration-100 ease-out",
                        "enter-from-class": "transform scale-95 opacity-0",
                        "enter-to-class": "transform scale-100 opacity-100",
                        "leave-active-class": "transition duration-75 ease-in",
                        "leave-from-class": "transform scale-100 opacity-100",
                        "leave-to-class": "transform scale-95 opacity-0"
                    }, {
                        default: Re(() => [ne(fe(wI), {
                            class: "absolute md:right-0 mt-2 md:w-56 origin-top-right divide-y divide-gray-100 rounded-md bg-white z-10 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none"
                        }, {
                            default: Re(() => [K("div", ICe, [ne(fe(Ja), null, {
                                default: Re(() => [K("button", {
                                    type: "button",
                                    onClick: r[0] || (r[0] = l => n.$emit("duplicate-click", e.siteId)),
                                    class: "flex items-center text-slate-500 hover:text-brand-primary w-full rounded-md px-2 py-2 text-sm"
                                }, [ne(i, {
                                    class: "mr-2 h-5 w-5",
                                    "aria-hidden": "true"
                                }), xCe])]),
                                _: 1
                            })]), K("div", CCe, [ne(fe(Ja), null, {
                                default: Re(() => [K("button", {
                                    class: "flex items-center text-slate-500 hover:bg-red-600 hover:text-white w-full rounded-md px-2 py-2 text-sm",
                                    onClick: r[1] || (r[1] = l => n.$emit("delete-click", e.siteId))
                                }, [ne(o, {
                                    class: "mr-2 h-5 w-5",
                                    "aria-hidden": "true"
                                }), ACe])]),
                                _: 1
                            })])]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })])
            }
        }
    },
    OCe = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    DCe = K("g", {
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2"
    }, [K("path", {
        d: "M7 7H6a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2v-1"
    }), K("path", {
        d: "M20.385 6.585a2.1 2.1 0 0 0-2.97-2.97L9 12v3h3l8.385-8.415zM16 5l3 3"
    })], -1),
    NCe = [DCe];

function PCe(e, t) {
    return z(), Se("svg", OCe, NCe)
}
var MCe = {
    name: "tabler-edit",
    render: PCe
};
const LCe = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    FCe = K("path", {
        fill: "currentColor",
        d: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6l-6-6l1.41-1.41z"
    }, null, -1),
    UCe = [FCe];

function BCe(e, t) {
    return z(), Se("svg", LCe, UCe)
}
var VCe = {
    name: "ic-baseline-keyboard-arrow-down",
    render: BCe
};
const HCe = {
        preserveAspectRatio: "xMidYMid meet",
        viewBox: "0 0 24 24",
        width: "1.2em",
        height: "1.2em"
    },
    jCe = K("path", {
        fill: "currentColor",
        d: "M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6l-6 6z"
    }, null, -1),
    zCe = [jCe];

function WCe(e, t) {
    return z(), Se("svg", HCe, zCe)
}
var GCe = {
        name: "ic-baseline-keyboard-arrow-up",
        render: WCe
    },
    YN = 36,
    sz = "";
for (; YN--;) sz += YN.toString(36);

function qCe(e) {
    for (var t = "", n = e || 11; n--;) t += sz[Math.random() * 36 | 0];
    return t
}
const YCe = async (e, t) => {
        const n = il(Br, "sites"),
            r = {
                siteDataId: t,
                dateCreated: new Date().toISOString(),
                users: {
                    [e]: "owner"
                }
            };
        return {
            siteId: (await eF(n, r)).id,
            site: r
        }
    },
    KCe = async e => {
        try {
            const t = ed(Br, "sites", e),
                n = await zT(t);
            if (n.exists) return n.data();
            throw new Error("Site not found")
        } catch (t) {
            console.error(t)
        }
    },
    XCe = async (e, t) => {
        try {
            const n = ed(Br, "sites", e);
            return await t9(n, t)
        } catch (n) {
            console.error(n)
        }
    },
    aOe = async (e, t = null, n = null) => {
        const r = ed(Br, "sites", e);
        return tF(r, t, n)
    },
    QCe = async e => {
        const t = il(Br, "sites"),
            n = oh(t, ef(`users.${e}`, "!=", !1)),
            r = await ah(n),
            s = [];
        return r.forEach(i => {
            s.push(G(x({}, i.data()), {
                id: i.id
            }))
        }), s
    },
    JCe = async (e, t = 1e3) => {
        const n = il(Br, "sites", e, "leads"),
            r = oh(n, XK("dateCreated", "desc"), QK(t)),
            s = await ah(r),
            i = [];
        return s.forEach(o => {
            i.push(G(x({}, o.data()), {
                email: o.id
            }))
        }), i
    },
    lOe = async (e, t = "", n = !1) => {
        if (!t && !n) throw Error("No siteDateId provided and newSite is false");
        let r = t;
        n === !0 && (r = `${Math.floor(new Date().getTime()/1e3)}-${qCe()}`);
        try {
            return await zG(LM(O$, `sites/${r}`), e), r
        } catch (s) {
            console.error(s)
        }
    },
    ZCe = async e => {
        const t = LM(O$);
        return WG(Qg(t, `sites/${e}`)).then(n => {
            if (n.exists()) return n.val();
            throw new Error("Site data not found")
        }).catch(n => {
            console.error(n)
        })
    },
    eAe = (e = {}) => {
        if (fI(e)) return e;
        const t = [],
            n = {};
        for (const r in e) t.push(x({
            sectionName: r
        }, e[r]));
        return t.sort((r, s) => r.sortOrder - s.sortOrder), t.forEach(r => {
            n[r.sectionName] = r
        }), n
    },
    tAe = async e => {
        var s;
        const t = await ZCe(e),
            n = {};
        Oy((s = t == null ? void 0 : t.siteData) == null ? void 0 : s.pages, (i, o) => {
            n[o] = G(x({}, i), {
                sections: eAe(i.sections)
            })
        });
        const r = G(x({}, t.siteData), {
            pages: n
        });
        return G(x({}, t), {
            siteData: r
        })
    },
    nAe = (e = {}, t, n) => {
        for (let r in e)
            if (typeof e[r] == "object" && e[r] !== null) nAe(e[r], t, n);
            else if (typeof e[r] == "string" && Dy(["siteTitle", "siteName", "siteDescription", "review", "subtitle", "title", "testimonial", "content"], r)) {
            const i = String(e[r]);
            Dy(i, t) && (Ua.log(`${r} includes ${i}`), e[r] = I$e(i, t, n))
        }
        return e
    },
    Yh = "a-f\\d",
    rAe = `#?[${Yh}]{3}[${Yh}]?`,
    sAe = `#?[${Yh}]{6}([${Yh}]{2})?`,
    iAe = new RegExp(`[^#${Yh}]`, "gi"),
    oAe = new RegExp(`^${rAe}$|^${sAe}$`, "i");

function KN(e, t = {}) {
    if (typeof e != "string" || iAe.test(e) || !oAe.test(e)) throw new TypeError("Expected a valid hex string");
    e = e.replace(/^#/, "");
    let n = 1;
    e.length === 8 && (n = Number.parseInt(e.slice(6, 8), 16) / 255, e = e.slice(0, 6)), e.length === 4 && (n = Number.parseInt(e.slice(3, 4).repeat(2), 16) / 255, e = e.slice(0, 3)), e.length === 3 && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]);
    const r = Number.parseInt(e, 16),
        s = r >> 16,
        i = r >> 8 & 255,
        o = r & 255,
        a = typeof t.alpha == "number" ? t.alpha : n;
    if (t.format === "array") return [s, i, o, a];
    if (t.format === "css") {
        const l = a === 1 ? "" : ` / ${Number((a*100).toFixed(2))}%`;
        return `rgb(${s} ${i} ${o}${l})`
    }
    return {
        red: s,
        green: i,
        blue: o,
        alpha: a
    }
}
const cOe = (e = "firestore") => e === "rtdb" ? rq() : n9(),
    XN = e => e !== void 0 ? new Date(e).toLocaleDateString("en-gb", {
        year: "numeric",
        month: "long",
        day: "numeric"
    }) : void 0,
    iz = e => {
        const r = new Date(e),
            s = new Date,
            i = Math.round(Math.abs((r - s) / 864e5));
        if (i > 0) return i === 1 ? `${i} day ago` : `${i} days ago`;
        const o = Math.round(Math.abs((r - s) / 36e5));
        return o > 0 ? o === 1 ? `${o} hour ago` : `${o} hours ago` : "moments ago"
    },
    uOe = e => {
        const n = new Date(e),
            r = new Date;
        return Math.round(Math.abs((n - r) / 864e5)) > 0
    },
    dOe = (e, t) => {
        var n;
        if (window != null && window.document) {
            const r = document == null ? void 0 : document.querySelector(":root"),
                s = document.querySelector("#previewer"),
                i = (n = s == null ? void 0 : s.contentDocument) == null ? void 0 : n.querySelector(":root"),
                o = [r, i],
                a = KN(e || "#000000"),
                l = KN(t || "#000000");
            o.forEach(c => {
                var u, d, f;
                (u = c == null ? void 0 : c.style) == null || u.setProperty("--color-primary", `${a.red} ${a.green} ${a.blue}`), (d = c == null ? void 0 : c.style) == null || d.setProperty("--color-secondary", `${l.red} ${l.green} ${l.blue}`), (f = c == null ? void 0 : c.style) == null || f.setProperty("--plyr-color-main", e)
            })
        }
    },
    fOe = async e => {
        var s;
        const t = (s = Vt == null ? void 0 : Vt.currentUser) == null ? void 0 : s.uid;
        if (Ob(t)) throw new Error("uId is required to create a site");
        const {
            site: n,
            siteId: r
        } = await YCe(t, e);
        return {
            site: n,
            siteId: r
        }
    },
    hOe = async e => {
        const n = await ca(Fi, "publish")({
                siteId: e
            }),
            r = mt(n, "data.success"),
            s = mt(n, "data.data"),
            i = mt(n, "data.error", "Failed to publish site");
        if (r === !0) return s;
        throw Error(i)
    },
    pOe = async e => {
        const n = await ca(Fi, "unpublish")({
                siteId: e
            }),
            r = mt(n, "data.success"),
            s = mt(n, "data.data"),
            i = mt(n, "data.error", "Failed to unpublish site");
        if (r === !0) return s;
        throw Error(i)
    },
    mOe = async (e, t = !1) => {
        try {
            const n = await KCe(e);
            let r = null;
            return n && t && (r = (await tAe(n == null ? void 0 : n.siteDataId)).siteData, r.siteDataId = n.siteDataId), {
                site: n,
                siteData: r
            }
        } catch (n) {
            console.error(n)
        }
    },
    gOe = async (e, t) => {
        try {
            return await XCe(e, t)
        } catch (n) {
            console.error(n)
        }
    },
    oz = async () => {
        var s;
        const e = (s = Vt == null ? void 0 : Vt.currentUser) == null ? void 0 : s.uid;
        if (Ob(e)) throw new Error("uId is required to get sites");
        const t = await QCe(e),
            n = N$e(t, ["dateCreated"]),
            r = A$e(n);
        return I3(r, i => ({
            id: i.id,
            name: (i == null ? void 0 : i.name) || `Site ${i.id}`,
            subdomain: i == null ? void 0 : i.subdomain,
            logoUrl: (i == null ? void 0 : i.logoUrl) || "https://storage.googleapis.com/mixo-files/public/img/mixo-logo.svg",
            dateCreated: iz(i.dateCreated)
        }))
    },
    _Oe = async e => {
        const t = await JCe(e, 10),
            n = $3(t);
        return {
            lastSubmission: {
                date: XN(mt(n, "dateCreated")),
                age: iz(mt(n, "dateCreated"))
            },
            leads: I3(t, r => G(x({}, r), {
                date: XN(mt(r, "dateCreated"))
            }))
        }
    },
    yOe = async e => {
        const t = ca(Fi, "generateCsv");
        try {
            const n = await t({
                    siteId: e
                }),
                r = mt(n, "data");
            if (Ob(r)) throw new Error("Failed to export leads to CSV file");
            return r
        } catch (n) {
            console.error(n)
        }
    },
    aAe = e => {
        if (!e || e.length < 3) throw Error("Subdomain must be at least 3 characters long");
        if (e.length > 65) throw Error(`Subdomain must be shorter than 60 characters long (currently ${e.length})`);
        if (!/^[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?$/.test(e)) throw Error("Subdomain can only contain lowercase letters and numbers. It may contain dashes, but may not begin or end with a hyphen");
        return !0
    },
    lAe = e => {
        if (!e || e.length < 3) throw Error("Domain must be at least 3 characters long");
        if (e.length > 63) throw Error("Domain must be shorter than 60 characters long");
        if (!/^[a-z0-9](?:[a-z0-9\-.]{0,61}[a-z0-9])?$/.test(e)) throw Error("Domain can only contain lowercase letters and numbers. It may contain dashes, but may not begin or end with a hyphen");
        return !0
    },
    EI = async (e, t) => {
        if (mt(t, "siteId") === void 0) throw Error("SiteId is required to setup domain");
        if (e === "Subdomain" && mt(t, "subdomain") === void 0) throw Error("Subdomain must be provided to setup domain");
        if (e === "CustomDomain" && mt(t, "customDomain") === void 0) throw Error("Site must be provided to setup domain");
        const r = await ca(Fi, "setupDomain")(t),
            s = mt(r, "data.success"),
            i = mt(r, "data.data"),
            o = mt(r, "data.error");
        if (!Ob(o)) throw Error(o);
        return {
            success: s,
            data: i
        }
    },
    vOe = async (e, t, n) => {
        const r = `${t}.${n}`;
        return lAe(r), EI("CustomDomain", {
            siteId: e,
            customDomain: r,
            customDomainSettings: {
                subdomain: t,
                domain: n
            }
        })
    },
    bOe = async (e, t) => (aAe(t), EI("Subdomain", {
        siteId: e,
        subdomain: t
    })),
    wOe = async (e, t) => EI("Subfolder", {
        siteId: e,
        siteName: t
    }),
    EOe = async e => {
        const n = await ca(Fi, "checkCustomDomain")({
                siteId: e
            }),
            r = mt(n, "data.success"),
            s = mt(n, "data.data"),
            i = mt(n, "data.error", "Failed to publish site");
        if (r === !0) return s;
        throw Error(i)
    },
    cAe = async e => {
        const n = await ca(Fi, "duplicateSite")({
                siteId: e
            }),
            r = mt(n, "data.success"),
            s = mt(n, "data.data"),
            i = mt(n, "data.error", "Failed to duplicate site");
        if (r === !0) return s;
        throw Error(i)
    },
    uAe = async e => {
        const n = await ca(Fi, "archiveSite")({
                siteId: e
            }),
            r = mt(n, "data.success"),
            s = mt(n, "data.data"),
            i = mt(n, "data.error", "Failed to delete site");
        if (r === !0) return s;
        throw Error(i)
    },
    dAe = {
        errorMessage: "",
        sites: {}
    };
var fAe = qwe({
    id: "sitesSelector",
    initial: "loading",
    context: x({}, dAe),
    states: {
        loading: {
            id: "loading",
            tags: "loading",
            invoke: {
                src: "loadSites"
            },
            on: {
                LOAD_SITES_SUCCESS: {
                    target: "#ready",
                    actions: ["assignSites", "assignCurrentSite"]
                },
                LOAD_SITES_ERROR: {
                    target: "#error",
                    actions: "assignErrors"
                }
            }
        },
        ready: {
            id: "ready",
            on: {
                DUPLICATE_SITE: "duplicatingSite",
                DELETE_SITE: "deletingSite"
            }
        },
        deletingSite: {
            tags: "loading",
            invoke: {
                src: "deleteSite"
            },
            on: {
                DELETE_SITE_SUCCESS: {
                    target: "ready",
                    actions: [{
                        type: "showToast",
                        message: "Site Deleted",
                        toastType: "success",
                        toastOptions: {
                            duration: 7e3,
                            dismissible: !0
                        }
                    }, "redirectToIndexRoute"]
                },
                DELETE_SITE_ERROR: {
                    target: "error",
                    actions: ["assignErrors", "trackErrors"]
                }
            }
        },
        duplicatingSite: {
            tags: "loading",
            invoke: {
                src: "duplicateSite"
            },
            on: {
                DUPLICATE_SITE_SUCCESS: {
                    target: "ready",
                    actions: [{
                        type: "showToast",
                        message: "Site Duplicated (To rename go to the dashboard)",
                        toastType: "success",
                        toastOptions: {
                            duration: 7e3,
                            dismissible: !0
                        }
                    }, "redirectToSiteRoute"]
                },
                DUPLICATE_SITE_ERROR: {
                    target: "error",
                    actions: ["assignErrors", "trackErrors"]
                }
            }
        },
        error: {
            id: "error",
            on: {
                RESET: "loading"
            }
        }
    }
}, {
    actions: G(x({}, V$e), {
        assignSites: Of((e, {
            sites: t
        }) => ({
            sites: t
        })),
        assignCurrentSite: Of((e, {
            currentSite: t
        }) => ({
            currentSite: t
        }))
    }),
    services: {
        deleteSite: (e, {
            siteId: t
        }) => async n => {
            var r;
            try {
                const s = await uAe(t);
                if (((r = s == null ? void 0 : s.site) == null ? void 0 : r.isRemoved) === !0) n({
                    type: "DELETE_SITE_SUCCESS",
                    siteId: s == null ? void 0 : s.siteId
                });
                else throw Error("Site not deleted: " + t)
            } catch (s) {
                n({
                    type: "DELETE_SITE_ERROR",
                    error: s
                }), console.error(s)
            }
        },
        duplicateSite: (e, {
            siteId: t
        }) => async n => {
            try {
                const r = await cAe(t);
                if (r != null && r.siteId) n({
                    type: "DUPLICATE_SITE_SUCCESS",
                    siteId: r == null ? void 0 : r.siteId
                });
                else throw Error("No site id returned")
            } catch (r) {
                n({
                    type: "DUPLICATE_SITE_ERROR",
                    error: r
                }), console.error(r)
            }
        },
        loadSites: ({
            currentSiteId: e
        }) => async t => {
            try {
                const n = await oz(),
                    r = h$e(n, {
                        id: e
                    });
                t({
                    type: "LOAD_SITES_SUCCESS",
                    sites: n,
                    currentSite: r
                })
            } catch (n) {
                t({
                    type: "LOAD_SITES_ERROR",
                    error: n
                }), console.error(n)
            }
        }
    }
});
const hAe = {
        key: 0,
        class: "flex flex-wrap items-center gap-1 text-xs sm:text-sm"
    },
    pAe = K("span", {
        class: "text-red-500"
    }, "Error: ", -1),
    mAe = {
        class: "text-slate-500"
    },
    gAe = {
        key: 0,
        class: "flex items-center truncate"
    },
    _Ae = ["src", "alt"],
    yAe = {
        class: "px-1 font-medium text-slate-700 text-m"
    },
    vAe = {
        key: 1,
        class: "font-medium text-slate-700 text-sm md:text-base"
    },
    bAe = {
        class: "p-2 sm:p-3 md:p-4 flex items-center justify-between w-full border-b border-slate-100"
    },
    wAe = {
        class: "flex items-center w-full space-x-2 sm:space-x-3 group"
    },
    EAe = ["src"],
    SAe = {
        class: "flex flex-col gap-1 sm:gap-2 md:flex-row md:items-center md:justify-between w-full"
    },
    TAe = {
        class: "text-xs md:text-sm text-slate-500"
    },
    $Ae = {
        class: "flex items-center gap-2 text-xs md:text-sm"
    },
    kAe = hn(" Edit "),
    IAe = K("span", null, "Create New Site", -1),
    xAe = {
        name: "SiteSelector",
        props: {
            alignLeft: {
                type: Boolean,
                default: !0
            },
            showNewSite: {
                type: Boolean,
                default: !0
            },
            showWithNoSites: {
                type: Boolean,
                default: !0
            }
        },
        setup(e) {
            var p;
            const t = e,
                n = Vp(),
                r = Xk(),
                s = {
                    context: {
                        currentSiteId: ((p = n == null ? void 0 : n.params) == null ? void 0 : p.id) || "",
                        router: r
                    },
                    actions: {
                        redirectToIndexRoute: () => {
                            r.push("/")
                        },
                        redirectToSiteRoute: (m, {
                            siteId: g
                        }) => {
                            r.push(`/sites/${g}/edit`)
                        }
                    }
                },
                {
                    state: i,
                    send: o
                } = H$e(fAe, "Sites Selector", s),
                a = So(() => {
                    var m, g;
                    return ((g = (m = i == null ? void 0 : i.value) == null ? void 0 : m.context) == null ? void 0 : g.sites) || []
                }),
                l = So(() => {
                    var m, g;
                    return ((g = (m = i == null ? void 0 : i.value) == null ? void 0 : m.context) == null ? void 0 : g.errorMessage) || ""
                }),
                c = So(() => {
                    var m, g;
                    return ((g = (m = i == null ? void 0 : i.value) == null ? void 0 : m.context) == null ? void 0 : g.currentSite) || null
                }),
                u = So(() => {
                    var m;
                    return !(!((m = a == null ? void 0 : a.value) != null && m.length) && !t.showWithNoSites)
                }),
                d = m => {
                    o({
                        type: "DUPLICATE_SITE",
                        siteId: m
                    })
                },
                f = m => {
                    Vh({
                        name: "delete-confirm",
                        actions: !0
                    }, {
                        default: `
        <h2 class="mb-2 text-2xl font-bold text-red-600">
          Delete Site
        </h2>
        <p>
          You are about to delete your site. This action can't be undone.
        </p>
        <p class="mt-2 font-semibold text-lg">
          Are you sure you want to <span class="text-red-600">delete</span> this site?
        </p>
      `
                    }, {
                        confirm(g) {
                            window != null && window.confirm("Your site will now be deleted. Are you sure?") && (o({
                                type: "DELETE_SITE",
                                siteId: m
                            }), g())
                        }
                    })
                },
                h = m => {
                    o({
                        type: "RESET"
                    })
                };
            return (m, g) => {
                const y = M3,
                    _ = jl,
                    E = GCe,
                    b = VCe,
                    w = Do("router-link"),
                    T = MCe,
                    S = RCe,
                    v = cCe;
                return z(), Se("div", null, [fe(i).matches("error") ? (z(), Se("div", hAe, [ne(y, {
                    class: "w-4 h-4 text-red-500"
                }), pAe, K("span", mAe, xs(fe(l)), 1), K("button", {
                    type: "button",
                    class: "text-xs text-brand-primary",
                    onClick: h
                }, " (reset) ")])) : Ve("", !0), fe(i).hasTag("loading") ? (z(), ke(_, {
                    key: 1
                })) : Ve("", !0), fe(i).matches("ready") && fe(u) ? (z(), ke(fe(vI), {
                    key: 2,
                    as: "div",
                    class: "relative z-10"
                }, {
                    default: Re(({
                        open: $
                    }) => [ne(fe(bI), {
                        class: "p-2 max-w-xs bg-white flex items-center rounded-lg hover:outline-none hover:ring-2 hover:ring-offset-2 hover:ring-brand-primary border border-slate-200"
                    }, {
                        default: Re(() => {
                            var k, C, O, R, N;
                            return [(k = fe(c)) != null && k.id ? (z(), Se("div", gAe, [K("img", {
                                src: (C = fe(c)) == null ? void 0 : C.logoUrl,
                                alt: (O = fe(c)) == null ? void 0 : O.name,
                                class: wn(["px-0.5 flex-shrink-0 h-5 w-5 rounded-full", {
                                    hidden: ((R = fe(c)) == null ? void 0 : R.logoUrl) === void 0
                                }])
                            }, null, 10, _Ae), K("p", yAe, xs((N = fe(c)) == null ? void 0 : N.name), 1)])) : (z(), Se("p", vAe, "Sites")), $ ? (z(), ke(E, {
                                key: 2,
                                class: "text-slate-500"
                            })) : (z(), ke(b, {
                                key: 3,
                                class: "text-slate-500"
                            }))]
                        }),
                        _: 2
                    }, 1024), ne(Zo, {
                        "enter-active-class": "transition ease-out duration-100",
                        "enter-from-class": "transform opacity-0 scale-95",
                        "enter-to-class": "transform opacity-100 scale-100",
                        "leave-active-class": "transition ease-in duration-75",
                        "leave-from-class": "transform opacity-100 scale-100",
                        "leave-to-class": "transform opacity-0 scale-95"
                    }, {
                        default: Re(() => [ne(fe(wI), {
                            class: wn(["absolute border border-light-100 overflow-hidden mt-2 w-64 sm:w-80 md:w-96 rounded-lg shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none", e.alignLeft ? "left-0 origin-top-left" : "right-0 origin-top-right"]),
                            unmount: !1
                        }, {
                            default: Re(() => {
                                var k;
                                return [K("div", {
                                    class: wn(["max-h-80 scroll-py-3", {
                                        "overflow-y-auto": ((k = fe(a)) == null ? void 0 : k.length) > 2
                                    }])
                                }, [(z(!0), Se(Ht, null, $u(fe(a), C => (z(), ke(fe(Ja), {
                                    key: C == null ? void 0 : C.id,
                                    value: C,
                                    as: "template"
                                }, {
                                    default: Re(() => {
                                        var O;
                                        return [K("div", {
                                            class: wn(["flex flex-col sm:items-center justify-between w-full space-x-2 sm:space-x-3", {
                                                "bg-gray-100": ((O = fe(c)) == null ? void 0 : O.id) === (C == null ? void 0 : C.id)
                                            }])
                                        }, [K("div", bAe, [K("div", wAe, [ne(w, {
                                            to: `/sites/${C==null?void 0:C.id}`,
                                            title: "Go to site overview"
                                        }, {
                                            default: Re(() => [K("img", {
                                                src: C == null ? void 0 : C.logoUrl,
                                                alt: "",
                                                class: wn(["flex-shrink-0 h-8 w-8 rounded-full items-center group-hover:scale-125 transition-transform", {
                                                    hidden: (C == null ? void 0 : C.logoUrl) === void 0
                                                }])
                                            }, null, 10, EAe)]),
                                            _: 2
                                        }, 1032, ["to"]), K("div", SAe, [K("div", null, [ne(w, {
                                            to: `/sites/${C==null?void 0:C.id}`,
                                            title: "Go to site overview",
                                            class: "text-sm sm:text-base font-medium text-slate-700 group-hover:text-brand-primary"
                                        }, {
                                            default: Re(() => [hn(xs(C == null ? void 0 : C.name), 1)]),
                                            _: 2
                                        }, 1032, ["to"]), K("p", TAe, " Created " + xs(C == null ? void 0 : C.dateCreated), 1)]), K("div", $Ae, [ne(w, {
                                            to: `/sites/${C==null?void 0:C.id}/edit`,
                                            class: "flex items-center default-hover"
                                        }, {
                                            default: Re(() => [ne(T, {
                                                class: "mr-1"
                                            }), kAe]),
                                            _: 2
                                        }, 1032, ["to"]), ne(S, {
                                            "site-id": C == null ? void 0 : C.id,
                                            onDuplicateClick: d,
                                            onDeleteClick: f
                                        }, null, 8, ["site-id"])])])])])], 2)]
                                    }),
                                    _: 2
                                }, 1032, ["value"]))), 128))], 2), ne(fe(Ja), null, {
                                    default: Re(({
                                        close: C
                                    }) => [e.showNewSite ? (z(), ke(w, {
                                        key: 0,
                                        to: "/ai-website-builder",
                                        class: "font-medium text-white p-4 px-6 flex items-center w-96 bg-brand-primary hover:bg-brand-secondary hover:text-slate-900 border-t border-rose-700 text-sm md:text-base hover:border-yellow-500",
                                        onClick: O => {}
                                    }, {
                                        default: Re(() => [ne(v, {
                                            class: "mr-2 text-current w-4"
                                        }), IAe]),
                                        _: 2
                                    }, 1032, ["onClick"])) : Ve("", !0)]),
                                    _: 1
                                })]
                            }),
                            _: 1
                        }, 8, ["class"])]),
                        _: 1
                    })]),
                    _: 1
                })) : Ve("", !0)])
            }
        }
    };
var CAe = "/assets/mixo.9f465c81.svg";
const AAe = ["src"],
    RAe = {
        name: "BrandLogo",
        props: {
            size: {
                type: String,
                default: ""
            },
            tag: {
                type: String,
                default: "router-link"
            },
            to: {
                type: String,
                default: "/"
            }
        },
        setup(e) {
            const t = e,
                n = So(() => {
                    switch (t.size) {
                        case "sm":
                            return "w-5 h-5";
                        case "md":
                            return "w-8 h-8";
                        case "lg":
                            return "w-12 h-12";
                        default:
                            return "w-7 h-7"
                    }
                }),
                r = So(() => {
                    switch (t.size) {
                        case "sm":
                            return "text-lg";
                        case "md":
                            return "text-3xl";
                        case "lg":
                            return "text-4xl";
                        default:
                            return "text-xl"
                    }
                });
            return (s, i) => (z(), ke(Ah(e.tag), {
                to: e.to,
                class: "flex items-center shrink-0 space-x-1",
                "data-testid": "brand-logo"
            }, {
                default: Re(() => [K("img", {
                    class: wn(fe(n)),
                    src: fe(CAe),
                    alt: "Mixo Logo"
                }, null, 10, AAe), K("span", {
                    class: wn(["font-sans font-extrabold text-slate-800", fe(r)])
                }, " Mixo ", 2)]),
                _: 1
            }, 8, ["to"]))
        }
    };
var az = bs(RAe, [
    ["__scopeId", "data-v-9030b5c6"]
]);
const OAe = {
        class: "w-full bg-slate-100 py-2 md:py-4"
    },
    DAe = {
        class: "flex items-center space-x-2 md:space-x-4"
    },
    NAe = {
        class: "flex items-center space-x-2 md:space-x-4 justify-end"
    },
    PAe = {
        name: "MainNav",
        props: {
            fullWidth: {
                type: Boolean,
                default: !0
            },
            showAccountSelector: {
                type: Boolean,
                default: !0
            }
        },
        setup(e) {
            const t = Vp(),
                n = Tj();
            return (r, s) => {
                var l, c;
                const i = az,
                    o = xAe,
                    a = sCe;
                return z(), Se("div", OAe, [K("div", {
                    class: wn(["flex justify-between", {
                        container: !e.fullWidth,
                        "px-2 md:px-4": e.fullWidth
                    }])
                }, [K("div", DAe, [Gn(r.$slots, "pre", {}, void 0, !0), ne(i), Gn(r.$slots, "default", {}, void 0, !0), ((l = fe(n)) == null ? void 0 : l.uid) && e.showAccountSelector ? (z(), ke(o, {
                    key: (c = fe(t)) == null ? void 0 : c.path
                })) : Ve("", !0)]), K("div", NAe, [Gn(r.$slots, "meta", {}, void 0, !0), (z(), ke(P5, null, {
                    default: Re(() => [ne(a)]),
                    _: 1
                }))])], 2)])
            }
        }
    };
var MAe = bs(PAe, [
    ["__scopeId", "data-v-3e7a1ee0"]
]);
const LAe = e => {
        const t = {
            clickToClose: !1,
            showClose: !0
        };
        return (r, s) => {
            Vh(x(x({
                name: "auth"
            }, t), r), {
                default: {
                    component: e,
                    bind: x({}, s)
                }
            })
        }
    },
    FAe = {
        name: "default",
        props: {
            error: {
                type: Object,
                default () {
                    return {}
                }
            }
        },
        setup(e) {
            const t = Vp();
            _I({
                bodyAttrs: {
                    class: "bg-slate-100"
                }
            });
            const n = Tu(G(x({}, Gh), {
                loader: () => at(() =>
                    import ("./AuthForm.e9ca2ea7.js"), [])
            }));
            fi("openAuthModal", LAe(n));
            const r = So(() => {
                var s;
                return ((s = t == null ? void 0 : t.meta) == null ? void 0 : s.container) !== !1
            });
            return (s, i) => {
                var c;
                const o = MAe,
                    a = L3,
                    l = Do("RouterView");
                return z(), Se("main", null, [ne(o), (c = e.error) != null && c.message ? (z(), ke(a, {
                    key: 0,
                    title: e.error.message
                }, null, 8, ["title"])) : Ve("", !0), K("div", {
                    class: wn(["py-4 md:py-6 lg:py-8", {
                        container: fe(r)
                    }])
                }, [(z(), ke(l, xi(s.$attrs, {
                    key: s.$route.fullPath
                }), null, 16))], 2)])
            }
        }
    },
    UAe = {
        404: () => at(() =>
            import ("./404.91bfd6ef.js"), []),
        auth: () => at(() =>
            import ("./auth.0c82a2c8.js"), []),
        blank: () => at(() =>
            import ("./blank.f4f55d54.js"), []),
        default: FAe,
        editor: () => at(() =>
            import ("./editor.605232ad.js"), []),
        empty: () => at(() =>
            import ("./empty.1706e1c4.js"), [])
    };

function BAe(e) {
    return e.map(t => {
        var n;
        return {
            path: t.path,
            meta: t.meta,
            component: UAe[((n = t.meta) == null ? void 0 : n.layout) || "default"],
            children: t.path === "/" ? [t] : [G(x({}, t), {
                path: ""
            })]
        }
    })
}
const VAe = ({
        app: e,
        isClient: t,
        router: n
    }) => {
        t && sre({
            app: e,
            dsn: "https://8db4236e7f44495597276c7df5eb5f06@o4505144668389376.ingest.sentry.io/4505145018679296",
            environment: "production",
            integrations: [new w$({
                routingInstrumentation: ire(n)
            }), new _h({
                blockAllMedia: !1,
                mask: ['input[type="password"]'],
                maskAllInputs: !1,
                maskAllText: !1
            })],
            trackComponents: !0,
            tracesSampleRate: .1,
            replaysSessionSampleRate: .1,
            replaysOnErrorSampleRate: 1
        })
    },
    HAe = (e, t, n) => {
        t.$options.propsData && dl(e);
        var r = `Error in component: <${t.$options.name} />
`;
        n && (r += `Error occurred during lifecycle hook: ${n}
`), l$(r), dl(e)
    },
    jAe = hn("contact support"),
    zAe = {
        name: "SupportLink",
        setup(e) {
            const t = () => {
                window != null && window.$crisp ? window == null || window.$crisp.push(["do", "chat:open"]) : window.location = "mailto:team@mixo.io?subject=Help with Mixo"
            };
            return (n, r) => (z(), Se("button", {
                class: "default-link cursor-pointer",
                "data-testid": "support-link",
                onClick: t
            }, [Gn(n.$slots, "default", {}, () => [jAe])]))
        }
    },
    WAe = {},
    GAe = {
        class: "bg-white z-50 h-screen w-screen"
    },
    qAe = {
        class: "w-full bg-slate-100 py-2 md:py-4"
    },
    YAe = {
        class: "flex justify-between px-2 md:px-4"
    },
    KAe = {
        class: "flex items-center space-x-2 md:space-x-4"
    },
    XAe = {
        class: "flex items-center space-x-2 md:space-x-4 justify-end"
    },
    QAe = hn("Contact Support"),
    JAe = {
        class: "mt-10 flex flex-col items-center"
    },
    ZAe = {
        class: "lg:px-8 bg-slate-50 py-16 px-6 rounded-xl shadow"
    },
    eRe = {
        class: "mx-auto max-w-2xl flex flex-col items-center space-y-10"
    },
    tRe = K("h1", {
        class: "text-2xl font-extrabold leading-8 tracking-tight text-slate-900 sm:text-3xl sm:leading-9"
    }, " We'll be right back \u{1F468}\u200D\u{1F4BB}\u{1F916} ", -1),
    nRe = {
        class: "text-xl font-semibold leading-8 tracking-tight text-slate-700 sm:leading-9"
    },
    rRe = hn(" \u201CHi there, we're just working on some important updates and we'll be back online shortly. Please "),
    sRe = hn("reach out"),
    iRe = hn(" if you have any issues or would like to be updated when we're back online.\u201D ");

function oRe(e, t) {
    const n = az,
        r = zAe;
    return z(), Se("div", GAe, [K("div", qAe, [K("div", YAe, [K("div", KAe, [Gn(e.$slots, "pre"), ne(n), Gn(e.$slots, "default")]), K("div", XAe, [ne(r, null, {
        default: Re(() => [QAe]),
        _: 1
    })])])]), K("div", JAe, [K("section", ZAe, [K("div", eRe, [tRe, K("h2", nRe, [rRe, ne(r, null, {
        default: Re(() => [sRe]),
        _: 1
    }), iRe]), ne(n)])])])])
}
var lz = bs(WAe, [
        ["render", oRe]
    ]),
    aRe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: lz
    }, Symbol.toStringTag, {
        value: "Module"
    }));
Tu(G(x({}, Gh), {
    loader: () => at(() => Promise.resolve().then(function() {
        return aRe
    }), void 0)
}));
const {
    ModalsContainer: lRe
} = qh, cRe = {
    name: "App",
    components: {
        ModalsContainer: lRe
    },
    setup() {
        const e = Vp(),
            t = ae([{
                children: "(function (w, r) { w._rwq = r; w[r] = w[r] || function () { (w[r].q = w[r].q || []).push(arguments) } })(window, 'rewardful');"
            }, {
                src: "https://r.wdfl.co/rw.js",
                async: !0,
                "data-rewardful": "35dd66"
            }, {
                children: "window.$crisp = []; window.CRISP_WEBSITE_ID = '211a89ee-af11-4718-937e-be995ea69b2b'; (function() { d = document; s = d.createElement('script'); s.src = 'https://client.crisp.chat/l.js'; s.async = 1; d.getElementsByTagName('head')[0].appendChild(s) })()",
                async: !0
            }]);
        ((e == null ? void 0 : e.name) === "sites-preview" || (e == null ? void 0 : e.path) === "/sites/preview") && (t.value = []), _I({
            title: "Home",
            titleTemplate: "Mixo | %s",
            meta: [{
                name: "description",
                content: "AI-powered page builder to launch and validate your startup ideas."
            }, {
                name: "theme-color",
                content: Fe(() => (Hj.value, "#f1f5f9"))
            }, {
                name: "og:title",
                content: "Mixo"
            }, {
                name: "og:url",
                content: e.path
            }, {
                name: "twitter:url",
                content: e.path
            }, {
                name: "og:site_name",
                content: "Mixo"
            }, {
                name: "og:type",
                content: "website"
            }, {
                name: "og:description",
                content: "AI-powered page builder to launch and validate your startup ideas."
            }, {
                name: "og:image",
                content: "https://storage.googleapis.com/mixo-sites/images/file-2ea8702c-b5e0-4026-80fc-d60d790bb5b0.png"
            }, {
                name: "og:image:alt",
                content: "Mixo.io"
            }, {
                name: "twitter:title",
                content: "Mixo"
            }, {
                name: "twitter:description",
                content: "AI-powered page builder to launch and validate your startup ideas."
            }, {
                name: "twitter:card",
                content: "summary_large_image"
            }, {
                name: "twitter:image:src",
                content: "https://storage.googleapis.com/mixo-sites/images/file-2ea8702c-b5e0-4026-80fc-d60d790bb5b0.png"
            }],
            link: [{
                rel: "icon",
                type: "image/svg+xml",
                href: Fe(() => B0e.value ? "/favicon-dark.svg" : "/favicon.svg")
            }],
            htmlAttrs: {
                class: ""
            },
            script: t
        });
        const n = !1,
            r = typeof window != "undefined" && (window == null ? void 0 : window.localStorage.getItem("mixo-admin")) === "true";
        return {
            network: obe(),
            MAINTENANCE_MODE: n,
            MIXO_ADMIN: r
        }
    }
}, uRe = {
    key: 0,
    class: "text-center p-1 md:py-3 bg-red-100 text-sm text-red-800 border-b border-red-200"
};

function dRe(e, t, n, r, s, i) {
    var u, d;
    const o = Do("ModalsContainer"),
        a = Do("ClientOnly"),
        l = lz,
        c = Do("RouterView");
    return z(), Se(Ht, null, [(d = (u = r.network) == null ? void 0 : u.isOnline) != null && d.value ? Ve("", !0) : (z(), Se("div", uRe, " It looks like you're not connected to the internet. Please reconnect before continuing. ")), ne(a, null, {
        default: Re(() => [ne(o)]),
        _: 1
    }), r.MAINTENANCE_MODE && !r.MIXO_ADMIN ? (z(), ke(l, {
        key: 1
    })) : Ve("", !0), ne(c)], 64)
}
var fRe = bs(cRe, [
    ["render", dRe]
]);
const hRe = {
        name: "index",
        setup(e) {
            const t = Vp(),
                n = Xk();
            return jr(async () => {
                let r = "/ai-website-builder";
                const s = await kj(),
                    i = t.path === "/ai-website-builder";
                if (s && !i) {
                    const o = await oz(),
                        a = $3(o),
                        l = a == null ? void 0 : a.id;
                    l && (r = `/sites/${l}`)
                }
                n.push({
                    path: r
                })
            }), (r, s) => {
                const i = jl,
                    o = N3;
                return z(), ke(o, null, {
                    default: Re(() => [ne(i)]),
                    _: 1
                })
            }
        }
    },
    pRe = () => at(() =>
        import ("./preview.2448df02.js").then(function(e) {
            return e.p
        }), ["assets/preview.2448df02.js", "assets/preview.a89f9882.css", "assets/index.907e950c.js", "assets/star.03b6facb.js", "assets/route-block.9b0645f8.js"]),
    ww = () => at(() =>
        import ("./new.2b84c413.js"), ["assets/new.2b84c413.js", "assets/new.cf4398f3.css", "assets/star.03b6facb.js", "assets/MarketingFaqs.dea97eb1.js", "assets/PlanSelector.4a86a2ca.js", "assets/check.a548b91d.js", "assets/planet-ring2-line.eb2bb610.js", "assets/UiHeading.6d814843.js", "assets/index.907e950c.js", "assets/BrowserUi.f4994d26.js", "assets/BrowserUi.5aed889a.css", "assets/save24-regular.65bcdb0e.js", "assets/EditField.707c8331.js", "assets/media.fe609717.js", "assets/_copyArray.2183cf44.js", "assets/set.45204d52.js", "assets/_assignValue.893c69e5.js", "assets/route-block.9b0645f8.js"]),
    mRe = () => at(() =>
        import ("./blank.54be1716.js"), ["assets/blank.54be1716.js", "assets/blank.a7770adb.css", "assets/SiteEditor.46685e70.js", "assets/SiteEditor.1702ab56.css", "assets/external-link.a134d0f1.js", "assets/UiHeading.6d814843.js", "assets/index.907e950c.js", "assets/site-machine.a0b137fc.js", "assets/BrowserUi.f4994d26.js", "assets/BrowserUi.5aed889a.css", "assets/save24-regular.65bcdb0e.js", "assets/site-schema.740196f3.js", "assets/site-schema.e30bf265.css", "assets/planet-ring2-line.eb2bb610.js", "assets/_assignValue.893c69e5.js", "assets/_copyArray.2183cf44.js", "assets/route-block.9b0645f8.js"]),
    gRe = () => at(() =>
        import ("./zapier.7064b686.js"), ["assets/zapier.7064b686.js", "assets/route-block.9b0645f8.js"]),
    _Re = () => at(() =>
        import ("./success.b59c1cbd.js"), []),
    yRe = () => at(() =>
        import ("./terms.6206c0fc.js"), []),
    vRe = () => at(() =>
        import ("./terms-ltd.777ab854.js"), []),
    bRe = () => at(() =>
        import ("./terms-affiliate.d49be3b0.js"), []),
    wRe = () => at(() =>
        import ("./support.6a57e97c.js"), []),
    ERe = () => at(() =>
        import ("./privacy.337c534d.js"), []),
    SRe = () => at(() =>
        import ("./pricing.d39c0a42.js"), ["assets/pricing.d39c0a42.js", "assets/MarketingFaqs.dea97eb1.js", "assets/PlanSelector.4a86a2ca.js", "assets/check.a548b91d.js", "assets/planet-ring2-line.eb2bb610.js", "assets/UiHeading.6d814843.js", "assets/index.907e950c.js"]),
    TRe = () => at(() =>
        import ("./ping.f02d1707.js"), ["assets/ping.f02d1707.js", "assets/route-block.9b0645f8.js"]),
    $Re = () => at(() =>
        import ("./logout.70210db3.js"), []),
    kRe = () => at(() =>
        import ("./login.c2500d7f.js"), ["assets/login.c2500d7f.js", "assets/AuthForm.e9ca2ea7.js", "assets/route-block.9b0645f8.js"]),
    IRe = () => at(() =>
        import ("./_...all_.08f3e85c.js"), ["assets/_...all_.08f3e85c.js", "assets/route-block.9b0645f8.js"]),
    xRe = () => at(() =>
        import ("./_id_.10e4b8e3.js").then(function(e) {
            return e._
        }), ["assets/_id_.10e4b8e3.js", "assets/_id_.2af9dab8.css", "assets/MarketingFaqs.dea97eb1.js", "assets/check.a548b91d.js", "assets/route-block.9b0645f8.js"]),
    CRe = () => at(() =>
        import ("./edit.4f72ac32.js"), ["assets/edit.4f72ac32.js", "assets/SiteEditor.46685e70.js", "assets/SiteEditor.1702ab56.css", "assets/external-link.a134d0f1.js", "assets/UiHeading.6d814843.js", "assets/index.907e950c.js", "assets/site-machine.a0b137fc.js", "assets/BrowserUi.f4994d26.js", "assets/BrowserUi.5aed889a.css", "assets/save24-regular.65bcdb0e.js", "assets/site-schema.740196f3.js", "assets/site-schema.e30bf265.css", "assets/planet-ring2-line.eb2bb610.js", "assets/_assignValue.893c69e5.js", "assets/_copyArray.2183cf44.js", "assets/route-block.9b0645f8.js"]),
    ARe = () => at(() =>
        import ("./index.18d4ef83.js").then(function(e) {
            return e.i
        }), ["assets/index.18d4ef83.js", "assets/UiHeading.6d814843.js", "assets/index.907e950c.js", "assets/EditField.707c8331.js", "assets/save24-regular.65bcdb0e.js", "assets/site-machine.a0b137fc.js", "assets/external-link.a134d0f1.js"]),
    RRe = [{
        name: "sites-preview",
        path: "/sites/preview",
        component: pRe,
        props: !0,
        meta: {
            layout: "empty"
        }
    }, {
        name: "generator",
        path: "/sites/new",
        component: ww,
        props: !0,
        meta: {
            layout: "default",
            requiresAuth: !1,
            container: !1
        },
        alias: ["/ai-website-builder"],
        children: [{
            name: "idea",
            path: "/ai-website-builder/idea/:id",
            component: ww
        }, {
            name: "site",
            path: "/ai-website-builder/site/:id",
            component: ww,
            meta: {
                requiresAuth: !0
            }
        }]
    }, {
        name: "sites-blank",
        path: "/sites/blank",
        component: mRe,
        props: !0,
        meta: {
            requiresAuth: !0,
            layout: "editor"
        }
    }, {
        name: "oauth-zapier",
        path: "/oauth/zapier",
        component: gRe,
        props: !0,
        meta: {
            requiresAuth: !1
        }
    }, {
        name: "checkout-success",
        path: "/checkout/success",
        component: _Re,
        props: !0,
        meta: {
            requiresAuth: !0
        }
    }, {
        name: "terms",
        path: "/terms",
        component: yRe,
        props: !0
    }, {
        name: "terms-ltd",
        path: "/terms-ltd",
        component: vRe,
        props: !0
    }, {
        name: "terms-affiliate",
        path: "/terms-affiliate",
        component: bRe,
        props: !0
    }, {
        name: "support",
        path: "/support",
        component: wRe,
        props: !0
    }, {
        name: "privacy",
        path: "/privacy",
        component: ERe,
        props: !0
    }, {
        name: "pricing",
        path: "/pricing",
        component: SRe,
        props: !0
    }, {
        name: "ping",
        path: "/ping",
        component: TRe,
        props: !0,
        meta: {
            layout: "blank"
        }
    }, {
        name: "logout",
        path: "/logout",
        component: $Re,
        props: !0
    }, {
        name: "login",
        path: "/login",
        component: kRe,
        props: !0,
        meta: {
            layout: "auth"
        }
    }, {
        name: "index",
        path: "/",
        component: hRe,
        props: !0
    }, {
        name: "not-found",
        path: "/:all(.*)*",
        component: IRe,
        props: !0,
        meta: {
            requiresAuth: !1,
            layout: 404
        }
    }, {
        name: "partners-id",
        path: "/partners/:id",
        component: xRe,
        props: !0,
        meta: {
            requiresAuth: !1,
            layout: "blank"
        }
    }, {
        name: "sites-id-edit",
        path: "/sites/:id/edit",
        component: CRe,
        props: !0,
        meta: {
            requiresAuth: !0,
            layout: "editor"
        }
    }, {
        name: "sites-id",
        path: "/sites/:id",
        component: ARe,
        props: !0,
        meta: {
            requiresAuth: !0
        }
    }];
const ORe = BAe(RRe);
dxe(fRe, {
    routes: ORe,
    base: "/"
}, e => {
    var t;
    VAe(e), e.app.config.errorHandler = HAe, Object.values({
        "./modules/firebase.js": gie,
        "./modules/formkit.js": Hke,
        "./modules/i18n.js": zke,
        "./modules/nprogress.js": Gke,
        "./modules/pwa.js": Yke,
        "./modules/vue-final-modal.js": cIe,
        "./modules/vue-fire.js": dIe,
        "./modules/vue-toast-notification.js": mIe
    }).forEach(n => {
        var r;
        return (r = n.install) == null ? void 0 : r.call(n, e)
    }), (t = e == null ? void 0 : e.router) == null || t.beforeEach(async n => {
        var r;
        if ((r = n == null ? void 0 : n.meta) != null && r.requiresAuth && !await kj()) return {
            path: "/login",
            query: {
                redirect: n.fullPath
            }
        }
    })
});
export {
    c1e as $, nk as A, H_ as B, Y_ as C, Re as D, hn as E, wn as F, u1 as G, Eb as H, Ht as I, $u as J, Ah as K, Rle as L, Xk as M, jr as N, pa as O, P3 as P, BRe as Q, dOe as R, sr as S, Zv as T, u5 as U, d5 as V, Ay as W, Xc as X, m3 as Y, i1e as Z, bs as _, ne as a, SN as a$, _$e as a0, hr as a1, Gn as a2, bt as a3, N3 as a4, Vh as a5, Vp as a6, Tj as a7, qwe as a8, V$e as a9, rI as aA, N$e as aB, sOe as aC, oOe as aD, jl as aE, _j as aF, Vu as aG, y3 as aH, Ab as aI, sI as aJ, aN as aK, iI as aL, C3 as aM, x3 as aN, QRe as aO, xAe as aP, ewe as aQ, f3 as aR, ql as aS, Q1e as aT, J1e as aU, jp as aV, Xs as aW, eTe as aX, XSe as aY, v3 as aZ, tTe as a_, H$e as aa, So as ab, ca as ac, Fi as ad, mt as ae, ed as af, Br as ag, zT as ah, tAe as ai, Of as aj, Dy as ak, Ua as al, mOe as am, $3 as an, Oy as ao, nAe as ap, hie as aq, iOe as ar, VRe as as, Pb as at, yI as au, Fl as av, Axe as aw, Vs as ax, nOe as ay, Cn as az, ke as b, die as b$, qs as b0, $l as b1, rS as b2, hN as b3, Cy as b4, yi as b5, n1e as b6, _N as b7, hOe as b8, fOe as b9, ole as bA, N_ as bB, JRe as bC, zAe as bD, Qre as bE, kj as bF, po as bG, FRe as bH, NRe as bI, Vt as bJ, MRe as bK, PRe as bL, LRe as bM, Qn as bN, ku as bO, ZRe as bP, Zn as bQ, yOe as bR, _Oe as bS, uOe as bT, wOe as bU, bOe as bV, YRe as bW, KRe as bX, EOe as bY, fI as bZ, vOe as b_, qRe as ba, Pr as bb, XRe as bc, q5 as bd, tOe as be, Rh as bf, yk as bg, GRe as bh, dI as bi, eOe as bj, iz as bk, cOe as bl, lOe as bm, gOe as bn, aOe as bo, pOe as bp, Cxe as bq, Nb as br, Ly as bs, Zt as bt, ez as bu, lS as bv, rOe as bw, Exe as bx, Sxe as by, Op as bz, Se as c, URe as c0, hke as c1, Ve as d, K as e, MAe as f, L3 as g, fe as h, az as i, Tu as j, Gh as k, at as l, LAe as m, xi as n, z as o, fi as p, ae as q, Do as r, yl as s, Fe as t, _I as u, gt as v, $t as w, Ir as x, xs as y, tk as z
};
//# sourceMappingURL=app.e27838e5.js.map